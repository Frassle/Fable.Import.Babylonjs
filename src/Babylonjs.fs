// ts2fable 0.0.0
module rec Babylonjs
open System
open Fable.Core
open Fable.Import.JS
open Fable.Import.Browser

let [<Import("*","babylonjs")>] babylon: BABYLON.IExports = jsNative
let [<Import("safePostMessage","babylonjs")>] safePostMessage: obj option = jsNative
let [<Import("VRDisplay","babylonjs")>] VRDisplay: TypeLiteral_43 = jsNative
let [<Import("WebGLQuery","babylonjs")>] WebGLQuery: TypeLiteral_44 = jsNative
let [<Import("WebGLSampler","babylonjs")>] WebGLSampler: TypeLiteral_45 = jsNative
let [<Import("WebGLSync","babylonjs")>] WebGLSync: TypeLiteral_46 = jsNative
let [<Import("WebGLTransformFeedback","babylonjs")>] WebGLTransformFeedback: TypeLiteral_47 = jsNative
let [<Import("WebGLVertexArrayObject","babylonjs")>] WebGLVertexArrayObject: TypeLiteral_48 = jsNative
let [<Import("MediaRecorder","babylonjs")>] MediaRecorder: MediaRecorderConstructor = jsNative
let [<Import("DracoDecoderModule","babylonjs")>] DracoDecoderModule: obj option = jsNative
let [<Import("WebAssembly","babylonjs")>] WebAssembly: obj option = jsNative

type [<AllowNullLiteral>] IExports =
    abstract importScripts: [<ParamArray>] urls: ResizeArray<string> -> unit
    abstract MediaRecorderConstructor: MediaRecorderConstructorStatic

module BABYLON =
    let [<Import("Debug","babylonjs/BABYLON")>] debug: Debug.IExports = jsNative

    type [<AllowNullLiteral>] IExports =
        abstract AbstractScene: AbstractSceneStatic
        abstract KeepAssets: KeepAssetsStatic
        abstract AssetContainer: AssetContainerStatic
        abstract Node: NodeStatic
        abstract RenderingGroupInfo: RenderingGroupInfoStatic
        abstract Scene: SceneStatic
        abstract SceneComponentConstants: SceneComponentConstantsStatic
        abstract Stage: StageStatic
        abstract Action: ActionStatic
        abstract ActionEvent: ActionEventStatic
        abstract ActionManager: ActionManagerStatic
        abstract Condition: ConditionStatic
        abstract ValueCondition: ValueConditionStatic
        abstract PredicateCondition: PredicateConditionStatic
        abstract StateCondition: StateConditionStatic
        abstract SwitchBooleanAction: SwitchBooleanActionStatic
        abstract SetStateAction: SetStateActionStatic
        abstract SetValueAction: SetValueActionStatic
        abstract IncrementValueAction: IncrementValueActionStatic
        abstract PlayAnimationAction: PlayAnimationActionStatic
        abstract StopAnimationAction: StopAnimationActionStatic
        abstract DoNothingAction: DoNothingActionStatic
        abstract CombineAction: CombineActionStatic
        abstract ExecuteCodeAction: ExecuteCodeActionStatic
        abstract SetParentAction: SetParentActionStatic
        abstract PlaySoundAction: PlaySoundActionStatic
        abstract StopSoundAction: StopSoundActionStatic
        abstract InterpolateValueAction: InterpolateValueActionStatic
        abstract Analyser: AnalyserStatic
        abstract AudioEngine: AudioEngineStatic
        abstract AudioSceneComponent: AudioSceneComponentStatic
        abstract Sound: SoundStatic
        abstract SoundTrack: SoundTrackStatic
        abstract WeightedSound: WeightedSoundStatic
        abstract Animatable: AnimatableStatic
        abstract AnimationRange: AnimationRangeStatic
        abstract AnimationEvent: AnimationEventStatic
        abstract PathCursor: PathCursorStatic
        abstract Animation: AnimationStatic
        abstract TargetedAnimation: TargetedAnimationStatic
        abstract AnimationGroup: AnimationGroupStatic
        abstract AnimationPropertiesOverride: AnimationPropertiesOverrideStatic
        abstract EasingFunction: EasingFunctionStatic
        abstract CircleEase: CircleEaseStatic
        abstract BackEase: BackEaseStatic
        abstract BounceEase: BounceEaseStatic
        abstract CubicEase: CubicEaseStatic
        abstract ElasticEase: ElasticEaseStatic
        abstract ExponentialEase: ExponentialEaseStatic
        abstract PowerEase: PowerEaseStatic
        abstract QuadraticEase: QuadraticEaseStatic
        abstract QuarticEase: QuarticEaseStatic
        abstract QuinticEase: QuinticEaseStatic
        abstract SineEase: SineEaseStatic
        abstract BezierCurveEase: BezierCurveEaseStatic
        abstract RuntimeAnimation: RuntimeAnimationStatic
        abstract Bone: BoneStatic
        abstract BoneIKController: BoneIKControllerStatic
        abstract BoneLookController: BoneLookControllerStatic
        abstract Skeleton: SkeletonStatic
        abstract Collider: ColliderStatic
        abstract CollisionWorker: string
        abstract CollisionCoordinatorWorker: CollisionCoordinatorWorkerStatic
        abstract CollisionCoordinatorLegacy: CollisionCoordinatorLegacyStatic
        abstract WorkerIncluded: bool
        abstract CollisionCache: CollisionCacheStatic
        abstract CollideWorker: CollideWorkerStatic
        abstract CollisionDetectorTransferable: CollisionDetectorTransferableStatic
        abstract IntersectionInfo: IntersectionInfoStatic
        abstract PickingInfo: PickingInfoStatic
        abstract ArcRotateCamera: ArcRotateCameraStatic
        abstract ArcRotateCameraInputsManager: ArcRotateCameraInputsManagerStatic
        abstract Camera: CameraStatic
        abstract CameraInputTypes: TypeLiteral_01
        abstract CameraInputsManager: CameraInputsManagerStatic
        abstract DeviceOrientationCamera: DeviceOrientationCameraStatic
        abstract FollowCamera: FollowCameraStatic
        abstract ArcFollowCamera: ArcFollowCameraStatic
        abstract FreeCamera: FreeCameraStatic
        abstract FreeCameraInputsManager: FreeCameraInputsManagerStatic
        abstract GamepadCamera: GamepadCameraStatic
        abstract TargetCamera: TargetCameraStatic
        abstract TouchCamera: TouchCameraStatic
        abstract UniversalCamera: UniversalCameraStatic
        abstract VirtualJoysticksCamera: VirtualJoysticksCameraStatic
        abstract DebugLayer: DebugLayerStatic
        abstract RayHelper: RayHelperStatic
        abstract InstancingAttributeInfo: InstancingAttributeInfoStatic
        abstract RenderTargetCreationOptions: RenderTargetCreationOptionsStatic
        abstract DepthTextureCreationOptions: DepthTextureCreationOptionsStatic
        abstract EngineCapabilities: EngineCapabilitiesStatic
        abstract Engine: EngineStatic
        abstract NullEngineOptions: NullEngineOptionsStatic
        abstract NullEngine: NullEngineStatic
        abstract BoundingBox: BoundingBoxStatic
        abstract BoundingInfo: BoundingInfoStatic
        abstract BoundingSphere: BoundingSphereStatic
        abstract Ray: RayStatic
        abstract KeyboardEventTypes: KeyboardEventTypesStatic
        abstract KeyboardInfo: KeyboardInfoStatic
        abstract KeyboardInfoPre: KeyboardInfoPreStatic
        abstract PointerEventTypes: PointerEventTypesStatic
        abstract PointerInfoBase: PointerInfoBaseStatic
        abstract PointerInfoPre: PointerInfoPreStatic
        abstract PointerInfo: PointerInfoStatic
        abstract StickValues: StickValuesStatic
        abstract Gamepad: GamepadStatic
        abstract GenericPad: GenericPadStatic
        abstract GamepadManager: GamepadManagerStatic
        abstract GamepadSystemSceneComponent: GamepadSystemSceneComponentStatic
        abstract Xbox360Pad: Xbox360PadStatic
        abstract AxisDragGizmo: AxisDragGizmoStatic
        abstract AxisScaleGizmo: AxisScaleGizmoStatic
        abstract BoundingBoxGizmo: BoundingBoxGizmoStatic
        abstract Gizmo: GizmoStatic
        abstract GizmoManager: GizmoManagerStatic
        abstract PlaneRotationGizmo: PlaneRotationGizmoStatic
        abstract PositionGizmo: PositionGizmoStatic
        abstract RotationGizmo: RotationGizmoStatic
        abstract ScaleGizmo: ScaleGizmoStatic
        abstract EngineInstrumentation: EngineInstrumentationStatic
        abstract SceneInstrumentation: SceneInstrumentationStatic
        abstract _TimeToken: _TimeTokenStatic
        abstract EnvironmentHelper: EnvironmentHelperStatic
        abstract PhotoDome: PhotoDomeStatic
        abstract VideoDome: VideoDomeStatic
        abstract EffectLayer: EffectLayerStatic
        abstract EffectLayerSceneComponent: EffectLayerSceneComponentStatic
        abstract GlowLayer: GlowLayerStatic
        abstract HighlightLayer: HighlightLayerStatic
        abstract Layer: LayerStatic
        abstract LayerSceneComponent: LayerSceneComponentStatic
        abstract LensFlare: LensFlareStatic
        abstract LensFlareSystem: LensFlareSystemStatic
        abstract LensFlareSystemSceneComponent: LensFlareSystemSceneComponentStatic
        abstract DirectionalLight: DirectionalLightStatic
        abstract HemisphericLight: HemisphericLightStatic
        abstract Light: LightStatic
        abstract PointLight: PointLightStatic
        abstract ShadowLight: ShadowLightStatic
        abstract SpotLight: SpotLightStatic
        abstract DefaultLoadingScreen: DefaultLoadingScreenStatic
        abstract SceneLoaderProgressEvent: SceneLoaderProgressEventStatic
        abstract SceneLoader: SceneLoaderStatic
        abstract ColorCurves: ColorCurvesStatic
        abstract EffectFallbacks: EffectFallbacksStatic
        abstract EffectCreationOptions: EffectCreationOptionsStatic
        abstract Effect: EffectStatic
        abstract FresnelParameters: FresnelParametersStatic
        abstract ImageProcessingConfigurationDefines: ImageProcessingConfigurationDefinesStatic
        abstract ImageProcessingConfiguration: ImageProcessingConfigurationStatic
        abstract MaterialDefines: MaterialDefinesStatic
        abstract Material: MaterialStatic
        abstract MaterialHelper: MaterialHelperStatic
        abstract MultiMaterial: MultiMaterialStatic
        abstract PushMaterial: PushMaterialStatic
        abstract ShaderMaterial: ShaderMaterialStatic
        abstract StandardMaterialDefines: StandardMaterialDefinesStatic
        abstract StandardMaterial: StandardMaterialStatic
        abstract UniformBuffer: UniformBufferStatic
        abstract Scalar: ScalarStatic
        abstract ToGammaSpace: float
        abstract ToLinearSpace: obj
        abstract Epsilon: obj
        abstract Color3: Color3Static
        abstract Color4: Color4Static
        abstract Vector2: Vector2Static
        abstract Vector3: Vector3Static
        abstract Vector4: Vector4Static
        abstract Size: SizeStatic
        abstract Quaternion: QuaternionStatic
        abstract Matrix: MatrixStatic
        abstract Plane: PlaneStatic
        abstract Viewport: ViewportStatic
        abstract Frustum: FrustumStatic
        abstract Axis: AxisStatic
        abstract BezierCurve: BezierCurveStatic
        abstract Angle: AngleStatic
        abstract Arc2: Arc2Static
        abstract Path2: Path2Static
        abstract Path3D: Path3DStatic
        abstract Curve3: Curve3Static
        abstract PositionNormalVertex: PositionNormalVertexStatic
        abstract PositionNormalTextureVertex: PositionNormalTextureVertexStatic
        abstract Tmp: TmpStatic
        abstract SphericalPolynomial: SphericalPolynomialStatic
        abstract SphericalHarmonics: SphericalHarmonicsStatic
        abstract AbstractMesh: AbstractMeshStatic
        abstract Buffer: BufferStatic
        abstract CSG: CSGStatic
        abstract Geometry: GeometryStatic
        abstract _PrimitiveGeometry: _PrimitiveGeometryStatic
        abstract RibbonGeometry: RibbonGeometryStatic
        abstract BoxGeometry: BoxGeometryStatic
        abstract SphereGeometry: SphereGeometryStatic
        abstract DiscGeometry: DiscGeometryStatic
        abstract CylinderGeometry: CylinderGeometryStatic
        abstract TorusGeometry: TorusGeometryStatic
        abstract GroundGeometry: GroundGeometryStatic
        abstract TiledGroundGeometry: TiledGroundGeometryStatic
        abstract PlaneGeometry: PlaneGeometryStatic
        abstract TorusKnotGeometry: TorusKnotGeometryStatic
        abstract GroundMesh: GroundMeshStatic
        abstract InstancedMesh: InstancedMeshStatic
        abstract LinesMesh: LinesMeshStatic
        abstract _CreationDataStorage: _CreationDataStorageStatic
        abstract _InstanceDataStorage: _InstanceDataStorageStatic
        abstract _InstancesBatch: _InstancesBatchStatic
        abstract Mesh: MeshStatic
        abstract VertexData: VertexDataStatic
        abstract MeshBuilder: MeshBuilderStatic
        abstract MeshLODLevel: MeshLODLevelStatic
        abstract SimplificationSettings: SimplificationSettingsStatic
        abstract SimplificationQueue: SimplificationQueueStatic
        abstract SimplicationQueueSceneComponent: SimplicationQueueSceneComponentStatic
        abstract Polygon: PolygonStatic
        abstract PolygonMeshBuilder: PolygonMeshBuilderStatic
        abstract BaseSubMesh: BaseSubMeshStatic
        abstract SubMesh: SubMeshStatic
        abstract TransformNode: TransformNodeStatic
        abstract VertexBuffer: VertexBufferStatic
        abstract MorphTarget: MorphTargetStatic
        abstract MorphTargetManager: MorphTargetManagerStatic
        abstract BaseParticleSystem: BaseParticleSystemStatic
        abstract GPUParticleSystem: GPUParticleSystemStatic
        abstract Particle: ParticleStatic
        abstract ParticleHelper: ParticleHelperStatic
        abstract ParticleSystem: ParticleSystemStatic
        abstract ParticleSystemSet: ParticleSystemSetStatic
        abstract SolidParticle: SolidParticleStatic
        abstract ModelShape: ModelShapeStatic
        abstract DepthSortedParticle: DepthSortedParticleStatic
        abstract SolidParticleSystem: SolidParticleSystemStatic
        abstract SubEmitter: SubEmitterStatic
        abstract PhysicsEngine: PhysicsEngineStatic
        abstract PhysicsEngineSceneComponent: PhysicsEngineSceneComponentStatic
        abstract PhysicsHelper: PhysicsHelperStatic
        abstract PhysicsRadialExplosionEvent: PhysicsRadialExplosionEventStatic
        abstract PhysicsGravitationalFieldEvent: PhysicsGravitationalFieldEventStatic
        abstract PhysicsUpdraftEvent: PhysicsUpdraftEventStatic
        abstract PhysicsVortexEvent: PhysicsVortexEventStatic
        abstract PhysicsImpostor: PhysicsImpostorStatic
        abstract PhysicsJoint: PhysicsJointStatic
        abstract DistanceJoint: DistanceJointStatic
        abstract MotorEnabledJoint: MotorEnabledJointStatic
        abstract HingeJoint: HingeJointStatic
        abstract Hinge2Joint: Hinge2JointStatic
        abstract ReflectionProbe: ReflectionProbeStatic
        abstract BoundingBoxRenderer: BoundingBoxRendererStatic
        abstract DepthRenderer: DepthRendererStatic
        abstract DepthRendererSceneComponent: DepthRendererSceneComponentStatic
        abstract EdgesRenderer: EdgesRendererStatic
        abstract GeometryBufferRenderer: GeometryBufferRendererStatic
        abstract GeometryBufferRendererSceneComponent: GeometryBufferRendererSceneComponentStatic
        abstract LineEdgesRenderer: LineEdgesRendererStatic
        abstract OutlineRenderer: OutlineRendererStatic
        abstract RenderingGroup: RenderingGroupStatic
        abstract RenderingManager: RenderingManagerStatic
        abstract UtilityLayerRenderer: UtilityLayerRendererStatic
        abstract AnaglyphPostProcess: AnaglyphPostProcessStatic
        abstract BlackAndWhitePostProcess: BlackAndWhitePostProcessStatic
        abstract BloomEffect: BloomEffectStatic
        abstract BloomMergePostProcess: BloomMergePostProcessStatic
        abstract BlurPostProcess: BlurPostProcessStatic
        abstract ChromaticAberrationPostProcess: ChromaticAberrationPostProcessStatic
        abstract CircleOfConfusionPostProcess: CircleOfConfusionPostProcessStatic
        abstract ColorCorrectionPostProcess: ColorCorrectionPostProcessStatic
        abstract ConvolutionPostProcess: ConvolutionPostProcessStatic
        abstract DepthOfFieldBlurPostProcess: DepthOfFieldBlurPostProcessStatic
        abstract DepthOfFieldEffect: DepthOfFieldEffectStatic
        abstract DepthOfFieldMergePostProcessOptions: DepthOfFieldMergePostProcessOptionsStatic
        abstract DepthOfFieldMergePostProcess: DepthOfFieldMergePostProcessStatic
        abstract DisplayPassPostProcess: DisplayPassPostProcessStatic
        abstract ExtractHighlightsPostProcess: ExtractHighlightsPostProcessStatic
        abstract FilterPostProcess: FilterPostProcessStatic
        abstract FxaaPostProcess: FxaaPostProcessStatic
        abstract GrainPostProcess: GrainPostProcessStatic
        abstract HighlightsPostProcess: HighlightsPostProcessStatic
        abstract ImageProcessingPostProcess: ImageProcessingPostProcessStatic
        abstract PassPostProcess: PassPostProcessStatic
        abstract PostProcess: PostProcessStatic
        abstract PostProcessManager: PostProcessManagerStatic
        abstract RefractionPostProcess: RefractionPostProcessStatic
        abstract SharpenPostProcess: SharpenPostProcessStatic
        abstract StereoscopicInterlacePostProcess: StereoscopicInterlacePostProcessStatic
        abstract TonemapPostProcess: TonemapPostProcessStatic
        abstract VolumetricLightScatteringPostProcess: VolumetricLightScatteringPostProcessStatic
        abstract VRDistortionCorrectionPostProcess: VRDistortionCorrectionPostProcessStatic
        abstract Sprite: SpriteStatic
        abstract SpriteManager: SpriteManagerStatic
        abstract SpriteSceneComponent: SpriteSceneComponentStatic
        abstract _AlphaState: _AlphaStateStatic
        abstract _DepthCullingState: _DepthCullingStateStatic
        abstract _StencilState: _StencilStateStatic
        abstract AndOrNotEvaluator: AndOrNotEvaluatorStatic
        abstract AbstractAssetTask: AbstractAssetTaskStatic
        abstract AssetsProgressEvent: AssetsProgressEventStatic
        abstract MeshAssetTask: MeshAssetTaskStatic
        abstract TextFileAssetTask: TextFileAssetTaskStatic
        abstract BinaryFileAssetTask: BinaryFileAssetTaskStatic
        abstract ImageAssetTask: ImageAssetTaskStatic
        abstract TextureAssetTask: TextureAssetTaskStatic
        abstract CubeTextureAssetTask: CubeTextureAssetTaskStatic
        abstract HDRCubeTextureAssetTask: HDRCubeTextureAssetTaskStatic
        abstract AssetsManager: AssetsManagerStatic
        abstract Database: DatabaseStatic
        abstract DDSTools: DDSToolsStatic
        abstract expandToProperty: callback: string * ?targetKey: string -> (obj option -> string -> unit)
        abstract serialize: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsTexture: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsColor3: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsFresnelParameters: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsVector2: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsVector3: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsMeshReference: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsColorCurves: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsColor4: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsImageProcessingConfiguration: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsQuaternion: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        /// <summary>Decorator used to define property that can be serialized as reference to a camera</summary>
        /// <param name="sourceName">defines the name of the property to decorate</param>
        abstract serializeAsCameraReference: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract SerializationHelper: SerializationHelperStatic
        abstract Deferred: DeferredStatic
        abstract EnvironmentTextureTools: EnvironmentTextureToolsStatic
        abstract FilesInput: FilesInputStatic
        abstract KhronosTextureContainer: KhronosTextureContainerStatic
        abstract EventState: EventStateStatic
        abstract Observer: ObserverStatic
        abstract MultiObserver: MultiObserverStatic
        abstract Observable: ObservableStatic
        abstract PerformanceMonitor: PerformanceMonitorStatic
        abstract RollingAverage: RollingAverageStatic
        abstract PromisePolyfill: PromisePolyfillStatic
        abstract SceneOptimization: SceneOptimizationStatic
        abstract TextureOptimization: TextureOptimizationStatic
        abstract HardwareScalingOptimization: HardwareScalingOptimizationStatic
        abstract ShadowsOptimization: ShadowsOptimizationStatic
        abstract PostProcessesOptimization: PostProcessesOptimizationStatic
        abstract LensFlaresOptimization: LensFlaresOptimizationStatic
        abstract CustomOptimization: CustomOptimizationStatic
        abstract ParticlesOptimization: ParticlesOptimizationStatic
        abstract RenderTargetsOptimization: RenderTargetsOptimizationStatic
        abstract MergeMeshesOptimization: MergeMeshesOptimizationStatic
        abstract SceneOptimizerOptions: SceneOptimizerOptionsStatic
        abstract SceneOptimizer: SceneOptimizerStatic
        abstract SceneSerializer: SceneSerializerStatic
        abstract SmartArray: SmartArrayStatic
        abstract SmartArrayNoDuplicate: SmartArrayNoDuplicateStatic
        abstract StringDictionary: StringDictionaryStatic
        abstract Tags: TagsStatic
        abstract TextureTools: TextureToolsStatic
        abstract TGATools: TGAToolsStatic
        abstract ColorGradient: ColorGradientStatic
        abstract Color3Gradient: Color3GradientStatic
        abstract FactorGradient: FactorGradientStatic
        abstract LoadFileError: LoadFileErrorStatic
        abstract RetryStrategy: RetryStrategyStatic
        abstract Tools: ToolsStatic
        abstract PerfCounter: PerfCounterStatic
        /// <summary>Use this className as a decorator on a given class definition to add it a name and optionally its module.
        /// You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.
        /// This method is the only way to get it done in all cases, even if the .js file declaring the class is minified</summary>
        /// <param name="name">The name of the class, case should be preserved</param>
        /// <param name="module">The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.</param>
        abstract className: name: string * ?``module``: string -> (Object -> unit)
        abstract AsyncLoop: AsyncLoopStatic
        abstract VideoRecorder: VideoRecorderStatic
        abstract VirtualJoystick: VirtualJoystickStatic
        abstract WorkerPool: WorkerPoolStatic
        abstract AutoRotationBehavior: AutoRotationBehaviorStatic
        abstract BouncingBehavior: BouncingBehaviorStatic
        abstract FramingBehavior: FramingBehaviorStatic
        abstract AttachToBoxBehavior: AttachToBoxBehaviorStatic
        abstract FadeInOutBehavior: FadeInOutBehaviorStatic
        abstract MultiPointerScaleBehavior: MultiPointerScaleBehaviorStatic
        abstract PointerDragBehavior: PointerDragBehaviorStatic
        abstract SixDofDragBehavior: SixDofDragBehaviorStatic
        abstract ArcRotateCameraGamepadInput: ArcRotateCameraGamepadInputStatic
        abstract ArcRotateCameraKeyboardMoveInput: ArcRotateCameraKeyboardMoveInputStatic
        abstract ArcRotateCameraMouseWheelInput: ArcRotateCameraMouseWheelInputStatic
        abstract ArcRotateCameraPointersInput: ArcRotateCameraPointersInputStatic
        abstract ArcRotateCameraVRDeviceOrientationInput: ArcRotateCameraVRDeviceOrientationInputStatic
        abstract FreeCameraDeviceOrientationInput: FreeCameraDeviceOrientationInputStatic
        abstract FreeCameraGamepadInput: FreeCameraGamepadInputStatic
        abstract FreeCameraKeyboardMoveInput: FreeCameraKeyboardMoveInputStatic
        abstract FreeCameraMouseInput: FreeCameraMouseInputStatic
        abstract FreeCameraTouchInput: FreeCameraTouchInputStatic
        abstract FreeCameraVirtualJoystickInput: FreeCameraVirtualJoystickInputStatic
        abstract AnaglyphArcRotateCamera: AnaglyphArcRotateCameraStatic
        abstract AnaglyphFreeCamera: AnaglyphFreeCameraStatic
        abstract AnaglyphGamepadCamera: AnaglyphGamepadCameraStatic
        abstract AnaglyphUniversalCamera: AnaglyphUniversalCameraStatic
        abstract StereoscopicArcRotateCamera: StereoscopicArcRotateCameraStatic
        abstract StereoscopicFreeCamera: StereoscopicFreeCameraStatic
        abstract StereoscopicGamepadCamera: StereoscopicGamepadCameraStatic
        abstract StereoscopicUniversalCamera: StereoscopicUniversalCameraStatic
        abstract VRCameraMetrics: VRCameraMetricsStatic
        abstract VRDeviceOrientationArcRotateCamera: VRDeviceOrientationArcRotateCameraStatic
        abstract VRDeviceOrientationFreeCamera: VRDeviceOrientationFreeCameraStatic
        abstract VRDeviceOrientationGamepadCamera: VRDeviceOrientationGamepadCameraStatic
        abstract VRExperienceHelper: VRExperienceHelperStatic
        abstract WebVRFreeCamera: WebVRFreeCameraStatic
        abstract _OcclusionDataStorage: _OcclusionDataStorageStatic
        abstract Octree: OctreeStatic
        abstract OctreeBlock: OctreeBlockStatic
        abstract OctreeSceneComponent: OctreeSceneComponentStatic
        abstract DaydreamController: DaydreamControllerStatic
        abstract GearVRController: GearVRControllerStatic
        abstract GenericController: GenericControllerStatic
        abstract OculusTouchController: OculusTouchControllerStatic
        abstract PoseEnabledControllerHelper: PoseEnabledControllerHelperStatic
        abstract PoseEnabledController: PoseEnabledControllerStatic
        abstract ViveController: ViveControllerStatic
        abstract WebVRController: WebVRControllerStatic
        abstract WindowsMotionController: WindowsMotionControllerStatic
        abstract ShadowGenerator: ShadowGeneratorStatic
        abstract ShadowGeneratorSceneComponent: ShadowGeneratorSceneComponentStatic
        abstract BackgroundMaterial: BackgroundMaterialStatic
        abstract PBRBaseMaterial: PBRBaseMaterialStatic
        abstract PBRBaseSimpleMaterial: PBRBaseSimpleMaterialStatic
        abstract PBRMaterial: PBRMaterialStatic
        abstract PBRMetallicRoughnessMaterial: PBRMetallicRoughnessMaterialStatic
        abstract PBRSpecularGlossinessMaterial: PBRSpecularGlossinessMaterialStatic
        abstract BaseTexture: BaseTextureStatic
        abstract ColorGradingTexture: ColorGradingTextureStatic
        abstract CubeTexture: CubeTextureStatic
        abstract DynamicTexture: DynamicTextureStatic
        abstract HDRCubeTexture: HDRCubeTextureStatic
        abstract InternalTexture: InternalTextureStatic
        abstract DummyInternalTextureTracker: DummyInternalTextureTrackerStatic
        abstract MirrorTexture: MirrorTextureStatic
        abstract MultiRenderTarget: MultiRenderTargetStatic
        abstract RawCubeTexture: RawCubeTextureStatic
        abstract RawTexture: RawTextureStatic
        abstract RawTexture3D: RawTexture3DStatic
        abstract RefractionTexture: RefractionTextureStatic
        abstract RenderTargetTexture: RenderTargetTextureStatic
        abstract Texture: TextureStatic
        abstract VideoTexture: VideoTextureStatic
        abstract DracoCompression: DracoCompressionStatic
        abstract BoxParticleEmitter: BoxParticleEmitterStatic
        abstract ConeParticleEmitter: ConeParticleEmitterStatic
        abstract CylinderParticleEmitter: CylinderParticleEmitterStatic
        abstract CylinderDirectedParticleEmitter: CylinderDirectedParticleEmitterStatic
        abstract HemisphericParticleEmitter: HemisphericParticleEmitterStatic
        abstract PointParticleEmitter: PointParticleEmitterStatic
        abstract SphereParticleEmitter: SphereParticleEmitterStatic
        abstract SphereDirectedParticleEmitter: SphereDirectedParticleEmitterStatic
        abstract CannonJSPlugin: CannonJSPluginStatic
        abstract OimoJSPlugin: OimoJSPluginStatic
        abstract PostProcessRenderEffect: PostProcessRenderEffectStatic
        abstract PostProcessRenderPipeline: PostProcessRenderPipelineStatic
        abstract PostProcessRenderPipelineManager: PostProcessRenderPipelineManagerStatic
        abstract PostProcessRenderPipelineManagerSceneComponent: PostProcessRenderPipelineManagerSceneComponentStatic
        abstract CubeMapToSphericalPolynomialTools: CubeMapToSphericalPolynomialToolsStatic
        abstract HDRTools: HDRToolsStatic
        abstract PanoramaToCubeMapTools: PanoramaToCubeMapToolsStatic
        abstract CustomProceduralTexture: CustomProceduralTextureStatic
        abstract NoiseProceduralTexture: NoiseProceduralTextureStatic
        abstract ProceduralTexture: ProceduralTextureStatic
        abstract ProceduralTextureSceneComponent: ProceduralTextureSceneComponentStatic
        abstract DefaultRenderingPipeline: DefaultRenderingPipelineStatic
        abstract LensRenderingPipeline: LensRenderingPipelineStatic
        abstract SSAO2RenderingPipeline: SSAO2RenderingPipelineStatic
        abstract SSAORenderingPipeline: SSAORenderingPipelineStatic
        abstract StandardRenderingPipeline: StandardRenderingPipelineStatic

    type [<AllowNullLiteral>] BabylonFileParser =
        [<Emit "$0($1...)">] abstract Invoke: parsedData: obj option * scene: Scene * container: AssetContainer * rootUrl: string -> unit

    type [<AllowNullLiteral>] IndividualBabylonFileParser =
        [<Emit "$0($1...)">] abstract Invoke: parsedData: obj option * scene: Scene * rootUrl: string -> obj option

    /// Base class of the scene acting as a container for the different elements composing a scene.
    /// This class is dynamically extended by the different components of the scene increasing
    /// flexibility and reducing coupling
    type [<AllowNullLiteral>] AbstractScene =
        /// Gets the list of root nodes (ie. nodes with no parent)
        abstract rootNodes: ResizeArray<Node> with get, set
        /// All of the cameras added to this scene
        abstract cameras: ResizeArray<Camera> with get, set
        /// All of the lights added to this scene
        abstract lights: ResizeArray<Light> with get, set
        /// All of the (abstract) meshes added to this scene
        abstract meshes: ResizeArray<AbstractMesh> with get, set
        /// The list of skeletons added to the scene
        abstract skeletons: ResizeArray<Skeleton> with get, set
        /// All of the particle systems added to this scene
        abstract particleSystems: ResizeArray<IParticleSystem> with get, set
        /// Gets a list of Animations associated with the scene
        abstract animations: ResizeArray<Animation> with get, set
        /// All of the animation groups added to this scene
        abstract animationGroups: ResizeArray<AnimationGroup> with get, set
        /// All of the multi-materials added to this scene
        abstract multiMaterials: ResizeArray<MultiMaterial> with get, set
        /// All of the materials added to this scene
        abstract materials: ResizeArray<Material> with get, set
        /// The list of morph target managers added to the scene
        abstract morphTargetManagers: ResizeArray<MorphTargetManager> with get, set
        /// The list of geometries used in the scene.
        abstract geometries: ResizeArray<Geometry> with get, set
        /// All of the tranform nodes added to this scene
        abstract transformNodes: ResizeArray<TransformNode> with get, set
        /// ActionManagers available on the scene.
        abstract actionManagers: ResizeArray<ActionManager> with get, set
        /// Textures to keep.
        abstract textures: ResizeArray<BaseTexture> with get, set
        /// The list of sounds used in the scene.
        abstract sounds: Nullable<Array<Sound>> with get, set
        /// The list of effect layers (highlights/glow) added to the scene
        abstract effectLayers: Array<EffectLayer> with get, set
        /// <summary>Removes the given effect layer from this scene.</summary>
        /// <param name="toRemove">defines the effect layer to remove</param>
        abstract removeEffectLayer: toRemove: EffectLayer -> float
        /// <summary>Adds the given effect layer to this scene</summary>
        /// <param name="newEffectLayer">defines the effect layer to add</param>
        abstract addEffectLayer: newEffectLayer: EffectLayer -> unit
        /// <summary>Return a the first highlight layer of the scene with a given name.</summary>
        /// <param name="name">The name of the highlight layer to look for.</param>
        abstract getGlowLayerByName: name: string -> Nullable<GlowLayer>
        /// <summary>Return a the first highlight layer of the scene with a given name.</summary>
        /// <param name="name">The name of the highlight layer to look for.</param>
        abstract getHighlightLayerByName: name: string -> Nullable<HighlightLayer>
        /// The list of layers (background and foreground) of the scene
        abstract layers: Array<Layer> with get, set
        /// The list of lens flare system added to the scene
        abstract lensFlareSystems: Array<LensFlareSystem> with get, set
        /// <summary>Removes the given lens flare system from this scene.</summary>
        /// <param name="toRemove">The lens flare system to remove</param>
        abstract removeLensFlareSystem: toRemove: LensFlareSystem -> float
        /// <summary>Adds the given lens flare system to this scene</summary>
        /// <param name="newLensFlareSystem">The lens flare system to add</param>
        abstract addLensFlareSystem: newLensFlareSystem: LensFlareSystem -> unit
        /// <summary>Gets a lens flare system using its name</summary>
        /// <param name="name">defines the name to look for</param>
        abstract getLensFlareSystemByName: name: string -> Nullable<LensFlareSystem>
        /// <summary>Gets a lens flare system using its id</summary>
        /// <param name="id">defines the id to look for</param>
        abstract getLensFlareSystemByID: id: string -> Nullable<LensFlareSystem>
        /// The list of procedural textures added to the scene
        abstract proceduralTextures: Array<ProceduralTexture> with get, set

    /// Base class of the scene acting as a container for the different elements composing a scene.
    /// This class is dynamically extended by the different components of the scene increasing
    /// flexibility and reducing coupling
    type [<AllowNullLiteral>] AbstractSceneStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> AbstractScene
        /// <summary>Adds a parser in the list of available ones</summary>
        /// <param name="name">Defines the name of the parser</param>
        /// <param name="parser">Defines the parser to add</param>
        abstract AddParser: name: string * parser: BabylonFileParser -> unit
        /// <summary>Gets a general parser from the list of avaialble ones</summary>
        /// <param name="name">Defines the name of the parser</param>
        abstract GetParser: name: string -> Nullable<BabylonFileParser>
        /// <summary>Adds n individual parser in the list of available ones</summary>
        /// <param name="name">Defines the name of the parser</param>
        /// <param name="parser">Defines the parser to add</param>
        abstract AddIndividualParser: name: string * parser: IndividualBabylonFileParser -> unit
        /// <summary>Gets an individual parser from the list of avaialble ones</summary>
        /// <param name="name">Defines the name of the parser</param>
        abstract GetIndividualParser: name: string -> Nullable<IndividualBabylonFileParser>
        /// <summary>Parser json data and populate both a scene and its associated container object</summary>
        /// <param name="jsonData">Defines the data to parse</param>
        /// <param name="scene">Defines the scene to parse the data for</param>
        /// <param name="container">Defines the container attached to the parsing sequence</param>
        /// <param name="rootUrl">Defines the root url of the data</param>
        abstract Parse: jsonData: obj option * scene: Scene * container: AssetContainer * rootUrl: string -> unit

    /// Set of assets to keep when moving a scene into an asset container.
    type [<AllowNullLiteral>] KeepAssets =
        inherit AbstractScene

    /// Set of assets to keep when moving a scene into an asset container.
    type [<AllowNullLiteral>] KeepAssetsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> KeepAssets

    /// Container with a set of assets that can be added or removed from a scene.
    type [<AllowNullLiteral>] AssetContainer =
        inherit AbstractScene
        /// The scene the AssetContainer belongs to.
        abstract scene: Scene with get, set
        /// Adds all the assets from the container to the scene.
        abstract addAllToScene: unit -> unit
        /// Removes all the assets in the container from the scene
        abstract removeAllFromScene: unit -> unit
        /// <summary>Removes all the assets contained in the scene and adds them to the container.</summary>
        /// <param name="keepAssets">Set of assets to keep in the scene. (default: empty)</param>
        abstract moveAllFromScene: ?keepAssets: KeepAssets -> unit
        /// Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.
        abstract createRootMesh: unit -> Mesh

    /// Container with a set of assets that can be added or removed from a scene.
    type [<AllowNullLiteral>] AssetContainerStatic =
        /// <summary>Instantiates an AssetContainer.</summary>
        /// <param name="scene">The scene the AssetContainer belongs to.</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> AssetContainer

    type [<AllowNullLiteral>] NodeConstructor =
        [<Emit "$0($1...)">] abstract Invoke: name: string * scene: Scene * ?options: obj -> (unit -> Node)

    /// Node is the basic class for all scene objects (Mesh, Light, Camera.)
    type [<AllowNullLiteral>] Node =
        inherit IBehaviorAware<Node>
        /// Gets or sets the name of the node
        abstract name: string with get, set
        /// Gets or sets the id of the node
        abstract id: string with get, set
        /// Gets or sets the unique id of the node
        abstract uniqueId: float with get, set
        /// Gets or sets a string used to store user defined state for the node
        abstract state: string with get, set
        /// Gets or sets an object used to store user defined information for the node
        abstract metadata: obj option with get, set
        /// Gets or sets a boolean used to define if the node must be serialized
        abstract doNotSerialize: bool with get, set
        abstract _isDisposed: bool with get, set
        /// Gets a list of Animations associated with the node
        abstract animations: ResizeArray<Animation> with get, set
        abstract _ranges: TypeLiteral_02 with get, set
        /// Callback raised when the node is ready to be used
        abstract onReady: (Node -> unit) with get, set
        abstract _currentRenderId: float with get, set
        abstract _childRenderId: float with get, set
        abstract _waitingParentId: Nullable<string> with get, set
        abstract _scene: Scene with get, set
        abstract _cache: obj option with get, set
        abstract _worldMatrix: Matrix with get, set
        abstract _worldMatrixDeterminant: float with get, set
        /// Gets a boolean indicating if the node has been disposed
        abstract isDisposed: unit -> bool
        /// Gets or sets the parent of the node
        abstract parent: Nullable<Node> with get, set
        /// Gets or sets the animation properties override
        abstract animationPropertiesOverride: Nullable<AnimationPropertiesOverride> with get, set
        /// Gets a string idenfifying the name of the class
        abstract getClassName: unit -> string
        /// An event triggered when the mesh is disposed
        abstract onDisposeObservable: Observable<Node> with get, set
        /// Sets a callback that will be raised when the node will be disposed
        abstract onDispose: (unit -> unit) with get, set
        /// Gets the scene of the node
        abstract getScene: unit -> Scene
        /// Gets the engine of the node
        abstract getEngine: unit -> Engine
        /// <summary>Attach a behavior to the node</summary>
        /// <param name="behavior">defines the behavior to attach</param>
        /// <param name="attachImmediately">defines that the behavior must be attached even if the scene is still loading</param>
        abstract addBehavior: behavior: Behavior<Node> * ?attachImmediately: bool -> Node
        /// <summary>Remove an attached behavior</summary>
        /// <param name="behavior">defines the behavior to attach</param>
        abstract removeBehavior: behavior: Behavior<Node> -> Node
        /// Gets the list of attached behaviors
        abstract behaviors: ResizeArray<Behavior<Node>>
        /// <summary>Gets an attached behavior by name</summary>
        /// <param name="name">defines the name of the behavior to look for</param>
        abstract getBehaviorByName: name: string -> Nullable<Behavior<Node>>
        /// Returns the latest update of the World matrix
        abstract getWorldMatrix: unit -> Matrix
        abstract _getWorldMatrixDeterminant: unit -> float
        /// Returns directly the latest state of the mesh World matrix.
        /// A Matrix is returned.
        abstract worldMatrixFromCache: Matrix
        abstract _initCache: unit -> unit
        abstract updateCache: ?force: bool -> unit
        abstract _updateCache: ?ignoreParentClass: bool -> unit
        abstract _isSynchronized: unit -> bool
        abstract _markSyncedWithParent: unit -> unit
        abstract isSynchronizedWithParent: unit -> bool
        abstract isSynchronized: unit -> bool
        /// <summary>Is this node ready to be used/rendered</summary>
        /// <param name="completeCheck">defines if a complete check (including materials and lights) has to be done (false by default)</param>
        abstract isReady: ?completeCheck: bool -> bool
        /// <summary>Is this node enabled?
        /// If the node has a parent, all ancestors will be checked and false will be returned if any are false (not enabled), otherwise will return true</summary>
        /// <param name="checkAncestors">indicates if this method should check the ancestors. The default is to check the ancestors. If set to false, the method will return the value of this node without checking ancestors</param>
        abstract isEnabled: ?checkAncestors: bool -> bool
        abstract _syncParentEnabledState: unit -> unit
        /// <summary>Set the enabled state of this node</summary>
        /// <param name="value">defines the new enabled state</param>
        abstract setEnabled: value: bool -> unit
        /// <summary>Is this node a descendant of the given node?
        /// The function will iterate up the hierarchy until the ancestor was found or no more parents defined</summary>
        /// <param name="ancestor">defines the parent node to inspect</param>
        abstract isDescendantOf: ancestor: Node -> bool
        abstract _getDescendants: results: ResizeArray<Node> * ?directDescendantsOnly: bool * ?predicate: (Node -> bool) -> unit
        /// <summary>Will return all nodes that have this node as ascendant</summary>
        /// <param name="directDescendantsOnly">defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered</param>
        /// <param name="predicate">defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored</param>
        abstract getDescendants: ?directDescendantsOnly: bool * ?predicate: (Node -> bool) -> ResizeArray<Node>
        /// <summary>Get all child-meshes of this node</summary>
        /// <param name="directDescendantsOnly">defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered</param>
        /// <param name="predicate">defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored</param>
        abstract getChildMeshes: ?directDescendantsOnly: bool * ?predicate: (Node -> bool) -> ResizeArray<AbstractMesh>
        /// <summary>Get all child-transformNodes of this node</summary>
        /// <param name="directDescendantsOnly">defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered</param>
        /// <param name="predicate">defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored</param>
        abstract getChildTransformNodes: ?directDescendantsOnly: bool * ?predicate: (Node -> bool) -> ResizeArray<TransformNode>
        /// <summary>Get all direct children of this node</summary>
        /// <param name="predicate">defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored</param>
        abstract getChildren: ?predicate: (Node -> bool) -> ResizeArray<Node>
        abstract _setReady: state: bool -> unit
        /// <summary>Get an animation by name</summary>
        /// <param name="name">defines the name of the animation to look for</param>
        abstract getAnimationByName: name: string -> Nullable<Animation>
        /// <summary>Creates an animation range for this node</summary>
        /// <param name="name">defines the name of the range</param>
        /// <param name="from">defines the starting key</param>
        /// <param name="to">defines the end key</param>
        abstract createAnimationRange: name: string * from: float * ``to``: float -> unit
        /// <summary>Delete a specific animation range</summary>
        /// <param name="name">defines the name of the range to delete</param>
        /// <param name="deleteFrames">defines if animation frames from the range must be deleted as well</param>
        abstract deleteAnimationRange: name: string * ?deleteFrames: bool -> unit
        /// <summary>Get an animation range by name</summary>
        /// <param name="name">defines the name of the animation range to look for</param>
        abstract getAnimationRange: name: string -> Nullable<AnimationRange>
        /// <summary>Will start the animation sequence</summary>
        /// <param name="name">defines the range frames for animation sequence</param>
        /// <param name="loop">defines if the animation should loop (false by default)</param>
        /// <param name="speedRatio">defines the speed factor in which to run the animation (1 by default)</param>
        /// <param name="onAnimationEnd">defines a function to be executed when the animation ended (undefined by default)</param>
        abstract beginAnimation: name: string * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) -> Nullable<Animatable>
        /// Serialize animation ranges into a JSON compatible object
        abstract serializeAnimationRanges: unit -> obj option
        /// <summary>Computes the world matrix of the node</summary>
        /// <param name="force">defines if the cache version should be invalidated forcing the world matrix to be created from scratch</param>
        abstract computeWorldMatrix: ?force: bool -> Matrix
        /// <summary>Releases resources associated with this node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit

    /// Node is the basic class for all scene objects (Mesh, Light, Camera.)
    type [<AllowNullLiteral>] NodeStatic =
        /// <summary>Add a new node constructor</summary>
        /// <param name="type">defines the type name of the node to construct</param>
        /// <param name="constructorFunc">defines the constructor function</param>
        abstract AddNodeConstructor: ``type``: string * constructorFunc: NodeConstructor -> unit
        /// <summary>Returns a node constructor based on type name</summary>
        /// <param name="type">defines the type name</param>
        /// <param name="name">defines the new node name</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="options">defines optional options to transmit to constructors</param>
        abstract Construct: ``type``: string * name: string * scene: Scene * ?options: obj -> Nullable<(unit -> Node)>
        /// <summary>Creates a new Node</summary>
        /// <param name="name">the name and id to be given to this node</param>
        /// <param name="scene">the scene this node will be added to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Scene -> Node
        /// <summary>Parse animation range data from a serialization object and store them into a given node</summary>
        /// <param name="node">defines where to store the animation ranges</param>
        /// <param name="parsedNode">defines the serialization object to read data from</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract ParseAnimationRanges: node: Node * parsedNode: obj option * scene: Scene -> unit

    /// Define an interface for all classes that will hold resources
    type [<AllowNullLiteral>] IDisposable =
        /// Releases all held resources
        abstract dispose: unit -> unit

    /// This class is used by the onRenderingGroupObservable
    type [<AllowNullLiteral>] RenderingGroupInfo =
        /// The Scene that being rendered
        abstract scene: Scene with get, set
        /// The camera currently used for the rendering pass
        abstract camera: Nullable<Camera> with get, set
        /// The ID of the renderingGroup being processed
        abstract renderingGroupId: float with get, set

    /// This class is used by the onRenderingGroupObservable
    type [<AllowNullLiteral>] RenderingGroupInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> RenderingGroupInfo

    /// Represents a scene to be rendered by the engine.
    type [<AllowNullLiteral>] Scene =
        inherit AbstractScene
        inherit IAnimatable
        /// Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame
        abstract autoClear: bool with get, set
        /// Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame
        abstract autoClearDepthAndStencil: bool with get, set
        /// Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))
        abstract clearColor: Color4 with get, set
        /// Defines the color used to simulate the ambient color (Default is (0, 0, 0))
        abstract ambientColor: Color3 with get, set
        abstract _environmentBRDFTexture: BaseTexture with get, set
        abstract _environmentTexture: BaseTexture with get, set
        /// Texture used in all pbr material as the reflection texture.
        /// As in the majority of the scene they are the same (exception for multi room and so on),
        /// this is easier to reference from here than from all the materials.
        /// Texture used in all pbr material as the reflection texture.
        /// As in the majority of the scene they are the same (exception for multi room and so on),
        /// this is easier to set here than in all the materials.
        abstract environmentTexture: BaseTexture with get, set
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Default image processing configuration used either in the rendering
        /// Forward main pass or through the imageProcessingPostProcess if present.
        /// As in the majority of the scene they are the same (exception for multi camera),
        /// this is easier to reference from here than from all the materials and post process.
        /// 
        /// No setter as we it is a shared configuration, you can set the values instead.
        abstract imageProcessingConfiguration: ImageProcessingConfiguration
        /// Gets or sets a boolean indicating if all rendering must be done in wireframe
        abstract forceWireframe: bool with get, set
        /// Gets or sets a boolean indicating if all rendering must be done in point cloud
        abstract forcePointsCloud: bool with get, set
        /// Gets or sets the active clipplane 1
        abstract clipPlane: Nullable<Plane> with get, set
        /// Gets or sets the active clipplane 2
        abstract clipPlane2: Nullable<Plane> with get, set
        /// Gets or sets the active clipplane 3
        abstract clipPlane3: Nullable<Plane> with get, set
        /// Gets or sets the active clipplane 4
        abstract clipPlane4: Nullable<Plane> with get, set
        /// Gets or sets a boolean indicating if animations are enabled
        abstract animationsEnabled: bool with get, set
        /// Gets or sets the animation properties override
        abstract animationPropertiesOverride: Nullable<AnimationPropertiesOverride> with get, set
        /// Gets or sets a boolean indicating if a constant deltatime has to be used
        /// This is mostly useful for testing purposes when you do not want the animations to scale with the framerate
        abstract useConstantAnimationDeltaTime: bool with get, set
        /// Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated
        /// Please note that it requires to run a ray cast through the scene on every frame
        abstract constantlyUpdateMeshUnderPointer: bool with get, set
        /// Defines the HTML cursor to use when hovering over interactive elements
        abstract hoverCursor: string with get, set
        /// Defines the HTML default cursor to use (empty by default)
        abstract defaultCursor: string with get, set
        /// This is used to call preventDefault() on pointer down
        /// in order to block unwanted artifacts like system double clicks
        abstract preventDefaultOnPointerDown: bool with get, set
        /// Gets or sets user defined metadata
        abstract metadata: obj option with get, set
        /// Gets the name of the plugin used to load this scene (null by default)
        abstract loadingPluginName: string with get, set
        /// Use this array to add regular expressions used to disable offline support for specific urls
        abstract disableOfflineSupportExceptionRules: ResizeArray<RegExp> with get, set
        /// An event triggered when the scene is disposed.
        abstract onDisposeObservable: Observable<Scene> with get, set
        /// Sets a function to be executed when this scene is disposed. 
        abstract onDispose: (unit -> unit) with get, set
        /// An event triggered before rendering the scene (right after animations and physics)
        abstract onBeforeRenderObservable: Observable<Scene> with get, set
        /// Sets a function to be executed before rendering this scene 
        abstract beforeRender: Nullable<(unit -> unit)> with get, set
        /// An event triggered after rendering the scene
        abstract onAfterRenderObservable: Observable<Scene> with get, set
        /// Sets a function to be executed after rendering this scene 
        abstract afterRender: Nullable<(unit -> unit)> with get, set
        /// An event triggered before animating the scene
        abstract onBeforeAnimationsObservable: Observable<Scene> with get, set
        /// An event triggered after animations processing
        abstract onAfterAnimationsObservable: Observable<Scene> with get, set
        /// An event triggered before draw calls are ready to be sent
        abstract onBeforeDrawPhaseObservable: Observable<Scene> with get, set
        /// An event triggered after draw calls have been sent
        abstract onAfterDrawPhaseObservable: Observable<Scene> with get, set
        /// An event triggered when the scene is ready
        abstract onReadyObservable: Observable<Scene> with get, set
        /// An event triggered before rendering a camera
        abstract onBeforeCameraRenderObservable: Observable<Camera> with get, set
        /// Sets a function to be executed before rendering a camera
        abstract beforeCameraRender: (unit -> unit) with get, set
        /// An event triggered after rendering a camera
        abstract onAfterCameraRenderObservable: Observable<Camera> with get, set
        /// Sets a function to be executed after rendering a camera
        abstract afterCameraRender: (unit -> unit) with get, set
        /// An event triggered when active meshes evaluation is about to start
        abstract onBeforeActiveMeshesEvaluationObservable: Observable<Scene> with get, set
        /// An event triggered when active meshes evaluation is done
        abstract onAfterActiveMeshesEvaluationObservable: Observable<Scene> with get, set
        /// An event triggered when particles rendering is about to start
        /// Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
        abstract onBeforeParticlesRenderingObservable: Observable<Scene> with get, set
        /// An event triggered when particles rendering is done
        /// Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
        abstract onAfterParticlesRenderingObservable: Observable<Scene> with get, set
        /// An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed
        abstract onDataLoadedObservable: Observable<Scene> with get, set
        /// An event triggered when a camera is created
        abstract onNewCameraAddedObservable: Observable<Camera> with get, set
        /// An event triggered when a camera is removed
        abstract onCameraRemovedObservable: Observable<Camera> with get, set
        /// An event triggered when a light is created
        abstract onNewLightAddedObservable: Observable<Light> with get, set
        /// An event triggered when a light is removed
        abstract onLightRemovedObservable: Observable<Light> with get, set
        /// An event triggered when a geometry is created
        abstract onNewGeometryAddedObservable: Observable<Geometry> with get, set
        /// An event triggered when a geometry is removed
        abstract onGeometryRemovedObservable: Observable<Geometry> with get, set
        /// An event triggered when a transform node is created
        abstract onNewTransformNodeAddedObservable: Observable<TransformNode> with get, set
        /// An event triggered when a transform node is removed
        abstract onTransformNodeRemovedObservable: Observable<TransformNode> with get, set
        /// An event triggered when a mesh is created
        abstract onNewMeshAddedObservable: Observable<AbstractMesh> with get, set
        /// An event triggered when a mesh is removed
        abstract onMeshRemovedObservable: Observable<AbstractMesh> with get, set
        /// An event triggered when a material is created
        abstract onNewMaterialAddedObservable: Observable<Material> with get, set
        /// An event triggered when a material is removed
        abstract onMaterialRemovedObservable: Observable<Material> with get, set
        /// An event triggered when a texture is created
        abstract onNewTextureAddedObservable: Observable<BaseTexture> with get, set
        /// An event triggered when a texture is removed
        abstract onTextureRemovedObservable: Observable<BaseTexture> with get, set
        /// An event triggered when render targets are about to be rendered
        /// Can happen multiple times per frame.
        abstract onBeforeRenderTargetsRenderObservable: Observable<Scene> with get, set
        /// An event triggered when render targets were rendered.
        /// Can happen multiple times per frame.
        abstract onAfterRenderTargetsRenderObservable: Observable<Scene> with get, set
        /// An event triggered before calculating deterministic simulation step
        abstract onBeforeStepObservable: Observable<Scene> with get, set
        /// An event triggered after calculating deterministic simulation step
        abstract onAfterStepObservable: Observable<Scene> with get, set
        /// This Observable will be triggered before rendering each renderingGroup of each rendered camera.
        /// The RenderinGroupInfo class contains all the information about the context in which the observable is called
        /// If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)
        abstract onBeforeRenderingGroupObservable: Observable<RenderingGroupInfo> with get, set
        /// This Observable will be triggered after rendering each renderingGroup of each rendered camera.
        /// The RenderinGroupInfo class contains all the information about the context in which the observable is called
        /// If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)
        abstract onAfterRenderingGroupObservable: Observable<RenderingGroupInfo> with get, set
        /// This Observable will when a mesh has been imported into the scene.
        abstract onMeshImportedObservable: Observable<AbstractMesh> with get, set
        /// Gets or sets a predicate used to select candidate meshes for a pointer down event
        abstract pointerDownPredicate: (AbstractMesh -> bool) with get, set
        /// Gets or sets a predicate used to select candidate meshes for a pointer up event
        abstract pointerUpPredicate: (AbstractMesh -> bool) with get, set
        /// Gets or sets a predicate used to select candidate meshes for a pointer move event
        abstract pointerMovePredicate: (AbstractMesh -> bool) with get, set
        /// Deprecated. Use onPointerObservable instead 
        abstract onPointerMove: (PointerEvent -> PickingInfo -> PointerEventTypes -> unit) with get, set
        /// Deprecated. Use onPointerObservable instead 
        abstract onPointerDown: (PointerEvent -> PickingInfo -> PointerEventTypes -> unit) with get, set
        /// Deprecated. Use onPointerObservable instead 
        abstract onPointerUp: (PointerEvent -> Nullable<PickingInfo> -> PointerEventTypes -> unit) with get, set
        /// Deprecated. Use onPointerObservable instead 
        abstract onPointerPick: (PointerEvent -> PickingInfo -> unit) with get, set
        /// This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).
        /// You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true
        abstract onPrePointerObservable: Observable<PointerInfoPre> with get, set
        /// Observable event triggered each time an input event is received from the rendering canvas
        abstract onPointerObservable: Observable<PointerInfo> with get, set
        /// Gets the pointer coordinates without any translation (ie. straight out of the pointer event)
        abstract unTranslatedPointer: Vector2
        /// Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position 
        abstract cameraToUseForPointers: Nullable<Camera> with get, set
        abstract _mirroredCameraPosition: Nullable<Vector3> with get, set
        /// This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()
        /// You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true
        abstract onPreKeyboardObservable: Observable<KeyboardInfoPre> with get, set
        /// Observable event triggered each time an keyboard event is received from the hosting window
        abstract onKeyboardObservable: Observable<KeyboardInfo> with get, set
        /// Gets or sets a boolean indicating if the scene must use right-handed coordinates system
        abstract useRightHandedSystem: bool with get, set
        /// <summary>Sets the step Id used by deterministic lock step</summary>
        /// <param name="newStepId">defines the step Id</param>
        abstract setStepId: newStepId: float -> unit
        /// Gets the step Id used by deterministic lock step
        abstract getStepId: unit -> float
        /// Gets the internal step used by deterministic lock step
        abstract getInternalStep: unit -> float
        /// Gets or sets a boolean indicating if fog is enabled on this scene
        abstract fogEnabled: bool with get, set
        /// Gets or sets the fog mode to use
        abstract fogMode: float with get, set
        /// Gets or sets the fog color to use
        abstract fogColor: Color3 with get, set
        /// Gets or sets the fog density to use
        abstract fogDensity: float with get, set
        /// Gets or sets the fog start distance to use
        abstract fogStart: float with get, set
        /// Gets or sets the fog end distance to use
        abstract fogEnd: float with get, set
        /// Gets or sets a boolean indicating if shadows are enabled on this scene
        abstract shadowsEnabled: bool with get, set
        /// Gets or sets a boolean indicating if lights are enabled on this scene
        abstract lightsEnabled: bool with get, set
        /// All of the active cameras added to this scene. 
        abstract activeCameras: ResizeArray<Camera> with get, set
        /// The current active camera 
        abstract activeCamera: Nullable<Camera> with get, set
        /// The default material used on meshes when no material is affected 
        /// The default material used on meshes when no material is affected 
        abstract defaultMaterial: Material with get, set
        /// Gets or sets a boolean indicating if textures are enabled on this scene
        abstract texturesEnabled: bool with get, set
        /// Gets or sets a boolean indicating if particles are enabled on this scene
        abstract particlesEnabled: bool with get, set
        /// Gets or sets a boolean indicating if sprites are enabled on this scene
        abstract spritesEnabled: bool with get, set
        /// Gets or sets a boolean indicating if skeletons are enabled on this scene
        abstract skeletonsEnabled: bool with get, set
        /// Gets or sets a boolean indicating if lens flares are enabled on this scene
        abstract lensFlaresEnabled: bool with get, set
        /// Gets or sets a boolean indicating if collisions are enabled on this scene
        abstract collisionsEnabled: bool with get, set
        abstract collisionCoordinator: ICollisionCoordinator with get, set
        /// Defines the gravity applied to this scene (used only for collisions)
        abstract gravity: Vector3 with get, set
        /// Gets or sets a boolean indicating if postprocesses are enabled on this scene
        abstract postProcessesEnabled: bool with get, set
        /// The list of postprocesses added to the scene
        abstract postProcesses: ResizeArray<PostProcess> with get, set
        /// Gets the current postprocess manager
        abstract postProcessManager: PostProcessManager with get, set
        /// Gets or sets a boolean indicating if render targets are enabled on this scene
        abstract renderTargetsEnabled: bool with get, set
        /// Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes
        /// We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com
        abstract dumpNextRenderTargets: bool with get, set
        /// The list of user defined render targets added to the scene
        abstract customRenderTargets: ResizeArray<RenderTargetTexture> with get, set
        /// Defines if texture loading must be delayed
        /// If true, textures will only be loaded when they need to be rendered
        abstract useDelayedTextureLoading: bool with get, set
        /// Gets the list of meshes imported to the scene through SceneLoader
        abstract importedMeshesFiles: ResizeArray<String> with get, set
        /// Gets or sets a boolean indicating if probes are enabled on this scene
        abstract probesEnabled: bool with get, set
        abstract database: Database with get, set
        /// Gets or sets the action manager associated with the scene
        abstract actionManager: ActionManager with get, set
        /// Gets or sets a boolean indicating if procedural textures are enabled on this scene
        abstract proceduralTexturesEnabled: bool with get, set
        abstract _activeIndices: PerfCounter with get, set
        abstract _activeParticles: PerfCounter with get, set
        abstract _activeBones: PerfCounter with get, set
        /// Gets or sets a general scale for animation speed
        abstract animationTimeScale: float with get, set
        abstract _cachedMaterial: Nullable<Material> with get, set
        abstract _cachedEffect: Nullable<Effect> with get, set
        abstract _cachedVisibility: Nullable<float> with get, set
        abstract _toBeDisposed: ResizeArray<Nullable<IDisposable>> with get, set
        /// Gets or sets a boolean indicating that all submeshes of active meshes must be rendered
        /// Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)
        abstract dispatchAllSubMeshesOfActiveMeshes: bool with get, set
        abstract _activeParticleSystems: SmartArray<IParticleSystem> with get, set
        abstract _activeAnimatables: ResizeArray<Animatable> with get, set
        abstract _forcedViewPosition: Nullable<Vector3> with get, set
        abstract _isAlternateRenderingEnabled: bool
        /// Gets the list of frustum planes (built from the active camera)
        abstract frustumPlanes: ResizeArray<Plane>
        /// Gets or sets a boolean indicating if lights must be sorted by priority (off by default)
        /// This is useful if there are more lights that the maximum simulteanous authorized
        abstract requireLightSorting: bool with get, set
        abstract _components: ResizeArray<ISceneComponent> with get, set
        abstract _serializableComponents: ResizeArray<ISceneSerializableComponent> with get, set
        /// <param name="component">Defines the component to add to the scene</param>
        abstract _addComponent: ``component``: ISceneComponent -> unit
        /// <param name="name">defines the name of the component to retrieve</param>
        abstract _getComponent: name: string -> Nullable<ISceneComponent>
        abstract _beforeCameraUpdateStage: Stage<SimpleStageAction> with get, set
        abstract _beforeClearStage: Stage<SimpleStageAction> with get, set
        abstract _gatherRenderTargetsStage: Stage<RenderTargetsStageAction> with get, set
        abstract _gatherActiveCameraRenderTargetsStage: Stage<RenderTargetsStageAction> with get, set
        abstract _isReadyForMeshStage: Stage<MeshStageAction> with get, set
        abstract _beforeEvaluateActiveMeshStage: Stage<SimpleStageAction> with get, set
        abstract _evaluateSubMeshStage: Stage<EvaluateSubMeshStageAction> with get, set
        abstract _activeMeshStage: Stage<ActiveMeshStageAction> with get, set
        abstract _cameraDrawRenderTargetStage: Stage<CameraStageAction> with get, set
        abstract _beforeCameraDrawStage: Stage<CameraStageAction> with get, set
        abstract _beforeRenderingGroupDrawStage: Stage<RenderingGroupStageAction> with get, set
        abstract _beforeRenderingMeshStage: Stage<RenderingMeshStageAction> with get, set
        abstract _afterRenderingMeshStage: Stage<RenderingMeshStageAction> with get, set
        abstract _afterRenderingGroupDrawStage: Stage<RenderingGroupStageAction> with get, set
        abstract _afterCameraDrawStage: Stage<CameraStageAction> with get, set
        abstract _afterRenderStage: Stage<SimpleStageAction> with get, set
        abstract _pointerMoveStage: Stage<PointerMoveStageAction> with get, set
        abstract _pointerDownStage: Stage<PointerUpDownStageAction> with get, set
        abstract _pointerUpStage: Stage<PointerUpDownStageAction> with get, set
        abstract _getDefaultMeshCandidates: unit -> ISmartArrayLike<AbstractMesh>
        abstract _getDefaultSubMeshCandidates: mesh: AbstractMesh -> ISmartArrayLike<SubMesh>
        /// Sets the default candidate providers for the scene.
        /// This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates
        /// and getCollidingSubMeshCandidates to their default function
        abstract setDefaultCandidateProviders: unit -> unit
        /// Gets a boolean indicating if collisions are processed on a web worker
        abstract workerCollisions: bool with get, set
        /// Gets the mesh that is currently under the pointer
        abstract meshUnderPointer: Nullable<AbstractMesh>
        /// Gets the current on-screen X position of the pointer
        abstract pointerX: float
        /// Gets the current on-screen Y position of the pointer
        abstract pointerY: float
        /// Gets the cached material (ie. the latest rendered one)
        abstract getCachedMaterial: unit -> Nullable<Material>
        /// Gets the cached effect (ie. the latest rendered one)
        abstract getCachedEffect: unit -> Nullable<Effect>
        /// Gets the cached visibility state (ie. the latest rendered one)
        abstract getCachedVisibility: unit -> Nullable<float>
        /// <summary>Gets a boolean indicating if the current material / effect / visibility must be bind again</summary>
        /// <param name="material">defines the current material</param>
        /// <param name="effect">defines the current effect</param>
        /// <param name="visibility">defines the current visibility state</param>
        abstract isCachedMaterialInvalid: material: Material * effect: Effect * ?visibility: float -> bool
        /// Gets the engine associated with the scene
        abstract getEngine: unit -> Engine
        /// Gets the total number of vertices rendered per frame
        abstract getTotalVertices: unit -> float
        /// Gets the performance counter for total vertices
        abstract totalVerticesPerfCounter: PerfCounter
        /// Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)
        abstract getActiveIndices: unit -> float
        /// Gets the performance counter for active indices
        abstract totalActiveIndicesPerfCounter: PerfCounter
        /// Gets the total number of active particles rendered per frame
        abstract getActiveParticles: unit -> float
        /// Gets the performance counter for active particles
        abstract activeParticlesPerfCounter: PerfCounter
        /// Gets the total number of active bones rendered per frame
        abstract getActiveBones: unit -> float
        /// Gets the performance counter for active bones
        abstract activeBonesPerfCounter: PerfCounter
        abstract getInterFramePerfCounter: unit -> float
        abstract interFramePerfCounter: Nullable<PerfCounter>
        abstract getLastFrameDuration: unit -> float
        abstract lastFramePerfCounter: Nullable<PerfCounter>
        abstract getEvaluateActiveMeshesDuration: unit -> float
        abstract evaluateActiveMeshesDurationPerfCounter: Nullable<PerfCounter>
        /// Gets the array of active meshes
        abstract getActiveMeshes: unit -> SmartArray<AbstractMesh>
        abstract getRenderTargetsDuration: unit -> float
        abstract getRenderDuration: unit -> float
        abstract renderDurationPerfCounter: Nullable<PerfCounter>
        abstract getParticlesDuration: unit -> float
        abstract particlesDurationPerfCounter: Nullable<PerfCounter>
        abstract getSpritesDuration: unit -> float
        abstract spriteDuractionPerfCounter: Nullable<PerfCounter>
        /// Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)
        abstract getAnimationRatio: unit -> float
        /// Gets an unique Id for the current render phase
        abstract getRenderId: unit -> float
        /// Gets an unique Id for the current frame
        abstract getFrameId: unit -> float
        /// Call this function if you want to manually increment the render Id
        abstract incrementRenderId: unit -> unit
        /// <summary>Use this method to simulate a pointer move on a mesh
        /// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay</summary>
        /// <param name="pickResult">pickingInfo of the object wished to simulate pointer event on</param>
        /// <param name="pointerEventInit">pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)</param>
        abstract simulatePointerMove: pickResult: PickingInfo * ?pointerEventInit: PointerEventInit -> Scene
        /// <summary>Use this method to simulate a pointer down on a mesh
        /// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay</summary>
        /// <param name="pickResult">pickingInfo of the object wished to simulate pointer event on</param>
        /// <param name="pointerEventInit">pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)</param>
        abstract simulatePointerDown: pickResult: PickingInfo * ?pointerEventInit: PointerEventInit -> Scene
        /// <summary>Use this method to simulate a pointer up on a mesh
        /// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay</summary>
        /// <param name="pickResult">pickingInfo of the object wished to simulate pointer event on</param>
        /// <param name="pointerEventInit">pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)</param>
        abstract simulatePointerUp: pickResult: PickingInfo * ?pointerEventInit: PointerEventInit -> Scene
        /// <summary>Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)</summary>
        /// <param name="pointerId">defines the pointer id to use in a multi-touch scenario (0 by default)</param>
        abstract isPointerCaptured: ?pointerId: float -> bool
        abstract _isPointerSwiping: unit -> bool
        /// <summary>Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp</summary>
        /// <param name="attachUp">defines if you want to attach events to pointerup</param>
        /// <param name="attachDown">defines if you want to attach events to pointerdown</param>
        /// <param name="attachMove">defines if you want to attach events to pointermove</param>
        abstract attachControl: ?attachUp: bool * ?attachDown: bool * ?attachMove: bool -> unit
        /// Detaches all event handlers
        abstract detachControl: unit -> unit
        /// This function will check if the scene can be rendered (textures are loaded, shaders are compiled)
        /// Delay loaded resources are not taking in account
        abstract isReady: unit -> bool
        /// Resets all cached information relative to material (including effect and visibility) 
        abstract resetCachedMaterial: unit -> unit
        /// <summary>Registers a function to be called before every frame render</summary>
        /// <param name="func">defines the function to register</param>
        abstract registerBeforeRender: func: (unit -> unit) -> unit
        /// <summary>Unregisters a function called before every frame render</summary>
        /// <param name="func">defines the function to unregister</param>
        abstract unregisterBeforeRender: func: (unit -> unit) -> unit
        /// <summary>Registers a function to be called after every frame render</summary>
        /// <param name="func">defines the function to register</param>
        abstract registerAfterRender: func: (unit -> unit) -> unit
        /// <summary>Unregisters a function called after every frame render</summary>
        /// <param name="func">defines the function to unregister</param>
        abstract unregisterAfterRender: func: (unit -> unit) -> unit
        /// <summary>The provided function will run before render once and will be disposed afterwards.
        /// A timeout delay can be provided so that the function will be executed in N ms.
        /// The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.</summary>
        /// <param name="func">The function to be executed.</param>
        /// <param name="timeout">optional delay in ms</param>
        abstract executeOnceBeforeRender: func: (unit -> unit) * ?timeout: float -> unit
        abstract _addPendingData: data: obj option -> unit
        abstract _removePendingData: data: obj option -> unit
        /// Returns the number of items waiting to be loaded
        abstract getWaitingItemsCount: unit -> float
        /// Returns a boolean indicating if the scene is still loading data
        abstract isLoading: bool
        /// <summary>Registers a function to be executed when the scene is ready</summary>
        /// <param name="func">- the function to be executed</param>
        abstract executeWhenReady: func: (unit -> unit) -> unit
        /// Returns a promise that resolves when the scene is ready
        abstract whenReadyAsync: unit -> Promise<unit>
        abstract _checkIsReady: unit -> unit
        /// <summary>Will start the animation sequence of a given target</summary>
        /// <param name="target">defines the target</param>
        /// <param name="from">defines from which frame should animation start</param>
        /// <param name="to">defines until which frame should animation run.</param>
        /// <param name="weight">defines the weight to apply to the animation (1.0 by default)</param>
        /// <param name="loop">defines if the animation loops</param>
        /// <param name="speedRatio">defines the speed in which to run the animation (1.0 by default)</param>
        /// <param name="onAnimationEnd">defines the function to be executed when the animation ends</param>
        /// <param name="animatable">defines an animatable object. If not provided a new one will be created from the given params</param>
        /// <param name="targetMask">defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)</param>
        abstract beginWeightedAnimation: target: obj option * from: float * ``to``: float * ?weight: float * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) * ?animatable: Animatable * ?targetMask: (obj option -> bool) -> Animatable
        /// <summary>Will start the animation sequence of a given target</summary>
        /// <param name="target">defines the target</param>
        /// <param name="from">defines from which frame should animation start</param>
        /// <param name="to">defines until which frame should animation run.</param>
        /// <param name="loop">defines if the animation loops</param>
        /// <param name="speedRatio">defines the speed in which to run the animation (1.0 by default)</param>
        /// <param name="onAnimationEnd">defines the function to be executed when the animation ends</param>
        /// <param name="animatable">defines an animatable object. If not provided a new one will be created from the given params</param>
        /// <param name="stopCurrent">defines if the current animations must be stopped first (true by default)</param>
        /// <param name="targetMask">defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)</param>
        abstract beginAnimation: target: obj option * from: float * ``to``: float * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) * ?animatable: Animatable * ?stopCurrent: bool * ?targetMask: (obj option -> bool) -> Animatable
        /// <summary>Begin a new animation on a given node</summary>
        /// <param name="target">defines the target where the animation will take place</param>
        /// <param name="animations">defines the list of animations to start</param>
        /// <param name="from">defines the initial value</param>
        /// <param name="to">defines the final value</param>
        /// <param name="loop">defines if you want animation to loop (off by default)</param>
        /// <param name="speedRatio">defines the speed ratio to apply to all animations</param>
        /// <param name="onAnimationEnd">defines the callback to call when an animation ends (will be called once per node)</param>
        abstract beginDirectAnimation: target: obj option * animations: ResizeArray<Animation> * from: float * ``to``: float * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) -> Animatable
        /// <summary>Begin a new animation on a given node and its hierarchy</summary>
        /// <param name="target">defines the root node where the animation will take place</param>
        /// <param name="directDescendantsOnly">if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.</param>
        /// <param name="animations">defines the list of animations to start</param>
        /// <param name="from">defines the initial value</param>
        /// <param name="to">defines the final value</param>
        /// <param name="loop">defines if you want animation to loop (off by default)</param>
        /// <param name="speedRatio">defines the speed ratio to apply to all animations</param>
        /// <param name="onAnimationEnd">defines the callback to call when an animation ends (will be called once per node)</param>
        abstract beginDirectHierarchyAnimation: target: Node * directDescendantsOnly: bool * animations: ResizeArray<Animation> * from: float * ``to``: float * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) -> ResizeArray<Animatable>
        /// <summary>Gets the animatable associated with a specific target</summary>
        /// <param name="target">defines the target of the animatable</param>
        abstract getAnimatableByTarget: target: obj option -> Nullable<Animatable>
        /// <summary>Gets all animatables associated with a given target</summary>
        /// <param name="target">defines the target to look animatables for</param>
        abstract getAllAnimatablesByTarget: target: obj option -> Array<Animatable>
        /// Gets all animatable attached to the scene
        abstract animatables: ResizeArray<Animatable>
        /// <summary>Will stop the animation of the given target</summary>
        /// <param name="target">- the target</param>
        /// <param name="animationName">- the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)</param>
        /// <param name="targetMask">- a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)</param>
        abstract stopAnimation: target: obj option * ?animationName: string * ?targetMask: (obj option -> bool) -> unit
        /// Stops and removes all animations that have been applied to the scene
        abstract stopAllAnimations: unit -> unit
        abstract _registerTargetForLateAnimationBinding: runtimeAnimation: RuntimeAnimation * originalValue: obj option -> unit
        abstract _switchToAlternateCameraConfiguration: active: bool -> unit
        /// Gets the current view matrix
        abstract getViewMatrix: unit -> Matrix
        /// Gets the current projection matrix
        abstract getProjectionMatrix: unit -> Matrix
        /// Gets the current transform matrix
        abstract getTransformMatrix: unit -> Matrix
        /// <summary>Sets the current transform matrix</summary>
        /// <param name="view">defines the View matrix to use</param>
        /// <param name="projection">defines the Projection matrix to use</param>
        abstract setTransformMatrix: view: Matrix * projection: Matrix -> unit
        abstract _setAlternateTransformMatrix: view: Matrix * projection: Matrix -> unit
        /// Gets the uniform buffer used to store scene data
        abstract getSceneUniformBuffer: unit -> UniformBuffer
        /// Gets an unique (relatively to the current scene) Id
        abstract getUniqueId: unit -> float
        /// <summary>Add a mesh to the list of scene's meshes</summary>
        /// <param name="newMesh">defines the mesh to add</param>
        /// <param name="recursive">if all child meshes should also be added to the scene</param>
        abstract addMesh: newMesh: AbstractMesh * ?recursive: bool -> unit
        /// <summary>Remove a mesh for the list of scene's meshes</summary>
        /// <param name="toRemove">defines the mesh to remove</param>
        /// <param name="recursive">if all child meshes should also be removed from the scene</param>
        abstract removeMesh: toRemove: AbstractMesh * ?recursive: bool -> float
        /// <summary>Add a transform node to the list of scene's transform nodes</summary>
        /// <param name="newTransformNode">defines the transform node to add</param>
        abstract addTransformNode: newTransformNode: TransformNode -> unit
        /// <summary>Remove a transform node for the list of scene's transform nodes</summary>
        /// <param name="toRemove">defines the transform node to remove</param>
        abstract removeTransformNode: toRemove: TransformNode -> float
        /// <summary>Remove a skeleton for the list of scene's skeletons</summary>
        /// <param name="toRemove">defines the skeleton to remove</param>
        abstract removeSkeleton: toRemove: Skeleton -> float
        /// <summary>Remove a morph target for the list of scene's morph targets</summary>
        /// <param name="toRemove">defines the morph target to remove</param>
        abstract removeMorphTargetManager: toRemove: MorphTargetManager -> float
        /// <summary>Remove a light for the list of scene's lights</summary>
        /// <param name="toRemove">defines the light to remove</param>
        abstract removeLight: toRemove: Light -> float
        /// <summary>Remove a camera for the list of scene's cameras</summary>
        /// <param name="toRemove">defines the camera to remove</param>
        abstract removeCamera: toRemove: Camera -> float
        /// <summary>Remove a particle system for the list of scene's particle systems</summary>
        /// <param name="toRemove">defines the particle system to remove</param>
        abstract removeParticleSystem: toRemove: IParticleSystem -> float
        /// <summary>Remove a animation for the list of scene's animations</summary>
        /// <param name="toRemove">defines the animation to remove</param>
        abstract removeAnimation: toRemove: Animation -> float
        /// <summary>Removes the given animation group from this scene.</summary>
        /// <param name="toRemove">The animation group to remove</param>
        abstract removeAnimationGroup: toRemove: AnimationGroup -> float
        /// <summary>Removes the given multi-material from this scene.</summary>
        /// <param name="toRemove">The multi-material to remove</param>
        abstract removeMultiMaterial: toRemove: MultiMaterial -> float
        /// <summary>Removes the given material from this scene.</summary>
        /// <param name="toRemove">The material to remove</param>
        abstract removeMaterial: toRemove: Material -> float
        /// <summary>Removes the given action manager from this scene.</summary>
        /// <param name="toRemove">The action manager to remove</param>
        abstract removeActionManager: toRemove: ActionManager -> float
        /// <summary>Removes the given texture from this scene.</summary>
        /// <param name="toRemove">The texture to remove</param>
        abstract removeTexture: toRemove: BaseTexture -> float
        /// <summary>Adds the given light to this scene</summary>
        /// <param name="newLight">The light to add</param>
        abstract addLight: newLight: Light -> unit
        /// Sorts the list list based on light priorities
        abstract sortLightsByPriority: unit -> unit
        /// <summary>Adds the given camera to this scene</summary>
        /// <param name="newCamera">The camera to add</param>
        abstract addCamera: newCamera: Camera -> unit
        /// <summary>Adds the given skeleton to this scene</summary>
        /// <param name="newSkeleton">The skeleton to add</param>
        abstract addSkeleton: newSkeleton: Skeleton -> unit
        /// <summary>Adds the given particle system to this scene</summary>
        /// <param name="newParticleSystem">The particle system to add</param>
        abstract addParticleSystem: newParticleSystem: IParticleSystem -> unit
        /// <summary>Adds the given animation to this scene</summary>
        /// <param name="newAnimation">The animation to add</param>
        abstract addAnimation: newAnimation: Animation -> unit
        /// <summary>Adds the given animation group to this scene.</summary>
        /// <param name="newAnimationGroup">The animation group to add</param>
        abstract addAnimationGroup: newAnimationGroup: AnimationGroup -> unit
        /// <summary>Adds the given multi-material to this scene</summary>
        /// <param name="newMultiMaterial">The multi-material to add</param>
        abstract addMultiMaterial: newMultiMaterial: MultiMaterial -> unit
        /// <summary>Adds the given material to this scene</summary>
        /// <param name="newMaterial">The material to add</param>
        abstract addMaterial: newMaterial: Material -> unit
        /// <summary>Adds the given morph target to this scene</summary>
        /// <param name="newMorphTargetManager">The morph target to add</param>
        abstract addMorphTargetManager: newMorphTargetManager: MorphTargetManager -> unit
        /// <summary>Adds the given geometry to this scene</summary>
        /// <param name="newGeometry">The geometry to add</param>
        abstract addGeometry: newGeometry: Geometry -> unit
        /// <summary>Adds the given action manager to this scene</summary>
        /// <param name="newActionManager">The action manager to add</param>
        abstract addActionManager: newActionManager: ActionManager -> unit
        /// <summary>Adds the given texture to this scene.</summary>
        /// <param name="newTexture">The texture to add</param>
        abstract addTexture: newTexture: BaseTexture -> unit
        /// <summary>Switch active camera</summary>
        /// <param name="newCamera">defines the new active camera</param>
        /// <param name="attachControl">defines if attachControl must be called for the new active camera (default: true)</param>
        abstract switchActiveCamera: newCamera: Camera * ?attachControl: bool -> unit
        /// <summary>sets the active camera of the scene using its ID</summary>
        /// <param name="id">defines the camera's ID</param>
        abstract setActiveCameraByID: id: string -> Nullable<Camera>
        /// <summary>sets the active camera of the scene using its name</summary>
        /// <param name="name">defines the camera's name</param>
        abstract setActiveCameraByName: name: string -> Nullable<Camera>
        /// <summary>get an animation group using its name</summary>
        /// <param name="name">defines the material's name</param>
        abstract getAnimationGroupByName: name: string -> Nullable<AnimationGroup>
        /// <summary>get a material using its id</summary>
        /// <param name="id">defines the material's ID</param>
        abstract getMaterialByID: id: string -> Nullable<Material>
        /// <summary>Gets a material using its name</summary>
        /// <param name="name">defines the material's name</param>
        abstract getMaterialByName: name: string -> Nullable<Material>
        /// <summary>Gets a camera using its id</summary>
        /// <param name="id">defines the id to look for</param>
        abstract getCameraByID: id: string -> Nullable<Camera>
        /// <summary>Gets a camera using its unique id</summary>
        /// <param name="uniqueId">defines the unique id to look for</param>
        abstract getCameraByUniqueID: uniqueId: float -> Nullable<Camera>
        /// <summary>Gets a camera using its name</summary>
        /// <param name="name">defines the camera's name</param>
        abstract getCameraByName: name: string -> Nullable<Camera>
        /// <summary>Gets a bone using its id</summary>
        /// <param name="id">defines the bone's id</param>
        abstract getBoneByID: id: string -> Nullable<Bone>
        /// <summary>Gets a bone using its id</summary>
        /// <param name="name">defines the bone's name</param>
        abstract getBoneByName: name: string -> Nullable<Bone>
        /// <summary>Gets a light node using its name</summary>
        /// <param name="name">defines the the light's name</param>
        abstract getLightByName: name: string -> Nullable<Light>
        /// <summary>Gets a light node using its id</summary>
        /// <param name="id">defines the light's id</param>
        abstract getLightByID: id: string -> Nullable<Light>
        /// <summary>Gets a light node using its scene-generated unique ID</summary>
        /// <param name="uniqueId">defines the light's unique id</param>
        abstract getLightByUniqueID: uniqueId: float -> Nullable<Light>
        /// <summary>Gets a particle system by id</summary>
        /// <param name="id">defines the particle system id</param>
        abstract getParticleSystemByID: id: string -> Nullable<IParticleSystem>
        /// <summary>Gets a geometry using its ID</summary>
        /// <param name="id">defines the geometry's id</param>
        abstract getGeometryByID: id: string -> Nullable<Geometry>
        /// <summary>Add a new geometry to this scene</summary>
        /// <param name="geometry">defines the geometry to be added to the scene.</param>
        /// <param name="force">defines if the geometry must be pushed even if a geometry with this id already exists</param>
        abstract pushGeometry: geometry: Geometry * ?force: bool -> bool
        /// <summary>Removes an existing geometry</summary>
        /// <param name="geometry">defines the geometry to be removed from the scene</param>
        abstract removeGeometry: geometry: Geometry -> bool
        /// Gets the list of geometries attached to the scene
        abstract getGeometries: unit -> ResizeArray<Geometry>
        /// <summary>Gets the first added mesh found of a given ID</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getMeshByID: id: string -> Nullable<AbstractMesh>
        /// <summary>Gets a list of meshes using their id</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getMeshesByID: id: string -> Array<AbstractMesh>
        /// <summary>Gets the first added transform node found of a given ID</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getTransformNodeByID: id: string -> Nullable<TransformNode>
        /// <summary>Gets a list of transform nodes using their id</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getTransformNodesByID: id: string -> Array<TransformNode>
        /// <summary>Gets a mesh with its auto-generated unique id</summary>
        /// <param name="uniqueId">defines the unique id to search for</param>
        abstract getMeshByUniqueID: uniqueId: float -> Nullable<AbstractMesh>
        /// <summary>Gets a the last added mesh using a given id</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getLastMeshByID: id: string -> Nullable<AbstractMesh>
        /// <summary>Gets a the last added node (Mesh, Camera, Light) using a given id</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getLastEntryByID: id: string -> Nullable<Node>
        /// <summary>Gets a node (Mesh, Camera, Light) using a given id</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getNodeByID: id: string -> Nullable<Node>
        /// <summary>Gets a node (Mesh, Camera, Light) using a given name</summary>
        /// <param name="name">defines the name to search for</param>
        abstract getNodeByName: name: string -> Nullable<Node>
        /// <summary>Gets a mesh using a given name</summary>
        /// <param name="name">defines the name to search for</param>
        abstract getMeshByName: name: string -> Nullable<AbstractMesh>
        /// <summary>Gets a transform node using a given name</summary>
        /// <param name="name">defines the name to search for</param>
        abstract getTransformNodeByName: name: string -> Nullable<TransformNode>
        /// <summary>Gets a skeleton using a given id (if many are found, this function will pick the last one)</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getLastSkeletonByID: id: string -> Nullable<Skeleton>
        /// <summary>Gets a skeleton using a given id (if many are found, this function will pick the first one)</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getSkeletonById: id: string -> Nullable<Skeleton>
        /// <summary>Gets a skeleton using a given name</summary>
        /// <param name="name">defines the name to search for</param>
        abstract getSkeletonByName: name: string -> Nullable<Skeleton>
        /// <summary>Gets a morph target manager  using a given id (if many are found, this function will pick the last one)</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getMorphTargetManagerById: id: float -> Nullable<MorphTargetManager>
        /// <summary>Gets a boolean indicating if the given mesh is active</summary>
        /// <param name="mesh">defines the mesh to look for</param>
        abstract isActiveMesh: mesh: AbstractMesh -> bool
        /// Return a unique id as a string which can serve as an identifier for the scene
        abstract uid: string
        /// <summary>Add an externaly attached data from its key.
        /// This method call will fail and return false, if such key already exists.
        /// If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.</summary>
        /// <param name="key">the unique key that identifies the data</param>
        /// <param name="data">the data object to associate to the key for this Engine instance</param>
        abstract addExternalData: key: string * data: 'T -> bool
        /// <summary>Get an externaly attached data from its key</summary>
        /// <param name="key">the unique key that identifies the data</param>
        abstract getExternalData: key: string -> Nullable<'T>
        /// <summary>Get an externaly attached data from its key, create it using a factory if it's not already present</summary>
        /// <param name="key">the unique key that identifies the data</param>
        /// <param name="factory">the factory that will be called to create the instance if and only if it doesn't exists</param>
        abstract getOrAddExternalDataWithFactory: key: string * factory: (string -> 'T) -> 'T
        /// <summary>Remove an externaly attached data from the Engine instance</summary>
        /// <param name="key">the unique key that identifies the data</param>
        abstract removeExternalData: key: string -> bool
        /// Clear the processed materials smart array preventing retention point in material dispose.
        abstract freeProcessedMaterials: unit -> unit
        /// Clear the active meshes smart array preventing retention point in mesh dispose.
        abstract freeActiveMeshes: unit -> unit
        /// Clear the info related to rendering groups preventing retention points during dispose.
        abstract freeRenderingGroups: unit -> unit
        abstract _isInIntermediateRendering: unit -> bool
        /// Lambda returning the list of potentially active meshes.
        abstract getActiveMeshCandidates: (unit -> ISmartArrayLike<AbstractMesh>) with get, set
        /// Lambda returning the list of potentially active sub meshes.
        abstract getActiveSubMeshCandidates: (AbstractMesh -> ISmartArrayLike<SubMesh>) with get, set
        /// Lambda returning the list of potentially intersecting sub meshes.
        abstract getIntersectingSubMeshCandidates: (AbstractMesh -> Ray -> ISmartArrayLike<SubMesh>) with get, set
        /// Lambda returning the list of potentially colliding sub meshes.
        abstract getCollidingSubMeshCandidates: (AbstractMesh -> Collider -> ISmartArrayLike<SubMesh>) with get, set
        /// Use this function to stop evaluating active meshes. The current list will be keep alive between frames
        abstract freezeActiveMeshes: unit -> Scene
        /// Use this function to restart evaluating active meshes on every frame
        abstract unfreezeActiveMeshes: unit -> Scene
        /// <summary>Update the transform matrix to update from the current active camera</summary>
        /// <param name="force">defines a boolean used to force the update even if cache is up to date</param>
        abstract updateTransformMatrix: ?force: bool -> unit
        /// <summary>Defines an alternate camera (used mostly in VR-like scenario where two cameras can render the same scene from a slightly different point of view)</summary>
        /// <param name="alternateCamera">defines the camera to use</param>
        abstract updateAlternateTransformMatrix: alternateCamera: Camera -> unit
        abstract _allowPostProcessClearColor: bool with get, set
        abstract _advancePhysicsEngineStep: step: float -> unit
        /// User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode
        abstract getDeterministicFrameTime: (unit -> float) with get, set
        /// <summary>Render the scene</summary>
        /// <param name="updateCameras">defines a boolean indicating if cameras must update according to their inputs (true by default)</param>
        abstract render: ?updateCameras: bool -> unit
        /// Freeze all materials
        /// A frozen material will not be updatable but should be faster to render
        abstract freezeMaterials: unit -> unit
        /// Unfreeze all materials
        /// A frozen material will not be updatable but should be faster to render
        abstract unfreezeMaterials: unit -> unit
        /// Releases all held ressources
        abstract dispose: unit -> unit
        /// Gets if the scene is already disposed
        abstract isDisposed: bool
        /// Call this function to reduce memory footprint of the scene.
        /// Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)
        abstract clearCachedVertexData: unit -> unit
        /// This function will remove the local cached buffer data from texture.
        /// It will save memory but will prevent the texture from being rebuilt
        abstract cleanCachedTextureBuffer: unit -> unit
        /// <summary>Get the world extend vectors with an optional filter</summary>
        /// <param name="filterPredicate">the predicate - which meshes should be included when calculating the world size</param>
        abstract getWorldExtends: ?filterPredicate: (AbstractMesh -> bool) -> SceneGetWorldExtendsReturn
        /// <summary>Creates a ray that can be used to pick in the scene</summary>
        /// <param name="x">defines the x coordinate of the origin (on-screen)</param>
        /// <param name="y">defines the y coordinate of the origin (on-screen)</param>
        /// <param name="world">defines the world matrix to use if you want to pick in object space (instead of world space)</param>
        /// <param name="camera">defines the camera to use for the picking</param>
        /// <param name="cameraViewSpace">defines if picking will be done in view space (false by default)</param>
        abstract createPickingRay: x: float * y: float * world: Matrix * camera: Nullable<Camera> * ?cameraViewSpace: bool -> Ray
        /// <summary>Creates a ray that can be used to pick in the scene</summary>
        /// <param name="x">defines the x coordinate of the origin (on-screen)</param>
        /// <param name="y">defines the y coordinate of the origin (on-screen)</param>
        /// <param name="world">defines the world matrix to use if you want to pick in object space (instead of world space)</param>
        /// <param name="result">defines the ray where to store the picking ray</param>
        /// <param name="camera">defines the camera to use for the picking</param>
        /// <param name="cameraViewSpace">defines if picking will be done in view space (false by default)</param>
        abstract createPickingRayToRef: x: float * y: float * world: Matrix * result: Ray * camera: Nullable<Camera> * ?cameraViewSpace: bool -> Scene
        /// <summary>Creates a ray that can be used to pick in the scene</summary>
        /// <param name="x">defines the x coordinate of the origin (on-screen)</param>
        /// <param name="y">defines the y coordinate of the origin (on-screen)</param>
        /// <param name="camera">defines the camera to use for the picking</param>
        abstract createPickingRayInCameraSpace: x: float * y: float * ?camera: Camera -> Ray
        /// <summary>Creates a ray that can be used to pick in the scene</summary>
        /// <param name="x">defines the x coordinate of the origin (on-screen)</param>
        /// <param name="y">defines the y coordinate of the origin (on-screen)</param>
        /// <param name="result">defines the ray where to store the picking ray</param>
        /// <param name="camera">defines the camera to use for the picking</param>
        abstract createPickingRayInCameraSpaceToRef: x: float * y: float * result: Ray * ?camera: Camera -> Scene
        /// <summary>Launch a ray to try to pick a mesh in the scene</summary>
        /// <param name="x">position on screen</param>
        /// <param name="y">position on screen</param>
        /// <param name="predicate">Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true</param>
        /// <param name="fastCheck">Launch a fast check only using the bounding boxes. Can be set to null.</param>
        /// <param name="camera">to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used</param>
        abstract pick: x: float * y: float * ?predicate: (AbstractMesh -> bool) * ?fastCheck: bool * ?camera: Camera -> Nullable<PickingInfo>
        /// <summary>Use the given ray to pick a mesh in the scene</summary>
        /// <param name="ray">The ray to use to pick meshes</param>
        /// <param name="predicate">Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true</param>
        /// <param name="fastCheck">Launch a fast check only using the bounding boxes. Can be set to null</param>
        abstract pickWithRay: ray: Ray * ?predicate: (AbstractMesh -> bool) * ?fastCheck: bool -> Nullable<PickingInfo>
        /// <summary>Launch a ray to try to pick a mesh in the scene</summary>
        /// <param name="x">X position on screen</param>
        /// <param name="y">Y position on screen</param>
        /// <param name="predicate">Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true</param>
        /// <param name="camera">camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used</param>
        abstract multiPick: x: float * y: float * ?predicate: (AbstractMesh -> bool) * ?camera: Camera -> Nullable<ResizeArray<PickingInfo>>
        /// <summary>Launch a ray to try to pick a mesh in the scene</summary>
        /// <param name="ray">Ray to use</param>
        /// <param name="predicate">Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true</param>
        abstract multiPickWithRay: ray: Ray * predicate: (AbstractMesh -> bool) -> Nullable<ResizeArray<PickingInfo>>
        /// <summary>Force the value of meshUnderPointer</summary>
        /// <param name="mesh">defines the mesh to use</param>
        abstract setPointerOverMesh: mesh: Nullable<AbstractMesh> -> unit
        /// Gets the mesh under the pointer
        abstract getPointerOverMesh: unit -> Nullable<AbstractMesh>
        abstract _rebuildGeometries: unit -> unit
        abstract _rebuildTextures: unit -> unit
        /// <summary>Get a list of meshes by tags</summary>
        /// <param name="tagsQuery">defines the tags query to use</param>
        /// <param name="forEach">defines a predicate used to filter results</param>
        abstract getMeshesByTags: tagsQuery: string * ?forEach: (AbstractMesh -> unit) -> ResizeArray<Mesh>
        /// <summary>Get a list of cameras by tags</summary>
        /// <param name="tagsQuery">defines the tags query to use</param>
        /// <param name="forEach">defines a predicate used to filter results</param>
        abstract getCamerasByTags: tagsQuery: string * ?forEach: (Camera -> unit) -> ResizeArray<Camera>
        /// <summary>Get a list of lights by tags</summary>
        /// <param name="tagsQuery">defines the tags query to use</param>
        /// <param name="forEach">defines a predicate used to filter results</param>
        abstract getLightsByTags: tagsQuery: string * ?forEach: (Light -> unit) -> ResizeArray<Light>
        /// <summary>Get a list of materials by tags</summary>
        /// <param name="tagsQuery">defines the tags query to use</param>
        /// <param name="forEach">defines a predicate used to filter results</param>
        abstract getMaterialByTags: tagsQuery: string * ?forEach: (Material -> unit) -> ResizeArray<Material>
        /// <summary>Overrides the default sort function applied in the renderging group to prepare the meshes.
        /// This allowed control for front to back rendering or reversly depending of the special needs.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="opaqueSortCompareFn">The opaque queue comparison function use to sort.</param>
        /// <param name="alphaTestSortCompareFn">The alpha test queue comparison function use to sort.</param>
        /// <param name="transparentSortCompareFn">The transparent queue comparison function use to sort.</param>
        abstract setRenderingOrder: renderingGroupId: float * ?opaqueSortCompareFn: (SubMesh -> SubMesh -> float) * ?alphaTestSortCompareFn: (SubMesh -> SubMesh -> float) * ?transparentSortCompareFn: (SubMesh -> SubMesh -> float) -> unit
        /// <summary>Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="autoClearDepthStencil">Automatically clears depth and stencil between groups if true.</param>
        /// <param name="depth">Automatically clears depth between groups if true and autoClear is true.</param>
        /// <param name="stencil">Automatically clears stencil between groups if true and autoClear is true.</param>
        abstract setRenderingAutoClearDepthStencil: renderingGroupId: float * autoClearDepthStencil: bool * ?depth: bool * ?stencil: bool -> unit
        /// <summary>Gets the current auto clear configuration for one rendering group of the rendering
        /// manager.</summary>
        /// <param name="index">the rendering group index to get the information for</param>
        abstract getAutoClearDepthStencilSetup: index: float -> IRenderingManagerAutoClearSetup
        /// Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) 
        abstract blockMaterialDirtyMechanism: bool with get, set
        /// <summary>Will flag all materials as dirty to trigger new shader compilation</summary>
        /// <param name="flag">defines the flag used to specify which material part must be marked as dirty</param>
        /// <param name="predicate">If not null, it will be used to specifiy if a material has to be marked as dirty</param>
        abstract markAllMaterialsAsDirty: flag: float * ?predicate: (Material -> bool) -> unit
        abstract _loadFile: url: string * onSuccess: (U2<string, ArrayBuffer> -> string -> unit) * ?onProgress: (obj option -> unit) * ?useDatabase: bool * ?useArrayBuffer: bool * ?onError: (XMLHttpRequest -> obj -> unit) -> IFileRequest
        abstract _loadFileAsync: url: string * ?useDatabase: bool * ?useArrayBuffer: bool -> Promise<U2<string, ArrayBuffer>>
        abstract _mainSoundTrack: SoundTrack with get, set
        /// The main sound track played by the scene.
        /// It cotains your primary collection of sounds.
        abstract mainSoundTrack: SoundTrack with get, set
        /// The list of sound tracks added to the scene
        abstract soundTracks: Nullable<Array<SoundTrack>> with get, set
        /// <summary>Gets a sound using a given name</summary>
        /// <param name="name">defines the name to search for</param>
        abstract getSoundByName: name: string -> Nullable<Sound>
        /// Gets or sets if audio support is enabled
        abstract audioEnabled: bool with get, set
        /// Gets or sets if audio will be output to headphones
        abstract headphone: bool with get, set
        abstract _debugLayer: DebugLayer with get, set
        /// Gets the debug layer (aka Inspector) associated with the scene
        abstract debugLayer: DebugLayer with get, set
        abstract _gamepadManager: Nullable<GamepadManager> with get, set
        /// Gets the gamepad manager associated with the scene
        abstract gamepadManager: GamepadManager with get, set
        /// <summary>Creates a default light for the scene.</summary>
        /// <param name="replace">has the default false, when true replaces the existing lights in the scene with a hemispheric light</param>
        abstract createDefaultLight: ?replace: bool -> unit
        /// <summary>Creates a default camera for the scene.</summary>
        /// <param name="createArcRotateCamera">has the default false which creates a free camera, when true creates an arc rotate camera</param>
        /// <param name="replace">has default false, when true replaces the active camera in the scene</param>
        /// <param name="attachCameraControls">has default false, when true attaches camera controls to the canvas.</param>
        abstract createDefaultCamera: ?createArcRotateCamera: bool * ?replace: bool * ?attachCameraControls: bool -> unit
        /// <summary>Creates a default camera and a default light.</summary>
        /// <param name="createArcRotateCamera">has the default false which creates a free camera, when true creates an arc rotate camera</param>
        /// <param name="replace">has the default false, when true replaces the active camera/light in the scene</param>
        /// <param name="attachCameraControls">has the default false, when true attaches camera controls to the canvas.</param>
        abstract createDefaultCameraOrLight: ?createArcRotateCamera: bool * ?replace: bool * ?attachCameraControls: bool -> unit
        /// <summary>Creates a new sky box</summary>
        /// <param name="environmentTexture">defines the texture to use as environment texture</param>
        /// <param name="pbr">has default false which requires the StandardMaterial to be used, when true PBRMaterial must be used</param>
        /// <param name="scale">defines the overall scale of the skybox</param>
        /// <param name="blur">is only available when pbr is true, default is 0, no blur, maximum value is 1</param>
        /// <param name="setGlobalEnvTexture">has default true indicating that scene.environmentTexture must match the current skybox texture</param>
        abstract createDefaultSkybox: ?environmentTexture: BaseTexture * ?pbr: bool * ?scale: float * ?blur: float * ?setGlobalEnvTexture: bool -> Nullable<Mesh>
        /// <summary>Creates a new environment</summary>
        /// <param name="options">defines the options you can use to configure the environment</param>
        abstract createDefaultEnvironment: ?options: obj -> Nullable<EnvironmentHelper>
        /// <summary>Creates a new VREXperienceHelper</summary>
        /// <param name="webVROptions">defines the options used to create the new VREXperienceHelper</param>
        abstract createDefaultVRExperience: ?webVROptions: VRExperienceHelperOptions -> VRExperienceHelper
        abstract _simplificationQueue: SimplificationQueue with get, set
        /// Gets or sets the simplification queue attached to the scene
        abstract simplificationQueue: SimplificationQueue with get, set
        abstract _physicsEngine: Nullable<IPhysicsEngine> with get, set
        /// Gets the current physics engine
        abstract getPhysicsEngine: unit -> Nullable<IPhysicsEngine>
        /// <summary>Enables physics to the current scene</summary>
        /// <param name="gravity">defines the scene's gravity for the physics engine</param>
        /// <param name="plugin">defines the physics engine to be used. defaults to OimoJS.</param>
        abstract enablePhysics: gravity: Nullable<Vector3> * ?plugin: IPhysicsEnginePlugin -> bool
        /// Disables and disposes the physics engine associated with the scene
        abstract disablePhysicsEngine: unit -> unit
        /// Gets a boolean indicating if there is an active physics engine
        abstract isPhysicsEnabled: unit -> bool
        /// <summary>Deletes a physics compound impostor</summary>
        /// <param name="compound">defines the compound to delete</param>
        abstract deleteCompoundImpostor: compound: obj option -> unit
        /// An event triggered when physic simulation is about to be run
        abstract onBeforePhysicsObservable: Observable<Scene> with get, set
        /// An event triggered when physic simulation has been done
        abstract onAfterPhysicsObservable: Observable<Scene> with get, set
        /// The list of reflection probes added to the scene
        abstract reflectionProbes: Array<ReflectionProbe> with get, set
        abstract _boundingBoxRenderer: BoundingBoxRenderer with get, set
        abstract _forceShowBoundingBoxes: bool with get, set
        /// Gets or sets a boolean indicating if all bounding boxes must be rendered
        abstract forceShowBoundingBoxes: bool with get, set
        /// Gets the bounding box renderer associated with the scene
        abstract getBoundingBoxRenderer: unit -> BoundingBoxRenderer
        abstract _depthRenderer: TypeLiteral_03 with get, set
        /// <summary>Creates a depth renderer a given camera which contains a depth map which can be used for post processing.</summary>
        /// <param name="camera">The camera to create the depth renderer on (default: scene's active camera)</param>
        abstract enableDepthRenderer: ?camera: Camera -> DepthRenderer
        /// <summary>Disables a depth renderer for a given camera</summary>
        /// <param name="camera">The camera to disable the depth renderer on (default: scene's active camera)</param>
        abstract disableDepthRenderer: ?camera: Camera -> unit
        abstract _geometryBufferRenderer: Nullable<GeometryBufferRenderer> with get, set
        /// Gets or Sets the current geometry buffer associated to the scene.
        abstract geometryBufferRenderer: Nullable<GeometryBufferRenderer> with get, set
        /// <summary>Enables a GeometryBufferRender and associates it with the scene</summary>
        /// <param name="ratio">defines the scaling ratio to apply to the renderer (1 by default which means same resolution)</param>
        abstract enableGeometryBufferRenderer: ?ratio: float -> Nullable<GeometryBufferRenderer>
        /// Disables the GeometryBufferRender associated with the scene
        abstract disableGeometryBufferRenderer: unit -> unit
        abstract _outlineRenderer: OutlineRenderer with get, set
        /// Gets the outline renderer associated with the scene
        abstract getOutlineRenderer: unit -> OutlineRenderer
        abstract _pointerOverSprite: Nullable<Sprite> with get, set
        abstract _pickedDownSprite: Nullable<Sprite> with get, set
        abstract _tempSpritePickingRay: Nullable<Ray> with get, set
        /// All of the sprite managers added to this scene
        abstract spriteManagers: Array<ISpriteManager> with get, set
        /// An event triggered when sprites rendering is about to start
        /// Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
        abstract onBeforeSpritesRenderingObservable: Observable<Scene> with get, set
        /// An event triggered when sprites rendering is done
        /// Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
        abstract onAfterSpritesRenderingObservable: Observable<Scene> with get, set
        abstract _internalPickSprites: ray: Ray * ?predicate: (Sprite -> bool) * ?fastCheck: bool * ?camera: Camera -> Nullable<PickingInfo>
        /// <summary>Launch a ray to try to pick a sprite in the scene</summary>
        /// <param name="x">position on screen</param>
        /// <param name="y">position on screen</param>
        /// <param name="predicate">Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true</param>
        /// <param name="fastCheck">Launch a fast check only using the bounding boxes. Can be set to null.</param>
        /// <param name="camera">camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used</param>
        abstract pickSprite: x: float * y: float * ?predicate: (Sprite -> bool) * ?fastCheck: bool * ?camera: Camera -> Nullable<PickingInfo>
        /// <summary>Use the given ray to pick a sprite in the scene</summary>
        /// <param name="ray">The ray (in world space) to use to pick meshes</param>
        /// <param name="predicate">Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true</param>
        /// <param name="fastCheck">Launch a fast check only using the bounding boxes. Can be set to null.</param>
        /// <param name="camera">camera to use. Can be set to null. In this case, the scene.activeCamera will be used</param>
        abstract pickSpriteWithRay: ray: Ray * ?predicate: (Sprite -> bool) * ?fastCheck: bool * ?camera: Camera -> Nullable<PickingInfo>
        /// <summary>Force the sprite under the pointer</summary>
        /// <param name="sprite">defines the sprite to use</param>
        abstract setPointerOverSprite: sprite: Nullable<Sprite> -> unit
        /// Gets the sprite under the pointer
        abstract getPointerOverSprite: unit -> Nullable<Sprite>
        abstract _selectionOctree: Octree<AbstractMesh> with get, set
        /// Gets the octree used to boost mesh selection (picking)
        abstract selectionOctree: Octree<AbstractMesh> with get, set
        /// <summary>Creates or updates the octree used to boost selection (picking)</summary>
        /// <param name="maxCapacity">defines the maximum capacity per leaf</param>
        /// <param name="maxDepth">defines the maximum depth of the octree</param>
        abstract createOrUpdateSelectionOctree: ?maxCapacity: float * ?maxDepth: float -> Octree<AbstractMesh>
        abstract _postProcessRenderPipelineManager: PostProcessRenderPipelineManager with get, set
        /// Gets the postprocess render pipeline manager
        abstract postProcessRenderPipelineManager: PostProcessRenderPipelineManager

    type [<AllowNullLiteral>] SceneGetWorldExtendsReturn =
        abstract min: Vector3 with get, set
        abstract max: Vector3 with get, set

    /// Represents a scene to be rendered by the engine.
    type [<AllowNullLiteral>] SceneStatic =
        /// The fog is deactivated 
        abstract FOGMODE_NONE: float
        /// The fog density is following an exponential function 
        abstract FOGMODE_EXP: float
        /// The fog density is following an exponential function faster than FOGMODE_EXP 
        abstract FOGMODE_EXP2: float
        /// The fog density is following a linear function. 
        abstract FOGMODE_LINEAR: float
        /// Gets or sets the minimum deltatime when deterministic lock step is enabled
        abstract MinDeltaTime: float with get, set
        /// Gets or sets the maximum deltatime when deterministic lock step is enabled
        abstract MaxDeltaTime: float with get, set
        /// The distance in pixel that you have to move to prevent some events 
        abstract DragMovementThreshold: float with get, set
        /// Time in milliseconds to wait to raise long press events if button is still pressed 
        abstract LongPressDelay: float with get, set
        /// Time in milliseconds with two consecutive clicks will be considered as a double click 
        abstract DoubleClickDelay: float with get, set
        /// If you need to check double click without raising a single click at first click, enable this flag 
        abstract ExclusiveDoubleClickMode: bool with get, set
        /// <summary>Creates a new Scene</summary>
        /// <param name="engine">defines the engine to use to render this scene</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine -> Scene

    /// Groups all the scene component constants in one place to ease maintenance.
    type [<AllowNullLiteral>] SceneComponentConstants =
        interface end

    /// Groups all the scene component constants in one place to ease maintenance.
    type [<AllowNullLiteral>] SceneComponentConstantsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SceneComponentConstants
        abstract NAME_EFFECTLAYER: string
        abstract NAME_LAYER: string
        abstract NAME_LENSFLARESYSTEM: string
        abstract NAME_BOUNDINGBOXRENDERER: string
        abstract NAME_PARTICLESYSTEM: string
        abstract NAME_GAMEPAD: string
        abstract NAME_SIMPLIFICATIONQUEUE: string
        abstract NAME_GEOMETRYBUFFERRENDERER: string
        abstract NAME_DEPTHRENDERER: string
        abstract NAME_POSTPROCESSRENDERPIPELINEMANAGER: string
        abstract NAME_SPRITE: string
        abstract NAME_OUTLINERENDERER: string
        abstract NAME_PROCEDURALTEXTURE: string
        abstract NAME_SHADOWGENERATOR: string
        abstract NAME_OCTREE: string
        abstract NAME_PHYSICSENGINE: string
        abstract NAME_AUDIO: string
        abstract STEP_ISREADYFORMESH_EFFECTLAYER: float
        abstract STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER: float
        abstract STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER: float
        abstract STEP_ACTIVEMESH_BOUNDINGBOXRENDERER: float
        abstract STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER: float
        abstract STEP_BEFORECAMERADRAW_EFFECTLAYER: float
        abstract STEP_BEFORECAMERADRAW_LAYER: float
        abstract STEP_BEFORERENDERINGMESH_OUTLINE: float
        abstract STEP_AFTERRENDERINGMESH_OUTLINE: float
        abstract STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW: float
        abstract STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER: float
        abstract STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE: float
        abstract STEP_BEFORECAMERAUPDATE_GAMEPAD: float
        abstract STEP_BEFORECLEAR_PROCEDURALTEXTURE: float
        abstract STEP_AFTERCAMERADRAW_EFFECTLAYER: float
        abstract STEP_AFTERCAMERADRAW_LENSFLARESYSTEM: float
        abstract STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW: float
        abstract STEP_AFTERCAMERADRAW_LAYER: float
        abstract STEP_AFTERRENDER_AUDIO: float
        abstract STEP_GATHERRENDERTARGETS_SHADOWGENERATOR: float
        abstract STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER: float
        abstract STEP_GATHERRENDERTARGETS_DEPTHRENDERER: float
        abstract STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER: float
        abstract STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER: float
        abstract STEP_POINTERMOVE_SPRITE: float
        abstract STEP_POINTERDOWN_SPRITE: float
        abstract STEP_POINTERUP_SPRITE: float

    /// This represents a scene component.
    /// 
    /// This is used to decouple the dependency the scene is having on the different workloads like
    /// layers, post processes...
    type [<AllowNullLiteral>] ISceneComponent =
        /// The name of the component. Each component must have a unique name.
        abstract name: string with get, set
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Register the component to one instance of a scene.
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources.
        abstract dispose: unit -> unit

    /// This represents a SERIALIZABLE scene component.
    /// 
    /// This extends Scene Component to add Serialization methods on top.
    type [<AllowNullLiteral>] ISceneSerializableComponent =
        inherit ISceneComponent
        /// <summary>Adds all the element from the container to the scene</summary>
        /// <param name="container">the container holding the elements</param>
        abstract addFromContainer: container: AbstractScene -> unit
        /// <summary>Removes all the elements in the container from the scene</summary>
        /// <param name="container">contains the elements to remove</param>
        abstract removeFromContainer: container: AbstractScene -> unit
        /// <summary>Serializes the component data to the specified json object</summary>
        /// <param name="serializationObject">The object to serialize to</param>
        abstract serialize: serializationObject: obj option -> unit

    type [<AllowNullLiteral>] MeshStageAction =
        [<Emit "$0($1...)">] abstract Invoke: mesh: AbstractMesh * hardwareInstancedRendering: bool -> bool

    type [<AllowNullLiteral>] EvaluateSubMeshStageAction =
        [<Emit "$0($1...)">] abstract Invoke: mesh: AbstractMesh * subMesh: SubMesh -> unit

    type [<AllowNullLiteral>] ActiveMeshStageAction =
        [<Emit "$0($1...)">] abstract Invoke: sourceMesh: AbstractMesh * mesh: AbstractMesh -> unit

    type [<AllowNullLiteral>] CameraStageAction =
        [<Emit "$0($1...)">] abstract Invoke: camera: Camera -> unit

    type [<AllowNullLiteral>] RenderingGroupStageAction =
        [<Emit "$0($1...)">] abstract Invoke: renderingGroupId: float -> unit

    type [<AllowNullLiteral>] RenderingMeshStageAction =
        [<Emit "$0($1...)">] abstract Invoke: mesh: AbstractMesh * subMesh: SubMesh * batch: _InstancesBatch -> unit

    type [<AllowNullLiteral>] SimpleStageAction =
        [<Emit "$0($1...)">] abstract Invoke: unit -> unit

    type [<AllowNullLiteral>] RenderTargetsStageAction =
        [<Emit "$0($1...)">] abstract Invoke: renderTargets: SmartArrayNoDuplicate<RenderTargetTexture> -> unit

    type [<AllowNullLiteral>] PointerMoveStageAction =
        [<Emit "$0($1...)">] abstract Invoke: unTranslatedPointerX: float * unTranslatedPointerY: float * pickResult: Nullable<PickingInfo> * isMeshPicked: bool * canvas: HTMLCanvasElement -> Nullable<PickingInfo>

    type [<AllowNullLiteral>] PointerUpDownStageAction =
        [<Emit "$0($1...)">] abstract Invoke: unTranslatedPointerX: float * unTranslatedPointerY: float * pickResult: Nullable<PickingInfo> * evt: PointerEvent -> Nullable<PickingInfo>

    /// Repressentation of a stage in the scene (Basically a list of ordered steps)
    type [<AllowNullLiteral>] Stage<'T> =
        inherit Array<TypeLiteral_04<'T>>
        /// <summary>Registers a step in an ordered way in the targeted stage.</summary>
        /// <param name="index">Defines the position to register the step in</param>
        /// <param name="component">Defines the component attached to the step</param>
        /// <param name="action">Defines the action to launch during the step</param>
        abstract registerStep: index: float * ``component``: ISceneComponent * action: 'T -> unit
        /// Clears all the steps from the stage.
        abstract clear: unit -> unit

    /// Repressentation of a stage in the scene (Basically a list of ordered steps)
    type [<AllowNullLiteral>] StageStatic =
        /// Creates a new Stage.
        abstract Create: unit -> Stage<'T>

    type Nullable<'T> =
        'T option

    type double =
        float

    type int =
        float

    type FloatArray =
        U2<ResizeArray<float>, Float32Array>

    [<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
    module FloatArray =
        let ofFloatArray v: FloatArray = v |> U2.Case1
        let isFloatArray (v: FloatArray) = match v with U2.Case1 _ -> true | _ -> false
        let asFloatArray (v: FloatArray) = match v with U2.Case1 o -> Some o | _ -> None
        let ofFloat32Array v: FloatArray = v |> U2.Case2
        let isFloat32Array (v: FloatArray) = match v with U2.Case2 _ -> true | _ -> false
        let asFloat32Array (v: FloatArray) = match v with U2.Case2 o -> Some o | _ -> None

    type IndicesArray =
        U4<ResizeArray<float>, Int32Array, Uint32Array, Uint16Array>

    [<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
    module IndicesArray =
        let ofFloatArray v: IndicesArray = v |> U4.Case1
        let isFloatArray (v: IndicesArray) = match v with U4.Case1 _ -> true | _ -> false
        let asFloatArray (v: IndicesArray) = match v with U4.Case1 o -> Some o | _ -> None
        let ofInt32Array v: IndicesArray = v |> U4.Case2
        let isInt32Array (v: IndicesArray) = match v with U4.Case2 _ -> true | _ -> false
        let asInt32Array (v: IndicesArray) = match v with U4.Case2 o -> Some o | _ -> None
        let ofUint32Array v: IndicesArray = v |> U4.Case3
        let isUint32Array (v: IndicesArray) = match v with U4.Case3 _ -> true | _ -> false
        let asUint32Array (v: IndicesArray) = match v with U4.Case3 o -> Some o | _ -> None
        let ofUint16Array v: IndicesArray = v |> U4.Case4
        let isUint16Array (v: IndicesArray) = match v with U4.Case4 _ -> true | _ -> false
        let asUint16Array (v: IndicesArray) = match v with U4.Case4 o -> Some o | _ -> None

    type DataArray =
        U3<ResizeArray<float>, ArrayBuffer, ArrayBufferView>

    [<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
    module DataArray =
        let ofFloatArray v: DataArray = v |> U3.Case1
        let isFloatArray (v: DataArray) = match v with U3.Case1 _ -> true | _ -> false
        let asFloatArray (v: DataArray) = match v with U3.Case1 o -> Some o | _ -> None
        let ofArrayBuffer v: DataArray = v |> U3.Case2
        let isArrayBuffer (v: DataArray) = match v with U3.Case2 _ -> true | _ -> false
        let asArrayBuffer (v: DataArray) = match v with U3.Case2 o -> Some o | _ -> None
        let ofArrayBufferView v: DataArray = v |> U3.Case3
        let isArrayBufferView (v: DataArray) = match v with U3.Case3 _ -> true | _ -> false
        let asArrayBufferView (v: DataArray) = match v with U3.Case3 o -> Some o | _ -> None

    /// The action to be carried out following a trigger
    type [<AllowNullLiteral>] Action =
        /// the trigger, with or without parameters, for the action 
        abstract triggerOptions: obj option with get, set
        /// Trigger for the action
        abstract trigger: float with get, set
        /// Internal only - manager for action
        abstract _actionManager: ActionManager with get, set
        /// An event triggered prior to action being executed.
        abstract onBeforeExecuteObservable: Observable<Action> with get, set
        /// Internal only
        abstract _prepare: unit -> unit
        /// Gets the trigger parameters
        abstract getTriggerParameter: unit -> obj option
        /// Internal only - executes current action event
        abstract _executeCurrent: ?evt: ActionEvent -> unit
        /// <summary>Execute placeholder for child classes</summary>
        /// <param name="evt">optional action event</param>
        abstract execute: ?evt: ActionEvent -> unit
        /// Skips to next active action
        abstract skipToNextActiveAction: unit -> unit
        /// <summary>Adds action to chain of actions, may be a DoNothingAction</summary>
        /// <param name="action">defines the next action to execute</param>
        abstract ``then``: action: Action -> Action
        /// Internal only
        abstract _getProperty: propertyPath: string -> string
        /// Internal only
        abstract _getEffectiveTarget: target: obj option * propertyPath: string -> obj option
        /// <summary>Serialize placeholder for child classes</summary>
        /// <param name="parent">of child</param>
        abstract serialize: parent: obj option -> obj option
        /// Internal only called by serialize
        abstract _serialize: serializedAction: obj option * ?parent: obj -> obj option

    /// The action to be carried out following a trigger
    type [<AllowNullLiteral>] ActionStatic =
        /// <summary>Creates a new Action</summary>
        /// <param name="triggerOptions">the trigger, with or without parameters, for the action</param>
        /// <param name="condition">an optional determinant of action</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * ?condition: Condition -> Action
        /// Internal only
        abstract _SerializeValueAsString: (obj option -> string) with get, set
        /// Internal only
        abstract _GetTargetProperty: (U2<Scene, Node> -> TypeLiteral_05) with get, set

    /// ActionEvent is the event being sent when an action is triggered.
    type [<AllowNullLiteral>] ActionEvent =
        /// The mesh or sprite that triggered the action 
        abstract source: obj option with get, set
        /// The X mouse cursor position at the time of the event 
        abstract pointerX: float with get, set
        /// The Y mouse cursor position at the time of the event 
        abstract pointerY: float with get, set
        /// The mesh that is currently pointed at (can be null) 
        abstract meshUnderPointer: Nullable<AbstractMesh> with get, set
        /// the original (browser) event that triggered the ActionEvent 
        abstract sourceEvent: obj option with get, set
        /// additional data for the event 
        abstract additionalData: obj option with get, set

    /// ActionEvent is the event being sent when an action is triggered.
    type [<AllowNullLiteral>] ActionEventStatic =
        /// <summary>Creates a new ActionEvent</summary>
        /// <param name="source">The mesh or sprite that triggered the action</param>
        /// <param name="pointerX">The X mouse cursor position at the time of the event</param>
        /// <param name="pointerY">The Y mouse cursor position at the time of the event</param>
        /// <param name="meshUnderPointer">The mesh that is currently pointed at (can be null)</param>
        /// <param name="sourceEvent">the original (browser) event that triggered the ActionEvent</param>
        /// <param name="additionalData">additional data for the event</param>
        [<Emit "new $0($1...)">] abstract Create: source: obj option * pointerX: float * pointerY: float * meshUnderPointer: Nullable<AbstractMesh> * ?sourceEvent: obj * ?additionalData: obj -> ActionEvent
        /// <summary>Helper function to auto-create an ActionEvent from a source mesh.</summary>
        /// <param name="source">The source mesh that triggered the event</param>
        /// <param name="evt">The original (browser) event</param>
        /// <param name="additionalData">additional data for the event</param>
        abstract CreateNew: source: AbstractMesh * ?evt: Event * ?additionalData: obj -> ActionEvent
        /// <summary>Helper function to auto-create an ActionEvent from a source sprite</summary>
        /// <param name="source">The source sprite that triggered the event</param>
        /// <param name="scene">Scene associated with the sprite</param>
        /// <param name="evt">The original (browser) event</param>
        /// <param name="additionalData">additional data for the event</param>
        abstract CreateNewFromSprite: source: Sprite * scene: Scene * ?evt: Event * ?additionalData: obj -> ActionEvent
        /// <summary>Helper function to auto-create an ActionEvent from a scene. If triggered by a mesh use ActionEvent.CreateNew</summary>
        /// <param name="scene">the scene where the event occurred</param>
        /// <param name="evt">The original (browser) event</param>
        abstract CreateNewFromScene: scene: Scene * evt: Event -> ActionEvent
        /// <summary>Helper function to auto-create an ActionEvent from a primitive</summary>
        /// <param name="prim">defines the target primitive</param>
        /// <param name="pointerPos">defines the pointer position</param>
        /// <param name="evt">The original (browser) event</param>
        /// <param name="additionalData">additional data for the event</param>
        abstract CreateNewFromPrimitive: prim: obj option * pointerPos: Vector2 * ?evt: Event * ?additionalData: obj -> ActionEvent

    /// Action Manager manages all events to be triggered on a given mesh or the global scene.
    /// A single scene can have many Action Managers to handle predefined actions on specific meshes.
    type [<AllowNullLiteral>] ActionManager =
        /// Gets the list of actions 
        abstract actions: ResizeArray<Action> with get, set
        /// Gets the cursor to use when hovering items 
        abstract hoverCursor: string with get, set
        /// Releases all associated resources
        abstract dispose: unit -> unit
        /// Gets hosting scene
        abstract getScene: unit -> Scene
        /// <summary>Does this action manager handles actions of any of the given triggers</summary>
        /// <param name="triggers">defines the triggers to be tested</param>
        abstract hasSpecificTriggers: triggers: ResizeArray<float> -> bool
        /// <summary>Does this action manager handles actions of any of the given triggers. This function takes two arguments for
        /// speed.</summary>
        /// <param name="triggerA">defines the trigger to be tested</param>
        /// <param name="triggerB">defines the trigger to be tested</param>
        abstract hasSpecificTriggers2: triggerA: float * triggerB: float -> bool
        /// <summary>Does this action manager handles actions of a given trigger</summary>
        /// <param name="trigger">defines the trigger to be tested</param>
        /// <param name="parameterPredicate">defines an optional predicate to filter triggers by parameter</param>
        abstract hasSpecificTrigger: trigger: float * ?parameterPredicate: (obj option -> bool) -> bool
        /// Does this action manager has pointer triggers
        abstract hasPointerTriggers: bool
        /// Does this action manager has pick triggers
        abstract hasPickTriggers: bool
        /// <summary>Registers an action to this action manager</summary>
        /// <param name="action">defines the action to be registered</param>
        abstract registerAction: action: Action -> Nullable<Action>
        /// <summary>Unregisters an action to this action manager</summary>
        /// <param name="action">defines the action to be unregistered</param>
        abstract unregisterAction: action: Action -> Boolean
        /// <summary>Process a specific trigger</summary>
        /// <param name="trigger">defines the trigger to process</param>
        /// <param name="evt">defines the event details to be processed</param>
        abstract processTrigger: trigger: float * ?evt: ActionEvent -> unit
        abstract _getEffectiveTarget: target: obj option * propertyPath: string -> obj option
        abstract _getProperty: propertyPath: string -> string
        /// <summary>Serialize this manager to a JSON object</summary>
        /// <param name="name">defines the property name to store this manager</param>
        abstract serialize: name: string -> obj option

    /// Action Manager manages all events to be triggered on a given mesh or the global scene.
    /// A single scene can have many Action Managers to handle predefined actions on specific meshes.
    type [<AllowNullLiteral>] ActionManagerStatic =
        /// Nothing
        abstract NothingTrigger: float
        /// On pick
        abstract OnPickTrigger: float
        /// On left pick
        abstract OnLeftPickTrigger: float
        /// On right pick
        abstract OnRightPickTrigger: float
        /// On center pick
        abstract OnCenterPickTrigger: float
        /// On pick down
        abstract OnPickDownTrigger: float
        /// On double pick
        abstract OnDoublePickTrigger: float
        /// On pick up
        abstract OnPickUpTrigger: float
        /// On pick out.
        /// This trigger will only be raised if you also declared a OnPickDown
        abstract OnPickOutTrigger: float
        /// On long press
        abstract OnLongPressTrigger: float
        /// On pointer over
        abstract OnPointerOverTrigger: float
        /// On pointer out
        abstract OnPointerOutTrigger: float
        /// On every frame
        abstract OnEveryFrameTrigger: float
        /// On intersection enter
        abstract OnIntersectionEnterTrigger: float
        /// On intersection exit
        abstract OnIntersectionExitTrigger: float
        /// On key down
        abstract OnKeyDownTrigger: float
        /// On key up
        abstract OnKeyUpTrigger: float
        /// Gets the list of active triggers 
        abstract Triggers: TypeLiteral_06 with get, set
        /// <summary>Creates a new action manager</summary>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> ActionManager
        /// Does exist one action manager with at least one trigger
        abstract HasTriggers: bool
        /// Does exist one action manager with at least one pick trigger
        abstract HasPickTriggers: bool
        /// <summary>Does exist one action manager that handles actions of a given trigger</summary>
        /// <param name="trigger">defines the trigger to be tested</param>
        abstract HasSpecificTrigger: trigger: float -> bool
        /// <summary>Creates a new ActionManager from a JSON data</summary>
        /// <param name="parsedActions">defines the JSON data to read from</param>
        /// <param name="object">defines the hosting mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract Parse: parsedActions: obj option * ``object``: Nullable<AbstractMesh> * scene: Scene -> unit
        /// <summary>Get a trigger name by index</summary>
        /// <param name="trigger">defines the trigger index</param>
        abstract GetTriggerName: trigger: float -> string

    /// A Condition applied to an Action
    type [<AllowNullLiteral>] Condition =
        /// Internal only - manager for action
        abstract _actionManager: ActionManager with get, set
        /// Internal only
        abstract _evaluationId: float with get, set
        /// Internal only
        abstract _currentResult: bool with get, set
        /// Check if the current condition is valid
        abstract isValid: unit -> bool
        /// Internal only
        abstract _getProperty: propertyPath: string -> string
        /// Internal only
        abstract _getEffectiveTarget: target: obj option * propertyPath: string -> obj option
        /// Serialize placeholder for child classes
        abstract serialize: unit -> obj option
        /// Internal only
        abstract _serialize: serializedCondition: obj option -> obj option

    /// A Condition applied to an Action
    type [<AllowNullLiteral>] ConditionStatic =
        /// <summary>Creates a new Condition</summary>
        /// <param name="actionManager">the manager of the action the condition is applied to</param>
        [<Emit "new $0($1...)">] abstract Create: actionManager: ActionManager -> Condition

    /// Defines specific conditional operators as extensions of Condition
    type [<AllowNullLiteral>] ValueCondition =
        inherit Condition
        /// path to specify the property of the target the conditional operator uses  
        abstract propertyPath: string with get, set
        /// the value compared by the conditional operator against the current value of the property 
        abstract value: obj option with get, set
        /// the conditional operator, default ValueCondition.IsEqual 
        abstract operator: float with get, set
        /// Internal only The action manager for the condition
        abstract _actionManager: ActionManager with get, set
        /// Compares the given value with the property value for the specified conditional operator
        abstract isValid: unit -> bool
        /// Serialize the ValueCondition into a JSON compatible object
        abstract serialize: unit -> obj option

    /// Defines specific conditional operators as extensions of Condition
    type [<AllowNullLiteral>] ValueConditionStatic =
        /// returns the number for IsEqual
        abstract IsEqual: float
        /// Returns the number for IsDifferent
        abstract IsDifferent: float
        /// Returns the number for IsGreater
        abstract IsGreater: float
        /// Returns the number for IsLesser
        abstract IsLesser: float
        /// <summary>Creates a new ValueCondition</summary>
        /// <param name="actionManager">manager for the action the condition applies to</param>
        /// <param name="target">for the action</param>
        /// <param name="propertyPath">path to specify the property of the target the conditional operator uses</param>
        /// <param name="value">the value compared by the conditional operator against the current value of the property</param>
        /// <param name="operator">the conditional operator, default ValueCondition.IsEqual</param>
        [<Emit "new $0($1...)">] abstract Create: actionManager: ActionManager * target: obj option * propertyPath: string * value: obj option * ?operator: float -> ValueCondition
        /// <summary>Gets the name of the conditional operator for the ValueCondition</summary>
        /// <param name="operator">the conditional operator</param>
        abstract GetOperatorName: operator: float -> string

    /// Defines a predicate condition as an extension of Condition
    type [<AllowNullLiteral>] PredicateCondition =
        inherit Condition
        /// defines the predicate function used to validate the condition 
        abstract predicate: (unit -> bool) with get, set
        /// Internal only - manager for action
        abstract _actionManager: ActionManager with get, set
        abstract isValid: unit -> bool

    /// Defines a predicate condition as an extension of Condition
    type [<AllowNullLiteral>] PredicateConditionStatic =
        /// <summary>Creates a new PredicateCondition</summary>
        /// <param name="actionManager">manager for the action the condition applies to</param>
        /// <param name="predicate">defines the predicate function used to validate the condition</param>
        [<Emit "new $0($1...)">] abstract Create: actionManager: ActionManager * predicate: (unit -> bool) -> PredicateCondition

    /// Defines a state condition as an extension of Condition
    type [<AllowNullLiteral>] StateCondition =
        inherit Condition
        /// Value to compare with target state  
        abstract value: string with get, set
        /// Internal only - manager for action
        abstract _actionManager: ActionManager with get, set
        /// Gets a boolean indicating if the current condition is met
        abstract isValid: unit -> bool
        /// Serialize the StateCondition into a JSON compatible object
        abstract serialize: unit -> obj option

    /// Defines a state condition as an extension of Condition
    type [<AllowNullLiteral>] StateConditionStatic =
        /// <summary>Creates a new StateCondition</summary>
        /// <param name="actionManager">manager for the action the condition applies to</param>
        /// <param name="target">of the condition</param>
        /// <param name="value">to compare with target state</param>
        [<Emit "new $0($1...)">] abstract Create: actionManager: ActionManager * target: obj option * value: string -> StateCondition

    /// This defines an action responsible to toggle a boolean once triggered.
    type [<AllowNullLiteral>] SwitchBooleanAction =
        inherit Action
        /// The path to the boolean property in the target object
        abstract propertyPath: string with get, set
        abstract _prepare: unit -> unit
        /// Execute the action toggle the boolean value.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action responsible to toggle a boolean once triggered.
    type [<AllowNullLiteral>] SwitchBooleanActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="target">defines the object containing the boolean</param>
        /// <param name="propertyPath">defines the path to the boolean property in the target object</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * propertyPath: string * ?condition: Condition -> SwitchBooleanAction

    /// This defines an action responsible to set a the state field of the target
    ///   to a desired value once triggered.
    type [<AllowNullLiteral>] SetStateAction =
        inherit Action
        /// The value to store in the state field.
        abstract value: string with get, set
        /// Execute the action and store the value on the target state property.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action responsible to set a the state field of the target
    ///   to a desired value once triggered.
    type [<AllowNullLiteral>] SetStateActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="target">defines the object containing the state property</param>
        /// <param name="value">defines the value to store in the state field</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * value: string * ?condition: Condition -> SetStateAction

    /// This defines an action responsible to set a property of the target
    ///   to a desired value once triggered.
    type [<AllowNullLiteral>] SetValueAction =
        inherit Action
        /// The path of the property to set in the target.
        abstract propertyPath: string with get, set
        /// The value to set in the property
        abstract value: obj option with get, set
        abstract _prepare: unit -> unit
        /// Execute the action and set the targetted property to the desired value.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action responsible to set a property of the target
    ///   to a desired value once triggered.
    type [<AllowNullLiteral>] SetValueActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="target">defines the object containing the property</param>
        /// <param name="propertyPath">defines the path of the property to set in the target</param>
        /// <param name="value">defines the value to set in the property</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * propertyPath: string * value: obj option * ?condition: Condition -> SetValueAction

    /// This defines an action responsible to increment the target value
    ///   to a desired value once triggered.
    type [<AllowNullLiteral>] IncrementValueAction =
        inherit Action
        /// The path of the property to increment in the target.
        abstract propertyPath: string with get, set
        /// The value we should increment the property by.
        abstract value: obj option with get, set
        abstract _prepare: unit -> unit
        /// Execute the action and increment the target of the value amount.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action responsible to increment the target value
    ///   to a desired value once triggered.
    type [<AllowNullLiteral>] IncrementValueActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="target">defines the object containing the property</param>
        /// <param name="propertyPath">defines the path of the property to increment in the target</param>
        /// <param name="value">defines the value value we should increment the property by</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * propertyPath: string * value: obj option * ?condition: Condition -> IncrementValueAction

    /// This defines an action responsible to start an animation once triggered.
    type [<AllowNullLiteral>] PlayAnimationAction =
        inherit Action
        /// Where the animation should start (animation frame)
        abstract from: float with get, set
        /// Where the animation should stop (animation frame)
        abstract ``to``: float with get, set
        /// Define if the animation should loop or stop after the first play.
        abstract loop: bool option with get, set
        abstract _prepare: unit -> unit
        /// Execute the action and play the animation.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action responsible to start an animation once triggered.
    type [<AllowNullLiteral>] PlayAnimationActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="target">defines the target animation or animation name</param>
        /// <param name="from">defines from where the animation should start (animation frame)</param>
        /// <param name="loop">defines if the animation should loop or stop after the first play</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * from: float * ``to``: float * ?loop: bool * ?condition: Condition -> PlayAnimationAction

    /// This defines an action responsible to stop an animation once triggered.
    type [<AllowNullLiteral>] StopAnimationAction =
        inherit Action
        abstract _prepare: unit -> unit
        /// Execute the action and stop the animation.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action responsible to stop an animation once triggered.
    type [<AllowNullLiteral>] StopAnimationActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="target">defines the target animation or animation name</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * ?condition: Condition -> StopAnimationAction

    /// This defines an action responsible that does nothing once triggered.
    type [<AllowNullLiteral>] DoNothingAction =
        inherit Action
        /// Execute the action and do nothing.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action responsible that does nothing once triggered.
    type [<AllowNullLiteral>] DoNothingActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: ?triggerOptions: obj * ?condition: Condition -> DoNothingAction

    /// This defines an action responsible to trigger several actions once triggered.
    type [<AllowNullLiteral>] CombineAction =
        inherit Action
        /// The list of aggregated animations to run.
        abstract children: ResizeArray<Action> with get, set
        abstract _prepare: unit -> unit
        /// Execute the action and executes all the aggregated actions.
        abstract execute: evt: ActionEvent -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action responsible to trigger several actions once triggered.
    type [<AllowNullLiteral>] CombineActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="children">defines the list of aggregated animations to run</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * children: ResizeArray<Action> * ?condition: Condition -> CombineAction

    /// This defines an action responsible to run code (external event) once triggered.
    type [<AllowNullLiteral>] ExecuteCodeAction =
        inherit Action
        /// The callback function to run.
        abstract func: (ActionEvent -> unit) with get, set
        /// Execute the action and run the attached code.
        abstract execute: evt: ActionEvent -> unit

    /// This defines an action responsible to run code (external event) once triggered.
    type [<AllowNullLiteral>] ExecuteCodeActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="func">defines the callback function to run</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * func: (ActionEvent -> unit) * ?condition: Condition -> ExecuteCodeAction

    /// This defines an action responsible to set the parent property of the target once triggered.
    type [<AllowNullLiteral>] SetParentAction =
        inherit Action
        abstract _prepare: unit -> unit
        /// Execute the action and set the parent property.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action responsible to set the parent property of the target once triggered.
    type [<AllowNullLiteral>] SetParentActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="target">defines the target containing the parent property</param>
        /// <param name="parent">defines from where the animation should start (animation frame)</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * parent: obj option * ?condition: Condition -> SetParentAction

    /// This defines an action helpful to play a defined sound on a triggered action.
    type [<AllowNullLiteral>] PlaySoundAction =
        inherit Action
        abstract _prepare: unit -> unit
        /// Execute the action and play the sound.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action helpful to play a defined sound on a triggered action.
    type [<AllowNullLiteral>] PlaySoundActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="sound">defines the sound to play</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * sound: Sound * ?condition: Condition -> PlaySoundAction

    /// This defines an action helpful to stop a defined sound on a triggered action.
    type [<AllowNullLiteral>] StopSoundAction =
        inherit Action
        abstract _prepare: unit -> unit
        /// Execute the action and stop the sound.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action helpful to stop a defined sound on a triggered action.
    type [<AllowNullLiteral>] StopSoundActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="sound">defines the sound to stop</param>
        /// <param name="condition">defines the trigger related conditions</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * sound: Sound * ?condition: Condition -> StopSoundAction

    /// This defines an action responsible to change the value of a property
    /// by interpolating between its current value and the newly set one once triggered.
    type [<AllowNullLiteral>] InterpolateValueAction =
        inherit Action
        /// Defines the path of the property where the value should be interpolated
        abstract propertyPath: string with get, set
        /// Defines the target value at the end of the interpolation.
        abstract value: obj option with get, set
        /// Defines the time it will take for the property to interpolate to the value.
        abstract duration: float with get, set
        /// Defines if the other scene animations should be stopped when the action has been triggered
        abstract stopOtherAnimations: bool option with get, set
        /// Defines a callback raised once the interpolation animation has been done.
        abstract onInterpolationDone: (unit -> unit) option with get, set
        /// Observable triggered once the interpolation animation has been done.
        abstract onInterpolationDoneObservable: Observable<InterpolateValueAction> with get, set
        abstract _prepare: unit -> unit
        /// Execute the action starts the value interpolation.
        abstract execute: unit -> unit
        /// <summary>Serializes the actions and its related information.</summary>
        /// <param name="parent">defines the object to serialize in</param>
        abstract serialize: parent: obj option -> obj option

    /// This defines an action responsible to change the value of a property
    /// by interpolating between its current value and the newly set one once triggered.
    type [<AllowNullLiteral>] InterpolateValueActionStatic =
        /// <summary>Instantiate the action</summary>
        /// <param name="triggerOptions">defines the trigger options</param>
        /// <param name="target">defines the object containing the value to interpolate</param>
        /// <param name="propertyPath">defines the path to the property in the target object</param>
        /// <param name="value">defines the target value at the end of the interpolation</param>
        /// <param name="duration">deines the time it will take for the property to interpolate to the value.</param>
        /// <param name="condition">defines the trigger related conditions</param>
        /// <param name="stopOtherAnimations">defines if the other scene animations should be stopped when the action has been triggered</param>
        /// <param name="onInterpolationDone">defines a callback raised once the interpolation animation has been done</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * propertyPath: string * value: obj option * ?duration: float * ?condition: Condition * ?stopOtherAnimations: bool * ?onInterpolationDone: (unit -> unit) -> InterpolateValueAction

    /// Class used to work with sound analyzer using fast fourier transform (FFT)
    type [<AllowNullLiteral>] Analyser =
        /// Gets or sets the smoothing
        abstract SMOOTHING: float with get, set
        /// Gets or sets the FFT table size
        abstract FFT_SIZE: float with get, set
        /// Gets or sets the bar graph amplitude
        abstract BARGRAPHAMPLITUDE: float with get, set
        /// Gets or sets the position of the debug canvas
        abstract DEBUGCANVASPOS: TypeLiteral_07 with get, set
        /// Gets or sets the debug canvas size
        abstract DEBUGCANVASSIZE: TypeLiteral_08 with get, set
        /// Get the number of data values you will have to play with for the visualization
        abstract getFrequencyBinCount: unit -> float
        /// Gets the current frequency data as a byte array
        abstract getByteFrequencyData: unit -> Uint8Array
        /// Gets the current waveform as a byte array
        abstract getByteTimeDomainData: unit -> Uint8Array
        /// Gets the current frequency data as a float array
        abstract getFloatFrequencyData: unit -> Float32Array
        /// Renders the debug canvas
        abstract drawDebugCanvas: unit -> unit
        /// Stops rendering the debug canvas and removes it
        abstract stopDebugCanvas: unit -> unit
        /// <summary>Connects two audio nodes</summary>
        /// <param name="inputAudioNode">defines first node to connect</param>
        /// <param name="outputAudioNode">defines second node to connect</param>
        abstract connectAudioNodes: inputAudioNode: AudioNode * outputAudioNode: AudioNode -> unit
        /// Releases all associated resources
        abstract dispose: unit -> unit

    /// Class used to work with sound analyzer using fast fourier transform (FFT)
    type [<AllowNullLiteral>] AnalyserStatic =
        /// <summary>Creates a new analyser</summary>
        /// <param name="scene">defines hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> Analyser

    /// This represents an audio engine and it is responsible
    /// to play, synchronize and analyse sounds throughout the application.
    type [<AllowNullLiteral>] IAudioEngine =
        inherit IDisposable
        /// Gets whether the current host supports Web Audio and thus could create AudioContexts.
        abstract canUseWebAudio: bool
        /// Gets the current AudioContext if available.
        abstract audioContext: Nullable<AudioContext>
        /// The master gain node defines the global audio volume of your audio engine.
        abstract masterGain: GainNode
        /// Gets whether or not mp3 are supported by your browser.
        abstract isMP3supported: bool
        /// Gets whether or not ogg are supported by your browser.
        abstract isOGGsupported: bool
        /// Defines if Babylon should emit a warning if WebAudio is not supported.
        abstract WarnedWebAudioUnsupported: bool with get, set
        /// Defines if the audio engine relies on a custom unlocked button.
        /// In this case, the embedded button will not be displayed.
        abstract useCustomUnlockedButton: bool with get, set
        /// Gets whether or not the audio engine is unlocked (require first a user gesture on some browser).
        abstract unlocked: bool
        /// Event raised when audio has been unlocked on the browser.
        abstract onAudioUnlockedObservable: Observable<AudioEngine> with get, set
        /// Event raised when audio has been locked on the browser.
        abstract onAudioLockedObservable: Observable<AudioEngine> with get, set
        /// Flags the audio engine in Locked state.
        /// This happens due to new browser policies preventing audio to autoplay.
        abstract lock: unit -> unit
        /// Unlocks the audio engine once a user action has been done on the dom.
        /// This is helpful to resume play once browser policies have been satisfied.
        abstract unlock: unit -> unit

    /// This represents the default audio engine used in babylon.
    /// It is responsible to play, synchronize and analyse sounds throughout the  application.
    type [<AllowNullLiteral>] AudioEngine =
        inherit IAudioEngine
        /// Gets whether the current host supports Web Audio and thus could create AudioContexts.
        abstract canUseWebAudio: bool with get, set
        /// The master gain node defines the global audio volume of your audio engine.
        abstract masterGain: GainNode with get, set
        /// Defines if Babylon should emit a warning if WebAudio is not supported.
        abstract WarnedWebAudioUnsupported: bool with get, set
        /// Gets whether or not mp3 are supported by your browser.
        abstract isMP3supported: bool with get, set
        /// Gets whether or not ogg are supported by your browser.
        abstract isOGGsupported: bool with get, set
        /// Gets whether audio has been unlocked on the device.
        /// Some Browsers have strong restrictions about Audio and won t autoplay unless
        /// a user interaction has happened.
        abstract unlocked: bool with get, set
        /// Defines if the audio engine relies on a custom unlocked button.
        /// In this case, the embedded button will not be displayed.
        abstract useCustomUnlockedButton: bool with get, set
        /// Event raised when audio has been unlocked on the browser.
        abstract onAudioUnlockedObservable: Observable<AudioEngine> with get, set
        /// Event raised when audio has been locked on the browser.
        abstract onAudioLockedObservable: Observable<AudioEngine> with get, set
        /// Gets the current AudioContext if available.
        abstract audioContext: Nullable<AudioContext>
        /// Flags the audio engine in Locked state.
        /// This happens due to new browser policies preventing audio to autoplay.
        abstract lock: unit -> unit
        /// Unlocks the audio engine once a user action has been done on the dom.
        /// This is helpful to resume play once browser policies have been satisfied.
        abstract unlock: unit -> unit
        /// Destroy and release the resources associated with the audio ccontext.
        abstract dispose: unit -> unit
        /// Gets the global volume sets on the master gain.
        abstract getGlobalVolume: unit -> float
        /// <summary>Sets the global volume of your experience (sets on the master gain).</summary>
        /// <param name="newVolume">Defines the new global volume of the application</param>
        abstract setGlobalVolume: newVolume: float -> unit
        /// <summary>Connect the audio engine to an audio analyser allowing some amazing
        /// synchornization between the sounds/music and your visualization (VuMeter for instance).</summary>
        /// <param name="analyser">The analyser to connect to the engine</param>
        abstract connectToAnalyser: analyser: Analyser -> unit

    /// This represents the default audio engine used in babylon.
    /// It is responsible to play, synchronize and analyse sounds throughout the  application.
    type [<AllowNullLiteral>] AudioEngineStatic =
        /// <summary>Instantiates a new audio engine.
        /// 
        /// There should be only one per page as some browsers restrict the number
        /// of audio contexts you can create.</summary>
        /// <param name="hostElement">defines the host element where to display the mute icon if necessary</param>
        [<Emit "new $0($1...)">] abstract Create: ?hostElement: HTMLElement -> AudioEngine

    /// Defines the sound scene component responsible to manage any sounds
    /// in a given scene.
    type [<AllowNullLiteral>] AudioSceneComponent =
        inherit ISceneSerializableComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Gets whether audio is enabled or not.
        /// Please use related enable/disable method to switch state.
        abstract audioEnabled: bool
        /// Gets whether audio is outputing to headphone or not.
        /// Please use the according Switch methods to change output.
        abstract headphone: bool
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// <summary>Serializes the component data to the specified json object</summary>
        /// <param name="serializationObject">The object to serialize to</param>
        abstract serialize: serializationObject: obj option -> unit
        /// <summary>Adds all the element from the container to the scene</summary>
        /// <param name="container">the container holding the elements</param>
        abstract addFromContainer: container: AbstractScene -> unit
        /// <summary>Removes all the elements in the container from the scene</summary>
        /// <param name="container">contains the elements to remove</param>
        abstract removeFromContainer: container: AbstractScene -> unit
        /// Disposes the component and the associated ressources.
        abstract dispose: unit -> unit
        /// Disables audio in the associated scene.
        abstract disableAudio: unit -> unit
        /// Enables audio in the associated scene.
        abstract enableAudio: unit -> unit
        /// Switch audio to headphone output.
        abstract switchAudioModeForHeadphones: unit -> unit
        /// Switch audio to normal speakers.
        abstract switchAudioModeForNormalSpeakers: unit -> unit

    /// Defines the sound scene component responsible to manage any sounds
    /// in a given scene.
    type [<AllowNullLiteral>] AudioSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> AudioSceneComponent

    /// Defines a sound that can be played in the application.
    /// The sound can either be an ambient track or a simple sound played in reaction to a user action.
    type [<AllowNullLiteral>] Sound =
        /// The name of the sound in the scene.
        abstract name: string with get, set
        /// Does the sound autoplay once loaded.
        abstract autoplay: bool with get, set
        /// Does the sound loop after it finishes playing once.
        abstract loop: bool with get, set
        /// Does the sound use a custom attenuation curve to simulate the falloff
        /// happening when the source gets further away from the camera.
        abstract useCustomAttenuation: bool with get, set
        /// The sound track id this sound belongs to.
        abstract soundTrackId: float with get, set
        /// Is this sound currently played.
        abstract isPlaying: bool with get, set
        /// Is this sound currently paused.
        abstract isPaused: bool with get, set
        /// Does this sound enables spatial sound.
        abstract spatialSound: bool with get, set
        /// Define the reference distance the sound should be heard perfectly.
        abstract refDistance: float with get, set
        /// Define the roll off factor of spatial sounds.
        abstract rolloffFactor: float with get, set
        /// Define the max distance the sound should be heard (intensity just became 0 at this point).
        abstract maxDistance: float with get, set
        /// Define the distance attenuation model the sound will follow.
        abstract distanceModel: string with get, set
        abstract onended: (unit -> obj option) with get, set
        /// Observable event when the current playing sound finishes.
        abstract onEndedObservable: Observable<Sound> with get, set
        abstract _positionInEmitterSpace: bool with get, set
        /// Release the sound and its associated resources
        abstract dispose: unit -> unit
        /// Gets if the sounds is ready to be played or not.
        abstract isReady: unit -> bool
        /// <summary>Sets the data of the sound from an audiobuffer</summary>
        /// <param name="audioBuffer">The audioBuffer containing the data</param>
        abstract setAudioBuffer: audioBuffer: AudioBuffer -> unit
        /// <summary>Updates the current sounds options such as maxdistance, loop...</summary>
        /// <param name="options">A JSON object containing values named as the object properties</param>
        abstract updateOptions: options: obj option -> unit
        /// Switch the panning model to HRTF:
        /// Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.
        abstract switchPanningModelToHRTF: unit -> unit
        /// Switch the panning model to Equal Power:
        /// Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
        abstract switchPanningModelToEqualPower: unit -> unit
        /// <summary>Connect this sound to a sound track audio node like gain...</summary>
        /// <param name="soundTrackAudioNode">the sound track audio node to connect to</param>
        abstract connectToSoundTrackAudioNode: soundTrackAudioNode: AudioNode -> unit
        /// <summary>Transform this sound into a directional source</summary>
        /// <param name="coneInnerAngle">Size of the inner cone in degree</param>
        /// <param name="coneOuterAngle">Size of the outer cone in degree</param>
        /// <param name="coneOuterGain">Volume of the sound outside the outer cone (between 0.0 and 1.0)</param>
        abstract setDirectionalCone: coneInnerAngle: float * coneOuterAngle: float * coneOuterGain: float -> unit
        /// Gets or sets the inner angle for the directional cone.
        /// Gets or sets the inner angle for the directional cone.
        abstract directionalConeInnerAngle: float with get, set
        /// Gets or sets the outer angle for the directional cone.
        /// Gets or sets the outer angle for the directional cone.
        abstract directionalConeOuterAngle: float with get, set
        /// <summary>Sets the position of the emitter if spatial sound is enabled</summary>
        /// <param name="newPosition">Defines the new posisiton</param>
        abstract setPosition: newPosition: Vector3 -> unit
        /// <summary>Sets the local direction of the emitter if spatial sound is enabled</summary>
        /// <param name="newLocalDirection">Defines the new local direction</param>
        abstract setLocalDirectionToMesh: newLocalDirection: Vector3 -> unit
        abstract updateDistanceFromListener: unit -> unit
        /// <summary>Sets a new custom attenuation function for the sound.</summary>
        /// <param name="callback">Defines the function used for the attenuation</param>
        abstract setAttenuationFunction: callback: (float -> float -> float -> float -> float -> float) -> unit
        /// <summary>Play the sound</summary>
        /// <param name="time">(optional) Start the sound after X seconds. Start immediately (0) by default.</param>
        /// <param name="offset">(optional) Start the sound setting it at a specific time</param>
        abstract play: ?time: float * ?offset: float -> unit
        /// <summary>Stop the sound</summary>
        /// <param name="time">(optional) Stop the sound after X seconds. Stop immediately (0) by default.</param>
        abstract stop: ?time: float -> unit
        /// Put the sound in pause
        abstract pause: unit -> unit
        /// <summary>Sets a dedicated volume for this sounds</summary>
        /// <param name="newVolume">Define the new volume of the sound</param>
        /// <param name="time">Define in how long the sound should be at this value</param>
        abstract setVolume: newVolume: float * ?time: float -> unit
        /// <summary>Set the sound play back rate</summary>
        /// <param name="newPlaybackRate">Define the playback rate the sound should be played at</param>
        abstract setPlaybackRate: newPlaybackRate: float -> unit
        /// Gets the volume of the sound.
        abstract getVolume: unit -> float
        /// <summary>Attach the sound to a dedicated mesh</summary>
        /// <param name="meshToConnectTo">The mesh to connect the sound with</param>
        abstract attachToMesh: meshToConnectTo: AbstractMesh -> unit
        /// Detach the sound from the previously attached mesh
        abstract detachFromMesh: unit -> unit
        /// Clone the current sound in the scene.
        abstract clone: unit -> Nullable<Sound>
        /// Gets the current underlying audio buffer containing the data
        abstract getAudioBuffer: unit -> Nullable<AudioBuffer>
        /// Serializes the Sound in a JSON representation
        abstract serialize: unit -> obj option

    /// Defines a sound that can be played in the application.
    /// The sound can either be an ambient track or a simple sound played in reaction to a user action.
    type [<AllowNullLiteral>] SoundStatic =
        /// <summary>Create a sound and attach it to a scene</summary>
        /// <param name="name">Name of your sound</param>
        /// <param name="urlOrArrayBuffer">Url to the sound to load async or ArrayBuffer, it also works with MediaStreams</param>
        /// <param name="readyToPlayCallback">Provide a callback function if you'd like to load your code once the sound is ready to be played</param>
        /// <param name="options">Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * urlOrArrayBuffer: obj option * scene: Scene * ?readyToPlayCallback: (unit -> unit) * ?options: obj -> Sound
        /// <summary>Parse a JSON representation of a sound to innstantiate in a given scene</summary>
        /// <param name="parsedSound">Define the JSON representation of the sound (usually coming from the serialize method)</param>
        /// <param name="scene">Define the scene the new parsed sound should be created in</param>
        /// <param name="rootUrl">Define the rooturl of the load in case we need to fetch relative dependencies</param>
        /// <param name="sourceSound">Define a cound place holder if do not need to instantiate a new one</param>
        abstract Parse: parsedSound: obj option * scene: Scene * rootUrl: string * ?sourceSound: Sound -> Sound

    /// Options allowed during the creation of a sound track.
    type [<AllowNullLiteral>] ISoundTrackOptions =
        /// The volume the sound track should take during creation
        abstract volume: float option with get, set
        /// Define if the sound track is the main sound track of the scene
        abstract mainTrack: bool option with get, set

    /// It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.
    /// It will be also used in a future release to apply effects on a specific track.
    type [<AllowNullLiteral>] SoundTrack =
        /// The unique identifier of the sound track in the scene.
        abstract id: float with get, set
        /// The list of sounds included in the sound track.
        abstract soundCollection: Array<Sound> with get, set
        /// Release the sound track and its associated resources
        abstract dispose: unit -> unit
        /// <summary>Adds a sound to this sound track</summary>
        /// <param name="sound">define the cound to add</param>
        abstract AddSound: sound: Sound -> unit
        /// <summary>Removes a sound to this sound track</summary>
        /// <param name="sound">define the cound to remove</param>
        abstract RemoveSound: sound: Sound -> unit
        /// <summary>Set a global volume for the full sound track.</summary>
        /// <param name="newVolume">Define the new volume of the sound track</param>
        abstract setVolume: newVolume: float -> unit
        /// Switch the panning model to HRTF:
        /// Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.
        abstract switchPanningModelToHRTF: unit -> unit
        /// Switch the panning model to Equal Power:
        /// Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
        abstract switchPanningModelToEqualPower: unit -> unit
        /// <summary>Connect the sound track to an audio analyser allowing some amazing
        /// synchornization between the sounds/music and your visualization (VuMeter for instance).</summary>
        /// <param name="analyser">The analyser to connect to the engine</param>
        abstract connectToAnalyser: analyser: Analyser -> unit

    /// It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.
    /// It will be also used in a future release to apply effects on a specific track.
    type [<AllowNullLiteral>] SoundTrackStatic =
        /// <summary>Creates a new sound track.</summary>
        /// <param name="scene">Define the scene the sound track belongs to</param>
        /// <param name="options"></param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?options: ISoundTrackOptions -> SoundTrack

    /// Wraps one or more Sound objects and selects one with random weight for playback.
    type [<AllowNullLiteral>] WeightedSound =
        /// When true a Sound will be selected and played when the current playing Sound completes. 
        abstract loop: bool with get, set
        /// A Sound is currently playing. 
        abstract isPlaying: bool with get, set
        /// A Sound is currently paused. 
        abstract isPaused: bool with get, set
        /// The size of cone in degrees for a directional sound in which there will be no attenuation.
        /// The size of cone in degress for a directional sound in which there will be no attenuation.
        abstract directionalConeInnerAngle: float with get, set
        /// Size of cone in degrees for a directional sound outside of which there will be no sound.
        /// Listener angles between innerAngle and outerAngle will falloff linearly.
        /// Size of cone in degrees for a directional sound outside of which there will be no sound.
        /// Listener angles between innerAngle and outerAngle will falloff linearly.
        abstract directionalConeOuterAngle: float with get, set
        /// Playback volume.
        /// Playback volume.
        abstract volume: float with get, set
        /// Suspend playback
        abstract pause: unit -> unit
        /// Stop playback
        abstract stop: unit -> unit
        /// <summary>Start playback.</summary>
        /// <param name="startOffset">Position the clip head at a specific time in seconds.</param>
        abstract play: ?startOffset: float -> unit

    /// Wraps one or more Sound objects and selects one with random weight for playback.
    type [<AllowNullLiteral>] WeightedSoundStatic =
        /// <summary>Creates a new WeightedSound from the list of sounds given.</summary>
        /// <param name="loop">When true a Sound will be selected and played when the current playing Sound completes.</param>
        /// <param name="sounds">Array of Sounds that will be selected from.</param>
        /// <param name="weights">Array of number values for selection weights; length must equal sounds, values will be normalized to 1</param>
        [<Emit "new $0($1...)">] abstract Create: loop: bool * sounds: ResizeArray<Sound> * weights: ResizeArray<float> -> WeightedSound

    /// Class used to store an actual running animation
    type [<AllowNullLiteral>] Animatable =
        /// defines the target object 
        abstract target: obj option with get, set
        /// defines the starting frame number (default is 0) 
        abstract fromFrame: float with get, set
        /// defines the ending frame number (default is 100) 
        abstract toFrame: float with get, set
        /// defines if the animation must loop (default is false)  
        abstract loopAnimation: bool with get, set
        /// defines a callback to call when animation ends if it is not looping 
        abstract onAnimationEnd: (unit -> unit) option with get, set
        /// Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.
        /// This will only apply for non looping animation (default is true)
        abstract disposeOnEnd: bool with get, set
        /// Gets a boolean indicating if the animation has started
        abstract animationStarted: bool with get, set
        /// Observer raised when the animation ends
        abstract onAnimationEndObservable: Observable<Animatable> with get, set
        /// Gets the root Animatable used to synchronize and normalize animations
        abstract syncRoot: Animatable
        /// Gets the current frame of the first RuntimeAnimation
        /// Used to synchronize Animatables
        abstract masterFrame: float
        /// Gets or sets the animatable weight (-1.0 by default meaning not weighted)
        abstract weight: float with get, set
        /// Gets or sets the speed ratio to apply to the animatable (1.0 by default)
        abstract speedRatio: float with get, set
        /// <summary>Synchronize and normalize current Animatable with a source Animatable
        /// This is useful when using animation weights and when animations are not of the same length</summary>
        /// <param name="root">defines the root Animatable to synchronize with</param>
        abstract syncWith: root: Animatable -> Animatable
        /// Gets the list of runtime animations
        abstract getAnimations: unit -> ResizeArray<RuntimeAnimation>
        /// <summary>Adds more animations to the current animatable</summary>
        /// <param name="target">defines the target of the animations</param>
        /// <param name="animations">defines the new animations to add</param>
        abstract appendAnimations: target: obj option * animations: ResizeArray<Animation> -> unit
        /// <summary>Gets the source animation for a specific property</summary>
        /// <param name="property">defines the propertyu to look for</param>
        abstract getAnimationByTargetProperty: property: string -> Nullable<Animation>
        /// <summary>Gets the runtime animation for a specific property</summary>
        /// <param name="property">defines the propertyu to look for</param>
        abstract getRuntimeAnimationByTargetProperty: property: string -> Nullable<RuntimeAnimation>
        /// Resets the animatable to its original state
        abstract reset: unit -> unit
        /// <summary>Allows the animatable to blend with current running animations</summary>
        /// <param name="blendingSpeed">defines the blending speed to use</param>
        abstract enableBlending: blendingSpeed: float -> unit
        /// Disable animation blending
        abstract disableBlending: unit -> unit
        /// <summary>Jump directly to a given frame</summary>
        /// <param name="frame">defines the frame to jump to</param>
        abstract goToFrame: frame: float -> unit
        /// Pause the animation
        abstract pause: unit -> unit
        /// Restart the animation
        abstract restart: unit -> unit
        /// <summary>Stop and delete the current animation</summary>
        /// <param name="animationName">defines a string used to only stop some of the runtime animations instead of all</param>
        /// <param name="targetMask">- a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)</param>
        abstract stop: ?animationName: string * ?targetMask: (obj option -> bool) -> unit
        /// Wait asynchronously for the animation to end
        abstract waitAsync: unit -> Promise<Animatable>
        abstract _animate: delay: float -> bool

    /// Class used to store an actual running animation
    type [<AllowNullLiteral>] AnimatableStatic =
        /// <summary>Creates a new Animatable</summary>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="target">defines the target object</param>
        /// <param name="fromFrame">defines the starting frame number (default is 0)</param>
        /// <param name="toFrame">defines the ending frame number (default is 100)</param>
        /// <param name="loopAnimation">defines if the animation must loop (default is false)</param>
        /// <param name="speedRatio">defines the factor to apply to animation speed (default is 1)</param>
        /// <param name="onAnimationEnd">defines a callback to call when animation ends if it is not looping</param>
        /// <param name="animations">defines a group of animation to add to the new Animatable</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * target: obj option * ?fromFrame: float * ?toFrame: float * ?loopAnimation: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) * ?animations: ResizeArray<Animation> -> Animatable

    /// Represents the range of an animation
    type [<AllowNullLiteral>] AnimationRange =
        /// The name of the animation range*
        abstract name: string with get, set
        /// The starting frame of the animation 
        abstract from: float with get, set
        /// The ending frame of the animation
        abstract ``to``: float with get, set
        /// Makes a copy of the animation range
        abstract clone: unit -> AnimationRange

    /// Represents the range of an animation
    type [<AllowNullLiteral>] AnimationRangeStatic =
        /// <summary>Initializes the range of an animation</summary>
        /// <param name="name">The name of the animation range</param>
        /// <param name="from">The starting frame of the animation</param>
        /// <param name="to">The ending frame of the animation</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * from: float * ``to``: float -> AnimationRange

    /// Composed of a frame, and an action function
    type [<AllowNullLiteral>] AnimationEvent =
        /// The frame for which the event is triggered *
        abstract frame: float with get, set
        /// The event to perform when triggered *
        abstract action: (float -> unit) with get, set
        /// Specifies if the event should be triggered only once*
        abstract onlyOnce: bool option with get, set
        /// Specifies if the animation event is done
        abstract isDone: bool with get, set
        abstract _clone: unit -> AnimationEvent

    /// Composed of a frame, and an action function
    type [<AllowNullLiteral>] AnimationEventStatic =
        /// <summary>Initializes the animation event</summary>
        /// <param name="frame">The frame for which the event is triggered</param>
        /// <param name="action">The event to perform when triggered</param>
        /// <param name="onlyOnce">Specifies if the event should be triggered only once</param>
        [<Emit "new $0($1...)">] abstract Create: frame: float * action: (float -> unit) * ?onlyOnce: bool -> AnimationEvent

    /// A cursor which tracks a point on a path
    type [<AllowNullLiteral>] PathCursor =
        /// The value of the path cursor
        abstract value: float with get, set
        /// The animation array of the path cursor
        abstract animations: ResizeArray<Animation> with get, set
        /// Gets the cursor point on the path
        abstract getPoint: unit -> Vector3
        /// <summary>Moves the cursor ahead by the step amount</summary>
        /// <param name="step">The amount to move the cursor forward</param>
        abstract moveAhead: ?step: float -> PathCursor
        /// <summary>Moves the cursor behind by the step amount</summary>
        /// <param name="step">The amount to move the cursor back</param>
        abstract moveBack: ?step: float -> PathCursor
        /// <summary>Moves the cursor by the step amount
        /// If the step amount is greater than one, an exception is thrown</summary>
        /// <param name="step">The amount to move the cursor</param>
        abstract move: step: float -> PathCursor
        /// <summary>Executes a function on change</summary>
        /// <param name="f">A path cursor onchange callback</param>
        abstract onchange: f: (PathCursor -> unit) -> PathCursor

    /// A cursor which tracks a point on a path
    type [<AllowNullLiteral>] PathCursorStatic =
        /// <summary>Initializes the path cursor</summary>
        /// <param name="path">The path to track</param>
        [<Emit "new $0($1...)">] abstract Create: path: Path2 -> PathCursor

    /// Defines an interface which represents an animation key frame
    type [<AllowNullLiteral>] IAnimationKey =
        /// Frame of the key frame
        abstract frame: float with get, set
        /// Value at the specifies key frame
        abstract value: obj option with get, set
        /// The input tangent for the cubic hermite spline
        abstract inTangent: obj option with get, set
        /// The output tangent for the cubic hermite spline
        abstract outTangent: obj option with get, set
        /// The animation interpolation type
        abstract interpolation: AnimationKeyInterpolation option with get, set

    type [<RequireQualifiedAccess>] AnimationKeyInterpolation =
        | STEP = 1

    /// Class used to store any kind of animation
    type [<AllowNullLiteral>] Animation =
        /// Name of the animation 
        abstract name: string with get, set
        /// Property to animate 
        abstract targetProperty: string with get, set
        /// The frames per second of the animation 
        abstract framePerSecond: float with get, set
        /// The data type of the animation 
        abstract dataType: float with get, set
        /// The loop mode of the animation 
        abstract loopMode: float option with get, set
        /// Specifies if blending should be enabled 
        abstract enableBlending: bool option with get, set
        abstract _runtimeAnimations: ResizeArray<RuntimeAnimation> with get, set
        /// Stores an array of target property paths
        abstract targetPropertyPath: ResizeArray<string> with get, set
        /// Stores the blending speed of the animation
        abstract blendingSpeed: float with get, set
        /// Return the array of runtime animations currently using this animation
        abstract runtimeAnimations: ResizeArray<RuntimeAnimation>
        /// Specifies if any of the runtime animations are currently running
        abstract hasRunningRuntimeAnimations: bool
        /// <summary>Converts the animation to a string</summary>
        /// <param name="fullDetails">support for multiple levels of logging within scene loading</param>
        abstract toString: ?fullDetails: bool -> string
        /// <summary>Add an event to this animation</summary>
        /// <param name="event">Event to add</param>
        abstract addEvent: ``event``: AnimationEvent -> unit
        /// <summary>Remove all events found at the given frame</summary>
        /// <param name="frame">The frame to remove events from</param>
        abstract removeEvents: frame: float -> unit
        /// Retrieves all the events from the animation
        abstract getEvents: unit -> ResizeArray<AnimationEvent>
        /// <summary>Creates an animation range</summary>
        /// <param name="name">Name of the animation range</param>
        /// <param name="from">Starting frame of the animation range</param>
        /// <param name="to">Ending frame of the animation</param>
        abstract createRange: name: string * from: float * ``to``: float -> unit
        /// <summary>Deletes an animation range by name</summary>
        /// <param name="name">Name of the animation range to delete</param>
        /// <param name="deleteFrames">Specifies if the key frames for the range should also be deleted (true) or not (false)</param>
        abstract deleteRange: name: string * ?deleteFrames: bool -> unit
        /// <summary>Gets the animation range by name, or null if not defined</summary>
        /// <param name="name">Name of the animation range</param>
        abstract getRange: name: string -> Nullable<AnimationRange>
        /// Gets the key frames from the animation
        abstract getKeys: unit -> Array<IAnimationKey>
        /// Gets the highest frame rate of the animation
        abstract getHighestFrame: unit -> float
        /// Gets the easing function of the animation
        abstract getEasingFunction: unit -> IEasingFunction
        /// <summary>Sets the easing function of the animation</summary>
        /// <param name="easingFunction">A custom mathematical formula for animation</param>
        abstract setEasingFunction: easingFunction: EasingFunction -> unit
        /// <summary>Interpolates a scalar linearly</summary>
        /// <param name="startValue">Start value of the animation curve</param>
        /// <param name="endValue">End value of the animation curve</param>
        /// <param name="gradient">Scalar amount to interpolate</param>
        abstract floatInterpolateFunction: startValue: float * endValue: float * gradient: float -> float
        /// <summary>Interpolates a scalar cubically</summary>
        /// <param name="startValue">Start value of the animation curve</param>
        /// <param name="outTangent">End tangent of the animation</param>
        /// <param name="endValue">End value of the animation curve</param>
        /// <param name="inTangent">Start tangent of the animation curve</param>
        /// <param name="gradient">Scalar amount to interpolate</param>
        abstract floatInterpolateFunctionWithTangents: startValue: float * outTangent: float * endValue: float * inTangent: float * gradient: float -> float
        /// <summary>Interpolates a quaternion using a spherical linear interpolation</summary>
        /// <param name="startValue">Start value of the animation curve</param>
        /// <param name="endValue">End value of the animation curve</param>
        /// <param name="gradient">Scalar amount to interpolate</param>
        abstract quaternionInterpolateFunction: startValue: Quaternion * endValue: Quaternion * gradient: float -> Quaternion
        /// <summary>Interpolates a quaternion cubically</summary>
        /// <param name="startValue">Start value of the animation curve</param>
        /// <param name="outTangent">End tangent of the animation curve</param>
        /// <param name="endValue">End value of the animation curve</param>
        /// <param name="inTangent">Start tangent of the animation curve</param>
        /// <param name="gradient">Scalar amount to interpolate</param>
        abstract quaternionInterpolateFunctionWithTangents: startValue: Quaternion * outTangent: Quaternion * endValue: Quaternion * inTangent: Quaternion * gradient: float -> Quaternion
        /// <summary>Interpolates a Vector3 linearl</summary>
        /// <param name="startValue">Start value of the animation curve</param>
        /// <param name="endValue">End value of the animation curve</param>
        /// <param name="gradient">Scalar amount to interpolate</param>
        abstract vector3InterpolateFunction: startValue: Vector3 * endValue: Vector3 * gradient: float -> Vector3
        /// <summary>Interpolates a Vector3 cubically</summary>
        /// <param name="startValue">Start value of the animation curve</param>
        /// <param name="outTangent">End tangent of the animation</param>
        /// <param name="endValue">End value of the animation curve</param>
        /// <param name="inTangent">Start tangent of the animation curve</param>
        /// <param name="gradient">Scalar amount to interpolate</param>
        abstract vector3InterpolateFunctionWithTangents: startValue: Vector3 * outTangent: Vector3 * endValue: Vector3 * inTangent: Vector3 * gradient: float -> Vector3
        /// <summary>Interpolates a Vector2 linearly</summary>
        /// <param name="startValue">Start value of the animation curve</param>
        /// <param name="endValue">End value of the animation curve</param>
        /// <param name="gradient">Scalar amount to interpolate</param>
        abstract vector2InterpolateFunction: startValue: Vector2 * endValue: Vector2 * gradient: float -> Vector2
        /// <summary>Interpolates a Vector2 cubically</summary>
        /// <param name="startValue">Start value of the animation curve</param>
        /// <param name="outTangent">End tangent of the animation</param>
        /// <param name="endValue">End value of the animation curve</param>
        /// <param name="inTangent">Start tangent of the animation curve</param>
        /// <param name="gradient">Scalar amount to interpolate</param>
        abstract vector2InterpolateFunctionWithTangents: startValue: Vector2 * outTangent: Vector2 * endValue: Vector2 * inTangent: Vector2 * gradient: float -> Vector2
        /// <summary>Interpolates a size linearly</summary>
        /// <param name="startValue">Start value of the animation curve</param>
        /// <param name="endValue">End value of the animation curve</param>
        /// <param name="gradient">Scalar amount to interpolate</param>
        abstract sizeInterpolateFunction: startValue: Size * endValue: Size * gradient: float -> Size
        /// <summary>Interpolates a Color3 linearly</summary>
        /// <param name="startValue">Start value of the animation curve</param>
        /// <param name="endValue">End value of the animation curve</param>
        /// <param name="gradient">Scalar amount to interpolate</param>
        abstract color3InterpolateFunction: startValue: Color3 * endValue: Color3 * gradient: float -> Color3
        abstract _getKeyValue: value: obj option -> obj option
        abstract _interpolate: currentFrame: float * repeatCount: float * ?workValue: obj * ?loopMode: float * ?offsetValue: obj * ?highLimitValue: obj -> obj option
        /// <summary>Defines the function to use to interpolate matrices</summary>
        /// <param name="startValue">defines the start matrix</param>
        /// <param name="endValue">defines the end matrix</param>
        /// <param name="gradient">defines the gradient between both matrices</param>
        /// <param name="result">defines an optional target matrix where to store the interpolation</param>
        abstract matrixInterpolateFunction: startValue: Matrix * endValue: Matrix * gradient: float * ?result: Matrix -> Matrix
        /// Makes a copy of the animation
        abstract clone: unit -> Animation
        /// <summary>Sets the key frames of the animation</summary>
        /// <param name="values">The animation key frames to set</param>
        abstract setKeys: values: Array<IAnimationKey> -> unit
        /// Serializes the animation to an object
        abstract serialize: unit -> obj option

    /// Class used to store any kind of animation
    type [<AllowNullLiteral>] AnimationStatic =
        /// Use matrix interpolation instead of using direct key value when animating matrices
        abstract AllowMatricesInterpolation: bool with get, set
        /// When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower
        abstract AllowMatrixDecomposeForInterpolation: bool with get, set
        abstract _PrepareAnimation: name: string * targetProperty: string * framePerSecond: float * totalFrame: float * from: obj option * ``to``: obj option * ?loopMode: float * ?easingFunction: EasingFunction -> Nullable<Animation>
        /// <summary>Sets up an animation</summary>
        /// <param name="property">The property to animate</param>
        /// <param name="animationType">The animation type to apply</param>
        /// <param name="framePerSecond">The frames per second of the animation</param>
        /// <param name="easingFunction">The easing function used in the animation</param>
        abstract CreateAnimation: property: string * animationType: float * framePerSecond: float * easingFunction: EasingFunction -> Animation
        /// <summary>Create and start an animation on a node</summary>
        /// <param name="name">defines the name of the global animation that will be run on all nodes</param>
        /// <param name="node">defines the root node where the animation will take place</param>
        /// <param name="targetProperty">defines property to animate</param>
        /// <param name="framePerSecond">defines the number of frame per second yo use</param>
        /// <param name="totalFrame">defines the number of frames in total</param>
        /// <param name="from">defines the initial value</param>
        /// <param name="to">defines the final value</param>
        /// <param name="loopMode">defines which loop mode you want to use (off by default)</param>
        /// <param name="easingFunction">defines the easing function to use (linear by default)</param>
        /// <param name="onAnimationEnd">defines the callback to call when animation end</param>
        abstract CreateAndStartAnimation: name: string * node: Node * targetProperty: string * framePerSecond: float * totalFrame: float * from: obj option * ``to``: obj option * ?loopMode: float * ?easingFunction: EasingFunction * ?onAnimationEnd: (unit -> unit) -> Nullable<Animatable>
        /// <summary>Create and start an animation on a node and its descendants</summary>
        /// <param name="name">defines the name of the global animation that will be run on all nodes</param>
        /// <param name="node">defines the root node where the animation will take place</param>
        /// <param name="directDescendantsOnly">if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used</param>
        /// <param name="targetProperty">defines property to animate</param>
        /// <param name="framePerSecond">defines the number of frame per second to use</param>
        /// <param name="totalFrame">defines the number of frames in total</param>
        /// <param name="from">defines the initial value</param>
        /// <param name="to">defines the final value</param>
        /// <param name="loopMode">defines which loop mode you want to use (off by default)</param>
        /// <param name="easingFunction">defines the easing function to use (linear by default)</param>
        /// <param name="onAnimationEnd">defines the callback to call when an animation ends (will be called once per node)</param>
        abstract CreateAndStartHierarchyAnimation: name: string * node: Node * directDescendantsOnly: bool * targetProperty: string * framePerSecond: float * totalFrame: float * from: obj option * ``to``: obj option * ?loopMode: float * ?easingFunction: EasingFunction * ?onAnimationEnd: (unit -> unit) -> Nullable<ResizeArray<Animatable>>
        /// <summary>Creates a new animation, merges it with the existing animations and starts it</summary>
        /// <param name="name">Name of the animation</param>
        /// <param name="node">Node which contains the scene that begins the animations</param>
        /// <param name="targetProperty">Specifies which property to animate</param>
        /// <param name="framePerSecond">The frames per second of the animation</param>
        /// <param name="totalFrame">The total number of frames</param>
        /// <param name="from">The frame at the beginning of the animation</param>
        /// <param name="to">The frame at the end of the animation</param>
        /// <param name="loopMode">Specifies the loop mode of the animation</param>
        /// <param name="easingFunction">(Optional) The easing function of the animation, which allow custom mathematical formulas for animations</param>
        /// <param name="onAnimationEnd">Callback to run once the animation is complete</param>
        abstract CreateMergeAndStartAnimation: name: string * node: Node * targetProperty: string * framePerSecond: float * totalFrame: float * from: obj option * ``to``: obj option * ?loopMode: float * ?easingFunction: EasingFunction * ?onAnimationEnd: (unit -> unit) -> Nullable<Animatable>
        /// <summary>Transition property of an host to the target Value</summary>
        /// <param name="property">The property to transition</param>
        /// <param name="targetValue">The target Value of the property</param>
        /// <param name="host">The object where the property to animate belongs</param>
        /// <param name="scene">Scene used to run the animation</param>
        /// <param name="frameRate">Framerate (in frame/s) to use</param>
        /// <param name="transition">The transition type we want to use</param>
        /// <param name="duration">The duration of the animation, in milliseconds</param>
        /// <param name="onAnimationEnd">Callback trigger at the end of the animation</param>
        abstract TransitionTo: property: string * targetValue: obj option * host: obj option * scene: Scene * frameRate: float * transition: Animation * duration: float * ?onAnimationEnd: (unit -> unit) -> Nullable<Animatable>
        /// <summary>Initializes the animation</summary>
        /// <param name="name">Name of the animation</param>
        /// <param name="targetProperty">Property to animate</param>
        /// <param name="framePerSecond">The frames per second of the animation</param>
        /// <param name="dataType">The data type of the animation</param>
        /// <param name="loopMode">The loop mode of the animation</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * targetProperty: string * framePerSecond: float * dataType: float * ?loopMode: float * ?enableBlending: bool -> Animation
        /// Get the float animation type
        abstract ANIMATIONTYPE_FLOAT: float
        /// Get the Vector3 animation type
        abstract ANIMATIONTYPE_VECTOR3: float
        /// Get the Vector2 animation type
        abstract ANIMATIONTYPE_VECTOR2: float
        /// Get the Size animation type
        abstract ANIMATIONTYPE_SIZE: float
        /// Get the Quaternion animation type
        abstract ANIMATIONTYPE_QUATERNION: float
        /// Get the Matrix animation type
        abstract ANIMATIONTYPE_MATRIX: float
        /// Get the Color3 animation type
        abstract ANIMATIONTYPE_COLOR3: float
        /// Get the Relative Loop Mode
        abstract ANIMATIONLOOPMODE_RELATIVE: float
        /// Get the Cycle Loop Mode
        abstract ANIMATIONLOOPMODE_CYCLE: float
        /// Get the Constant Loop Mode
        abstract ANIMATIONLOOPMODE_CONSTANT: float
        abstract _UniversalLerp: left: obj option * right: obj option * amount: float -> obj option
        /// <summary>Parses an animation object and creates an animation</summary>
        /// <param name="parsedAnimation">Parsed animation object</param>
        abstract Parse: parsedAnimation: obj option -> Animation
        /// <summary>Appends the serialized animations from the source animations</summary>
        /// <param name="source">Source containing the animations</param>
        /// <param name="destination">Target to store the animations</param>
        abstract AppendSerializedAnimations: source: IAnimatable * destination: obj option -> unit

    /// This class defines the direct association between an animation and a target
    type [<AllowNullLiteral>] TargetedAnimation =
        /// Animation to perform
        abstract animation: Animation with get, set
        /// Target to animate
        abstract target: obj option with get, set

    /// This class defines the direct association between an animation and a target
    type [<AllowNullLiteral>] TargetedAnimationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> TargetedAnimation

    /// Use this class to create coordinated animations on multiple targets
    type [<AllowNullLiteral>] AnimationGroup =
        inherit IDisposable
        /// The name of the animation group 
        abstract name: string with get, set
        /// This observable will notify when one animation have ended.
        abstract onAnimationEndObservable: Observable<TargetedAnimation> with get, set
        /// This observable will notify when all animations have ended.
        abstract onAnimationGroupEndObservable: Observable<AnimationGroup> with get, set
        /// This observable will notify when all animations have paused.
        abstract onAnimationGroupPauseObservable: Observable<AnimationGroup> with get, set
        /// Gets the first frame
        abstract from: float
        /// Gets the last frame
        abstract ``to``: float
        /// Define if the animations are started
        abstract isStarted: bool
        /// Gets or sets the speed ratio to use for all animations
        /// Gets or sets the speed ratio to use for all animations
        abstract speedRatio: float with get, set
        /// Gets the targeted animations for this animation group
        abstract targetedAnimations: Array<TargetedAnimation>
        /// returning the list of animatables controlled by this animation group.
        abstract animatables: Array<Animatable>
        /// <summary>Add an animation (with its target) in the group</summary>
        /// <param name="animation">defines the animation we want to add</param>
        /// <param name="target">defines the target of the animation</param>
        abstract addTargetedAnimation: animation: Animation * target: obj option -> TargetedAnimation
        /// <summary>This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame
        /// It can add constant keys at begin or end</summary>
        /// <param name="beginFrame">defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)</param>
        /// <param name="endFrame">defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)</param>
        abstract normalize: ?beginFrame: float * ?endFrame: float -> AnimationGroup
        /// <summary>Start all animations on given targets</summary>
        /// <param name="loop">defines if animations must loop</param>
        /// <param name="speedRatio">defines the ratio to apply to animation speed (1 by default)</param>
        /// <param name="from">defines the from key (optional)</param>
        /// <param name="to">defines the to key (optional)</param>
        abstract start: ?loop: bool * ?speedRatio: float * ?from: float * ?``to``: float -> AnimationGroup
        /// Pause all animations
        abstract pause: unit -> AnimationGroup
        /// <summary>Play all animations to initial state
        /// This function will start() the animations if they were not started or will restart() them if they were paused</summary>
        /// <param name="loop">defines if animations must loop</param>
        abstract play: ?loop: bool -> AnimationGroup
        /// Reset all animations to initial state
        abstract reset: unit -> AnimationGroup
        /// Restart animations from key 0
        abstract restart: unit -> AnimationGroup
        /// Stop all animations
        abstract stop: unit -> AnimationGroup
        /// <summary>Set animation weight for all animatables</summary>
        /// <param name="weight">defines the weight to use</param>
        abstract setWeightForAllAnimatables: weight: float -> AnimationGroup
        /// <summary>Synchronize and normalize all animatables with a source animatable</summary>
        /// <param name="root">defines the root animatable to synchronize with</param>
        abstract syncAllAnimationsWith: root: Animatable -> AnimationGroup
        /// <summary>Goes to a specific frame in this animation group</summary>
        /// <param name="frame">the frame number to go to</param>
        abstract goToFrame: frame: float -> AnimationGroup
        /// Dispose all associated resources
        abstract dispose: unit -> unit
        /// Returns the string "AnimationGroup"
        abstract getClassName: unit -> string
        /// <summary>Creates a detailled string about the object</summary>
        /// <param name="fullDetails">defines if the output string will support multiple levels of logging within scene loading</param>
        abstract toString: ?fullDetails: bool -> string

    /// Use this class to create coordinated animations on multiple targets
    type [<AllowNullLiteral>] AnimationGroupStatic =
        /// <summary>Instantiates a new Animation Group.
        /// This helps managing several animations at once.</summary>
        /// <param name="name">Defines the name of the group</param>
        /// <param name="scene">Defines the scene the group belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Scene -> AnimationGroup
        /// <summary>Returns a new AnimationGroup object parsed from the source provided.</summary>
        /// <param name="parsedAnimationGroup">defines the source</param>
        /// <param name="scene">defines the scene that will receive the animationGroup</param>
        abstract Parse: parsedAnimationGroup: obj option * scene: Scene -> AnimationGroup

    /// Class used to override all child animations of a given target
    type [<AllowNullLiteral>] AnimationPropertiesOverride =
        /// Gets or sets a value indicating if animation blending must be used
        abstract enableBlending: bool with get, set
        /// Gets or sets the blending speed to use when enableBlending is true
        abstract blendingSpeed: float with get, set
        /// Gets or sets the default loop mode to use
        abstract loopMode: float with get, set

    /// Class used to override all child animations of a given target
    type [<AllowNullLiteral>] AnimationPropertiesOverrideStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> AnimationPropertiesOverride

    /// This represents the main contract an easing function should follow.
    /// Easing functions are used throughout the animation system.
    type [<AllowNullLiteral>] IEasingFunction =
        /// <summary>Given an input gradient between 0 and 1, this returns the corrseponding value
        /// of the easing function.
        /// The link below provides some of the most common examples of easing functions.</summary>
        /// <param name="gradient">Defines the value between 0 and 1 we want the easing value for</param>
        abstract ease: gradient: float -> float

    /// Base class used for every default easing function.
    type [<AllowNullLiteral>] EasingFunction =
        inherit IEasingFunction
        /// <summary>Sets the easing mode of the current function.</summary>
        /// <param name="easingMode">Defines the willing mode (EASINGMODE_EASEIN, EASINGMODE_EASEOUT or EASINGMODE_EASEINOUT)</param>
        abstract setEasingMode: easingMode: float -> unit
        /// Gets the current easing mode.
        abstract getEasingMode: unit -> float
        abstract easeInCore: gradient: float -> float
        /// <summary>Given an input gradient between 0 and 1, this returns the corrseponding value
        /// of the easing function.</summary>
        /// <param name="gradient">Defines the value between 0 and 1 we want the easing value for</param>
        abstract ease: gradient: float -> float

    /// Base class used for every default easing function.
    type [<AllowNullLiteral>] EasingFunctionStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> EasingFunction
        /// Interpolation follows the mathematical formula associated with the easing function.
        abstract EASINGMODE_EASEIN: float
        /// Interpolation follows 100% interpolation minus the output of the formula associated with the easing function.
        abstract EASINGMODE_EASEOUT: float
        /// Interpolation uses EaseIn for the first half of the animation and EaseOut for the second half.
        abstract EASINGMODE_EASEINOUT: float

    /// Easing function with a circle shape (see link below).
    type [<AllowNullLiteral>] CircleEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    /// Easing function with a circle shape (see link below).
    type [<AllowNullLiteral>] CircleEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CircleEase

    /// Easing function with a ease back shape (see link below).
    type [<AllowNullLiteral>] BackEase =
        inherit EasingFunction
        inherit IEasingFunction
        /// Defines the amplitude of the function 
        abstract amplitude: float with get, set
        abstract easeInCore: gradient: float -> float

    /// Easing function with a ease back shape (see link below).
    type [<AllowNullLiteral>] BackEaseStatic =
        /// <summary>Instantiates a back ease easing</summary>
        /// <param name="amplitude">Defines the amplitude of the function</param>
        [<Emit "new $0($1...)">] abstract Create: ?amplitude: float -> BackEase

    /// Easing function with a bouncing shape (see link below).
    type [<AllowNullLiteral>] BounceEase =
        inherit EasingFunction
        inherit IEasingFunction
        /// Defines the number of bounces 
        abstract bounces: float with get, set
        /// Defines the amplitude of the bounce 
        abstract bounciness: float with get, set
        abstract easeInCore: gradient: float -> float

    /// Easing function with a bouncing shape (see link below).
    type [<AllowNullLiteral>] BounceEaseStatic =
        /// <summary>Instantiates a bounce easing</summary>
        /// <param name="bounces">Defines the number of bounces</param>
        /// <param name="bounciness">Defines the amplitude of the bounce</param>
        [<Emit "new $0($1...)">] abstract Create: ?bounces: float * ?bounciness: float -> BounceEase

    /// Easing function with a power of 3 shape (see link below).
    type [<AllowNullLiteral>] CubicEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    /// Easing function with a power of 3 shape (see link below).
    type [<AllowNullLiteral>] CubicEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CubicEase

    /// Easing function with an elastic shape (see link below).
    type [<AllowNullLiteral>] ElasticEase =
        inherit EasingFunction
        inherit IEasingFunction
        /// Defines the number of oscillations
        abstract oscillations: float with get, set
        /// Defines the amplitude of the oscillations
        abstract springiness: float with get, set
        abstract easeInCore: gradient: float -> float

    /// Easing function with an elastic shape (see link below).
    type [<AllowNullLiteral>] ElasticEaseStatic =
        /// <summary>Instantiates an elastic easing function</summary>
        /// <param name="oscillations">Defines the number of oscillations</param>
        /// <param name="springiness">Defines the amplitude of the oscillations</param>
        [<Emit "new $0($1...)">] abstract Create: ?oscillations: float * ?springiness: float -> ElasticEase

    /// Easing function with an exponential shape (see link below).
    type [<AllowNullLiteral>] ExponentialEase =
        inherit EasingFunction
        inherit IEasingFunction
        /// Defines the exponent of the function 
        abstract exponent: float with get, set
        abstract easeInCore: gradient: float -> float

    /// Easing function with an exponential shape (see link below).
    type [<AllowNullLiteral>] ExponentialEaseStatic =
        /// <summary>Instantiates an exponential easing function</summary>
        /// <param name="exponent">Defines the exponent of the function</param>
        [<Emit "new $0($1...)">] abstract Create: ?exponent: float -> ExponentialEase

    /// Easing function with a power shape (see link below).
    type [<AllowNullLiteral>] PowerEase =
        inherit EasingFunction
        inherit IEasingFunction
        /// Defines the power of the function 
        abstract power: float with get, set
        abstract easeInCore: gradient: float -> float

    /// Easing function with a power shape (see link below).
    type [<AllowNullLiteral>] PowerEaseStatic =
        /// <summary>Instantiates an power base easing function</summary>
        /// <param name="power">Defines the power of the function</param>
        [<Emit "new $0($1...)">] abstract Create: ?power: float -> PowerEase

    /// Easing function with a power of 2 shape (see link below).
    type [<AllowNullLiteral>] QuadraticEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    /// Easing function with a power of 2 shape (see link below).
    type [<AllowNullLiteral>] QuadraticEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> QuadraticEase

    /// Easing function with a power of 4 shape (see link below).
    type [<AllowNullLiteral>] QuarticEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    /// Easing function with a power of 4 shape (see link below).
    type [<AllowNullLiteral>] QuarticEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> QuarticEase

    /// Easing function with a power of 5 shape (see link below).
    type [<AllowNullLiteral>] QuinticEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    /// Easing function with a power of 5 shape (see link below).
    type [<AllowNullLiteral>] QuinticEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> QuinticEase

    /// Easing function with a sin shape (see link below).
    type [<AllowNullLiteral>] SineEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    /// Easing function with a sin shape (see link below).
    type [<AllowNullLiteral>] SineEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SineEase

    /// Easing function with a bezier shape (see link below).
    type [<AllowNullLiteral>] BezierCurveEase =
        inherit EasingFunction
        inherit IEasingFunction
        /// Defines the x component of the start tangent in the bezier curve 
        abstract x1: float with get, set
        /// Defines the y component of the start tangent in the bezier curve 
        abstract y1: float with get, set
        /// Defines the x component of the end tangent in the bezier curve 
        abstract x2: float with get, set
        /// Defines the y component of the end tangent in the bezier curve 
        abstract y2: float with get, set
        abstract easeInCore: gradient: float -> float

    /// Easing function with a bezier shape (see link below).
    type [<AllowNullLiteral>] BezierCurveEaseStatic =
        /// <summary>Instantiates a bezier function</summary>
        /// <param name="x1">Defines the x component of the start tangent in the bezier curve</param>
        /// <param name="y1">Defines the y component of the start tangent in the bezier curve</param>
        /// <param name="x2">Defines the x component of the end tangent in the bezier curve</param>
        /// <param name="y2">Defines the y component of the end tangent in the bezier curve</param>
        [<Emit "new $0($1...)">] abstract Create: ?x1: float * ?y1: float * ?x2: float * ?y2: float -> BezierCurveEase

    /// Defines a runtime animation
    type [<AllowNullLiteral>] RuntimeAnimation =
        abstract _workValue: obj option with get, set
        /// Gets the current frame of the runtime animation
        abstract currentFrame: float
        /// Gets the weight of the runtime animation
        abstract weight: float
        /// Gets the current value of the runtime animation
        abstract currentValue: obj option
        /// Gets the target path of the runtime animation
        abstract targetPath: string
        /// Gets the actual target of the runtime animation
        abstract target: obj option
        /// Gets the animation from the runtime animation
        abstract animation: Animation
        /// <summary>Resets the runtime animation to the beginning</summary>
        /// <param name="restoreOriginal">defines whether to restore the target property to the original value</param>
        abstract reset: ?restoreOriginal: bool -> unit
        /// Specifies if the runtime animation is stopped
        abstract isStopped: unit -> bool
        /// Disposes of the runtime animation
        abstract dispose: unit -> unit
        /// <summary>Apply the interpolated value to the target</summary>
        /// <param name="currentValue">defines the value computed by the animation</param>
        /// <param name="weight">defines the weight to apply to this value (Defaults to 1.0)</param>
        abstract setValue: currentValue: obj option * ?weight: float -> unit
        /// <summary>Move the current animation to a given frame</summary>
        /// <param name="frame">defines the frame to move to</param>
        abstract goToFrame: frame: float -> unit
        abstract _prepareForSpeedRatioChange: newSpeedRatio: float -> unit
        /// <summary>Execute the current animation</summary>
        /// <param name="delay">defines the delay to add to the current frame</param>
        /// <param name="from">defines the lower bound of the animation range</param>
        /// <param name="to">defines the upper bound of the animation range</param>
        /// <param name="loop">defines if the current animation must loop</param>
        /// <param name="speedRatio">defines the current speed ratio</param>
        /// <param name="weight">defines the weight of the animation (default is -1 so no weight)</param>
        abstract animate: delay: float * from: float * ``to``: float * loop: bool * speedRatio: float * ?weight: float -> bool

    /// Defines a runtime animation
    type [<AllowNullLiteral>] RuntimeAnimationStatic =
        /// <summary>Create a new RuntimeAnimation object</summary>
        /// <param name="target">defines the target of the animation</param>
        /// <param name="animation">defines the source animation object</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="host">defines the initiating Animatable</param>
        [<Emit "new $0($1...)">] abstract Create: target: obj option * animation: Animation * scene: Scene * host: Animatable -> RuntimeAnimation

    /// Interface used to define a behavior
    type [<AllowNullLiteral>] Behavior<'T> =
        /// gets or sets behavior's name 
        abstract name: string with get, set
        /// Function called when the behavior needs to be initialized (after attaching it to a target)
        abstract init: unit -> unit
        /// <summary>Called when the behavior is attached to a target</summary>
        /// <param name="target">defines the target where the behavior is attached to</param>
        abstract attach: target: 'T -> unit
        /// Called when the behavior is detached from its target
        abstract detach: unit -> unit

    /// Interface implemented by classes supporting behaviors
    type [<AllowNullLiteral>] IBehaviorAware<'T> =
        /// <summary>Attach a behavior</summary>
        /// <param name="behavior">defines the behavior to attach</param>
        abstract addBehavior: behavior: Behavior<'T> -> 'T
        /// <summary>Remove a behavior from the current object</summary>
        /// <param name="behavior">defines the behavior to detach</param>
        abstract removeBehavior: behavior: Behavior<'T> -> 'T
        /// <summary>Gets a behavior using its name to search</summary>
        /// <param name="name">defines the name to search</param>
        abstract getBehaviorByName: name: string -> Nullable<Behavior<'T>>

    /// Class used to store bone information
    type [<AllowNullLiteral>] Bone =
        inherit Node
        /// defines the bone name
        abstract name: string with get, set
        /// Gets the list of child bones
        abstract children: ResizeArray<Bone> with get, set
        /// Gets the animations associated with this bone 
        abstract animations: ResizeArray<Animation> with get, set
        /// Gets or sets bone length
        abstract length: float with get, set
        abstract _index: Nullable<float> with get, set
        abstract _matrix: Matrix with get, set
        /// Gets the parent skeleton
        abstract getSkeleton: unit -> Skeleton
        /// Gets parent bone
        abstract getParent: unit -> Nullable<Bone>
        /// <summary>Sets the parent bone</summary>
        /// <param name="parent">defines the parent (can be null if the bone is the root)</param>
        /// <param name="updateDifferenceMatrix">defines if the difference matrix must be updated</param>
        abstract setParent: parent: Nullable<Bone> * ?updateDifferenceMatrix: bool -> unit
        /// Gets the local matrix
        abstract getLocalMatrix: unit -> Matrix
        /// Gets the base matrix (initial matrix which remains unchanged)
        abstract getBaseMatrix: unit -> Matrix
        /// Gets the rest pose matrix
        abstract getRestPose: unit -> Matrix
        /// Gets a matrix used to store world matrix (ie. the matrix sent to shaders)
        abstract getWorldMatrix: unit -> Matrix
        /// Sets the local matrix to rest pose matrix
        abstract returnToRest: unit -> unit
        /// Gets the inverse of the absolute transform matrix.
        /// This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)
        abstract getInvertedAbsoluteTransform: unit -> Matrix
        /// Gets the absolute transform matrix (ie base matrix * parent world matrix)
        abstract getAbsoluteTransform: unit -> Matrix
        /// Gets or sets current position (in local space) 
        abstract position: Vector3 with get, set
        /// Gets or sets current rotation (in local space) 
        abstract rotation: Vector3 with get, set
        /// Gets or sets current rotation quaternion (in local space) 
        abstract rotationQuaternion: Quaternion with get, set
        /// Gets or sets current scaling (in local space) 
        abstract scaling: Vector3 with get, set
        /// Gets the animation properties override
        abstract animationPropertiesOverride: Nullable<AnimationPropertiesOverride>
        /// <summary>Update the base and local matrices</summary>
        /// <param name="matrix">defines the new base or local matrix</param>
        /// <param name="updateDifferenceMatrix">defines if the difference matrix must be updated</param>
        /// <param name="updateLocalMatrix">defines if the local matrix should be updated</param>
        abstract updateMatrix: matrix: Matrix * ?updateDifferenceMatrix: bool * ?updateLocalMatrix: bool -> unit
        abstract _updateDifferenceMatrix: ?rootMatrix: Matrix * ?updateChildren: bool -> unit
        /// Flag the bone as dirty (Forcing it to update everything)
        abstract markAsDirty: unit -> unit
        /// <summary>Copy an animation range from another bone</summary>
        /// <param name="source">defines the source bone</param>
        /// <param name="rangeName">defines the range name to copy</param>
        /// <param name="frameOffset">defines the frame offset</param>
        /// <param name="rescaleAsRequired">defines if rescaling must be applied if required</param>
        /// <param name="skelDimensionsRatio">defines the scaling ratio</param>
        abstract copyAnimationRange: source: Bone * rangeName: string * frameOffset: float * ?rescaleAsRequired: bool * ?skelDimensionsRatio: Vector3 -> bool
        /// <summary>Translate the bone in local or world space</summary>
        /// <param name="vec">The amount to translate the bone</param>
        /// <param name="space">The space that the translation is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract translate: vec: Vector3 * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the postion of the bone in local or world space</summary>
        /// <param name="position">The position to set the bone</param>
        /// <param name="space">The space that the position is in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract setPosition: position: Vector3 * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the absolute position of the bone (world space)</summary>
        /// <param name="position">The position to set the bone</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        abstract setAbsolutePosition: position: Vector3 * ?mesh: AbstractMesh -> unit
        /// <summary>Scale the bone on the x, y and z axes (in local space)</summary>
        /// <param name="x">The amount to scale the bone on the x axis</param>
        /// <param name="y">The amount to scale the bone on the y axis</param>
        /// <param name="z">The amount to scale the bone on the z axis</param>
        /// <param name="scaleChildren">sets this to true if children of the bone should be scaled as well (false by default)</param>
        abstract scale: x: float * y: float * z: float * ?scaleChildren: bool -> unit
        /// <summary>Set the bone scaling in local space</summary>
        /// <param name="scale">defines the scaling vector</param>
        abstract setScale: scale: Vector3 -> unit
        /// Gets the current scaling in local space
        abstract getScale: unit -> Vector3
        /// <summary>Gets the current scaling in local space and stores it in a target vector</summary>
        /// <param name="result">defines the target vector</param>
        abstract getScaleToRef: result: Vector3 -> unit
        /// <summary>Set the yaw, pitch, and roll of the bone in local or world space</summary>
        /// <param name="yaw">The rotation of the bone on the y axis</param>
        /// <param name="pitch">The rotation of the bone on the x axis</param>
        /// <param name="roll">The rotation of the bone on the z axis</param>
        /// <param name="space">The space that the axes of rotation are in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract setYawPitchRoll: yaw: float * pitch: float * roll: float * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Add a rotation to the bone on an axis in local or world space</summary>
        /// <param name="axis">The axis to rotate the bone on</param>
        /// <param name="amount">The amount to rotate the bone</param>
        /// <param name="space">The space that the axis is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract rotate: axis: Vector3 * amount: float * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the rotation of the bone to a particular axis angle in local or world space</summary>
        /// <param name="axis">The axis to rotate the bone on</param>
        /// <param name="angle">The angle that the bone should be rotated to</param>
        /// <param name="space">The space that the axis is in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract setAxisAngle: axis: Vector3 * angle: float * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the euler rotation of the bone in local of world space</summary>
        /// <param name="rotation">The euler rotation that the bone should be set to</param>
        /// <param name="space">The space that the rotation is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract setRotation: rotation: Vector3 * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the quaternion rotation of the bone in local of world space</summary>
        /// <param name="quat">The quaternion rotation that the bone should be set to</param>
        /// <param name="space">The space that the rotation is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract setRotationQuaternion: quat: Quaternion * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the rotation matrix of the bone in local of world space</summary>
        /// <param name="rotMat">The rotation matrix that the bone should be set to</param>
        /// <param name="space">The space that the rotation is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract setRotationMatrix: rotMat: Matrix * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Get the position of the bone in local or world space</summary>
        /// <param name="space">The space that the returned position is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract getPosition: ?space: Space * ?mesh: AbstractMesh -> Vector3
        /// <summary>Copy the position of the bone to a vector3 in local or world space</summary>
        /// <param name="space">The space that the returned position is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        /// <param name="result">The vector3 to copy the position to</param>
        abstract getPositionToRef: space: Space option * mesh: Nullable<AbstractMesh> * result: Vector3 -> unit
        /// <summary>Get the absolute position of the bone (world space)</summary>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        abstract getAbsolutePosition: ?mesh: AbstractMesh -> Vector3
        /// <summary>Copy the absolute position of the bone (world space) to the result param</summary>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        /// <param name="result">The vector3 to copy the absolute position to</param>
        abstract getAbsolutePositionToRef: mesh: AbstractMesh * result: Vector3 -> unit
        /// Compute the absolute transforms of this bone and its children
        abstract computeAbsoluteTransforms: unit -> unit
        /// <summary>Get the world direction from an axis that is in the local space of the bone</summary>
        /// <param name="localAxis">The local direction that is used to compute the world direction</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        abstract getDirection: localAxis: Vector3 * ?mesh: AbstractMesh -> Vector3
        /// <summary>Copy the world direction to a vector3 from an axis that is in the local space of the bone</summary>
        /// <param name="localAxis">The local direction that is used to compute the world direction</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        /// <param name="result">The vector3 that the world direction will be copied to</param>
        abstract getDirectionToRef: localAxis: Vector3 * mesh: AbstractMesh option * result: Vector3 -> unit
        /// <summary>Get the euler rotation of the bone in local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract getRotation: ?space: Space * ?mesh: AbstractMesh -> Vector3
        /// <summary>Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        /// <param name="result">The vector3 that the rotation should be copied to</param>
        abstract getRotationToRef: space: Space option * mesh: AbstractMesh option * result: Vector3 -> unit
        /// <summary>Get the quaternion rotation of the bone in either local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract getRotationQuaternion: ?space: Space * ?mesh: AbstractMesh -> Quaternion
        /// <summary>Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        /// <param name="result">The quaternion that the rotation should be copied to</param>
        abstract getRotationQuaternionToRef: space: Space option * mesh: AbstractMesh option * result: Quaternion -> unit
        /// <summary>Get the rotation matrix of the bone in local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract getRotationMatrix: space: Space option * mesh: AbstractMesh -> Matrix
        /// <summary>Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        /// <param name="result">The quaternion that the rotation should be copied to</param>
        abstract getRotationMatrixToRef: space: Space option * mesh: AbstractMesh * result: Matrix -> unit
        /// <summary>Get the world position of a point that is in the local space of the bone</summary>
        /// <param name="position">The local position</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        abstract getAbsolutePositionFromLocal: position: Vector3 * ?mesh: AbstractMesh -> Vector3
        /// <summary>Get the world position of a point that is in the local space of the bone and copy it to the result param</summary>
        /// <param name="position">The local position</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        /// <param name="result">The vector3 that the world position should be copied to</param>
        abstract getAbsolutePositionFromLocalToRef: position: Vector3 * mesh: AbstractMesh option * result: Vector3 -> unit
        /// <summary>Get the local position of a point that is in world space</summary>
        /// <param name="position">The world position</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        abstract getLocalPositionFromAbsolute: position: Vector3 * ?mesh: AbstractMesh -> Vector3
        /// <summary>Get the local position of a point that is in world space and copy it to the result param</summary>
        /// <param name="position">The world position</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        /// <param name="result">The vector3 that the local position should be copied to</param>
        abstract getLocalPositionFromAbsoluteToRef: position: Vector3 * mesh: AbstractMesh option * result: Vector3 -> unit

    /// Class used to store bone information
    type [<AllowNullLiteral>] BoneStatic =
        /// <summary>Create a new bone</summary>
        /// <param name="name">defines the bone name</param>
        /// <param name="skeleton">defines the parent skeleton</param>
        /// <param name="parentBone">defines the parent (can be null if the bone is the root)</param>
        /// <param name="localMatrix">defines the local matrix</param>
        /// <param name="restPose">defines the rest pose matrix</param>
        /// <param name="baseMatrix">defines the base matrix</param>
        /// <param name="index">defines index of the bone in the hiearchy</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * skeleton: Skeleton * ?parentBone: Bone * ?localMatrix: Matrix * ?restPose: Matrix * ?baseMatrix: Matrix * ?index: float -> Bone

    /// Class used to apply inverse kinematics to bones
    type [<AllowNullLiteral>] BoneIKController =
        /// Gets or sets the target mesh
        abstract targetMesh: AbstractMesh with get, set
        /// Gets or sets the mesh used as pole 
        abstract poleTargetMesh: AbstractMesh with get, set
        /// Gets or sets the bone used as pole
        abstract poleTargetBone: Nullable<Bone> with get, set
        /// Gets or sets the target position
        abstract targetPosition: Vector3 with get, set
        /// Gets or sets the pole target position
        abstract poleTargetPosition: Vector3 with get, set
        /// Gets or sets the pole target local offset
        abstract poleTargetLocalOffset: Vector3 with get, set
        /// Gets or sets the pole angle
        abstract poleAngle: float with get, set
        /// Gets or sets the mesh associated with the controller
        abstract mesh: AbstractMesh with get, set
        /// The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
        abstract slerpAmount: float with get, set
        /// Gets or sets maximum allowed angle
        abstract maxAngle: float with get, set
        /// Force the controller to update the bones
        abstract update: unit -> unit

    /// Class used to apply inverse kinematics to bones
    type [<AllowNullLiteral>] BoneIKControllerStatic =
        /// <summary>Creates a new BoneIKController</summary>
        /// <param name="mesh">defines the mesh to control</param>
        /// <param name="bone">defines the bone to control</param>
        /// <param name="options">defines options to set up the controller</param>
        [<Emit "new $0($1...)">] abstract Create: mesh: AbstractMesh * bone: Bone * ?options: BoneIKControllerStaticOptions -> BoneIKController

    type [<AllowNullLiteral>] BoneIKControllerStaticOptions =
        abstract targetMesh: AbstractMesh option with get, set
        abstract poleTargetMesh: AbstractMesh option with get, set
        abstract poleTargetBone: Bone option with get, set
        abstract poleTargetLocalOffset: Vector3 option with get, set
        abstract poleAngle: float option with get, set
        abstract bendAxis: Vector3 option with get, set
        abstract maxAngle: float option with get, set
        abstract slerpAmount: float option with get, set

    /// Class used to make a bone look toward a point in space
    type [<AllowNullLiteral>] BoneLookController =
        /// The target Vector3 that the bone will look at
        abstract target: Vector3 with get, set
        /// The mesh that the bone is attached to
        abstract mesh: AbstractMesh with get, set
        /// The bone that will be looking to the target
        abstract bone: Bone with get, set
        /// The up axis of the coordinate system that is used when the bone is rotated
        abstract upAxis: Vector3 with get, set
        /// The space that the up axis is in - BABYLON.Space.BONE, BABYLON.Space.LOCAL (default), or BABYLON.Space.WORLD
        abstract upAxisSpace: Space with get, set
        /// Used to make an adjustment to the yaw of the bone
        abstract adjustYaw: float with get, set
        /// Used to make an adjustment to the pitch of the bone
        abstract adjustPitch: float with get, set
        /// Used to make an adjustment to the roll of the bone
        abstract adjustRoll: float with get, set
        /// The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
        abstract slerpAmount: float with get, set
        /// Gets or sets the minimum yaw angle that the bone can look to
        abstract minYaw: float with get, set
        /// Gets or sets the maximum yaw angle that the bone can look to
        abstract maxYaw: float with get, set
        /// Gets or sets the minimum pitch angle that the bone can look to
        abstract minPitch: float with get, set
        /// Gets or sets the maximum pitch angle that the bone can look to
        abstract maxPitch: float with get, set
        /// Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())
        abstract update: unit -> unit

    /// Class used to make a bone look toward a point in space
    type [<AllowNullLiteral>] BoneLookControllerStatic =
        /// <summary>Create a BoneLookController</summary>
        /// <param name="mesh">the mesh that the bone belongs to</param>
        /// <param name="bone">the bone that will be looking to the target</param>
        /// <param name="target">the target Vector3 to look at</param>
        [<Emit "new $0($1...)">] abstract Create: mesh: AbstractMesh * bone: Bone * target: Vector3 * ?options: BoneLookControllerStaticOptions -> BoneLookController

    type [<AllowNullLiteral>] BoneLookControllerStaticOptions =
        abstract maxYaw: float option with get, set
        abstract minYaw: float option with get, set
        abstract maxPitch: float option with get, set
        abstract minPitch: float option with get, set
        abstract slerpAmount: float option with get, set
        abstract upAxis: Vector3 option with get, set
        abstract upAxisSpace: Space option with get, set
        abstract yawAxis: Vector3 option with get, set
        abstract pitchAxis: Vector3 option with get, set
        abstract adjustYaw: float option with get, set
        abstract adjustPitch: float option with get, set
        abstract adjustRoll: float option with get, set

    /// Class used to handle skinning animations
    type [<AllowNullLiteral>] Skeleton =
        inherit IAnimatable
        /// defines the skeleton name 
        abstract name: string with get, set
        /// defines the skeleton Id 
        abstract id: string with get, set
        /// Gets the list of child bones
        abstract bones: ResizeArray<Bone> with get, set
        /// Gets an estimate of the dimension of the skeleton at rest
        abstract dimensionsAtRest: Vector3 with get, set
        /// Gets a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)
        abstract needInitialSkinMatrix: bool with get, set
        /// Gets the list of animations attached to this skeleton
        abstract animations: Array<Animation> with get, set
        /// Specifies if the skeleton should be serialized
        abstract doNotSerialize: bool with get, set
        /// Gets or sets the animation properties override
        abstract animationPropertiesOverride: Nullable<AnimationPropertiesOverride> with get, set
        /// An observable triggered before computing the skeleton's matrices
        abstract onBeforeComputeObservable: Observable<Skeleton> with get, set
        /// <summary>Gets the list of transform matrices to send to shaders (one matrix per bone)</summary>
        /// <param name="mesh">defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)</param>
        abstract getTransformMatrices: mesh: AbstractMesh -> Float32Array
        /// Gets the current hosting scene
        abstract getScene: unit -> Scene
        /// <summary>Gets a string representing the current skeleton data</summary>
        /// <param name="fullDetails">defines a boolean indicating if we want a verbose version</param>
        abstract toString: ?fullDetails: bool -> string
        /// <summary>Get bone's index searching by name</summary>
        /// <param name="name">defines bone's name to search for</param>
        abstract getBoneIndexByName: name: string -> float
        /// <summary>Creater a new animation range</summary>
        /// <param name="name">defines the name of the range</param>
        /// <param name="from">defines the start key</param>
        /// <param name="to">defines the end key</param>
        abstract createAnimationRange: name: string * from: float * ``to``: float -> unit
        /// <summary>Delete a specific animation range</summary>
        /// <param name="name">defines the name of the range</param>
        /// <param name="deleteFrames">defines if frames must be removed as well</param>
        abstract deleteAnimationRange: name: string * ?deleteFrames: bool -> unit
        /// <summary>Gets a specific animation range</summary>
        /// <param name="name">defines the name of the range to look for</param>
        abstract getAnimationRange: name: string -> Nullable<AnimationRange>
        /// Gets the list of all animation ranges defined on this skeleton
        abstract getAnimationRanges: unit -> ResizeArray<Nullable<AnimationRange>>
        /// <summary>Copy animation range from a source skeleton.
        /// This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences</summary>
        /// <param name="source">defines the source skeleton</param>
        /// <param name="name">defines the name of the range to copy</param>
        /// <param name="rescaleAsRequired">defines if rescaling must be applied if required</param>
        abstract copyAnimationRange: source: Skeleton * name: string * ?rescaleAsRequired: bool -> bool
        /// Forces the skeleton to go to rest pose
        abstract returnToRest: unit -> unit
        /// <summary>Begin a specific animation range</summary>
        /// <param name="name">defines the name of the range to start</param>
        /// <param name="loop">defines if looping must be turned on (false by default)</param>
        /// <param name="speedRatio">defines the speed ratio to apply (1 by default)</param>
        /// <param name="onAnimationEnd">defines a callback which will be called when animation will end</param>
        abstract beginAnimation: name: string * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) -> Nullable<Animatable>
        abstract _markAsDirty: unit -> unit
        abstract _registerMeshWithPoseMatrix: mesh: AbstractMesh -> unit
        abstract _unregisterMeshWithPoseMatrix: mesh: AbstractMesh -> unit
        abstract _computeTransformMatrices: targetMatrix: Float32Array * initialSkinMatrix: Nullable<Matrix> -> unit
        /// Build all resources required to render a skeleton
        abstract prepare: unit -> unit
        /// Gets the list of animatables currently running for this skeleton
        abstract getAnimatables: unit -> ResizeArray<IAnimatable>
        /// <summary>Clone the current skeleton</summary>
        /// <param name="name">defines the name of the new skeleton</param>
        /// <param name="id">defines the id of the enw skeleton</param>
        abstract clone: name: string * id: string -> Skeleton
        /// <summary>Enable animation blending for this skeleton</summary>
        /// <param name="blendingSpeed">defines the blending speed to apply</param>
        abstract enableBlending: ?blendingSpeed: float -> unit
        /// Releases all resources associated with the current skeleton
        abstract dispose: unit -> unit
        /// Serialize the skeleton in a JSON object
        abstract serialize: unit -> obj option
        /// <summary>Compute all node absolute transforms</summary>
        /// <param name="forceUpdate">defines if computation must be done even if cache is up to date</param>
        abstract computeAbsoluteTransforms: ?forceUpdate: bool -> unit
        /// Gets the root pose matrix
        abstract getPoseMatrix: unit -> Nullable<Matrix>
        /// Sorts bones per internal index
        abstract sortBones: unit -> unit

    /// Class used to handle skinning animations
    type [<AllowNullLiteral>] SkeletonStatic =
        /// <summary>Creates a new skeleton</summary>
        /// <param name="name">defines the skeleton name</param>
        /// <param name="id">defines the skeleton Id</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * id: string * scene: Scene -> Skeleton
        /// <summary>Creates a new skeleton from serialized data</summary>
        /// <param name="parsedSkeleton">defines the serialized data</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract Parse: parsedSkeleton: obj option * scene: Scene -> Skeleton

    type [<AllowNullLiteral>] Collider =
        /// Define if a collision was found 
        abstract collisionFound: bool with get, set
        /// Define last intersection point in local space
        abstract intersectionPoint: Vector3 with get, set
        /// Define last collided mesh
        abstract collidedMesh: Nullable<AbstractMesh> with get, set
        abstract _radius: Vector3 with get, set
        abstract _retry: float with get, set
        abstract _velocityWorldLength: float with get, set
        abstract _basePointWorld: Vector3 with get, set
        abstract _initialVelocity: Vector3 with get, set
        abstract _initialPosition: Vector3 with get, set
        abstract collisionMask: float with get, set
        /// Gets the plane normal used to compute the sliding response (in local space)
        abstract slidePlaneNormal: Vector3
        abstract _initialize: source: Vector3 * dir: Vector3 * e: float -> unit
        abstract _checkPointInTriangle: point: Vector3 * pa: Vector3 * pb: Vector3 * pc: Vector3 * n: Vector3 -> bool
        abstract _canDoCollision: sphereCenter: Vector3 * sphereRadius: float * vecMin: Vector3 * vecMax: Vector3 -> bool
        abstract _testTriangle: faceIndex: float * trianglePlaneArray: Array<Plane> * p1: Vector3 * p2: Vector3 * p3: Vector3 * hasMaterial: bool -> unit
        abstract _collide: trianglePlaneArray: Array<Plane> * pts: ResizeArray<Vector3> * indices: IndicesArray * indexStart: float * indexEnd: float * decal: float * hasMaterial: bool -> unit
        abstract _getResponse: pos: Vector3 * vel: Vector3 -> unit

    type [<AllowNullLiteral>] ColliderStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Collider

    type [<AllowNullLiteral>] ICollisionCoordinator =
        abstract getNewPosition: position: Vector3 * displacement: Vector3 * collider: Collider * maximumRetry: float * excludedMesh: Nullable<AbstractMesh> * onNewPosition: (float -> Vector3 -> Nullable<AbstractMesh> -> unit) * collisionIndex: float -> unit
        abstract init: scene: Scene -> unit
        abstract destroy: unit -> unit
        abstract onMeshAdded: mesh: AbstractMesh -> unit
        abstract onMeshUpdated: mesh: AbstractMesh -> unit
        abstract onMeshRemoved: mesh: AbstractMesh -> unit
        abstract onGeometryAdded: geometry: Geometry -> unit
        abstract onGeometryUpdated: geometry: Geometry -> unit
        abstract onGeometryDeleted: geometry: Geometry -> unit

    type [<AllowNullLiteral>] SerializedMesh =
        abstract id: string with get, set
        abstract name: string with get, set
        abstract uniqueId: float with get, set
        abstract geometryId: Nullable<string> with get, set
        abstract sphereCenter: Array<float> with get, set
        abstract sphereRadius: float with get, set
        abstract boxMinimum: Array<float> with get, set
        abstract boxMaximum: Array<float> with get, set
        abstract worldMatrixFromCache: obj option with get, set
        abstract subMeshes: Array<SerializedSubMesh> with get, set
        abstract checkCollisions: bool with get, set

    type [<AllowNullLiteral>] SerializedSubMesh =
        abstract position: float with get, set
        abstract verticesStart: float with get, set
        abstract verticesCount: float with get, set
        abstract indexStart: float with get, set
        abstract indexCount: float with get, set
        abstract hasMaterial: bool with get, set
        abstract sphereCenter: Array<float> with get, set
        abstract sphereRadius: float with get, set
        abstract boxMinimum: Array<float> with get, set
        abstract boxMaximum: Array<float> with get, set

    /// Interface describing the value associated with a geometry.
    type [<AllowNullLiteral>] SerializedGeometry =
        /// Defines the unique ID of the geometry
        abstract id: string with get, set
        /// Defines the array containing the positions
        abstract positions: Float32Array with get, set
        /// Defines the array containing the indices
        abstract indices: Uint32Array with get, set
        /// Defines the array containing the normals
        abstract normals: Float32Array with get, set

    type [<AllowNullLiteral>] BabylonMessage =
        abstract taskType: WorkerTaskType with get, set
        abstract payload: U3<InitPayload, CollidePayload, UpdatePayload> with get, set

    type [<AllowNullLiteral>] SerializedColliderToWorker =
        abstract position: Array<float> with get, set
        abstract velocity: Array<float> with get, set
        abstract radius: Array<float> with get, set

    type [<RequireQualifiedAccess>] WorkerTaskType =
        | INIT = 0
        | UPDATE = 1
        | COLLIDE = 2

    type [<AllowNullLiteral>] WorkerReply =
        abstract error: WorkerReplyType with get, set
        abstract taskType: WorkerTaskType with get, set
        abstract payload: obj option with get, set

    type [<AllowNullLiteral>] CollisionReplyPayload =
        abstract newPosition: Array<float> with get, set
        abstract collisionId: float with get, set
        abstract collidedMeshUniqueId: float with get, set

    type [<AllowNullLiteral>] InitPayload =
        interface end

    type [<AllowNullLiteral>] CollidePayload =
        abstract collisionId: float with get, set
        abstract collider: SerializedColliderToWorker with get, set
        abstract maximumRetry: float with get, set
        abstract excludedMeshUniqueId: Nullable<float> with get, set

    type [<AllowNullLiteral>] UpdatePayload =
        abstract updatedMeshes: TypeLiteral_09 with get, set
        abstract updatedGeometries: TypeLiteral_10 with get, set
        abstract removedMeshes: Array<float> with get, set
        abstract removedGeometries: Array<string> with get, set

    type [<RequireQualifiedAccess>] WorkerReplyType =
        | SUCCESS = 0
        | UNKNOWN_ERROR = 1

    type [<AllowNullLiteral>] CollisionCoordinatorWorker =
        inherit ICollisionCoordinator
        abstract getNewPosition: position: Vector3 * displacement: Vector3 * collider: Collider * maximumRetry: float * excludedMesh: AbstractMesh * onNewPosition: (float -> Vector3 -> Nullable<AbstractMesh> -> unit) * collisionIndex: float -> unit
        abstract init: scene: Scene -> unit
        abstract destroy: unit -> unit
        abstract onMeshAdded: mesh: AbstractMesh -> unit
        abstract onMeshUpdated: (TransformNode -> unit) with get, set
        abstract onMeshRemoved: mesh: AbstractMesh -> unit
        abstract onGeometryAdded: geometry: Geometry -> unit
        abstract onGeometryUpdated: (Geometry -> unit) with get, set
        abstract onGeometryDeleted: geometry: Geometry -> unit

    type [<AllowNullLiteral>] CollisionCoordinatorWorkerStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CollisionCoordinatorWorker
        abstract SerializeMesh: (AbstractMesh -> SerializedMesh) with get, set
        abstract SerializeGeometry: (Geometry -> SerializedGeometry) with get, set

    type [<AllowNullLiteral>] CollisionCoordinatorLegacy =
        inherit ICollisionCoordinator
        abstract getNewPosition: position: Vector3 * displacement: Vector3 * collider: Collider * maximumRetry: float * excludedMesh: AbstractMesh * onNewPosition: (float -> Vector3 -> Nullable<AbstractMesh> -> unit) * collisionIndex: float -> unit
        abstract init: scene: Scene -> unit
        abstract destroy: unit -> unit
        abstract onMeshAdded: mesh: AbstractMesh -> unit
        abstract onMeshUpdated: mesh: AbstractMesh -> unit
        abstract onMeshRemoved: mesh: AbstractMesh -> unit
        abstract onGeometryAdded: geometry: Geometry -> unit
        abstract onGeometryUpdated: geometry: Geometry -> unit
        abstract onGeometryDeleted: geometry: Geometry -> unit

    type [<AllowNullLiteral>] CollisionCoordinatorLegacyStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CollisionCoordinatorLegacy

    type [<AllowNullLiteral>] CollisionCache =
        abstract getMeshes: unit -> CollisionCacheGetMeshesReturn
        abstract getGeometries: unit -> CollisionCacheGetGeometriesReturn
        abstract getMesh: id: obj option -> SerializedMesh
        abstract addMesh: mesh: SerializedMesh -> unit
        abstract removeMesh: uniqueId: float -> unit
        abstract getGeometry: id: string -> SerializedGeometry
        abstract addGeometry: geometry: SerializedGeometry -> unit
        abstract removeGeometry: id: string -> unit

    type [<AllowNullLiteral>] CollisionCacheGetMeshesReturn =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: n: float -> SerializedMesh with get, set

    type [<AllowNullLiteral>] CollisionCacheGetGeometriesReturn =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: s: float -> SerializedGeometry with get, set

    type [<AllowNullLiteral>] CollisionCacheStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CollisionCache

    type [<AllowNullLiteral>] CollideWorker =
        abstract collider: Collider with get, set
        abstract collideWithWorld: position: Vector3 * velocity: Vector3 * maximumRetry: float * excludedMeshUniqueId: Nullable<float> -> unit

    type [<AllowNullLiteral>] CollideWorkerStatic =
        [<Emit "new $0($1...)">] abstract Create: collider: Collider * _collisionCache: CollisionCache * finalPosition: Vector3 -> CollideWorker

    type [<AllowNullLiteral>] ICollisionDetector =
        abstract onInit: payload: InitPayload -> unit
        abstract onUpdate: payload: UpdatePayload -> unit
        abstract onCollision: payload: CollidePayload -> unit

    type [<AllowNullLiteral>] CollisionDetectorTransferable =
        inherit ICollisionDetector
        abstract onInit: payload: InitPayload -> unit
        abstract onUpdate: payload: UpdatePayload -> unit
        abstract onCollision: payload: CollidePayload -> unit

    type [<AllowNullLiteral>] CollisionDetectorTransferableStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CollisionDetectorTransferable

    type [<AllowNullLiteral>] IntersectionInfo =
        abstract bu: Nullable<float> with get, set
        abstract bv: Nullable<float> with get, set
        abstract distance: float with get, set
        abstract faceId: float with get, set
        abstract subMeshId: float with get, set

    type [<AllowNullLiteral>] IntersectionInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: bu: Nullable<float> * bv: Nullable<float> * distance: float -> IntersectionInfo

    /// Information about the result of picking within a scene
    type [<AllowNullLiteral>] PickingInfo =
        /// If the pick collided with an object
        abstract hit: bool with get, set
        /// Distance away where the pick collided
        abstract distance: float with get, set
        /// The location of pick collision
        abstract pickedPoint: Nullable<Vector3> with get, set
        /// The mesh corresponding the the pick collision
        abstract pickedMesh: Nullable<AbstractMesh> with get, set
        /// (See getTextureCoordinates) The barycentric U coordinate that is used when calulating the texture coordinates of the collision.
        abstract bu: float with get, set
        /// (See getTextureCoordinates) The barycentric V coordinate that is used when calulating the texture coordinates of the collision.
        abstract bv: float with get, set
        /// The id of the face on the mesh that was picked  
        abstract faceId: float with get, set
        /// Id of the the submesh that was picked 
        abstract subMeshId: float with get, set
        /// If a sprite was picked, this will be the sprite the pick collided with 
        abstract pickedSprite: Nullable<Sprite> with get, set
        /// If a mesh was used to do the picking (eg. 6dof controller) this will be populated.
        abstract originMesh: Nullable<AbstractMesh> with get, set
        /// The ray that was used to perform the picking.
        abstract ray: Nullable<Ray> with get, set
        /// <summary>Gets the normal correspodning to the face the pick collided with</summary>
        /// <param name="useWorldCoordinates">If the resulting normal should be relative to the world (default: false)</param>
        /// <param name="useVerticesNormals">If the vertices normals should be used to calculate the normal instead of the normal map</param>
        abstract getNormal: ?useWorldCoordinates: bool * ?useVerticesNormals: bool -> Nullable<Vector3>
        /// Gets the texture coordinates of where the pick occured
        abstract getTextureCoordinates: unit -> Nullable<Vector2>

    /// Information about the result of picking within a scene
    type [<AllowNullLiteral>] PickingInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PickingInfo

    /// This represents an orbital type of camera.
    /// 
    /// This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.
    /// Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.
    type [<AllowNullLiteral>] ArcRotateCamera =
        inherit TargetCamera
        /// Defines the rotation angle of the camera along the longitudinal axis.
        abstract alpha: float with get, set
        /// Defines the rotation angle of the camera along the latitudinal axis.
        abstract beta: float with get, set
        /// Defines the radius of the camera from it s target point.
        abstract radius: float with get, set
        abstract _target: Vector3 with get, set
        abstract _targetHost: Nullable<AbstractMesh> with get, set
        /// Defines the target point of the camera.
        /// The camera looks towards it form the radius distance.
        abstract target: Vector3 with get, set
        /// Current inertia value on the longitudinal axis.
        /// The bigger this number the longer it will take for the camera to stop.
        abstract inertialAlphaOffset: float with get, set
        /// Current inertia value on the latitudinal axis.
        /// The bigger this number the longer it will take for the camera to stop.
        abstract inertialBetaOffset: float with get, set
        /// Current inertia value on the radius axis.
        /// The bigger this number the longer it will take for the camera to stop.
        abstract inertialRadiusOffset: float with get, set
        /// Minimum allowed angle on the longitudinal axis.
        /// This can help limiting how the Camera is able to move in the scene.
        abstract lowerAlphaLimit: Nullable<float> with get, set
        /// Maximum allowed angle on the longitudinal axis.
        /// This can help limiting how the Camera is able to move in the scene.
        abstract upperAlphaLimit: Nullable<float> with get, set
        /// Minimum allowed angle on the latitudinal axis.
        /// This can help limiting how the Camera is able to move in the scene.
        abstract lowerBetaLimit: float with get, set
        /// Maximum allowed angle on the latitudinal axis.
        /// This can help limiting how the Camera is able to move in the scene.
        abstract upperBetaLimit: float with get, set
        /// Minimum allowed distance of the camera to the target (The camera can not get closer).
        /// This can help limiting how the Camera is able to move in the scene.
        abstract lowerRadiusLimit: Nullable<float> with get, set
        /// Maximum allowed distance of the camera to the target (The camera can not get further).
        /// This can help limiting how the Camera is able to move in the scene.
        abstract upperRadiusLimit: Nullable<float> with get, set
        /// Defines the current inertia value used during panning of the camera along the X axis.
        abstract inertialPanningX: float with get, set
        /// Defines the current inertia value used during panning of the camera along the Y axis.
        abstract inertialPanningY: float with get, set
        /// Defines the distance used to consider the camera in pan mode vs pinch/zoom.
        /// Basically if your fingers moves away from more than this distance you will be considered
        /// in pinch mode.
        abstract pinchToPanMaxDistance: float with get, set
        /// Defines the maximum distance the camera can pan.
        /// This could help keeping the cammera always in your scene.
        abstract panningDistanceLimit: Nullable<float> with get, set
        /// Defines the target of the camera before paning.
        abstract panningOriginTarget: Vector3 with get, set
        /// Defines the value of the inertia used during panning.
        /// 0 would mean stop inertia and one would mean no decelleration at all.
        abstract panningInertia: float with get, set
        /// Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.
        abstract angularSensibilityX: float with get, set
        /// Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.
        abstract angularSensibilityY: float with get, set
        /// Gets or Set the pointer pinch precision or how fast is the camera zooming.
        abstract pinchPrecision: float with get, set
        /// Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.
        /// It will be used instead of pinchDeltaPrecision if different from 0.
        /// It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
        abstract pinchDeltaPercentage: float with get, set
        /// Gets or Set the pointer panning sensibility or how fast is the camera moving.
        abstract panningSensibility: float with get, set
        /// Gets or Set the list of keyboard keys used to control beta angle in a positive direction.
        abstract keysUp: ResizeArray<float> with get, set
        /// Gets or Set the list of keyboard keys used to control beta angle in a negative direction.
        abstract keysDown: ResizeArray<float> with get, set
        /// Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.
        abstract keysLeft: ResizeArray<float> with get, set
        /// Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.
        abstract keysRight: ResizeArray<float> with get, set
        /// Gets or Set the mouse wheel precision or how fast is the camera zooming.
        abstract wheelPrecision: float with get, set
        /// Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.
        /// It will be used instead of pinchDeltaPrecision if different from 0.
        /// It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
        abstract wheelDeltaPercentage: float with get, set
        /// Defines how much the radius should be scaled while zomming on a particular mesh (through the zoomOn function)
        abstract zoomOnFactor: float with get, set
        /// Defines a screen offset for the camera position.
        abstract targetScreenOffset: Vector2 with get, set
        /// Allows the camera to be completely reversed.
        /// If false the camera can not arrive upside down.
        abstract allowUpsideDown: bool with get, set
        /// Define if double tap/click is used to restore the previously saved state of the camera.
        abstract useInputToRestoreState: bool with get, set
        abstract _viewMatrix: Matrix with get, set
        abstract _useCtrlForPanning: bool with get, set
        abstract _panningMouseButton: float with get, set
        /// Defines the inpute associated to the camera.
        abstract inputs: ArcRotateCameraInputsManager with get, set
        abstract _reset: (unit -> unit) with get, set
        /// Defines the allowed panning axis.
        abstract panningAxis: Vector3 with get, set
        abstract _localDirection: Vector3 with get, set
        abstract _transformedDirection: Vector3 with get, set
        /// Gets the bouncing behavior of the camera if it has been enabled.
        abstract bouncingBehavior: Nullable<BouncingBehavior>
        /// Defines if the bouncing behavior of the camera is enabled on the camera.
        abstract useBouncingBehavior: bool with get, set
        /// Gets the framing behavior of the camera if it has been enabled.
        abstract framingBehavior: Nullable<FramingBehavior>
        /// Defines if the framing behavior of the camera is enabled on the camera.
        abstract useFramingBehavior: bool with get, set
        /// Gets the auto rotation behavior of the camera if it has been enabled.
        abstract autoRotationBehavior: Nullable<AutoRotationBehavior>
        /// Defines if the auto rotation behavior of the camera is enabled on the camera.
        abstract useAutoRotationBehavior: bool with get, set
        /// Observable triggered when the mesh target has been changed on the camera.
        abstract onMeshTargetChangedObservable: Observable<Nullable<AbstractMesh>> with get, set
        /// Event raised when the camera is colliding with a mesh.
        abstract onCollide: (AbstractMesh -> unit) with get, set
        /// Defines whether the camera should check collision with the objects oh the scene.
        abstract checkCollisions: bool with get, set
        /// Defines the collision radius of the camera.
        /// This simulates a sphere around the camera.
        abstract collisionRadius: Vector3 with get, set
        abstract _collider: Collider with get, set
        abstract _previousPosition: Vector3 with get, set
        abstract _collisionVelocity: Vector3 with get, set
        abstract _newPosition: Vector3 with get, set
        abstract _previousAlpha: float with get, set
        abstract _previousBeta: float with get, set
        abstract _previousRadius: float with get, set
        abstract _collisionTriggered: bool with get, set
        abstract _targetBoundingCenter: Nullable<Vector3> with get, set
        abstract _initCache: unit -> unit
        abstract _updateCache: ?ignoreParentClass: bool -> unit
        abstract _getTargetPosition: unit -> Vector3
        /// Stores the current state of the camera (alpha, beta, radius and target)
        abstract storeState: unit -> Camera
        abstract _restoreStateValues: unit -> bool
        abstract _isSynchronizedViewMatrix: unit -> bool
        /// <summary>Attached controls to the current camera.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        /// <param name="useCtrlForPanning">Defines whether ctrl is used for paning within the controls</param>
        /// <param name="panningMouseButton">Defines whether panning is allowed through mouse click button</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool * ?useCtrlForPanning: bool * ?panningMouseButton: float -> unit
        /// <summary>Detach the current controls from the camera.
        /// The camera will stop reacting to inputs.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: HTMLElement -> unit
        abstract _checkInputs: unit -> unit
        abstract _checkLimits: unit -> unit
        /// Rebuilds angles (alpha, beta) and radius from the give position and target.
        abstract rebuildAnglesAndRadius: unit -> unit
        /// <summary>Use a position to define the current camera related information like aplha, beta and radius</summary>
        /// <param name="position">Defines the position to set the camera at</param>
        abstract setPosition: position: Vector3 -> unit
        /// <summary>Defines the target the camera should look at.
        /// This will automatically adapt alpha beta and radius to fit within the new target.</summary>
        /// <param name="target">Defines the new target as a Vector or a mesh</param>
        /// <param name="toBoundingCenter">In case of a mesh target, defines wether to target the mesh position or its bounding information center</param>
        /// <param name="allowSamePosition">If false, prevents reapplying the new computed position if it is identical to the current one (optim)</param>
        abstract setTarget: target: U2<AbstractMesh, Vector3> * ?toBoundingCenter: bool * ?allowSamePosition: bool -> unit
        abstract _getViewMatrix: unit -> Matrix
        abstract _onCollisionPositionChange: (float -> Vector3 -> AbstractMesh -> unit) with get, set
        /// <summary>Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.</summary>
        /// <param name="meshes">Defines the mesh to zoom on</param>
        /// <param name="doNotUpdateMaxZ">Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)</param>
        abstract zoomOn: ?meshes: ResizeArray<AbstractMesh> * ?doNotUpdateMaxZ: bool -> unit
        /// <summary>Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.
        /// The target will be changed but the radius</summary>
        /// <param name="meshesOrMinMaxVectorAndDistance">Defines the mesh or bounding info to focus on</param>
        /// <param name="doNotUpdateMaxZ">Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)</param>
        abstract focusOn: meshesOrMinMaxVectorAndDistance: U2<ResizeArray<AbstractMesh>, TypeLiteral_11> * ?doNotUpdateMaxZ: bool -> unit
        abstract createRigCamera: name: string * cameraIndex: float -> Camera
        abstract _updateRigCameras: unit -> unit
        /// Destroy the camera and release the current resources hold by it.
        abstract dispose: unit -> unit
        /// Gets the current object class name.
        abstract getClassName: unit -> string

    /// This represents an orbital type of camera.
    /// 
    /// This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.
    /// Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.
    type [<AllowNullLiteral>] ArcRotateCameraStatic =
        /// <summary>Instantiates a new ArcRotateCamera in a given scene</summary>
        /// <param name="name">Defines the name of the camera</param>
        /// <param name="alpha">Defines the camera rotation along the logitudinal axis</param>
        /// <param name="beta">Defines the camera rotation along the latitudinal axis</param>
        /// <param name="radius">Defines the camera distance from its target</param>
        /// <param name="target">Defines the camera target</param>
        /// <param name="scene">Defines the scene the camera belongs to</param>
        /// <param name="setActiveOnSceneIfNoneActive">Defines wheter the camera should be marked as active if not other active cameras have been defined</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * alpha: float * beta: float * radius: float * target: Vector3 * scene: Scene * ?setActiveOnSceneIfNoneActive: bool -> ArcRotateCamera

    /// Default Inputs manager for the ArcRotateCamera.
    /// It groups all the default supported inputs for ease of use.
    /// Interface representing an arc rotate camera inputs manager
    type [<AllowNullLiteral>] ArcRotateCameraInputsManager =
        inherit CameraInputsManager<ArcRotateCamera>
        /// Add mouse wheel input support to the input manager.
        abstract addMouseWheel: unit -> ArcRotateCameraInputsManager
        /// Add pointers input support to the input manager.
        abstract addPointers: unit -> ArcRotateCameraInputsManager
        /// Add keyboard input support to the input manager.
        abstract addKeyboard: unit -> ArcRotateCameraInputsManager
        /// Add orientation input support to the input manager.
        abstract addVRDeviceOrientation: unit -> ArcRotateCameraInputsManager
        /// Adds gamepad input support to the ArcRotateCamera InputManager.
        abstract addGamepad: unit -> ArcRotateCameraInputsManager

    /// Default Inputs manager for the ArcRotateCamera.
    /// It groups all the default supported inputs for ease of use.
    /// Interface representing an arc rotate camera inputs manager
    type [<AllowNullLiteral>] ArcRotateCameraInputsManagerStatic =
        /// <summary>Instantiates a new ArcRotateCameraInputsManager.</summary>
        /// <param name="camera">Defines the camera the inputs belong to</param>
        [<Emit "new $0($1...)">] abstract Create: camera: ArcRotateCamera -> ArcRotateCameraInputsManager

    /// This is the base class of all the camera used in the application.
    type [<AllowNullLiteral>] Camera =
        inherit Node
        /// Define the input manager associated with the camera.
        abstract inputs: CameraInputsManager<Camera> with get, set
        /// Define the current local position of the camera in the scene
        abstract position: Vector3 with get, set
        /// The vector the camera should consider as up.
        /// (default is Vector3(0, 1, 0) aka Vector3.Up())
        abstract upVector: Vector3 with get, set
        /// Define the current limit on the left side for an orthographic camera
        /// In scene unit
        abstract orthoLeft: Nullable<float> with get, set
        /// Define the current limit on the right side for an orthographic camera
        /// In scene unit
        abstract orthoRight: Nullable<float> with get, set
        /// Define the current limit on the bottom side for an orthographic camera
        /// In scene unit
        abstract orthoBottom: Nullable<float> with get, set
        /// Define the current limit on the top side for an orthographic camera
        /// In scene unit
        abstract orthoTop: Nullable<float> with get, set
        /// Field Of View is set in Radians. (default is 0.8)
        abstract fov: float with get, set
        /// Define the minimum distance the camera can see from.
        /// This is important to note that the depth buffer are not infinite and the closer it starts
        /// the more your scene might encounter depth fighting issue.
        abstract minZ: float with get, set
        /// Define the maximum distance the camera can see to.
        /// This is important to note that the depth buffer are not infinite and the further it end
        /// the more your scene might encounter depth fighting issue.
        abstract maxZ: float with get, set
        /// Define the default inertia of the camera.
        /// This helps giving a smooth feeling to the camera movement.
        abstract inertia: float with get, set
        /// Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.PERSPECTIVE_ORTHOGRAPHIC)
        abstract mode: float with get, set
        /// Define wether the camera is intermediate.
        /// This is usefull to not present the output directly to the screen in case of rig without post process for instance
        abstract isIntermediate: bool with get, set
        /// Define the viewport of the camera.
        /// This correspond to the portion of the screen the camera will render to in normalized 0 to 1 unit.
        abstract viewport: Viewport with get, set
        /// Restricts the camera to viewing objects with the same layerMask.
        /// A camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0
        abstract layerMask: float with get, set
        /// fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)
        abstract fovMode: float with get, set
        /// Rig mode of the camera.
        /// This is usefull to create the camera with two "eyes" instead of one to create VR or stereoscopic scenes.
        /// This is normally controlled byt the camera themselves as internal use.
        abstract cameraRigMode: float with get, set
        /// Defines the distance between both "eyes" in case of a RIG
        abstract interaxialDistance: float with get, set
        /// Defines if stereoscopic rendering is done side by side or over under.
        abstract isStereoscopicSideBySide: bool with get, set
        /// Defines the list of custom render target the camera should render to.
        /// This is pretty helpfull if you wish to make a camera render to a texture you could reuse somewhere
        /// else in the scene.
        abstract customRenderTargets: ResizeArray<RenderTargetTexture> with get, set
        /// Observable triggered when the camera view matrix has changed.
        abstract onViewMatrixChangedObservable: Observable<Camera> with get, set
        /// Observable triggered when the camera Projection matrix has changed.
        abstract onProjectionMatrixChangedObservable: Observable<Camera> with get, set
        /// Observable triggered when the inputs have been processed.
        abstract onAfterCheckInputsObservable: Observable<Camera> with get, set
        /// Observable triggered when reset has been called and applied to the camera.
        abstract onRestoreStateObservable: Observable<Camera> with get, set
        abstract _cameraRigParams: obj option with get, set
        abstract _rigCameras: ResizeArray<Camera> with get, set
        abstract _rigPostProcess: Nullable<PostProcess> with get, set
        abstract _webvrViewMatrix: Matrix with get, set
        abstract _skipRendering: bool with get, set
        abstract _alternateCamera: Camera with get, set
        abstract _projectionMatrix: Matrix with get, set
        abstract _postProcesses: ResizeArray<Nullable<PostProcess>> with get, set
        abstract _activeMeshes: SmartArray<AbstractMesh> with get, set
        abstract _globalPosition: Vector3 with get, set
        /// Store current camera state (fov, position, etc..)
        abstract storeState: unit -> Camera
        /// Restores the camera state values if it has been stored. You must call storeState() first
        abstract _restoreStateValues: unit -> bool
        /// Restored camera state. You must call storeState() first.
        abstract restoreState: unit -> bool
        /// Gets the class name of the camera.
        abstract getClassName: unit -> string
        /// <summary>Gets a string representation of the camera usefull for debug purpose.</summary>
        /// <param name="fullDetails">Defines that a more verboe level of logging is required</param>
        abstract toString: ?fullDetails: bool -> string
        /// Gets the current world space position of the camera.
        abstract globalPosition: Vector3
        /// Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)
        abstract getActiveMeshes: unit -> SmartArray<AbstractMesh>
        /// <summary>Check wether a mesh is part of the current active mesh list of the camera</summary>
        /// <param name="mesh">Defines the mesh to check</param>
        abstract isActiveMesh: mesh: Mesh -> bool
        /// <summary>Is this camera ready to be used/rendered</summary>
        /// <param name="completeCheck">defines if a complete check (including post processes) has to be done (false by default)</param>
        abstract isReady: ?completeCheck: bool -> bool
        abstract _initCache: unit -> unit
        abstract _updateCache: ?ignoreParentClass: bool -> unit
        abstract _isSynchronized: unit -> bool
        abstract _isSynchronizedViewMatrix: unit -> bool
        abstract _isSynchronizedProjectionMatrix: unit -> bool
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: HTMLElement -> unit
        /// Update the camera state according to the different inputs gathered during the frame.
        abstract update: unit -> unit
        abstract _checkInputs: unit -> unit
        abstract rigCameras: ResizeArray<Camera>
        /// Gets the post process used by the rig cameras
        abstract rigPostProcess: Nullable<PostProcess>
        /// Internal, gets the first post proces.
        abstract _getFirstPostProcess: unit -> Nullable<PostProcess>
        /// <summary>Attach a post process to the camera.</summary>
        /// <param name="postProcess">The post process to attach to the camera</param>
        /// <param name="insertAt">The position of the post process in case several of them are in use in the scene</param>
        abstract attachPostProcess: postProcess: PostProcess * ?insertAt: float -> float
        /// <summary>Detach a post process to the camera.</summary>
        /// <param name="postProcess">The post process to detach from the camera</param>
        abstract detachPostProcess: postProcess: PostProcess -> unit
        /// Gets the current world matrix of the camera
        abstract getWorldMatrix: unit -> Matrix
        abstract _getViewMatrix: unit -> Matrix
        /// <summary>Gets the current view matrix of the camera.</summary>
        /// <param name="force">forces the camera to recompute the matrix without looking at the cached state</param>
        abstract getViewMatrix: ?force: bool -> Matrix
        /// <summary>Freeze the projection matrix.
        /// It will prevent the cache check of the camera projection compute and can speed up perf
        /// if no parameter of the camera are meant to change</summary>
        /// <param name="projection">Defines manually a projection if necessary</param>
        abstract freezeProjectionMatrix: ?projection: Matrix -> unit
        /// Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.
        abstract unfreezeProjectionMatrix: unit -> unit
        /// <summary>Gets the current projection matrix of the camera.</summary>
        /// <param name="force">forces the camera to recompute the matrix without looking at the cached state</param>
        abstract getProjectionMatrix: ?force: bool -> Matrix
        /// Gets the transformation matrix (ie. the multiplication of view by projection matrices)
        abstract getTransformationMatrix: unit -> Matrix
        /// <summary>Checks if a cullable object (mesh...) is in the camera frustum
        /// This checks the bounding box center. See isCompletelyInFrustum for a full bounding check</summary>
        /// <param name="target">The object to check</param>
        abstract isInFrustum: target: ICullable -> bool
        /// <summary>Checks if a cullable object (mesh...) is in the camera frustum
        /// Unlike isInFrustum this cheks the full bounding box</summary>
        /// <param name="target">The object to check</param>
        abstract isCompletelyInFrustum: target: ICullable -> bool
        /// <summary>Gets a ray in the forward direction from the camera.</summary>
        /// <param name="length">Defines the length of the ray to create</param>
        /// <param name="transform">Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray</param>
        /// <param name="origin">Defines the start point of the ray which defaults to the camera position</param>
        abstract getForwardRay: ?length: float * ?transform: Matrix * ?origin: Vector3 -> Ray
        /// <summary>Releases resources associated with this node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit
        /// Gets the left camera of a rig setup in case of Rigged Camera
        abstract leftCamera: Nullable<FreeCamera>
        /// Gets the right camera of a rig setup in case of Rigged Camera
        abstract rightCamera: Nullable<FreeCamera>
        /// Gets the left camera target of a rig setup in case of Rigged Camera
        abstract getLeftTarget: unit -> Nullable<Vector3>
        /// Gets the right camera target of a rig setup in case of Rigged Camera
        abstract getRightTarget: unit -> Nullable<Vector3>
        abstract setCameraRigMode: mode: float * rigParams: obj option -> unit
        abstract _updateCameraRotationMatrix: unit -> unit
        abstract _updateWebVRCameraRotationMatrix: unit -> unit
        /// This function MUST be overwritten by the different WebVR cameras available.
        /// The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.
        abstract _getWebVRProjectionMatrix: unit -> Matrix
        /// This function MUST be overwritten by the different WebVR cameras available.
        /// The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.
        abstract _getWebVRViewMatrix: unit -> Matrix
        abstract setCameraRigParameter: name: string * value: obj option -> unit
        /// needs to be overridden by children so sub has required properties to be copied
        abstract createRigCamera: name: string * cameraIndex: float -> Nullable<Camera>
        /// May need to be overridden by children
        abstract _updateRigCameras: unit -> unit
        abstract _setupInputs: unit -> unit
        /// Serialiaze the camera setup to a json represention
        abstract serialize: unit -> obj option
        /// <summary>Clones the current camera.</summary>
        /// <param name="name">The cloned camera name</param>
        abstract clone: name: string -> Camera
        /// <summary>Gets the direction of the camera relative to a given local axis.</summary>
        /// <param name="localAxis">Defines the reference axis to provide a relative direction.</param>
        abstract getDirection: localAxis: Vector3 -> Vector3
        /// <summary>Gets the direction of the camera relative to a given local axis into a passed vector.</summary>
        /// <param name="localAxis">Defines the reference axis to provide a relative direction.</param>
        /// <param name="result">Defines the vector to store the result in</param>
        abstract getDirectionToRef: localAxis: Vector3 * result: Vector3 -> unit
        /// Compute the world  matrix of the camera.
        abstract computeWorldMatrix: unit -> Matrix

    /// This is the base class of all the camera used in the application.
    type [<AllowNullLiteral>] CameraStatic =
        /// This is the default projection mode used by the cameras.
        /// It helps recreating a feeling of perspective and better appreciate depth.
        /// This is the best way to simulate real life cameras.
        abstract PERSPECTIVE_CAMERA: float
        /// This helps creating camera with an orthographic mode.
        /// Orthographic is commonly used in engineering as a means to produce object specifications that communicate dimensions unambiguously, each line of 1 unit length (cm, meter..whatever) will appear to have the same length everywhere on the drawing. This allows the drafter to dimension only a subset of lines and let the reader know that other lines of that length on the drawing are also that length in reality. Every parallel line in the drawing is also parallel in the object.
        abstract ORTHOGRAPHIC_CAMERA: float
        /// This is the default FOV mode for perspective cameras.
        /// This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.
        abstract FOVMODE_VERTICAL_FIXED: float
        /// This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.
        abstract FOVMODE_HORIZONTAL_FIXED: float
        /// This specifies ther is no need for a camera rig.
        /// Basically only one eye is rendered corresponding to the camera.
        abstract RIG_MODE_NONE: float
        /// Simulates a camera Rig with one blue eye and one red eye.
        /// This can be use with 3d blue and red glasses.
        abstract RIG_MODE_STEREOSCOPIC_ANAGLYPH: float
        /// Defines that both eyes of the camera will be rendered side by side with a parallel target.
        abstract RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL: float
        /// Defines that both eyes of the camera will be rendered side by side with a none parallel target.
        abstract RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED: float
        /// Defines that both eyes of the camera will be rendered over under each other.
        abstract RIG_MODE_STEREOSCOPIC_OVERUNDER: float
        /// Defines that both eyes of the camera should be renderered in a VR mode (carbox).
        abstract RIG_MODE_VR: float
        /// Defines that both eyes of the camera should be renderered in a VR mode (webVR).
        abstract RIG_MODE_WEBVR: float
        /// Defines if by default attaching controls should prevent the default javascript event to continue.
        abstract ForceAttachControlToAlwaysPreventDefault: bool with get, set
        abstract UseAlternateWebVRRendering: bool with get, set
        /// <summary>Instantiates a new camera object.
        /// This should not be used directly but through the inherited cameras: ArcRotate, Free...</summary>
        /// <param name="name">Defines the name of the camera in the scene</param>
        /// <param name="position">Defines the position of the camera</param>
        /// <param name="scene">Defines the scene the camera belongs too</param>
        /// <param name="setActiveOnSceneIfNoneActive">Defines if the camera should be set as active after creation if no other camera have been defined in the scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?setActiveOnSceneIfNoneActive: bool -> Camera
        /// <summary>Gets a camera constructor for a given camera type</summary>
        /// <param name="type">The type of the camera to construct (should be equal to one of the camera class name)</param>
        /// <param name="name">The name of the camera the result will be able to instantiate</param>
        /// <param name="scene">The scene the result will construct the camera in</param>
        /// <param name="interaxial_distance">In case of stereoscopic setup, the distance between both eyes</param>
        /// <param name="isStereoscopicSideBySide">In case of stereoscopic setup, should the sereo be side b side</param>
        abstract GetConstructorFromName: ``type``: string * name: string * scene: Scene * ?interaxial_distance: float * ?isStereoscopicSideBySide: bool -> (unit -> Camera)
        /// <summary>Parse a JSON and creates the camera from the parsed information</summary>
        /// <param name="parsedCamera">The JSON to parse</param>
        /// <param name="scene">The scene to instantiate the camera in</param>
        abstract Parse: parsedCamera: obj option * scene: Scene -> Camera

    /// This is the contract to implement in order to create a new input class.
    /// Inputs are dealing with listening to user actions and moving the camera accordingly.
    type [<AllowNullLiteral>] ICameraInput<'TCamera> =
        /// Defines the camera the input is attached to.
        abstract camera: Nullable<'TCamera> with get, set
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Update the current camera state depending on the inputs that have been used this frame.
        /// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
        abstract checkInputs: (unit -> unit) option with get, set

    /// Represents a map of input types to input instance or input index to input instance.
    type [<AllowNullLiteral>] CameraInputsMap<'TCamera> =
        /// Accessor to the input by input type.
        [<Emit "$0[$1]{{=$2}}">] abstract Item: name: string -> ICameraInput<'TCamera> with get, set
        /// Accessor to the input by input index.
        [<Emit "$0[$1]{{=$2}}">] abstract Item: idx: float -> ICameraInput<'TCamera> with get, set

    /// This represents the input manager used within a camera.
    /// It helps dealing with all the different kind of input attached to a camera.
    type [<AllowNullLiteral>] CameraInputsManager<'TCamera> =
        /// Defines the list of inputs attahed to the camera.
        abstract attached: CameraInputsMap<'TCamera> with get, set
        /// Defines the dom element the camera is collecting inputs from.
        /// This is null if the controls have not been attached.
        abstract attachedElement: Nullable<HTMLElement> with get, set
        /// Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
        abstract noPreventDefault: bool with get, set
        /// Defined the camera the input manager belongs to.
        abstract camera: 'TCamera with get, set
        /// Update the current camera state depending on the inputs that have been used this frame.
        /// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
        abstract checkInputs: (unit -> unit) with get, set
        /// <summary>Add an input method to a camera</summary>
        /// <param name="input">camera input method</param>
        abstract add: input: ICameraInput<'TCamera> -> unit
        /// <summary>Remove a specific input method from a camera
        /// example: camera.inputs.remove(camera.inputs.attached.mouse);</summary>
        /// <param name="inputToRemove">camera input method</param>
        abstract remove: inputToRemove: ICameraInput<'TCamera> -> unit
        /// <summary>Remove a specific input type from a camera
        /// example: camera.inputs.remove("ArcRotateCameraGamepadInput");</summary>
        /// <param name="inputType">the type of the input to remove</param>
        abstract removeByType: inputType: string -> unit
        /// <summary>Attach the input controls to the currently attached dom element to listen the events from.</summary>
        /// <param name="input">Defines the input to attach</param>
        abstract attachInput: input: ICameraInput<'TCamera> -> unit
        /// <summary>Attach the current manager inputs controls to a specific dom element to listen the events from.</summary>
        /// <param name="element">Defines the dom element to collect the events from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachElement: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current manager inputs controls from a specific dom element.</summary>
        /// <param name="element">Defines the dom element to collect the events from</param>
        /// <param name="disconnect">Defines whether the input should be removed from the current list of attached inputs</param>
        abstract detachElement: element: HTMLElement * ?disconnect: bool -> unit
        /// Rebuild the dynamic inputCheck function from the current list of
        /// defined inputs in the manager.
        abstract rebuildInputCheck: unit -> unit
        /// Remove all attached input methods from a camera
        abstract clear: unit -> unit
        /// <summary>Serialize the current input manager attached to a camera.
        /// This ensures than once parsed,
        /// the input associated to the camera will be identical to the current ones</summary>
        /// <param name="serializedCamera">Defines the camera serialization JSON the input serialization should write to</param>
        abstract serialize: serializedCamera: obj option -> unit
        /// <summary>Parses an input manager serialized JSON to restore the previous list of inputs
        /// and states associated to a camera.</summary>
        /// <param name="parsedCamera">Defines the JSON to parse</param>
        abstract parse: parsedCamera: obj option -> unit

    /// This represents the input manager used within a camera.
    /// It helps dealing with all the different kind of input attached to a camera.
    type [<AllowNullLiteral>] CameraInputsManagerStatic =
        /// <summary>Instantiate a new Camera Input Manager.</summary>
        /// <param name="camera">Defines the camera the input manager blongs to</param>
        [<Emit "new $0($1...)">] abstract Create: camera: 'TCamera -> CameraInputsManager<'TCamera>

    /// This is a camera specifically designed to react to device orientation events such as a modern mobile device
    /// being tilted forward or back and left or right.
    type [<AllowNullLiteral>] DeviceOrientationCamera =
        inherit FreeCamera
        /// Gets the current instance class name ("DeviceOrientationCamera").
        /// This helps avoiding instanceof at run time.
        abstract getClassName: unit -> string
        abstract _checkInputs: unit -> unit
        /// <summary>Reset the camera to its default orientation on the specified axis only.</summary>
        /// <param name="axis">The axis to reset</param>
        abstract resetToCurrentRotation: ?axis: Axis -> unit

    /// This is a camera specifically designed to react to device orientation events such as a modern mobile device
    /// being tilted forward or back and left or right.
    type [<AllowNullLiteral>] DeviceOrientationCameraStatic =
        /// <summary>Creates a new device orientation camera</summary>
        /// <param name="name">The name of the camera</param>
        /// <param name="position">The start position camera</param>
        /// <param name="scene">The scene the camera belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> DeviceOrientationCamera

    /// A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and
    /// an arc rotate version arcFollowCamera are available.
    type [<AllowNullLiteral>] FollowCamera =
        inherit TargetCamera
        /// Distance the follow camera should follow an object at
        abstract radius: float with get, set
        /// Define a rotation offset between the camera and the object it follows
        abstract rotationOffset: float with get, set
        /// Define a height offset between the camera and the object it follows.
        /// It can help following an object from the top (like a car chaing a plane)
        abstract heightOffset: float with get, set
        /// Define how fast the camera can accelerate to follow it s target.
        abstract cameraAcceleration: float with get, set
        /// Define the speed limit of the camera following an object.
        abstract maxCameraSpeed: float with get, set
        /// Define the target of the camera.
        abstract lockedTarget: Nullable<AbstractMesh> with get, set
        abstract _checkInputs: unit -> unit
        /// Gets the camera class name.
        abstract getClassName: unit -> string

    /// A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and
    /// an arc rotate version arcFollowCamera are available.
    type [<AllowNullLiteral>] FollowCameraStatic =
        /// <summary>Instantiates the follow camera.</summary>
        /// <param name="name">Define the name of the camera in the scene</param>
        /// <param name="position">Define the position of the camera</param>
        /// <param name="scene">Define the scene the camera belong to</param>
        /// <param name="lockedTarget">Define the target of the camera</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?lockedTarget: AbstractMesh -> FollowCamera

    /// Arc Rotate version of the follow camera.
    /// It still follows a Defined mesh but in an Arc Rotate Camera fashion.
    type [<AllowNullLiteral>] ArcFollowCamera =
        inherit TargetCamera
        /// The longitudinal angle of the camera 
        abstract alpha: float with get, set
        /// The latitudinal angle of the camera 
        abstract beta: float with get, set
        /// The radius of the camera from its target 
        abstract radius: float with get, set
        /// Define the camera target (the messh it should follow) 
        abstract target: Nullable<AbstractMesh> with get, set
        abstract _checkInputs: unit -> unit
        /// Returns the class name of the object.
        /// It is mostly used internally for serialization purposes.
        abstract getClassName: unit -> string

    /// Arc Rotate version of the follow camera.
    /// It still follows a Defined mesh but in an Arc Rotate Camera fashion.
    type [<AllowNullLiteral>] ArcFollowCameraStatic =
        /// <summary>Instantiates a new ArcFollowCamera</summary>
        /// <param name="name">Define the name of the camera</param>
        /// <param name="alpha">Define the rotation angle of the camera around the logitudinal axis</param>
        /// <param name="beta">Define the rotation angle of the camera around the elevation axis</param>
        /// <param name="radius">Define the radius of the camera from its target point</param>
        /// <param name="target">Define the target of the camera</param>
        /// <param name="scene">Define the scene the camera belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * alpha: float * beta: float * radius: float * target: Nullable<AbstractMesh> * scene: Scene -> ArcFollowCamera

    /// This represents a free type of camera. It can be usefull in First Person Shooter game for instance.
    /// Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.
    type [<AllowNullLiteral>] FreeCamera =
        inherit TargetCamera
        /// Define the collision ellipsoid of the camera.
        /// This is helpful to simulate a camera body like the player body around the camera
        abstract ellipsoid: Vector3 with get, set
        /// Define an offset for the position of the ellipsoid around the camera.
        /// This can be helpful to determine the center of the body near the gravity center of the body
        /// instead of its head.
        abstract ellipsoidOffset: Vector3 with get, set
        /// Enable or disable collisions of the camera with the rest of the scene objects.
        abstract checkCollisions: bool with get, set
        /// Enable or disable gravity on the camera.
        abstract applyGravity: bool with get, set
        /// Define the input manager associated to the camera.
        abstract inputs: FreeCameraInputsManager with get, set
        /// Gets the input sensibility for a mouse input. (default is 2000.0)
        /// Higher values reduce sensitivity.
        /// Sets the input sensibility for a mouse input. (default is 2000.0)
        /// Higher values reduce sensitivity.
        abstract angularSensibility: float with get, set
        /// Gets or Set the list of keyboard keys used to control the forward move of the camera.
        abstract keysUp: ResizeArray<float> with get, set
        /// Gets or Set the list of keyboard keys used to control the backward move of the camera.
        abstract keysDown: ResizeArray<float> with get, set
        /// Gets or Set the list of keyboard keys used to control the left strafe move of the camera.
        abstract keysLeft: ResizeArray<float> with get, set
        /// Gets or Set the list of keyboard keys used to control the right strafe move of the camera.
        abstract keysRight: ResizeArray<float> with get, set
        /// Event raised when the camera collide with a mesh in the scene.
        abstract onCollide: (AbstractMesh -> unit) with get, set
        abstract _localDirection: Vector3 with get, set
        abstract _transformedDirection: Vector3 with get, set
        /// <summary>Attached controls to the current camera.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the camera.
        /// The camera will stop reacting to inputs.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: HTMLElement -> unit
        /// Define a collision mask to limit the list of object the camera can collide with
        abstract collisionMask: float with get, set
        abstract _collideWithWorld: displacement: Vector3 -> unit
        abstract _checkInputs: unit -> unit
        abstract _decideIfNeedsToMove: unit -> bool
        abstract _updatePosition: unit -> unit
        /// Destroy the camera and release the current resources hold by it.
        abstract dispose: unit -> unit
        /// Gets the current object class name.
        abstract getClassName: unit -> string

    /// This represents a free type of camera. It can be usefull in First Person Shooter game for instance.
    /// Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.
    type [<AllowNullLiteral>] FreeCameraStatic =
        /// <summary>Instantiates a Free Camera.
        /// This represents a free type of camera. It can be usefull in First Person Shooter game for instance.
        /// Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.</summary>
        /// <param name="name">Define the name of the camera in the scene</param>
        /// <param name="position">Define the start position of the camera in the scene</param>
        /// <param name="scene">Define the scene the camera belongs to</param>
        /// <param name="setActiveOnSceneIfNoneActive">Defines wheter the camera should be marked as active if not other active cameras have been defined</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?setActiveOnSceneIfNoneActive: bool -> FreeCamera

    /// Default Inputs manager for the FreeCamera.
    /// It groups all the default supported inputs for ease of use.
    /// Interface representing a free camera inputs manager
    type [<AllowNullLiteral>] FreeCameraInputsManager =
        inherit CameraInputsManager<FreeCamera>
        /// Add keyboard input support to the input manager.
        abstract addKeyboard: unit -> FreeCameraInputsManager
        /// <summary>Add mouse input support to the input manager.</summary>
        /// <param name="touchEnabled">if the FreeCameraMouseInput should support touch (default: true)</param>
        abstract addMouse: ?touchEnabled: bool -> FreeCameraInputsManager
        /// Add orientation input support to the input manager.
        abstract addDeviceOrientation: unit -> FreeCameraInputsManager
        /// Add touch input support to the input manager.
        abstract addTouch: unit -> FreeCameraInputsManager
        /// Add virtual joystick input support to the input manager.
        abstract addVirtualJoystick: unit -> FreeCameraInputsManager
        /// Adds gamepad input support to the FreeCameraInputsManager.
        abstract addGamepad: unit -> FreeCameraInputsManager

    /// Default Inputs manager for the FreeCamera.
    /// It groups all the default supported inputs for ease of use.
    /// Interface representing a free camera inputs manager
    type [<AllowNullLiteral>] FreeCameraInputsManagerStatic =
        /// <summary>Instantiates a new FreeCameraInputsManager.</summary>
        /// <param name="camera">Defines the camera the inputs belong to</param>
        [<Emit "new $0($1...)">] abstract Create: camera: FreeCamera -> FreeCameraInputsManager

    /// This represents a FPS type of camera. This is only here for back compat purpose.
    /// Please use the UniversalCamera instead as both are identical.
    type [<AllowNullLiteral>] GamepadCamera =
        inherit UniversalCamera
        /// Gets the current object class name.
        abstract getClassName: unit -> string

    /// This represents a FPS type of camera. This is only here for back compat purpose.
    /// Please use the UniversalCamera instead as both are identical.
    type [<AllowNullLiteral>] GamepadCameraStatic =
        /// <summary>Instantiates a new Gamepad Camera
        /// This represents a FPS type of camera. This is only here for back compat purpose.
        /// Please use the UniversalCamera instead as both are identical.</summary>
        /// <param name="name">Define the name of the camera in the scene</param>
        /// <param name="position">Define the start position of the camera in the scene</param>
        /// <param name="scene">Define the scene the camera belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> GamepadCamera

    /// A target camera takes a mesh or position as a target and continues to look at it while it moves.
    /// This is the base of the follow, arc rotate cameras and Free camera
    type [<AllowNullLiteral>] TargetCamera =
        inherit Camera
        /// Define the current direction the camera is moving to
        abstract cameraDirection: Vector3 with get, set
        /// Define the current rotation the camera is rotating to
        abstract cameraRotation: Vector2 with get, set
        /// Define the current rotation of the camera
        abstract rotation: Vector3 with get, set
        /// Define the current rotation of the camera as a quaternion to prevent Gimbal lock
        abstract rotationQuaternion: Quaternion with get, set
        /// Define the current speed of the camera
        abstract speed: float with get, set
        /// Add cconstraint to the camera to prevent it to move freely in all directions and
        /// around all axis.
        abstract noRotationConstraint: bool with get, set
        /// Define the current target of the camera as an object or a position.
        abstract lockedTarget: obj option with get, set
        abstract _currentTarget: Vector3 with get, set
        abstract _viewMatrix: Matrix with get, set
        abstract _camMatrix: Matrix with get, set
        abstract _cameraTransformMatrix: Matrix with get, set
        abstract _cameraRotationMatrix: Matrix with get, set
        abstract _referencePoint: Vector3 with get, set
        abstract _transformedReferencePoint: Vector3 with get, set
        abstract _globalCurrentTarget: Vector3 with get, set
        abstract _globalCurrentUpVector: Vector3 with get, set
        abstract _reset: (unit -> unit) with get, set
        /// <summary>Gets the position in front of the camera at a given distance.</summary>
        /// <param name="distance">The distance from the camera we want the position to be</param>
        abstract getFrontPosition: distance: float -> Vector3
        abstract _getLockedTargetPosition: unit -> Nullable<Vector3>
        /// Store current camera state of the camera (fov, position, rotation, etc..)
        abstract storeState: unit -> Camera
        /// Restored camera state. You must call storeState() first
        abstract _restoreStateValues: unit -> bool
        abstract _initCache: unit -> unit
        abstract _updateCache: ?ignoreParentClass: bool -> unit
        abstract _isSynchronizedViewMatrix: unit -> bool
        abstract _computeLocalCameraSpeed: unit -> float
        abstract setTarget: target: Vector3 -> unit
        /// Return the current target position of the camera. This value is expressed in local space.
        abstract getTarget: unit -> Vector3
        abstract _decideIfNeedsToMove: unit -> bool
        abstract _updatePosition: unit -> unit
        abstract _checkInputs: unit -> unit
        abstract _updateCameraRotationMatrix: unit -> unit
        abstract _getViewMatrix: unit -> Matrix
        abstract _computeViewMatrix: position: Vector3 * target: Vector3 * up: Vector3 -> unit
        abstract createRigCamera: name: string * cameraIndex: float -> Nullable<Camera>
        abstract _updateRigCameras: unit -> unit
        /// Gets the current object class name.
        abstract getClassName: unit -> string

    /// A target camera takes a mesh or position as a target and continues to look at it while it moves.
    /// This is the base of the follow, arc rotate cameras and Free camera
    type [<AllowNullLiteral>] TargetCameraStatic =
        /// <summary>Instantiates a target camera that takes a meshor position as a target and continues to look at it while it moves.
        /// This is the base of the follow, arc rotate cameras and Free camera</summary>
        /// <param name="name">Defines the name of the camera in the scene</param>
        /// <param name="position">Defines the start position of the camera in the scene</param>
        /// <param name="scene">Defines the scene the camera belongs to</param>
        /// <param name="setActiveOnSceneIfNoneActive">Defines wheter the camera should be marked as active if not other active cameras have been defined</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?setActiveOnSceneIfNoneActive: bool -> TargetCamera

    /// This represents a FPS type of camera controlled by touch.
    /// This is like a universal camera minus the Gamepad controls.
    type [<AllowNullLiteral>] TouchCamera =
        inherit FreeCamera
        /// Defines the touch sensibility for rotation.
        /// The higher the faster.
        abstract touchAngularSensibility: float with get, set
        /// Defines the touch sensibility for move.
        /// The higher the faster.
        abstract touchMoveSensibility: float with get, set
        /// Gets the current object class name.
        abstract getClassName: unit -> string
        abstract _setupInputs: unit -> unit

    /// This represents a FPS type of camera controlled by touch.
    /// This is like a universal camera minus the Gamepad controls.
    type [<AllowNullLiteral>] TouchCameraStatic =
        /// <summary>Instantiates a new touch camera.
        /// This represents a FPS type of camera controlled by touch.
        /// This is like a universal camera minus the Gamepad controls.</summary>
        /// <param name="name">Define the name of the camera in the scene</param>
        /// <param name="position">Define the start position of the camera in the scene</param>
        /// <param name="scene">Define the scene the camera belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> TouchCamera

    /// The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
    /// which still works and will still be found in many Playgrounds.
    type [<AllowNullLiteral>] UniversalCamera =
        inherit TouchCamera
        /// Defines the gamepad rotation sensiblity.
        /// This is the threshold from when rotation starts to be accounted for to prevent jittering.
        abstract gamepadAngularSensibility: float with get, set
        /// Defines the gamepad move sensiblity.
        /// This is the threshold from when moving starts to be accounted for for to prevent jittering.
        abstract gamepadMoveSensibility: float with get, set
        /// Gets the current object class name.
        abstract getClassName: unit -> string

    /// The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
    /// which still works and will still be found in many Playgrounds.
    type [<AllowNullLiteral>] UniversalCameraStatic =
        /// <summary>The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
        /// which still works and will still be found in many Playgrounds.</summary>
        /// <param name="name">Define the name of the camera in the scene</param>
        /// <param name="position">Define the start position of the camera in the scene</param>
        /// <param name="scene">Define the scene the camera belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> UniversalCamera

    /// This represents a free type of camera. It can be usefull in First Person Shooter game for instance.
    /// It is identical to the Free Camera and simply adds by default a virtual joystick.
    /// Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.
    type [<AllowNullLiteral>] VirtualJoysticksCamera =
        inherit FreeCamera
        /// Gets the current object class name.
        abstract getClassName: unit -> string

    /// This represents a free type of camera. It can be usefull in First Person Shooter game for instance.
    /// It is identical to the Free Camera and simply adds by default a virtual joystick.
    /// Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.
    type [<AllowNullLiteral>] VirtualJoysticksCameraStatic =
        /// <summary>Intantiates a VirtualJoysticksCamera. It can be usefull in First Person Shooter game for instance.
        /// It is identical to the Free Camera and simply adds by default a virtual joystick.
        /// Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.</summary>
        /// <param name="name">Define the name of the camera in the scene</param>
        /// <param name="position">Define the start position of the camera in the scene</param>
        /// <param name="scene">Define the scene the camera belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> VirtualJoysticksCamera

    module Debug =

        type [<AllowNullLiteral>] IExports =
            abstract AxesViewer: AxesViewerStatic
            abstract BoneAxesViewer: BoneAxesViewerStatic
            abstract PhysicsViewer: PhysicsViewerStatic
            abstract SkeletonViewer: SkeletonViewerStatic

        /// The Axes viewer will show 3 axes in a specific point in space
        type [<AllowNullLiteral>] AxesViewer =
            /// Gets the hosting scene
            abstract scene: Nullable<Scene> with get, set
            /// Gets or sets a number used to scale line length
            abstract scaleLines: float with get, set
            /// <summary>Force the viewer to update</summary>
            /// <param name="position">defines the position of the viewer</param>
            /// <param name="xaxis">defines the x axis of the viewer</param>
            /// <param name="yaxis">defines the y axis of the viewer</param>
            /// <param name="zaxis">defines the z axis of the viewer</param>
            abstract update: position: Vector3 * xaxis: Vector3 * yaxis: Vector3 * zaxis: Vector3 -> unit
            /// Releases resources 
            abstract dispose: unit -> unit

        /// The Axes viewer will show 3 axes in a specific point in space
        type [<AllowNullLiteral>] AxesViewerStatic =
            /// <summary>Creates a new AxesViewer</summary>
            /// <param name="scene">defines the hosting scene</param>
            /// <param name="scaleLines">defines a number used to scale line length (1 by default)</param>
            [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?scaleLines: float -> AxesViewer

        /// The BoneAxesViewer will attach 3 axes to a specific bone of a specific mesh
        type [<AllowNullLiteral>] BoneAxesViewer =
            inherit AxesViewer
            /// Gets or sets the target mesh where to display the axes viewer
            abstract mesh: Nullable<Mesh> with get, set
            /// Gets or sets the target bone where to display the axes viewer
            abstract bone: Nullable<Bone> with get, set
            /// Gets current position 
            abstract pos: Vector3 with get, set
            /// Gets direction of X axis 
            abstract xaxis: Vector3 with get, set
            /// Gets direction of Y axis 
            abstract yaxis: Vector3 with get, set
            /// Gets direction of Z axis 
            abstract zaxis: Vector3 with get, set
            /// Force the viewer to update
            abstract update: unit -> unit
            /// Releases resources 
            abstract dispose: unit -> unit

        /// The BoneAxesViewer will attach 3 axes to a specific bone of a specific mesh
        type [<AllowNullLiteral>] BoneAxesViewerStatic =
            /// <summary>Creates a new BoneAxesViewer</summary>
            /// <param name="scene">defines the hosting scene</param>
            /// <param name="bone">defines the target bone</param>
            /// <param name="mesh">defines the target mesh</param>
            /// <param name="scaleLines">defines a scaling factor for line length (1 by default)</param>
            [<Emit "new $0($1...)">] abstract Create: scene: Scene * bone: Bone * mesh: Mesh * ?scaleLines: float -> BoneAxesViewer

        /// Used to show the physics impostor around the specific mesh
        type [<AllowNullLiteral>] PhysicsViewer =
            abstract _impostors: Array<Nullable<PhysicsImpostor>> with get, set
            abstract _meshes: Array<Nullable<AbstractMesh>> with get, set
            abstract _scene: Nullable<Scene> with get, set
            abstract _numMeshes: float with get, set
            abstract _physicsEnginePlugin: Nullable<IPhysicsEnginePlugin> with get, set
            abstract _updateDebugMeshes: unit -> unit
            /// <summary>Renders a specified physic impostor</summary>
            /// <param name="impostor">defines the impostor to render</param>
            abstract showImpostor: impostor: PhysicsImpostor -> unit
            /// <summary>Hides a specified physic impostor</summary>
            /// <param name="impostor">defines the impostor to hide</param>
            abstract hideImpostor: impostor: Nullable<PhysicsImpostor> -> unit
            /// Releases all resources 
            abstract dispose: unit -> unit

        /// Used to show the physics impostor around the specific mesh
        type [<AllowNullLiteral>] PhysicsViewerStatic =
            /// <summary>Creates a new PhysicsViewer</summary>
            /// <param name="scene">defines the hosting scene</param>
            [<Emit "new $0($1...)">] abstract Create: scene: Scene -> PhysicsViewer

        /// Class used to render a debug view of a given skeleton
        type [<AllowNullLiteral>] SkeletonViewer =
            /// defines the skeleton to render 
            abstract skeleton: Skeleton with get, set
            /// defines the mesh attached to the skeleton 
            abstract mesh: AbstractMesh with get, set
            /// defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  
            abstract autoUpdateBonesMatrices: bool with get, set
            /// defines the rendering group id to use with the viewer 
            abstract renderingGroupId: float with get, set
            /// Gets or sets the color used to render the skeleton 
            abstract color: Color3 with get, set
            /// Gets or sets a boolean indicating if the viewer is enabled 
            abstract isEnabled: bool with get, set
            /// Update the viewer to sync with current skeleton state 
            abstract update: unit -> unit
            /// Release associated resources 
            abstract dispose: unit -> unit

        /// Class used to render a debug view of a given skeleton
        type [<AllowNullLiteral>] SkeletonViewerStatic =
            /// <summary>Creates a new SkeletonViewer</summary>
            /// <param name="skeleton">defines the skeleton to render</param>
            /// <param name="mesh">defines the mesh attached to the skeleton</param>
            /// <param name="scene">defines the hosting scene</param>
            /// <param name="autoUpdateBonesMatrices">defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)</param>
            /// <param name="renderingGroupId">defines the rendering group id to use with the viewer</param>
            [<Emit "new $0($1...)">] abstract Create: skeleton: Skeleton * mesh: AbstractMesh * scene: Scene * ?autoUpdateBonesMatrices: bool * ?renderingGroupId: float -> SkeletonViewer

    /// The debug layer (aka Inspector) is the go to tool in order to better understand
    /// what is happening in your scene
    type [<AllowNullLiteral>] DebugLayer =
        /// Observable triggered when a property is changed through the inspector.
        abstract onPropertyChangedObservable: Observable<TypeLiteral_12> with get, set
        /// Get if the inspector is visible or not.
        abstract isVisible: unit -> bool
        /// Hide the inspector and close its window.
        abstract hide: unit -> unit
        /// <summary>Launch the debugLayer.
        /// 
        /// initialTab:
        /// | Value | Tab Name |
        /// | --- | --- |
        /// | 0 | Scene |
        /// | 1 | Console |
        /// | 2 | Stats |
        /// | 3 | Textures |
        /// | 4 | Mesh |
        /// | 5 | Light |
        /// | 6 | Material |
        /// | 7 | GLTF |
        /// | 8 | GUI |
        /// | 9 | Physics |
        /// | 10 | Camera |
        /// | 11 | Audio |</summary>
        /// <param name="config">Define the configuration of the inspector</param>
        abstract show: ?config: DebugLayerShowConfig -> unit
        /// Gets the active tab
        abstract getActiveTab: unit -> float

    type [<AllowNullLiteral>] DebugLayerShowConfig =
        abstract popup: bool option with get, set
        abstract initialTab: U2<float, string> option with get, set
        abstract parentElement: HTMLElement option with get, set
        abstract newColors: TypeLiteral_13 option with get, set

    /// The debug layer (aka Inspector) is the go to tool in order to better understand
    /// what is happening in your scene
    type [<AllowNullLiteral>] DebugLayerStatic =
        /// Define the url to get the inspector script from.
        /// By default it uses the babylonjs CDN.
        abstract InspectorURL: string with get, set
        /// <summary>Instantiates a new debug layer.
        /// The debug layer (aka Inspector) is the go to tool in order to better understand
        /// what is happening in your scene</summary>
        /// <param name="scene">Defines the scene to inspect</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> DebugLayer

    /// As raycast might be hard to debug, the RayHelper can help rendering the different rays
    /// in order to better appreciate the issue one might have.
    type [<AllowNullLiteral>] RayHelper =
        /// Defines the ray we are currently tryin to visualize.
        abstract ray: Nullable<Ray> with get, set
        /// <summary>Shows the ray we are willing to debug.</summary>
        /// <param name="scene">Defines the scene the ray needs to be rendered in</param>
        /// <param name="color">Defines the color the ray needs to be rendered in</param>
        abstract show: scene: Scene * ?color: Color3 -> unit
        /// Hides the ray we are debugging.
        abstract hide: unit -> unit
        /// <summary>Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.</summary>
        /// <param name="mesh">Defines the mesh we want the helper attached to</param>
        /// <param name="meshSpaceDirection">Defines the direction of the Ray in mesh space (local space of the mesh node)</param>
        /// <param name="meshSpaceOrigin">Defines the origin of the Ray in mesh space (local space of the mesh node)</param>
        /// <param name="length">Defines the length of the ray</param>
        abstract attachToMesh: mesh: AbstractMesh * ?meshSpaceDirection: Vector3 * ?meshSpaceOrigin: Vector3 * ?length: float -> unit
        /// Detach the ray helper from the mesh it has previously been attached to.
        abstract detachFromMesh: unit -> unit
        /// Dispose the helper and release its associated resources.
        abstract dispose: unit -> unit

    /// As raycast might be hard to debug, the RayHelper can help rendering the different rays
    /// in order to better appreciate the issue one might have.
    type [<AllowNullLiteral>] RayHelperStatic =
        /// <summary>Helper function to create a colored helper in a scene in one line.</summary>
        /// <param name="ray">Defines the ray we are currently tryin to visualize</param>
        /// <param name="scene">Defines the scene the ray is used in</param>
        /// <param name="color">Defines the color we want to see the ray in</param>
        abstract CreateAndShow: ray: Ray * scene: Scene * color: Color3 -> RayHelper
        /// <summary>Instantiate a new ray helper.
        /// As raycast might be hard to debug, the RayHelper can help rendering the different rays
        /// in order to better appreciate the issue one might have.</summary>
        /// <param name="ray">Defines the ray we are currently tryin to visualize</param>
        [<Emit "new $0($1...)">] abstract Create: ray: Ray -> RayHelper

    /// Interface for attribute information associated with buffer instanciation
    type [<AllowNullLiteral>] InstancingAttributeInfo =
        /// Index/offset of the attribute in the vertex shader
        abstract index: float with get, set
        /// size of the attribute, 1, 2, 3 or 4
        abstract attributeSize: float with get, set
        /// type of the attribute, gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.FIXED, gl.FLOAT.
        /// default is FLOAT
        abstract attribyteType: float with get, set
        /// normalization of fixed-point data. behavior unclear, use FALSE, default is FALSE
        abstract normalized: bool with get, set
        /// Offset of the data in the Vertex Buffer acting as the instancing buffer
        abstract offset: float with get, set
        /// Name of the GLSL attribute, for debugging purpose only
        abstract attributeName: string with get, set

    /// Interface for attribute information associated with buffer instanciation
    type [<AllowNullLiteral>] InstancingAttributeInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> InstancingAttributeInfo

    /// Define options used to create a render target texture
    type [<AllowNullLiteral>] RenderTargetCreationOptions =
        /// Specifies is mipmaps must be generated
        abstract generateMipMaps: bool option with get, set
        /// Specifies whether or not a depth should be allocated in the texture (true by default) 
        abstract generateDepthBuffer: bool option with get, set
        /// Specifies whether or not a stencil should be allocated in the texture (false by default)
        abstract generateStencilBuffer: bool option with get, set
        /// Defines texture type (int by default) 
        abstract ``type``: float option with get, set
        /// Defines sampling mode (trilinear by default) 
        abstract samplingMode: float option with get, set
        /// Defines format (RGBA by default) 
        abstract format: float option with get, set

    /// Define options used to create a render target texture
    type [<AllowNullLiteral>] RenderTargetCreationOptionsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> RenderTargetCreationOptions

    /// Define options used to create a depth texture
    type [<AllowNullLiteral>] DepthTextureCreationOptions =
        /// Specifies whether or not a stencil should be allocated in the texture 
        abstract generateStencil: bool option with get, set
        /// Specifies whether or not bilinear filtering is enable on the texture 
        abstract bilinearFiltering: bool option with get, set
        /// Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode 
        abstract comparisonFunction: float option with get, set
        /// Specifies if the created texture is a cube texture 
        abstract isCube: bool option with get, set

    /// Define options used to create a depth texture
    type [<AllowNullLiteral>] DepthTextureCreationOptionsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> DepthTextureCreationOptions

    /// Class used to describe the capabilities of the engine relatively to the current browser
    type [<AllowNullLiteral>] EngineCapabilities =
        /// Maximum textures units per fragment shader 
        abstract maxTexturesImageUnits: float with get, set
        /// Maximum texture units per vertex shader 
        abstract maxVertexTextureImageUnits: float with get, set
        /// Maximum textures units in the entire pipeline 
        abstract maxCombinedTexturesImageUnits: float with get, set
        /// Maximum texture size 
        abstract maxTextureSize: float with get, set
        /// Maximum cube texture size 
        abstract maxCubemapTextureSize: float with get, set
        /// Maximum render texture size 
        abstract maxRenderTextureSize: float with get, set
        /// Maximum number of vertex attributes 
        abstract maxVertexAttribs: float with get, set
        /// Maximum number of varyings 
        abstract maxVaryingVectors: float with get, set
        /// Maximum number of uniforms per vertex shader 
        abstract maxVertexUniformVectors: float with get, set
        /// Maximum number of uniforms per fragment shader 
        abstract maxFragmentUniformVectors: float with get, set
        /// Defines if standard derivates (dx/dy) are supported 
        abstract standardDerivatives: bool with get, set
        /// Defines if s3tc texture compression is supported 
        abstract s3tc: Nullable<WEBGL_compressed_texture_s3tc> with get, set
        /// Defines if pvrtc texture compression is supported 
        abstract pvrtc: obj option with get, set
        /// Defines if etc1 texture compression is supported 
        abstract etc1: obj option with get, set
        /// Defines if etc2 texture compression is supported 
        abstract etc2: obj option with get, set
        /// Defines if astc texture compression is supported 
        abstract astc: obj option with get, set
        /// Defines if float textures are supported 
        abstract textureFloat: bool with get, set
        /// Defines if vertex array objects are supported 
        abstract vertexArrayObject: bool with get, set
        /// Gets the webgl extension for anisotropic filtering (null if not supported) 
        abstract textureAnisotropicFilterExtension: Nullable<EXT_texture_filter_anisotropic> with get, set
        /// Gets the maximum level of anisotropy supported 
        abstract maxAnisotropy: float with get, set
        /// Defines if instancing is supported 
        abstract instancedArrays: bool with get, set
        /// Defines if 32 bits indices are supported 
        abstract uintIndices: bool with get, set
        /// Defines if high precision shaders are supported 
        abstract highPrecisionShaderSupported: bool with get, set
        /// Defines if depth reading in the fragment shader is supported 
        abstract fragmentDepthSupported: bool with get, set
        /// Defines if float texture linear filtering is supported
        abstract textureFloatLinearFiltering: bool with get, set
        /// Defines if rendering to float textures is supported 
        abstract textureFloatRender: bool with get, set
        /// Defines if half float textures are supported
        abstract textureHalfFloat: bool with get, set
        /// Defines if half float texture linear filtering is supported
        abstract textureHalfFloatLinearFiltering: bool with get, set
        /// Defines if rendering to half float textures is supported 
        abstract textureHalfFloatRender: bool with get, set
        /// Defines if textureLOD shader command is supported 
        abstract textureLOD: bool with get, set
        /// Defines if draw buffers extension is supported 
        abstract drawBuffersExtension: bool with get, set
        /// Defines if depth textures are supported 
        abstract depthTextureExtension: bool with get, set
        /// Defines if float color buffer are supported 
        abstract colorBufferFloat: bool with get, set
        /// Gets disjoint timer query extension (null if not supported) 
        abstract timerQuery: EXT_disjoint_timer_query with get, set
        /// Defines if timestamp can be used with timer query 
        abstract canUseTimestampForTimerQuery: bool with get, set

    /// Class used to describe the capabilities of the engine relatively to the current browser
    type [<AllowNullLiteral>] EngineCapabilitiesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> EngineCapabilities

    /// Interface defining initialization parameters for Engine class 
    type [<AllowNullLiteral>] EngineOptions =
        inherit WebGLContextAttributes
        /// Defines if the engine should no exceed a specified device ratio
        abstract limitDeviceRatio: float option with get, set
        /// Defines if webvr should be enabled automatically
        abstract autoEnableWebVR: bool option with get, set
        /// Defines if webgl2 should be turned off even if supported
        abstract disableWebGL2Support: bool option with get, set
        /// Defines if webaudio should be initialized as well
        abstract audioEngine: bool option with get, set
        /// Defines if animations should run using a deterministic lock step
        abstract deterministicLockstep: bool option with get, set
        /// Defines the maximum steps to use with deterministic lock step mode 
        abstract lockstepMaxSteps: float option with get, set
        /// Defines that engine should ignore context lost events
        /// If this event happens when this parameter is true, you will have to reload the page to restore rendering
        abstract doNotHandleContextLost: bool option with get, set

    /// Defines the interface used by display changed events
    type [<AllowNullLiteral>] IDisplayChangedEventArgs =
        /// Gets the vrDisplay object (if any) 
        abstract vrDisplay: Nullable<obj option> with get, set
        /// Gets a boolean indicating if webVR is supported 
        abstract vrSupported: bool with get, set

    /// The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio
    type [<AllowNullLiteral>] Engine =
        /// Gets or sets a boolean that indicates if textures must be forced to power of 2 size even if not required
        abstract forcePOTTextures: bool with get, set
        /// Gets a boolean indicating if the engine is currently rendering in fullscreen mode
        abstract isFullscreen: bool with get, set
        /// Gets a boolean indicating if the pointer is currently locked
        abstract isPointerLock: bool with get, set
        /// Gets or sets a boolean indicating if back faces must be culled (true by default)
        abstract cullBackFaces: bool with get, set
        /// Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foregroun
        abstract renderEvenInBackground: bool with get, set
        /// Gets or sets a boolean indicating that cache can be kept between frames
        abstract preventCacheWipeBetweenFrames: bool with get, set
        /// Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest
        abstract enableOfflineSupport: bool with get, set
        /// Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (Babylon.js will always consider the database is up to date)
        abstract disableManifestCheck: bool with get, set
        /// Gets the list of created scenes
        abstract scenes: ResizeArray<Scene> with get, set
        /// Gets the list of created postprocesses
        abstract postProcesses: ResizeArray<PostProcess> with get, set
        /// Gets or sets a boolean indicating if the engine should validate programs after compilation 
        abstract validateShaderPrograms: bool with get, set
        /// Observable event triggered each time the rendering canvas is resized
        abstract onResizeObservable: Observable<Engine> with get, set
        /// Observable event triggered each time the canvas loses focus
        abstract onCanvasBlurObservable: Observable<Engine> with get, set
        /// Observable event triggered each time the canvas gains focus
        abstract onCanvasFocusObservable: Observable<Engine> with get, set
        /// Observable event triggered each time the canvas receives pointerout event
        abstract onCanvasPointerOutObservable: Observable<PointerEvent> with get, set
        /// Observable event triggered before each texture is initialized
        abstract onBeforeTextureInitObservable: Observable<Texture> with get, set
        /// Gets a boolean indicating that the engine is currently in VR exclusive mode for the pointers
        abstract isInVRExclusivePointerMode: bool
        /// Gets or sets a boolean indicating that uniform buffers must be disabled even if they are supported
        abstract disableUniformBuffers: bool with get, set
        abstract _uniformBuffers: ResizeArray<UniformBuffer> with get, set
        /// Gets a boolean indicating that the engine supports uniform buffers
        abstract supportsUniformBuffers: bool
        /// Observable raised when the engine begins a new frame
        abstract onBeginFrameObservable: Observable<Engine> with get, set
        /// Observable raised when the engine ends the current frame
        abstract onEndFrameObservable: Observable<Engine> with get, set
        /// Observable raised when the engine is about to compile a shader
        abstract onBeforeShaderCompilationObservable: Observable<Engine> with get, set
        /// Observable raised when the engine has jsut compiled a shader
        abstract onAfterShaderCompilationObservable: Observable<Engine> with get, set
        abstract _gl: WebGLRenderingContext with get, set
        /// Gets a boolean indicating that only power of 2 textures are supported
        /// Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them
        abstract needPOTTextures: bool
        abstract _badOS: bool with get, set
        abstract _badDesktopOS: bool with get, set
        /// Gets or sets a value indicating if we want to disable texture binding optmization.
        /// This could be required on some buggy drivers which wants to have textures bound in a progressive order.
        /// By default Babylon.js will try to let textures bound where they are and only update the samplers to point where the texture is
        abstract disableTextureBindingOptimization: bool with get, set
        /// Observable signaled when VR display mode changes
        abstract onVRDisplayChangedObservable: Observable<IDisplayChangedEventArgs> with get, set
        /// Observable signaled when VR request present is complete
        abstract onVRRequestPresentComplete: Observable<bool> with get, set
        /// Observable signaled when VR request present starts
        abstract onVRRequestPresentStart: Observable<Engine> with get, set
        abstract _caps: EngineCapabilities with get, set
        abstract _drawCalls: PerfCounter with get, set
        abstract _textureCollisions: PerfCounter with get, set
        /// Observable signaled when a context lost event is raised
        abstract onContextLostObservable: Observable<Engine> with get, set
        /// Observable signaled when a context restored event is raised
        abstract onContextRestoredObservable: Observable<Engine> with get, set
        /// Gets or sets a boolean indicating if resources should be retained to be able to handle context lost events
        abstract doNotHandleContextLost: bool with get, set
        /// Turn this value on if you want to pause FPS computation when in background
        abstract disablePerformanceMonitorInBackground: bool with get, set
        /// Gets the performance monitor attached to this engine
        abstract performanceMonitor: PerformanceMonitor
        abstract _depthCullingState: _DepthCullingState with get, set
        abstract _stencilState: _StencilState with get, set
        abstract _alphaState: _AlphaState with get, set
        abstract _alphaMode: float with get, set
        abstract _internalTexturesCache: ResizeArray<InternalTexture> with get, set
        abstract _activeChannel: float with get, set
        abstract _boundTexturesCache: TypeLiteral_14 with get, set
        abstract _currentEffect: Nullable<Effect> with get, set
        abstract _currentProgram: Nullable<WebGLProgram> with get, set
        abstract _cachedViewport: Nullable<Viewport> with get, set
        abstract _cachedVertexBuffers: obj option with get, set
        abstract _cachedIndexBuffer: Nullable<WebGLBuffer> with get, set
        abstract _cachedEffectForVertexBuffers: Nullable<Effect> with get, set
        abstract _currentRenderTarget: Nullable<InternalTexture> with get, set
        abstract _currentFramebuffer: Nullable<WebGLFramebuffer> with get, set
        /// Gets the list of texture formats supported
        abstract texturesSupported: Array<string>
        /// Gets the list of texture formats in use
        abstract textureFormatInUse: Nullable<string>
        /// Gets the current viewport
        abstract currentViewport: Nullable<Viewport>
        /// Gets the default empty texture
        abstract emptyTexture: InternalTexture
        /// Gets the default empty 3D texture
        abstract emptyTexture3D: InternalTexture
        /// Gets the default empty cube texture
        abstract emptyCubeTexture: InternalTexture
        /// Defines whether the engine has been created with the premultipliedAlpha option on or not.
        abstract premultipliedAlpha: bool
        /// Gets version of the current webGL context
        abstract webGLVersion: float
        /// Returns true if the stencil buffer has been enabled through the creation option of the context.
        abstract isStencilEnable: bool
        /// Reset the texture cache to empty state
        abstract resetTextureCache: unit -> unit
        /// Gets a boolean indicating that the engine is running in deterministic lock step mode
        abstract isDeterministicLockStep: unit -> bool
        /// Gets the max steps when engine is running in deterministic lock step
        abstract getLockstepMaxSteps: unit -> float
        /// Gets an object containing information about the current webGL context
        abstract getGlInfo: unit -> EngineGetGlInfoReturn
        /// <summary>Gets current aspect ratio</summary>
        /// <param name="camera">defines the camera to use to get the aspect ratio</param>
        /// <param name="useScreen">defines if screen size must be used (or the current render target if any)</param>
        abstract getAspectRatio: camera: Camera * ?useScreen: bool -> float
        /// Gets current screen aspect ratio
        abstract getScreenAspectRatio: unit -> float
        /// <summary>Gets the current render width</summary>
        /// <param name="useScreen">defines if screen size must be used (or the current render target if any)</param>
        abstract getRenderWidth: ?useScreen: bool -> float
        /// <summary>Gets the current render height</summary>
        /// <param name="useScreen">defines if screen size must be used (or the current render target if any)</param>
        abstract getRenderHeight: ?useScreen: bool -> float
        /// Gets the HTML canvas attached with the current webGL context
        abstract getRenderingCanvas: unit -> Nullable<HTMLCanvasElement>
        /// Gets the client rect of the HTML canvas attached with the current webGL context
        abstract getRenderingCanvasClientRect: unit -> Nullable<ClientRect>
        /// <summary>Defines the hardware scaling level.
        /// By default the hardware scaling level is computed from the window device ratio.
        /// if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.</summary>
        /// <param name="level">defines the level to use</param>
        abstract setHardwareScalingLevel: level: float -> unit
        /// Gets the current hardware scaling level.
        /// By default the hardware scaling level is computed from the window device ratio.
        /// if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
        abstract getHardwareScalingLevel: unit -> float
        /// Gets the list of loaded textures
        abstract getLoadedTexturesCache: unit -> ResizeArray<InternalTexture>
        /// Gets the object containing all engine capabilities
        abstract getCaps: unit -> EngineCapabilities
        abstract drawCalls: float
        abstract drawCallsPerfCounter: Nullable<PerfCounter>
        /// Gets the current depth function
        abstract getDepthFunction: unit -> Nullable<float>
        /// <summary>Sets the current depth function</summary>
        /// <param name="depthFunc">defines the function to use</param>
        abstract setDepthFunction: depthFunc: float -> unit
        /// Sets the current depth function to GREATER
        abstract setDepthFunctionToGreater: unit -> unit
        /// Sets the current depth function to GEQUAL
        abstract setDepthFunctionToGreaterOrEqual: unit -> unit
        /// Sets the current depth function to LESS
        abstract setDepthFunctionToLess: unit -> unit
        /// Sets the current depth function to LEQUAL
        abstract setDepthFunctionToLessOrEqual: unit -> unit
        /// Gets a boolean indicating if stencil buffer is enabled
        abstract getStencilBuffer: unit -> bool
        /// <summary>Enable or disable the stencil buffer</summary>
        /// <param name="enable">defines if the stencil buffer must be enabled or disabled</param>
        abstract setStencilBuffer: enable: bool -> unit
        /// Gets the current stencil mask
        abstract getStencilMask: unit -> float
        /// <summary>Sets the current stencil mask</summary>
        /// <param name="mask">defines the new stencil mask to use</param>
        abstract setStencilMask: mask: float -> unit
        /// Gets the current stencil function
        abstract getStencilFunction: unit -> float
        /// Gets the current stencil reference value
        abstract getStencilFunctionReference: unit -> float
        /// Gets the current stencil mask
        abstract getStencilFunctionMask: unit -> float
        /// <summary>Sets the current stencil function</summary>
        /// <param name="stencilFunc">defines the new stencil function to use</param>
        abstract setStencilFunction: stencilFunc: float -> unit
        /// <summary>Sets the current stencil reference</summary>
        /// <param name="reference">defines the new stencil reference to use</param>
        abstract setStencilFunctionReference: reference: float -> unit
        /// <summary>Sets the current stencil mask</summary>
        /// <param name="mask">defines the new stencil mask to use</param>
        abstract setStencilFunctionMask: mask: float -> unit
        /// Gets the current stencil operation when stencil fails
        abstract getStencilOperationFail: unit -> float
        /// Gets the current stencil operation when depth fails
        abstract getStencilOperationDepthFail: unit -> float
        /// Gets the current stencil operation when stencil passes
        abstract getStencilOperationPass: unit -> float
        /// <summary>Sets the stencil operation to use when stencil fails</summary>
        /// <param name="operation">defines the stencil operation to use when stencil fails</param>
        abstract setStencilOperationFail: operation: float -> unit
        /// <summary>Sets the stencil operation to use when depth fails</summary>
        /// <param name="operation">defines the stencil operation to use when depth fails</param>
        abstract setStencilOperationDepthFail: operation: float -> unit
        /// <summary>Sets the stencil operation to use when stencil passes</summary>
        /// <param name="operation">defines the stencil operation to use when stencil passes</param>
        abstract setStencilOperationPass: operation: float -> unit
        /// <summary>Sets a boolean indicating if the dithering state is enabled or disabled</summary>
        /// <param name="value">defines the dithering state</param>
        abstract setDitheringState: value: bool -> unit
        /// <summary>Sets a boolean indicating if the rasterizer state is enabled or disabled</summary>
        /// <param name="value">defines the rasterizer state</param>
        abstract setRasterizerState: value: bool -> unit
        /// <summary>stop executing a render loop function and remove it from the execution array</summary>
        /// <param name="renderFunction">defines the function to be removed. If not provided all functions will be removed.</param>
        abstract stopRenderLoop: ?renderFunction: (unit -> unit) -> unit
        abstract _renderLoop: unit -> unit
        /// <summary>Register and execute a render loop. The engine can have more than one render function</summary>
        /// <param name="renderFunction">defines the function to continuously execute</param>
        abstract runRenderLoop: renderFunction: (unit -> unit) -> unit
        /// <summary>Toggle full screen mode</summary>
        /// <param name="requestPointerLock">defines if a pointer lock should be requested from the user</param>
        abstract switchFullscreen: requestPointerLock: bool -> unit
        /// <summary>Clear the current render buffer or the current render target (if any is set up)</summary>
        /// <param name="color">defines the color to use</param>
        /// <param name="backBuffer">defines if the back buffer must be cleared</param>
        /// <param name="depth">defines if the depth buffer must be cleared</param>
        /// <param name="stencil">defines if the stencil buffer must be cleared</param>
        abstract clear: color: Nullable<Color4> * backBuffer: bool * depth: bool * ?stencil: bool -> unit
        /// <summary>Executes a scissor clear (ie. a clear on a specific portion of the screen)</summary>
        /// <param name="x">defines the x-coordinate of the top left corner of the clear rectangle</param>
        /// <param name="y">defines the y-coordinate of the corner of the clear rectangle</param>
        /// <param name="width">defines the width of the clear rectangle</param>
        /// <param name="height">defines the height of the clear rectangle</param>
        /// <param name="clearColor">defines the clear color</param>
        abstract scissorClear: x: float * y: float * width: float * height: float * clearColor: Color4 -> unit
        abstract _viewport: x: float * y: float * width: float * height: float -> unit
        /// <summary>Set the WebGL's viewport</summary>
        /// <param name="viewport">defines the viewport element to be used</param>
        /// <param name="requiredWidth">defines the width required for rendering. If not provided the rendering canvas' width is used</param>
        /// <param name="requiredHeight">defines the height required for rendering. If not provided the rendering canvas' height is used</param>
        abstract setViewport: viewport: Viewport * ?requiredWidth: float * ?requiredHeight: float -> unit
        /// <summary>Directly set the WebGL Viewport</summary>
        /// <param name="x">defines the x coordinate of the viewport (in screen space)</param>
        /// <param name="y">defines the y coordinate of the viewport (in screen space)</param>
        /// <param name="width">defines the width of the viewport (in screen space)</param>
        /// <param name="height">defines the height of the viewport (in screen space)</param>
        abstract setDirectViewport: x: float * y: float * width: float * height: float -> Nullable<Viewport>
        /// Begin a new frame
        abstract beginFrame: unit -> unit
        /// Enf the current frame
        abstract endFrame: unit -> unit
        /// Resize the view according to the canvas' size
        abstract resize: unit -> unit
        /// <summary>Force a specific size of the canvas</summary>
        /// <param name="width">defines the new canvas' width</param>
        /// <param name="height">defines the new canvas' height</param>
        abstract setSize: width: float * height: float -> unit
        /// Gets a boolean indicating if a webVR device was detected
        abstract isVRDevicePresent: unit -> bool
        /// Gets the current webVR device
        abstract getVRDevice: unit -> obj option
        /// Initializes a webVR display and starts listening to display change events
        /// The onVRDisplayChangedObservable will be notified upon these changes
        abstract initWebVR: unit -> Observable<IDisplayChangedEventArgs>
        /// Initializes a webVR display and starts listening to display change events
        /// The onVRDisplayChangedObservable will be notified upon these changes
        abstract initWebVRAsync: unit -> Promise<IDisplayChangedEventArgs>
        /// Call this function to switch to webVR mode
        /// Will do nothing if webVR is not supported or if there is no webVR device
        abstract enableVR: unit -> unit
        /// Call this function to leave webVR mode
        /// Will do nothing if webVR is not supported or if there is no webVR device
        abstract disableVR: unit -> unit
        /// <summary>Binds the frame buffer to the specified texture.</summary>
        /// <param name="texture">The texture to render to or null for the default canvas</param>
        /// <param name="faceIndex">The face of the texture to render to in case of cube texture</param>
        /// <param name="requiredWidth">The width of the target to render to</param>
        /// <param name="requiredHeight">The height of the target to render to</param>
        /// <param name="forceFullscreenViewport">Forces the viewport to be the entire texture/screen if true</param>
        /// <param name="depthStencilTexture">The depth stencil texture to use to render</param>
        /// <param name="lodLevel">defines le lod level to bind to the frame buffer</param>
        abstract bindFramebuffer: texture: InternalTexture * ?faceIndex: float * ?requiredWidth: float * ?requiredHeight: float * ?forceFullscreenViewport: bool * ?depthStencilTexture: InternalTexture * ?lodLevel: float -> unit
        /// <summary>Unbind the current render target texture from the webGL context</summary>
        /// <param name="texture">defines the render target texture to unbind</param>
        /// <param name="disableGenerateMipMaps">defines a boolean indicating that mipmaps must not be generated</param>
        /// <param name="onBeforeUnbind">defines a function which will be called before the effective unbind</param>
        abstract unBindFramebuffer: texture: InternalTexture * ?disableGenerateMipMaps: bool * ?onBeforeUnbind: (unit -> unit) -> unit
        /// <summary>Unbind a list of render target textures from the webGL context
        /// This is used only when drawBuffer extension or webGL2 are active</summary>
        /// <param name="textures">defines the render target textures to unbind</param>
        /// <param name="disableGenerateMipMaps">defines a boolean indicating that mipmaps must not be generated</param>
        /// <param name="onBeforeUnbind">defines a function which will be called before the effective unbind</param>
        abstract unBindMultiColorAttachmentFramebuffer: textures: ResizeArray<InternalTexture> * ?disableGenerateMipMaps: bool * ?onBeforeUnbind: (unit -> unit) -> unit
        /// <summary>Force the mipmap generation for the given render target texture</summary>
        /// <param name="texture">defines the render target texture to use</param>
        abstract generateMipMapsForCubemap: texture: InternalTexture -> unit
        /// Force a webGL flush (ie. a flush of all waiting webGL commands)
        abstract flushFramebuffer: unit -> unit
        /// Unbind the current render target and bind the default framebuffer
        abstract restoreDefaultFramebuffer: unit -> unit
        /// <summary>Create an uniform buffer</summary>
        /// <param name="elements">defines the content of the uniform buffer</param>
        abstract createUniformBuffer: elements: FloatArray -> WebGLBuffer
        /// <summary>Create a dynamic uniform buffer</summary>
        /// <param name="elements">defines the content of the uniform buffer</param>
        abstract createDynamicUniformBuffer: elements: FloatArray -> WebGLBuffer
        /// <summary>Update an existing uniform buffer</summary>
        /// <param name="uniformBuffer">defines the target uniform buffer</param>
        /// <param name="elements">defines the content to update</param>
        /// <param name="offset">defines the offset in the uniform buffer where update should start</param>
        /// <param name="count">defines the size of the data to update</param>
        abstract updateUniformBuffer: uniformBuffer: WebGLBuffer * elements: FloatArray * ?offset: float * ?count: float -> unit
        /// <summary>Creates a vertex buffer</summary>
        /// <param name="data">the data for the vertex buffer</param>
        abstract createVertexBuffer: data: DataArray -> WebGLBuffer
        /// <summary>Creates a dynamic vertex buffer</summary>
        /// <param name="data">the data for the dynamic vertex buffer</param>
        abstract createDynamicVertexBuffer: data: DataArray -> WebGLBuffer
        /// <summary>Update a dynamic index buffer</summary>
        /// <param name="indexBuffer">defines the target index buffer</param>
        /// <param name="indices">defines the data to update</param>
        /// <param name="offset">defines the offset in the target index buffer where update should start</param>
        abstract updateDynamicIndexBuffer: indexBuffer: WebGLBuffer * indices: IndicesArray * ?offset: float -> unit
        /// <summary>Updates a dynamic vertex buffer.</summary>
        /// <param name="vertexBuffer">the vertex buffer to update</param>
        /// <param name="data">the data used to update the vertex buffer</param>
        /// <param name="byteOffset">the byte offset of the data</param>
        /// <param name="byteLength">the byte length of the data</param>
        abstract updateDynamicVertexBuffer: vertexBuffer: WebGLBuffer * data: DataArray * ?byteOffset: float * ?byteLength: float -> unit
        /// <summary>Creates a new index buffer</summary>
        /// <param name="indices">defines the content of the index buffer</param>
        /// <param name="updatable">defines if the index buffer must be updatable</param>
        abstract createIndexBuffer: indices: IndicesArray * ?updatable: bool -> WebGLBuffer
        /// <summary>Bind a webGL buffer to the webGL context</summary>
        /// <param name="buffer">defines the buffer to bind</param>
        abstract bindArrayBuffer: buffer: Nullable<WebGLBuffer> -> unit
        /// <summary>Bind an uniform buffer to the current webGL context</summary>
        /// <param name="buffer">defines the buffer to bind</param>
        abstract bindUniformBuffer: buffer: Nullable<WebGLBuffer> -> unit
        /// <summary>Bind a buffer to the current webGL context at a given location</summary>
        /// <param name="buffer">defines the buffer to bind</param>
        /// <param name="location">defines the index where to bind the buffer</param>
        abstract bindUniformBufferBase: buffer: WebGLBuffer * location: float -> unit
        /// <summary>Bind a specific block at a given index in a specific shader program</summary>
        /// <param name="shaderProgram">defines the shader program</param>
        /// <param name="blockName">defines the block name</param>
        /// <param name="index">defines the index where to bind the block</param>
        abstract bindUniformBlock: shaderProgram: WebGLProgram * blockName: string * index: float -> unit
        /// <summary>update the bound buffer with the given data</summary>
        /// <param name="data">defines the data to update</param>
        abstract updateArrayBuffer: data: Float32Array -> unit
        /// <summary>Records a vertex array object</summary>
        /// <param name="vertexBuffers">defines the list of vertex buffers to store</param>
        /// <param name="indexBuffer">defines the index buffer to store</param>
        /// <param name="effect">defines the effect to store</param>
        abstract recordVertexArrayObject: vertexBuffers: EngineRecordVertexArrayObjectVertexBuffers * indexBuffer: Nullable<WebGLBuffer> * effect: Effect -> WebGLVertexArrayObject
        /// <summary>Bind a specific vertex array object</summary>
        /// <param name="vertexArrayObject">defines the vertex array object to bind</param>
        /// <param name="indexBuffer">defines the index buffer to bind</param>
        abstract bindVertexArrayObject: vertexArrayObject: WebGLVertexArrayObject * indexBuffer: Nullable<WebGLBuffer> -> unit
        /// <summary>Bind webGl buffers directly to the webGL context</summary>
        /// <param name="vertexBuffer">defines the vertex buffer to bind</param>
        /// <param name="indexBuffer">defines the index buffer to bind</param>
        /// <param name="vertexDeclaration">defines the vertex declaration to use with the vertex buffer</param>
        /// <param name="vertexStrideSize">defines the vertex stride of the vertex buffer</param>
        /// <param name="effect">defines the effect associated with the vertex buffer</param>
        abstract bindBuffersDirectly: vertexBuffer: WebGLBuffer * indexBuffer: WebGLBuffer * vertexDeclaration: ResizeArray<float> * vertexStrideSize: float * effect: Effect -> unit
        /// <summary>Bind a list of vertex buffers to the webGL context</summary>
        /// <param name="vertexBuffers">defines the list of vertex buffers to bind</param>
        /// <param name="indexBuffer">defines the index buffer to bind</param>
        /// <param name="effect">defines the effect associated with the vertex buffers</param>
        abstract bindBuffers: vertexBuffers: EngineBindBuffersVertexBuffers * indexBuffer: Nullable<WebGLBuffer> * effect: Effect -> unit
        /// Unbind all instance attributes
        abstract unbindInstanceAttributes: unit -> unit
        /// <summary>Release and free the memory of a vertex array object</summary>
        /// <param name="vao">defines the vertex array object to delete</param>
        abstract releaseVertexArrayObject: vao: WebGLVertexArrayObject -> unit
        abstract _releaseBuffer: buffer: WebGLBuffer -> bool
        /// <summary>Creates a webGL buffer to use with instanciation</summary>
        /// <param name="capacity">defines the size of the buffer</param>
        abstract createInstancesBuffer: capacity: float -> WebGLBuffer
        /// <summary>Delete a webGL buffer used with instanciation</summary>
        /// <param name="buffer">defines the webGL buffer to delete</param>
        abstract deleteInstancesBuffer: buffer: WebGLBuffer -> unit
        /// <summary>Update the content of a webGL buffer used with instanciation and bind it to the webGL context</summary>
        /// <param name="instancesBuffer">defines the webGL buffer to update and bind</param>
        /// <param name="data">defines the data to store in the buffer</param>
        /// <param name="offsetLocations">defines the offsets or attributes information used to determine where data must be stored in the buffer</param>
        abstract updateAndBindInstancesBuffer: instancesBuffer: WebGLBuffer * data: Float32Array * offsetLocations: U2<ResizeArray<float>, ResizeArray<InstancingAttributeInfo>> -> unit
        /// Apply all cached states (depth, culling, stencil and alpha)
        abstract applyStates: unit -> unit
        /// <summary>Send a draw order</summary>
        /// <param name="useTriangles">defines if triangles must be used to draw (else wireframe will be used)</param>
        /// <param name="indexStart">defines the starting index</param>
        /// <param name="indexCount">defines the number of index to draw</param>
        /// <param name="instancesCount">defines the number of instances to draw (if instanciation is enabled)</param>
        abstract draw: useTriangles: bool * indexStart: float * indexCount: float * ?instancesCount: float -> unit
        /// <summary>Draw a list of points</summary>
        /// <param name="verticesStart">defines the index of first vertex to draw</param>
        /// <param name="verticesCount">defines the count of vertices to draw</param>
        /// <param name="instancesCount">defines the number of instances to draw (if instanciation is enabled)</param>
        abstract drawPointClouds: verticesStart: float * verticesCount: float * ?instancesCount: float -> unit
        /// <summary>Draw a list of unindexed primitives</summary>
        /// <param name="useTriangles">defines if triangles must be used to draw (else wireframe will be used)</param>
        /// <param name="verticesStart">defines the index of first vertex to draw</param>
        /// <param name="verticesCount">defines the count of vertices to draw</param>
        /// <param name="instancesCount">defines the number of instances to draw (if instanciation is enabled)</param>
        abstract drawUnIndexed: useTriangles: bool * verticesStart: float * verticesCount: float * ?instancesCount: float -> unit
        /// <summary>Draw a list of indexed primitives</summary>
        /// <param name="fillMode">defines the primitive to use</param>
        /// <param name="indexStart">defines the starting index</param>
        /// <param name="indexCount">defines the number of index to draw</param>
        /// <param name="instancesCount">defines the number of instances to draw (if instanciation is enabled)</param>
        abstract drawElementsType: fillMode: float * indexStart: float * indexCount: float * ?instancesCount: float -> unit
        /// <summary>Draw a list of unindexed primitives</summary>
        /// <param name="fillMode">defines the primitive to use</param>
        /// <param name="verticesStart">defines the index of first vertex to draw</param>
        /// <param name="verticesCount">defines the count of vertices to draw</param>
        /// <param name="instancesCount">defines the number of instances to draw (if instanciation is enabled)</param>
        abstract drawArraysType: fillMode: float * verticesStart: float * verticesCount: float * ?instancesCount: float -> unit
        abstract _releaseEffect: effect: Effect -> unit
        abstract _deleteProgram: program: WebGLProgram -> unit
        /// <summary>Create a new effect (used to store vertex/fragment shaders)</summary>
        /// <param name="baseName">defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)</param>
        /// <param name="attributesNamesOrOptions">defines either a list of attribute names or an EffectCreationOptions object</param>
        /// <param name="uniformsNamesOrEngine">defines either a list of uniform names or the engine to use</param>
        /// <param name="samplers">defines an array of string used to represent textures</param>
        /// <param name="defines">defines the string containing the defines to use to compile the shaders</param>
        /// <param name="fallbacks">defines the list of potential fallbacks to use if shader conmpilation fails</param>
        /// <param name="onCompiled">defines a function to call when the effect creation is successful</param>
        /// <param name="onError">defines a function to call when the effect creation has failed</param>
        /// <param name="indexParameters">defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)</param>
        abstract createEffect: baseName: obj option * attributesNamesOrOptions: U2<ResizeArray<string>, EffectCreationOptions> * uniformsNamesOrEngine: U2<ResizeArray<string>, Engine> * ?samplers: ResizeArray<string> * ?defines: string * ?fallbacks: EffectFallbacks * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) * ?indexParameters: obj -> Effect
        /// <summary>Directly creates a webGL program</summary>
        /// <param name="vertexCode">defines the vertex shader code to use</param>
        /// <param name="fragmentCode">defines the fragment shader code to use</param>
        /// <param name="context">defines the webGL context to use (if not set, the current one will be used)</param>
        /// <param name="transformFeedbackVaryings">defines the list of transform feedback varyings to use</param>
        abstract createRawShaderProgram: vertexCode: string * fragmentCode: string * ?context: WebGLRenderingContext * ?transformFeedbackVaryings: ResizeArray<string> -> WebGLProgram
        /// <summary>Creates a webGL program</summary>
        /// <param name="vertexCode">defines the vertex shader code to use</param>
        /// <param name="fragmentCode">defines the fragment shader code to use</param>
        /// <param name="defines">defines the string containing the defines to use to compile the shaders</param>
        /// <param name="context">defines the webGL context to use (if not set, the current one will be used)</param>
        /// <param name="transformFeedbackVaryings">defines the list of transform feedback varyings to use</param>
        abstract createShaderProgram: vertexCode: string * fragmentCode: string * defines: Nullable<string> * ?context: WebGLRenderingContext * ?transformFeedbackVaryings: ResizeArray<string> -> WebGLProgram
        /// <summary>Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names</summary>
        /// <param name="shaderProgram">defines the webGL program to use</param>
        /// <param name="uniformsNames">defines the list of uniform names</param>
        abstract getUniforms: shaderProgram: WebGLProgram * uniformsNames: ResizeArray<string> -> ResizeArray<Nullable<WebGLUniformLocation>>
        /// <summary>Gets the lsit of active attributes for a given webGL program</summary>
        /// <param name="shaderProgram">defines the webGL program to use</param>
        /// <param name="attributesNames">defines the list of attribute names to get</param>
        abstract getAttributes: shaderProgram: WebGLProgram * attributesNames: ResizeArray<string> -> ResizeArray<float>
        /// <summary>Activates an effect, mkaing it the current one (ie. the one used for rendering)</summary>
        /// <param name="effect">defines the effect to activate</param>
        abstract enableEffect: effect: Nullable<Effect> -> unit
        /// <summary>Set the value of an uniform to an array of int32</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of int32 to store</param>
        abstract setIntArray: uniform: Nullable<WebGLUniformLocation> * array: Int32Array -> unit
        /// <summary>Set the value of an uniform to an array of int32 (stored as vec2)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of int32 to store</param>
        abstract setIntArray2: uniform: Nullable<WebGLUniformLocation> * array: Int32Array -> unit
        /// <summary>Set the value of an uniform to an array of int32 (stored as vec3)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of int32 to store</param>
        abstract setIntArray3: uniform: Nullable<WebGLUniformLocation> * array: Int32Array -> unit
        /// <summary>Set the value of an uniform to an array of int32 (stored as vec4)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of int32 to store</param>
        abstract setIntArray4: uniform: Nullable<WebGLUniformLocation> * array: Int32Array -> unit
        /// <summary>Set the value of an uniform to an array of float32</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of float32 to store</param>
        abstract setFloatArray: uniform: Nullable<WebGLUniformLocation> * array: Float32Array -> unit
        /// <summary>Set the value of an uniform to an array of float32 (stored as vec2)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of float32 to store</param>
        abstract setFloatArray2: uniform: Nullable<WebGLUniformLocation> * array: Float32Array -> unit
        /// <summary>Set the value of an uniform to an array of float32 (stored as vec3)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of float32 to store</param>
        abstract setFloatArray3: uniform: Nullable<WebGLUniformLocation> * array: Float32Array -> unit
        /// <summary>Set the value of an uniform to an array of float32 (stored as vec4)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of float32 to store</param>
        abstract setFloatArray4: uniform: Nullable<WebGLUniformLocation> * array: Float32Array -> unit
        /// <summary>Set the value of an uniform to an array of number</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of number to store</param>
        abstract setArray: uniform: Nullable<WebGLUniformLocation> * array: ResizeArray<float> -> unit
        /// <summary>Set the value of an uniform to an array of number (stored as vec2)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of number to store</param>
        abstract setArray2: uniform: Nullable<WebGLUniformLocation> * array: ResizeArray<float> -> unit
        /// <summary>Set the value of an uniform to an array of number (stored as vec3)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of number to store</param>
        abstract setArray3: uniform: Nullable<WebGLUniformLocation> * array: ResizeArray<float> -> unit
        /// <summary>Set the value of an uniform to an array of number (stored as vec4)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of number to store</param>
        abstract setArray4: uniform: Nullable<WebGLUniformLocation> * array: ResizeArray<float> -> unit
        /// <summary>Set the value of an uniform to an array of float32 (stored as matrices)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="matrices">defines the array of float32 to store</param>
        abstract setMatrices: uniform: Nullable<WebGLUniformLocation> * matrices: Float32Array -> unit
        /// <summary>Set the value of an uniform to a matrix</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="matrix">defines the matrix to store</param>
        abstract setMatrix: uniform: Nullable<WebGLUniformLocation> * matrix: Matrix -> unit
        /// <summary>Set the value of an uniform to a matrix (3x3)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="matrix">defines the Float32Array representing the 3x3 matrix to store</param>
        abstract setMatrix3x3: uniform: Nullable<WebGLUniformLocation> * matrix: Float32Array -> unit
        /// <summary>Set the value of an uniform to a matrix (2x2)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="matrix">defines the Float32Array representing the 2x2 matrix to store</param>
        abstract setMatrix2x2: uniform: Nullable<WebGLUniformLocation> * matrix: Float32Array -> unit
        /// <summary>Set the value of an uniform to a number (int)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="value">defines the int number to store</param>
        abstract setInt: uniform: Nullable<WebGLUniformLocation> * value: float -> unit
        /// <summary>Set the value of an uniform to a number (float)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="value">defines the float number to store</param>
        abstract setFloat: uniform: Nullable<WebGLUniformLocation> * value: float -> unit
        /// <summary>Set the value of an uniform to a vec2</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="x">defines the 1st component of the value</param>
        /// <param name="y">defines the 2nd component of the value</param>
        abstract setFloat2: uniform: Nullable<WebGLUniformLocation> * x: float * y: float -> unit
        /// <summary>Set the value of an uniform to a vec3</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="x">defines the 1st component of the value</param>
        /// <param name="y">defines the 2nd component of the value</param>
        /// <param name="z">defines the 3rd component of the value</param>
        abstract setFloat3: uniform: Nullable<WebGLUniformLocation> * x: float * y: float * z: float -> unit
        /// <summary>Set the value of an uniform to a boolean</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="bool">defines the boolean to store</param>
        abstract setBool: uniform: Nullable<WebGLUniformLocation> * bool: float -> unit
        /// <summary>Set the value of an uniform to a vec4</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="x">defines the 1st component of the value</param>
        /// <param name="y">defines the 2nd component of the value</param>
        /// <param name="z">defines the 3rd component of the value</param>
        /// <param name="w">defines the 4th component of the value</param>
        abstract setFloat4: uniform: Nullable<WebGLUniformLocation> * x: float * y: float * z: float * w: float -> unit
        /// <summary>Set the value of an uniform to a Color3</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="color3">defines the color to store</param>
        abstract setColor3: uniform: Nullable<WebGLUniformLocation> * color3: Color3 -> unit
        /// <summary>Set the value of an uniform to a Color3 and an alpha value</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="color3">defines the color to store</param>
        /// <param name="alpha">defines the alpha component to store</param>
        abstract setColor4: uniform: Nullable<WebGLUniformLocation> * color3: Color3 * alpha: float -> unit
        /// <summary>Sets a Color4 on a uniform variable</summary>
        /// <param name="uniform">defines the uniform location</param>
        /// <param name="color4">defines the value to be set</param>
        abstract setDirectColor4: uniform: Nullable<WebGLUniformLocation> * color4: Color4 -> unit
        /// <summary>Set various states to the webGL context</summary>
        /// <param name="culling">defines backface culling state</param>
        /// <param name="zOffset">defines the value to apply to zOffset (0 by default)</param>
        /// <param name="force">defines if states must be applied even if cache is up to date</param>
        /// <param name="reverseSide">defines if culling must be reversed (CCW instead of CW and CW instead of CCW)</param>
        abstract setState: culling: bool * ?zOffset: float * ?force: bool * ?reverseSide: bool -> unit
        /// <summary>Set the z offset to apply to current rendering</summary>
        /// <param name="value">defines the offset to apply</param>
        abstract setZOffset: value: float -> unit
        /// Gets the current value of the zOffset
        abstract getZOffset: unit -> float
        /// <summary>Enable or disable depth buffering</summary>
        /// <param name="enable">defines the state to set</param>
        abstract setDepthBuffer: enable: bool -> unit
        /// Gets a boolean indicating if depth writing is enabled
        abstract getDepthWrite: unit -> bool
        /// <summary>Enable or disable depth writing</summary>
        /// <param name="enable">defines the state to set</param>
        abstract setDepthWrite: enable: bool -> unit
        /// <summary>Enable or disable color writing</summary>
        /// <param name="enable">defines the state to set</param>
        abstract setColorWrite: enable: bool -> unit
        /// Gets a boolean indicating if color writing is enabled
        abstract getColorWrite: unit -> bool
        /// <summary>Sets alpha constants used by some alpha blending modes</summary>
        /// <param name="r">defines the red component</param>
        /// <param name="g">defines the green component</param>
        /// <param name="b">defines the blue component</param>
        /// <param name="a">defines the alpha component</param>
        abstract setAlphaConstants: r: float * g: float * b: float * a: float -> unit
        /// <summary>Sets the current alpha mode</summary>
        /// <param name="mode">defines the mode to use (one of the BABYLON.Engine.ALPHA_XXX)</param>
        /// <param name="noDepthWriteChange">defines if depth writing state should remains unchanged (false by default)</param>
        abstract setAlphaMode: mode: float * ?noDepthWriteChange: bool -> unit
        /// Gets the current alpha mode
        abstract getAlphaMode: unit -> float
        /// Clears the list of texture accessible through engine.
        /// This can help preventing texture load conflict due to name collision.
        abstract clearInternalTexturesCache: unit -> unit
        /// <summary>Force the entire cache to be cleared
        /// You should not have to use this function unless your engine needs to share the webGL context with another engine</summary>
        /// <param name="bruteForce">defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)</param>
        abstract wipeCaches: ?bruteForce: bool -> unit
        /// <summary>Set the compressed texture format to use, based on the formats you have, and the formats
        /// supported by the hardware / browser.
        /// 
        /// Khronos Texture Container (.ktx) files are used to support this.  This format has the
        /// advantage of being specifically designed for OpenGL.  Header elements directly correspond
        /// to API arguments needed to compressed textures.  This puts the burden on the container
        /// generator to house the arcane code for determining these for current & future formats.
        /// 
        /// for description see https://www.khronos.org/opengles/sdk/tools/KTX/
        /// for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
        /// 
        /// Note: The result of this call is not taken into account when a texture is base64.</summary>
        /// <param name="formatsAvailable">defines the list of those format families you have created
        /// on your server.  Syntax: '-' + format family + '.ktx'.  (Case and order do not matter.)
        /// 
        /// Current families are astc, dxt, pvrtc, etc2, & etc1.</param>
        abstract setTextureFormatToUse: formatsAvailable: Array<string> -> Nullable<string>
        abstract _createTexture: unit -> WebGLTexture
        /// <summary>Usually called from BABYLON.Texture.ts.
        /// Passed information to create a WebGLTexture</summary>
        /// <param name="urlArg">defines a value which contains one of the following:
        /// * A conventional http URL, e.g. 'http://...' or 'file://...'
        /// * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
        /// * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'</param>
        /// <param name="noMipmap">defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file</param>
        /// <param name="invertY">when true, image is flipped when loaded.  You probably want true. Ignored for compressed textures.  Must be flipped in the file</param>
        /// <param name="scene">needed for loading to the correct scene</param>
        /// <param name="samplingMode">mode with should be used sample / access the texture (Default: BABYLON.Texture.TRILINEAR_SAMPLINGMODE)</param>
        /// <param name="onLoad">optional callback to be called upon successful completion</param>
        /// <param name="onError">optional callback to be called upon failure</param>
        /// <param name="buffer">a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob</param>
        /// <param name="fallback">an internal argument in case the function must be called again, due to etc1 not having alpha capabilities</param>
        /// <param name="format">internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures</param>
        /// <param name="forcedExtension">defines the extension to use to pick the right loader</param>
        abstract createTexture: urlArg: Nullable<string> * noMipmap: bool * invertY: bool * scene: Nullable<Scene> * ?samplingMode: float * ?onLoad: (unit -> unit) * ?onError: (string -> obj option -> unit) * ?buffer: U4<string, ArrayBuffer, HTMLImageElement, Blob> * ?fallback: InternalTexture * ?format: float * ?forcedExtension: string -> InternalTexture
        /// <summary>Update a raw texture</summary>
        /// <param name="texture">defines the texture to update</param>
        /// <param name="data">defines the data to store in the texture</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="compression">defines the compression used (null by default)</param>
        /// <param name="type">defines the type fo the data (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)</param>
        abstract updateRawTexture: texture: Nullable<InternalTexture> * data: Nullable<ArrayBufferView> * format: float * invertY: bool * ?compression: string * ?``type``: float -> unit
        /// <summary>Creates a raw texture</summary>
        /// <param name="data">defines the data to store in the texture</param>
        /// <param name="width">defines the width of the texture</param>
        /// <param name="height">defines the height of the texture</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="generateMipMaps">defines if the engine should generate the mip levels</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="samplingMode">defines the required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)</param>
        /// <param name="compression">defines the compression used (null by default)</param>
        /// <param name="type">defines the type fo the data (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)</param>
        abstract createRawTexture: data: Nullable<ArrayBufferView> * width: float * height: float * format: float * generateMipMaps: bool * invertY: bool * samplingMode: float * ?compression: string * ?``type``: float -> InternalTexture
        /// In case you are sharing the context with other applications, it might
        /// be interested to not cache the unpack flip y state to ensure a consistent
        /// value would be set.
        abstract enableUnpackFlipYCached: bool with get, set
        abstract _unpackFlipY: value: bool -> unit
        abstract _getUnpackAlignement: unit -> float
        /// <summary>Creates a dynamic texture</summary>
        /// <param name="width">defines the width of the texture</param>
        /// <param name="height">defines the height of the texture</param>
        /// <param name="generateMipMaps">defines if the engine should generate the mip levels</param>
        /// <param name="samplingMode">defines the required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)</param>
        abstract createDynamicTexture: width: float * height: float * generateMipMaps: bool * samplingMode: float -> InternalTexture
        /// <summary>Update the sampling mode of a given texture</summary>
        /// <param name="samplingMode">defines the required sampling mode</param>
        /// <param name="texture">defines the texture to update</param>
        abstract updateTextureSamplingMode: samplingMode: float * texture: InternalTexture -> unit
        /// <summary>Update the content of a dynamic texture</summary>
        /// <param name="texture">defines the texture to update</param>
        /// <param name="canvas">defines the canvas containing the source</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="premulAlpha">defines if alpha is stored as premultiplied</param>
        /// <param name="format">defines the format of the data</param>
        abstract updateDynamicTexture: texture: Nullable<InternalTexture> * canvas: HTMLCanvasElement * invertY: bool * ?premulAlpha: bool * ?format: float -> unit
        /// <summary>Update a video texture</summary>
        /// <param name="texture">defines the texture to update</param>
        /// <param name="video">defines the video element to use</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        abstract updateVideoTexture: texture: Nullable<InternalTexture> * video: HTMLVideoElement * invertY: bool -> unit
        /// <summary>Updates a depth texture Comparison Mode and Function.
        /// If the comparison Function is equal to 0, the mode will be set to none.
        /// Otherwise, this only works in webgl 2 and requires a shadow sampler in the shader.</summary>
        /// <param name="texture">The texture to set the comparison function for</param>
        /// <param name="comparisonFunction">The comparison function to set, 0 if no comparison required</param>
        abstract updateTextureComparisonFunction: texture: InternalTexture * comparisonFunction: float -> unit
        /// <summary>Creates a depth stencil texture.
        /// This is only available in WebGL 2 or with the depth texture extension available.</summary>
        /// <param name="size">The size of face edge in the texture.</param>
        /// <param name="options">The options defining the texture.</param>
        abstract createDepthStencilTexture: size: U2<float, TypeLiteral_08> * options: DepthTextureCreationOptions -> InternalTexture
        /// <summary>Sets the frame buffer Depth / Stencil attachement of the render target to the defined depth stencil texture.</summary>
        /// <param name="renderTarget">The render target to set the frame buffer for</param>
        abstract setFrameBufferDepthStencilTexture: renderTarget: RenderTargetTexture -> unit
        /// <summary>Creates a new render target texture</summary>
        /// <param name="size">defines the size of the texture</param>
        /// <param name="options">defines the options used to create the texture</param>
        abstract createRenderTargetTexture: size: U2<float, TypeLiteral_08> * options: U2<bool, RenderTargetCreationOptions> -> InternalTexture
        /// <summary>Create a multi render target texture</summary>
        /// <param name="size">defines the size of the texture</param>
        /// <param name="options">defines the creation options</param>
        abstract createMultipleRenderTarget: size: obj option * options: IMultiRenderTargetOptions -> ResizeArray<InternalTexture>
        /// <summary>Updates the sample count of a render target texture</summary>
        /// <param name="texture">defines the texture to update</param>
        /// <param name="samples">defines the sample count to set</param>
        abstract updateRenderTargetTextureSampleCount: texture: Nullable<InternalTexture> * samples: float -> float
        /// <summary>Update the sample count for a given multiple render target texture</summary>
        /// <param name="textures">defines the textures to update</param>
        /// <param name="samples">defines the sample count to set</param>
        abstract updateMultipleRenderTargetTextureSampleCount: textures: Nullable<ResizeArray<InternalTexture>> * samples: float -> float
        abstract _uploadCompressedDataToTextureDirectly: texture: InternalTexture * internalFormat: float * width: float * height: float * data: ArrayBufferView * ?faceIndex: float * ?lod: float -> unit
        abstract _uploadDataToTextureDirectly: texture: InternalTexture * imageData: ArrayBufferView * ?faceIndex: float * ?lod: float -> unit
        abstract _uploadArrayBufferViewToTexture: texture: InternalTexture * imageData: ArrayBufferView * ?faceIndex: float * ?lod: float -> unit
        abstract _uploadImageToTexture: texture: InternalTexture * image: HTMLImageElement * ?faceIndex: float * ?lod: float -> unit
        /// <summary>Creates a new render target cube texture</summary>
        /// <param name="size">defines the size of the texture</param>
        /// <param name="options">defines the options used to create the texture</param>
        abstract createRenderTargetCubeTexture: size: float * ?options: obj -> InternalTexture
        /// <summary>Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)</summary>
        /// <param name="rootUrl">defines the url where the file to load is located</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="lodScale">defines scale to apply to the mip map selection</param>
        /// <param name="lodOffset">defines offset to apply to the mip map selection</param>
        /// <param name="onLoad">defines an optional callback raised when the texture is loaded</param>
        /// <param name="onError">defines an optional callback raised if there is an issue to load the texture</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="forcedExtension">defines the extension to use to pick the right loader</param>
        /// <param name="createPolynomials">defines wheter or not to create polynomails harmonics for the texture</param>
        abstract createPrefilteredCubeTexture: rootUrl: string * scene: Nullable<Scene> * lodScale: float * lodOffset: float * ?onLoad: (Nullable<InternalTexture> -> unit) * ?onError: (string -> obj -> unit) * ?format: float * ?forcedExtension: obj * ?createPolynomials: bool -> InternalTexture
        /// <summary>Creates a cube texture</summary>
        /// <param name="rootUrl">defines the url where the files to load is located</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="files">defines the list of files to load (1 per face)</param>
        /// <param name="noMipmap">defines a boolean indicating that no mipmaps shall be generated (false by default)</param>
        /// <param name="onLoad">defines an optional callback raised when the texture is loaded</param>
        /// <param name="onError">defines an optional callback raised if there is an issue to load the texture</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="forcedExtension">defines the extension to use to pick the right loader</param>
        /// <param name="createPolynomials">if a polynomial sphere should be created for the cube texture</param>
        /// <param name="lodScale">defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness</param>
        /// <param name="lodOffset">defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness</param>
        /// <param name="fallback">defines texture to use while falling back when (compressed) texture file not found.</param>
        abstract createCubeTexture: rootUrl: string * scene: Nullable<Scene> * files: Nullable<ResizeArray<string>> * ?noMipmap: bool * ?onLoad: (obj -> unit) * ?onError: (string -> obj -> unit) * ?format: float * ?forcedExtension: obj * ?createPolynomials: bool * ?lodScale: float * ?lodOffset: float * ?fallback: InternalTexture -> InternalTexture
        abstract _setCubeMapTextureParams: loadMipmap: bool -> unit
        /// <summary>Update a raw cube texture</summary>
        /// <param name="texture">defines the texture to udpdate</param>
        /// <param name="data">defines the data to store</param>
        /// <param name="format">defines the data format</param>
        /// <param name="type">defines the type fo the data (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="compression">defines the compression used (null by default)</param>
        /// <param name="level">defines which level of the texture to update</param>
        abstract updateRawCubeTexture: texture: InternalTexture * data: ResizeArray<ArrayBufferView> * format: float * ``type``: float * invertY: bool * ?compression: string * ?level: float -> unit
        /// <summary>Creates a new raw cube texture</summary>
        /// <param name="data">defines the array of data to use to create each face</param>
        /// <param name="size">defines the size of the textures</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="type">defines the type of the data (like BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT)</param>
        /// <param name="generateMipMaps">defines if the engine should generate the mip levels</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="samplingMode">defines the required sampling mode (like BABYLON.Texture.NEAREST_SAMPLINGMODE)</param>
        /// <param name="compression">defines the compression used (null by default)</param>
        abstract createRawCubeTexture: data: Nullable<ResizeArray<ArrayBufferView>> * size: float * format: float * ``type``: float * generateMipMaps: bool * invertY: bool * samplingMode: float * ?compression: string -> InternalTexture
        /// <summary>Creates a new raw cube texture from a specified url</summary>
        /// <param name="url">defines the url where the data is located</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="size">defines the size of the textures</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="type">defines the type fo the data (like BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT)</param>
        /// <param name="noMipmap">defines if the engine should avoid generating the mip levels</param>
        /// <param name="callback">defines a callback used to extract texture data from loaded data</param>
        /// <param name="mipmapGenerator">defines to provide an optional tool to generate mip levels</param>
        /// <param name="onLoad">defines a callback called when texture is loaded</param>
        /// <param name="onError">defines a callback called if there is an error</param>
        /// <param name="samplingMode">defines the required sampling mode (like BABYLON.Texture.NEAREST_SAMPLINGMODE)</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        abstract createRawCubeTextureFromUrl: url: string * scene: Scene * size: float * format: float * ``type``: float * noMipmap: bool * callback: (ArrayBuffer -> Nullable<ResizeArray<ArrayBufferView>>) * mipmapGenerator: Nullable<(ResizeArray<ArrayBufferView> -> ResizeArray<ResizeArray<ArrayBufferView>>)> * ?onLoad: (unit -> unit) * ?onError: (string -> obj -> unit) * ?samplingMode: float * ?invertY: bool -> InternalTexture
        /// <summary>Update a raw 3D texture</summary>
        /// <param name="texture">defines the texture to update</param>
        /// <param name="data">defines the data to store</param>
        /// <param name="format">defines the data format</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="compression">defines the used compression (can be null)</param>
        /// <param name="textureType">defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)</param>
        abstract updateRawTexture3D: texture: InternalTexture * data: Nullable<ArrayBufferView> * format: float * invertY: bool * ?compression: string * ?textureType: float -> unit
        /// <summary>Creates a new raw 3D texture</summary>
        /// <param name="data">defines the data used to create the texture</param>
        /// <param name="width">defines the width of the texture</param>
        /// <param name="height">defines the height of the texture</param>
        /// <param name="depth">defines the depth of the texture</param>
        /// <param name="format">defines the format of the texture</param>
        /// <param name="generateMipMaps">defines if the engine must generate mip levels</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="samplingMode">defines the required sampling mode (like BABYLON.Texture.NEAREST_SAMPLINGMODE)</param>
        /// <param name="compression">defines the compressed used (can be null)</param>
        /// <param name="textureType">defines the compressed used (can be null)</param>
        abstract createRawTexture3D: data: Nullable<ArrayBufferView> * width: float * height: float * depth: float * format: float * generateMipMaps: bool * invertY: bool * samplingMode: float * ?compression: string * ?textureType: float -> InternalTexture
        abstract _releaseFramebufferObjects: texture: InternalTexture -> unit
        abstract _releaseTexture: texture: InternalTexture -> unit
        /// <summary>Binds an effect to the webGL context</summary>
        /// <param name="effect">defines the effect to bind</param>
        abstract bindSamplers: effect: Effect -> unit
        abstract _bindTextureDirectly: target: float * texture: Nullable<InternalTexture> * ?forTextureDataUpdate: bool * ?force: bool -> bool
        abstract _bindTexture: channel: float * texture: Nullable<InternalTexture> -> unit
        /// <summary>Sets a texture to the webGL context from a postprocess</summary>
        /// <param name="channel">defines the channel to use</param>
        /// <param name="postProcess">defines the source postprocess</param>
        abstract setTextureFromPostProcess: channel: float * postProcess: Nullable<PostProcess> -> unit
        /// <summary>Binds the output of the passed in post process to the texture channel specified</summary>
        /// <param name="channel">The channel the texture should be bound to</param>
        /// <param name="postProcess">The post process which's output should be bound</param>
        abstract setTextureFromPostProcessOutput: channel: float * postProcess: Nullable<PostProcess> -> unit
        /// Unbind all textures from the webGL context
        abstract unbindAllTextures: unit -> unit
        /// <summary>Sets a texture to the according uniform.</summary>
        /// <param name="channel">The texture channel</param>
        /// <param name="uniform">The uniform to set</param>
        /// <param name="texture">The texture to apply</param>
        abstract setTexture: channel: float * uniform: Nullable<WebGLUniformLocation> * texture: Nullable<BaseTexture> -> unit
        /// <summary>Sets a depth stencil texture from a render target to the according uniform.</summary>
        /// <param name="channel">The texture channel</param>
        /// <param name="uniform">The uniform to set</param>
        /// <param name="texture">The render target texture containing the depth stencil texture to apply</param>
        abstract setDepthStencilTexture: channel: float * uniform: Nullable<WebGLUniformLocation> * texture: Nullable<RenderTargetTexture> -> unit
        /// <summary>Sets an array of texture to the webGL context</summary>
        /// <param name="channel">defines the channel where the texture array must be set</param>
        /// <param name="uniform">defines the associated uniform location</param>
        /// <param name="textures">defines the array of textures to bind</param>
        abstract setTextureArray: channel: float * uniform: Nullable<WebGLUniformLocation> * textures: ResizeArray<BaseTexture> -> unit
        abstract _setAnisotropicLevel: target: float * texture: BaseTexture -> unit
        /// <summary>Reads pixels from the current frame buffer. Please note that this function can be slow</summary>
        /// <param name="x">defines the x coordinate of the rectangle where pixels must be read</param>
        /// <param name="y">defines the y coordinate of the rectangle where pixels must be read</param>
        /// <param name="width">defines the width of the rectangle where pixels must be read</param>
        /// <param name="height">defines the height of the rectangle where pixels must be read</param>
        abstract readPixels: x: float * y: float * width: float * height: float -> Uint8Array
        /// <summary>Add an externaly attached data from its key.
        /// This method call will fail and return false, if such key already exists.
        /// If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.</summary>
        /// <param name="key">the unique key that identifies the data</param>
        /// <param name="data">the data object to associate to the key for this Engine instance</param>
        abstract addExternalData: key: string * data: 'T -> bool
        /// <summary>Get an externaly attached data from its key</summary>
        /// <param name="key">the unique key that identifies the data</param>
        abstract getExternalData: key: string -> 'T
        /// <summary>Get an externaly attached data from its key, create it using a factory if it's not already present</summary>
        /// <param name="key">the unique key that identifies the data</param>
        /// <param name="factory">the factory that will be called to create the instance if and only if it doesn't exists</param>
        abstract getOrAddExternalDataWithFactory: key: string * factory: (string -> 'T) -> 'T
        /// <summary>Remove an externaly attached data from the Engine instance</summary>
        /// <param name="key">the unique key that identifies the data</param>
        abstract removeExternalData: key: string -> bool
        /// Unbind all vertex attributes from the webGL context
        abstract unbindAllAttributes: unit -> unit
        /// Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
        abstract releaseEffects: unit -> unit
        /// Dispose and release all associated resources
        abstract dispose: unit -> unit
        /// Display the loading screen
        abstract displayLoadingUI: unit -> unit
        /// Hide the loading screen
        abstract hideLoadingUI: unit -> unit
        /// Gets the current loading screen object
        /// Sets the current loading screen object
        abstract loadingScreen: ILoadingScreen with get, set
        /// Sets the current loading screen text
        abstract loadingUIText: string with get, set
        /// Sets the current loading screen background color
        abstract loadingUIBackgroundColor: string with get, set
        /// <summary>Attach a new callback raised when context lost event is fired</summary>
        /// <param name="callback">defines the callback to call</param>
        abstract attachContextLostEvent: callback: (WebGLContextEvent -> unit) -> unit
        /// <summary>Attach a new callback raised when context restored event is fired</summary>
        /// <param name="callback">defines the callback to call</param>
        abstract attachContextRestoredEvent: callback: (WebGLContextEvent -> unit) -> unit
        /// <summary>Gets the source code of the vertex shader associated with a specific webGL program</summary>
        /// <param name="program">defines the program to use</param>
        abstract getVertexShaderSource: program: WebGLProgram -> Nullable<string>
        /// <summary>Gets the source code of the fragment shader associated with a specific webGL program</summary>
        /// <param name="program">defines the program to use</param>
        abstract getFragmentShaderSource: program: WebGLProgram -> Nullable<string>
        /// Get the current error code of the webGL context
        abstract getError: unit -> float
        /// Gets the current framerate
        abstract getFps: unit -> float
        /// Gets the time spent between current and previous frame
        abstract getDeltaTime: unit -> float
        abstract _readTexturePixels: texture: InternalTexture * width: float * height: float * ?faceIndex: float * ?level: float * ?buffer: ArrayBufferView -> ArrayBufferView
        abstract _getWebGLTextureType: ``type``: float -> float
        abstract _getRGBABufferInternalSizedFormat: ``type``: float * ?format: float -> float
        abstract _getRGBAMultiSampleBufferFormat: ``type``: float -> float
        abstract _loadFile: url: string * onSuccess: (U2<string, ArrayBuffer> -> string -> unit) * ?onProgress: (obj option -> unit) * ?database: Database * ?useArrayBuffer: bool * ?onError: (XMLHttpRequest -> obj -> unit) -> IFileRequest
        abstract _loadFileAsync: url: string * ?database: Database * ?useArrayBuffer: bool -> Promise<U2<string, ArrayBuffer>>
        /// <summary>Create an effect to use with particle systems.
        /// Please note that some parameters like animation sheets or not being billboard are not supported in this configuration</summary>
        /// <param name="fragmentName">defines the base name of the effect (The name of file without .fragment.fx)</param>
        /// <param name="uniformsNames">defines a list of attribute names</param>
        /// <param name="samplers">defines an array of string used to represent textures</param>
        /// <param name="defines">defines the string containing the defines to use to compile the shaders</param>
        /// <param name="fallbacks">defines the list of potential fallbacks to use if shader conmpilation fails</param>
        /// <param name="onCompiled">defines a function to call when the effect creation is successful</param>
        /// <param name="onError">defines a function to call when the effect creation has failed</param>
        abstract createEffectForParticles: fragmentName: string * uniformsNames: ResizeArray<string> * samplers: ResizeArray<string> * defines: string * ?fallbacks: EffectFallbacks * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) -> Effect
        /// Create a new webGL query (you must be sure that queries are supported by checking getCaps() function)
        abstract createQuery: unit -> WebGLQuery
        /// <summary>Delete and release a webGL query</summary>
        /// <param name="query">defines the query to delete</param>
        abstract deleteQuery: query: WebGLQuery -> Engine
        /// <summary>Check if a given query has resolved and got its value</summary>
        /// <param name="query">defines the query to check</param>
        abstract isQueryResultAvailable: query: WebGLQuery -> bool
        /// <summary>Gets the value of a given query</summary>
        /// <param name="query">defines the query to check</param>
        abstract getQueryResult: query: WebGLQuery -> float
        /// <summary>Initiates an occlusion query</summary>
        /// <param name="algorithmType">defines the algorithm to use</param>
        /// <param name="query">defines the query to use</param>
        abstract beginOcclusionQuery: algorithmType: float * query: WebGLQuery -> Engine
        /// <summary>Ends an occlusion query</summary>
        /// <param name="algorithmType">defines the algorithm to use</param>
        abstract endOcclusionQuery: algorithmType: float -> Engine
        /// Starts a time query (used to measure time spent by the GPU on a specific frame)
        /// Please note that only one query can be issued at a time
        abstract startTimeQuery: unit -> Nullable<_TimeToken>
        /// <summary>Ends a time query</summary>
        /// <param name="token">defines the token used to measure the time span</param>
        abstract endTimeQuery: token: _TimeToken -> int
        abstract _currentNonTimestampToken: Nullable<_TimeToken> with get, set
        abstract _createTimeQuery: unit -> WebGLQuery
        abstract _deleteTimeQuery: query: WebGLQuery -> unit
        abstract _getGlAlgorithmType: algorithmType: float -> float
        abstract _getTimeQueryResult: query: WebGLQuery -> obj option
        abstract _getTimeQueryAvailability: query: WebGLQuery -> obj option
        /// Creates a webGL transform feedback object
        /// Please makes sure to check webGLVersion property to check if you are running webGL 2+
        abstract createTransformFeedback: unit -> WebGLTransformFeedback
        /// <summary>Delete a webGL transform feedback object</summary>
        /// <param name="value">defines the webGL transform feedback object to delete</param>
        abstract deleteTransformFeedback: value: WebGLTransformFeedback -> unit
        /// <summary>Bind a webGL transform feedback object to the webgl context</summary>
        /// <param name="value">defines the webGL transform feedback object to bind</param>
        abstract bindTransformFeedback: value: Nullable<WebGLTransformFeedback> -> unit
        /// <summary>Begins a transform feedback operation</summary>
        /// <param name="usePoints">defines if points or triangles must be used</param>
        abstract beginTransformFeedback: usePoints: bool -> unit
        /// Ends a transform feedback operation
        abstract endTransformFeedback: unit -> unit
        /// <summary>Specify the varyings to use with transform feedback</summary>
        /// <param name="program">defines the associated webGL program</param>
        /// <param name="value">defines the list of strings representing the varying names</param>
        abstract setTranformFeedbackVaryings: program: WebGLProgram * value: ResizeArray<string> -> unit
        /// <summary>Bind a webGL buffer for a transform feedback operation</summary>
        /// <param name="value">defines the webGL buffer to bind</param>
        abstract bindTransformFeedbackBuffer: value: Nullable<WebGLBuffer> -> unit

    type [<AllowNullLiteral>] EngineGetGlInfoReturn =
        abstract vendor: string with get, set
        abstract renderer: string with get, set
        abstract version: string with get, set

    type [<AllowNullLiteral>] EngineRecordVertexArrayObjectVertexBuffers =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> VertexBuffer with get, set

    type [<AllowNullLiteral>] EngineBindBuffersVertexBuffers =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> Nullable<VertexBuffer> with get, set

    /// The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio
    type [<AllowNullLiteral>] EngineStatic =
        /// Use this array to turn off some WebGL2 features on known buggy browsers version 
        abstract ExceptionList: ResizeArray<U2<TypeLiteral_15, TypeLiteral_16>> with get, set
        /// Gets the list of created engines 
        abstract Instances: ResizeArray<Engine> with get, set
        /// Gets the latest created engine
        abstract LastCreatedEngine: Nullable<Engine>
        /// Gets the latest created scene
        abstract LastCreatedScene: Nullable<Scene>
        /// <summary>Will flag all materials in all scenes in all engines as dirty to trigger new shader compilation</summary>
        /// <param name="flag">defines which part of the materials must be marked as dirty</param>
        /// <param name="predicate">defines a predicate used to filter which materials should be affected</param>
        abstract MarkAllMaterialsAsDirty: flag: float * ?predicate: (Material -> bool) -> unit
        /// Hidden
        abstract _TextureLoaders: ResizeArray<IInternalTextureLoader> with get, set
        /// Defines that alpha blending is disabled 
        abstract ALPHA_DISABLE: float
        /// Defines that alpha blending to SRC ALPHA * SRC + DEST 
        abstract ALPHA_ADD: float
        /// Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST 
        abstract ALPHA_COMBINE: float
        /// Defines that alpha blending to DEST - SRC * DEST 
        abstract ALPHA_SUBTRACT: float
        /// Defines that alpha blending to SRC * DEST 
        abstract ALPHA_MULTIPLY: float
        /// Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC) * DEST 
        abstract ALPHA_MAXIMIZED: float
        /// Defines that alpha blending to SRC + DEST 
        abstract ALPHA_ONEONE: float
        /// Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST 
        abstract ALPHA_PREMULTIPLIED: float
        /// Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST
        /// Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA
        abstract ALPHA_PREMULTIPLIED_PORTERDUFF: float
        /// Defines that alpha blending to CST * SRC + (1 - CST) * DEST 
        abstract ALPHA_INTERPOLATE: float
        /// Defines that alpha blending to SRC + (1 - SRC) * DEST
        /// Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA
        abstract ALPHA_SCREENMODE: float
        /// Defines that the ressource is not delayed
        abstract DELAYLOADSTATE_NONE: float
        /// Defines that the ressource was successfully delay loaded 
        abstract DELAYLOADSTATE_LOADED: float
        /// Defines that the ressource is currently delay loading 
        abstract DELAYLOADSTATE_LOADING: float
        /// Defines that the ressource is delayed and has not started loading 
        abstract DELAYLOADSTATE_NOTLOADED: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn 
        abstract NEVER: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn 
        abstract ALWAYS: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value 
        abstract LESS: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value 
        abstract EQUAL: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value 
        abstract LEQUAL: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value 
        abstract GREATER: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value 
        abstract GEQUAL: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value 
        abstract NOTEQUAL: float
        /// Passed to stencilOperation to specify that stencil value must be kept 
        abstract KEEP: float
        /// Passed to stencilOperation to specify that stencil value must be replaced 
        abstract REPLACE: float
        /// Passed to stencilOperation to specify that stencil value must be incremented 
        abstract INCR: float
        /// Passed to stencilOperation to specify that stencil value must be decremented 
        abstract DECR: float
        /// Passed to stencilOperation to specify that stencil value must be inverted 
        abstract INVERT: float
        /// Passed to stencilOperation to specify that stencil value must be incremented with wrapping 
        abstract INCR_WRAP: float
        /// Passed to stencilOperation to specify that stencil value must be decremented with wrapping 
        abstract DECR_WRAP: float
        /// Texture is not repeating outside of 0..1 UVs 
        abstract TEXTURE_CLAMP_ADDRESSMODE: float
        /// Texture is repeating outside of 0..1 UVs 
        abstract TEXTURE_WRAP_ADDRESSMODE: float
        /// Texture is repeating and mirrored 
        abstract TEXTURE_MIRROR_ADDRESSMODE: float
        /// ALPHA 
        abstract TEXTUREFORMAT_ALPHA: float
        /// LUMINANCE 
        abstract TEXTUREFORMAT_LUMINANCE: float
        /// LUMINANCE_ALPHA 
        abstract TEXTUREFORMAT_LUMINANCE_ALPHA: float
        /// RGB 
        abstract TEXTUREFORMAT_RGB: float
        /// RGBA 
        abstract TEXTUREFORMAT_RGBA: float
        /// RED 
        abstract TEXTUREFORMAT_RED: float
        /// RED (2nd reference) 
        abstract TEXTUREFORMAT_R: float
        /// RG 
        abstract TEXTUREFORMAT_RG: float
        /// RED_INTEGER 
        abstract TEXTUREFORMAT_RED_INTEGER: float
        /// RED_INTEGER (2nd reference) 
        abstract TEXTUREFORMAT_R_INTEGER: float
        /// RG_INTEGER 
        abstract TEXTUREFORMAT_RG_INTEGER: float
        /// RGB_INTEGER 
        abstract TEXTUREFORMAT_RGB_INTEGER: float
        /// RGBA_INTEGER 
        abstract TEXTUREFORMAT_RGBA_INTEGER: float
        /// UNSIGNED_BYTE 
        abstract TEXTURETYPE_UNSIGNED_BYTE: float
        /// UNSIGNED_BYTE (2nd reference) 
        abstract TEXTURETYPE_UNSIGNED_INT: float
        /// FLOAT 
        abstract TEXTURETYPE_FLOAT: float
        /// HALF_FLOAT 
        abstract TEXTURETYPE_HALF_FLOAT: float
        /// BYTE 
        abstract TEXTURETYPE_BYTE: float
        /// SHORT 
        abstract TEXTURETYPE_SHORT: float
        /// UNSIGNED_SHORT 
        abstract TEXTURETYPE_UNSIGNED_SHORT: float
        /// INT 
        abstract TEXTURETYPE_INT: float
        /// UNSIGNED_INT 
        abstract TEXTURETYPE_UNSIGNED_INTEGER: float
        /// UNSIGNED_SHORT_4_4_4_4 
        abstract TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4: float
        /// UNSIGNED_SHORT_5_5_5_1 
        abstract TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1: float
        /// UNSIGNED_SHORT_5_6_5 
        abstract TEXTURETYPE_UNSIGNED_SHORT_5_6_5: float
        /// UNSIGNED_INT_2_10_10_10_REV 
        abstract TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV: float
        /// UNSIGNED_INT_24_8 
        abstract TEXTURETYPE_UNSIGNED_INT_24_8: float
        /// UNSIGNED_INT_10F_11F_11F_REV 
        abstract TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV: float
        /// UNSIGNED_INT_5_9_9_9_REV 
        abstract TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV: float
        /// FLOAT_32_UNSIGNED_INT_24_8_REV 
        abstract TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV: float
        /// nearest is mag = nearest and min = nearest and mip = linear 
        abstract TEXTURE_NEAREST_SAMPLINGMODE: float
        /// Bilinear is mag = linear and min = linear and mip = nearest 
        abstract TEXTURE_BILINEAR_SAMPLINGMODE: float
        /// Trilinear is mag = linear and min = linear and mip = linear 
        abstract TEXTURE_TRILINEAR_SAMPLINGMODE: float
        /// nearest is mag = nearest and min = nearest and mip = linear 
        abstract TEXTURE_NEAREST_NEAREST_MIPLINEAR: float
        /// Bilinear is mag = linear and min = linear and mip = nearest 
        abstract TEXTURE_LINEAR_LINEAR_MIPNEAREST: float
        /// Trilinear is mag = linear and min = linear and mip = linear 
        abstract TEXTURE_LINEAR_LINEAR_MIPLINEAR: float
        /// mag = nearest and min = nearest and mip = nearest 
        abstract TEXTURE_NEAREST_NEAREST_MIPNEAREST: float
        /// mag = nearest and min = linear and mip = nearest 
        abstract TEXTURE_NEAREST_LINEAR_MIPNEAREST: float
        /// mag = nearest and min = linear and mip = linear 
        abstract TEXTURE_NEAREST_LINEAR_MIPLINEAR: float
        /// mag = nearest and min = linear and mip = none 
        abstract TEXTURE_NEAREST_LINEAR: float
        /// mag = nearest and min = nearest and mip = none 
        abstract TEXTURE_NEAREST_NEAREST: float
        /// mag = linear and min = nearest and mip = nearest 
        abstract TEXTURE_LINEAR_NEAREST_MIPNEAREST: float
        /// mag = linear and min = nearest and mip = linear 
        abstract TEXTURE_LINEAR_NEAREST_MIPLINEAR: float
        /// mag = linear and min = linear and mip = none 
        abstract TEXTURE_LINEAR_LINEAR: float
        /// mag = linear and min = nearest and mip = none 
        abstract TEXTURE_LINEAR_NEAREST: float
        /// Explicit coordinates mode 
        abstract TEXTURE_EXPLICIT_MODE: float
        /// Spherical coordinates mode 
        abstract TEXTURE_SPHERICAL_MODE: float
        /// Planar coordinates mode 
        abstract TEXTURE_PLANAR_MODE: float
        /// Cubic coordinates mode 
        abstract TEXTURE_CUBIC_MODE: float
        /// Projection coordinates mode 
        abstract TEXTURE_PROJECTION_MODE: float
        /// Skybox coordinates mode 
        abstract TEXTURE_SKYBOX_MODE: float
        /// Inverse Cubic coordinates mode 
        abstract TEXTURE_INVCUBIC_MODE: float
        /// Equirectangular coordinates mode 
        abstract TEXTURE_EQUIRECTANGULAR_MODE: float
        /// Equirectangular Fixed coordinates mode 
        abstract TEXTURE_FIXED_EQUIRECTANGULAR_MODE: float
        /// Equirectangular Fixed Mirrored coordinates mode 
        abstract TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE: float
        /// Defines that texture rescaling will use a floor to find the closer power of 2 size 
        abstract SCALEMODE_FLOOR: float
        /// Defines that texture rescaling will look for the nearest power of 2 size 
        abstract SCALEMODE_NEAREST: float
        /// Defines that texture rescaling will use a ceil to find the closer power of 2 size 
        abstract SCALEMODE_CEILING: float
        /// Returns the current version of the framework
        abstract Version: string
        /// Gets or sets the epsilon value used by collision engine
        abstract CollisionsEpsilon: float with get, set
        /// Gets or sets the relative url used to load code if using the engine in non-minified mode
        abstract CodeRepository: string with get, set
        /// Gets or sets the relative url used to load shaders if using the engine in non-minified mode
        abstract ShadersRepository: string with get, set
        /// Gets the audio engine
        abstract audioEngine: IAudioEngine with get, set
        /// Default AudioEngine Factory responsible of creating the Audio Engine.
        /// By default, this will create a BabylonJS Audio Engine if the workload
        /// has been embedded.
        abstract AudioEngineFactory: (Nullable<HTMLElement> -> IAudioEngine) with get, set
        /// <summary>Creates a new engine</summary>
        /// <param name="canvasOrContext">defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which alreay used the WebGL context</param>
        /// <param name="antialias">defines enable antialiasing (default: false)</param>
        /// <param name="options">defines further options to be sent to the getContext() function</param>
        /// <param name="adaptToDeviceRatio">defines whether to adapt to the device's viewport characteristics (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: canvasOrContext: Nullable<U2<HTMLCanvasElement, WebGLRenderingContext>> * ?antialias: bool * ?options: EngineOptions * ?adaptToDeviceRatio: bool -> Engine
        /// Gets a boolean indicating if the engine can be instanciated (ie. if a webGL context can be found)
        abstract isSupported: unit -> bool

    /// Options to create the null engine
    type [<AllowNullLiteral>] NullEngineOptions =
        /// Render width (Default: 512)
        abstract renderWidth: float with get, set
        /// Render height (Default: 256)
        abstract renderHeight: float with get, set
        /// Texture size (Default: 512)
        abstract textureSize: float with get, set
        /// If delta time between frames should be constant
        abstract deterministicLockstep: bool with get, set
        /// Maximum about of steps between frames (Default: 4)
        abstract lockstepMaxSteps: float with get, set

    /// Options to create the null engine
    type [<AllowNullLiteral>] NullEngineOptionsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> NullEngineOptions

    /// The null engine class provides support for headless version of babylon.js.
    /// This can be used in server side scenario or for testing purposes
    type [<AllowNullLiteral>] NullEngine =
        inherit Engine
        abstract isDeterministicLockStep: unit -> bool
        abstract getLockstepMaxSteps: unit -> float
        /// Sets hardware scaling, used to save performance if needed
        abstract getHardwareScalingLevel: unit -> float
        abstract createVertexBuffer: vertices: FloatArray -> WebGLBuffer
        abstract createIndexBuffer: indices: IndicesArray -> WebGLBuffer
        abstract clear: color: Color4 * backBuffer: bool * depth: bool * ?stencil: bool -> unit
        abstract getRenderWidth: ?useScreen: bool -> float
        abstract getRenderHeight: ?useScreen: bool -> float
        abstract setViewport: viewport: Viewport * ?requiredWidth: float * ?requiredHeight: float -> unit
        abstract createShaderProgram: vertexCode: string * fragmentCode: string * defines: string * ?context: WebGLRenderingContext -> WebGLProgram
        abstract getUniforms: shaderProgram: WebGLProgram * uniformsNames: ResizeArray<string> -> ResizeArray<WebGLUniformLocation>
        abstract getAttributes: shaderProgram: WebGLProgram * attributesNames: ResizeArray<string> -> ResizeArray<float>
        abstract bindSamplers: effect: Effect -> unit
        abstract enableEffect: effect: Effect -> unit
        abstract setState: culling: bool * ?zOffset: float * ?force: bool * ?reverseSide: bool -> unit
        abstract setIntArray: uniform: WebGLUniformLocation * array: Int32Array -> unit
        abstract setIntArray2: uniform: WebGLUniformLocation * array: Int32Array -> unit
        abstract setIntArray3: uniform: WebGLUniformLocation * array: Int32Array -> unit
        abstract setIntArray4: uniform: WebGLUniformLocation * array: Int32Array -> unit
        abstract setFloatArray: uniform: WebGLUniformLocation * array: Float32Array -> unit
        abstract setFloatArray2: uniform: WebGLUniformLocation * array: Float32Array -> unit
        abstract setFloatArray3: uniform: WebGLUniformLocation * array: Float32Array -> unit
        abstract setFloatArray4: uniform: WebGLUniformLocation * array: Float32Array -> unit
        abstract setArray: uniform: WebGLUniformLocation * array: ResizeArray<float> -> unit
        abstract setArray2: uniform: WebGLUniformLocation * array: ResizeArray<float> -> unit
        abstract setArray3: uniform: WebGLUniformLocation * array: ResizeArray<float> -> unit
        abstract setArray4: uniform: WebGLUniformLocation * array: ResizeArray<float> -> unit
        abstract setMatrices: uniform: WebGLUniformLocation * matrices: Float32Array -> unit
        abstract setMatrix: uniform: WebGLUniformLocation * matrix: Matrix -> unit
        abstract setMatrix3x3: uniform: WebGLUniformLocation * matrix: Float32Array -> unit
        abstract setMatrix2x2: uniform: WebGLUniformLocation * matrix: Float32Array -> unit
        abstract setFloat: uniform: WebGLUniformLocation * value: float -> unit
        abstract setFloat2: uniform: WebGLUniformLocation * x: float * y: float -> unit
        abstract setFloat3: uniform: WebGLUniformLocation * x: float * y: float * z: float -> unit
        abstract setBool: uniform: WebGLUniformLocation * bool: float -> unit
        abstract setFloat4: uniform: WebGLUniformLocation * x: float * y: float * z: float * w: float -> unit
        abstract setColor3: uniform: WebGLUniformLocation * color3: Color3 -> unit
        abstract setColor4: uniform: WebGLUniformLocation * color3: Color3 * alpha: float -> unit
        abstract setAlphaMode: mode: float * ?noDepthWriteChange: bool -> unit
        abstract bindBuffers: vertexBuffers: NullEngineBindBuffersVertexBuffers * indexBuffer: WebGLBuffer * effect: Effect -> unit
        abstract wipeCaches: ?bruteForce: bool -> unit
        abstract draw: useTriangles: bool * indexStart: float * indexCount: float * ?instancesCount: float -> unit
        abstract drawElementsType: fillMode: float * indexStart: float * indexCount: float * ?instancesCount: float -> unit
        abstract drawArraysType: fillMode: float * verticesStart: float * verticesCount: float * ?instancesCount: float -> unit
        abstract _createTexture: unit -> WebGLTexture
        abstract _releaseTexture: texture: InternalTexture -> unit
        abstract createTexture: urlArg: string * noMipmap: bool * invertY: bool * scene: Scene * ?samplingMode: float * ?onLoad: (unit -> unit) * ?onError: (string -> obj option -> unit) * ?buffer: U2<ArrayBuffer, HTMLImageElement> * ?fallBack: InternalTexture * ?format: float -> InternalTexture
        abstract createRenderTargetTexture: size: obj option * options: U2<bool, RenderTargetCreationOptions> -> InternalTexture
        abstract updateTextureSamplingMode: samplingMode: float * texture: InternalTexture -> unit
        abstract bindFramebuffer: texture: InternalTexture * ?faceIndex: float * ?requiredWidth: float * ?requiredHeight: float * ?forceFullscreenViewport: bool -> unit
        abstract unBindFramebuffer: texture: InternalTexture * ?disableGenerateMipMaps: bool * ?onBeforeUnbind: (unit -> unit) -> unit
        abstract createDynamicVertexBuffer: vertices: FloatArray -> WebGLBuffer
        abstract updateDynamicTexture: texture: Nullable<InternalTexture> * canvas: HTMLCanvasElement * invertY: bool * ?premulAlpha: bool * ?format: float -> unit
        abstract getError: unit -> float
        abstract _getUnpackAlignement: unit -> float
        abstract _unpackFlipY: value: bool -> unit
        abstract updateDynamicIndexBuffer: indexBuffer: WebGLBuffer * indices: IndicesArray * ?offset: float -> unit
        /// <summary>Updates a dynamic vertex buffer.</summary>
        /// <param name="vertexBuffer">the vertex buffer to update</param>
        /// <param name="byteOffset">the byte offset of the data (optional)</param>
        /// <param name="byteLength">the byte length of the data (optional)</param>
        abstract updateDynamicVertexBuffer: vertexBuffer: WebGLBuffer * vertices: FloatArray * ?byteOffset: float * ?byteLength: float -> unit
        abstract _bindTextureDirectly: target: float * texture: InternalTexture -> bool
        abstract _bindTexture: channel: float * texture: InternalTexture -> unit
        abstract _releaseBuffer: buffer: WebGLBuffer -> bool
        abstract releaseEffects: unit -> unit
        abstract displayLoadingUI: unit -> unit
        abstract hideLoadingUI: unit -> unit
        abstract _uploadCompressedDataToTextureDirectly: texture: InternalTexture * internalFormat: float * width: float * height: float * data: ArrayBufferView * ?faceIndex: float * ?lod: float -> unit
        abstract _uploadDataToTextureDirectly: texture: InternalTexture * imageData: ArrayBufferView * ?faceIndex: float * ?lod: float -> unit
        abstract _uploadArrayBufferViewToTexture: texture: InternalTexture * imageData: ArrayBufferView * ?faceIndex: float * ?lod: float -> unit
        abstract _uploadImageToTexture: texture: InternalTexture * image: HTMLImageElement * ?faceIndex: float * ?lod: float -> unit

    type [<AllowNullLiteral>] NullEngineBindBuffersVertexBuffers =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> VertexBuffer with get, set

    /// The null engine class provides support for headless version of babylon.js.
    /// This can be used in server side scenario or for testing purposes
    type [<AllowNullLiteral>] NullEngineStatic =
        [<Emit "new $0($1...)">] abstract Create: ?options: NullEngineOptions -> NullEngine

    /// Class used to store bounding box information
    type [<AllowNullLiteral>] BoundingBox =
        inherit ICullable
        /// Gets the 8 vectors representing the bounding box in local space
        abstract vectors: ResizeArray<Vector3> with get, set
        /// Gets the center of the bounding box in local space
        abstract center: Vector3 with get, set
        /// Gets the center of the bounding box in world space
        abstract centerWorld: Vector3 with get, set
        /// Gets the extend size in local space
        abstract extendSize: Vector3 with get, set
        /// Gets the extend size in world space
        abstract extendSizeWorld: Vector3 with get, set
        /// Gets the OBB (object bounding box) directions
        abstract directions: ResizeArray<Vector3> with get, set
        /// Gets the 8 vectors representing the bounding box in world space
        abstract vectorsWorld: ResizeArray<Vector3> with get, set
        /// Gets the minimum vector in world space
        abstract minimumWorld: Vector3 with get, set
        /// Gets the maximum vector in world space
        abstract maximumWorld: Vector3 with get, set
        /// Gets the minimum vector in local space
        abstract minimum: Vector3 with get, set
        /// Gets the maximum vector in local space
        abstract maximum: Vector3 with get, set
        abstract _tag: float with get, set
        /// <summary>Recreates the entire bounding box from scratch</summary>
        /// <param name="min">defines the new minimum vector (in local space)</param>
        /// <param name="max">defines the new maximum vector (in local space)</param>
        abstract reConstruct: min: Vector3 * max: Vector3 -> unit
        /// <summary>Scale the current bounding box by applying a scale factor</summary>
        /// <param name="factor">defines the scale factor to apply</param>
        abstract scale: factor: float -> BoundingBox
        /// Gets the world matrix of the bounding box
        abstract getWorldMatrix: unit -> Matrix
        /// <summary>Sets the world matrix stored in the bounding box</summary>
        /// <param name="matrix">defines the matrix to store</param>
        abstract setWorldMatrix: matrix: Matrix -> BoundingBox
        abstract _update: world: Matrix -> unit
        /// <summary>Tests if the bounding box is intersecting the frustum planes</summary>
        /// <param name="frustumPlanes">defines the frustum planes to test</param>
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// <summary>Tests if the bounding box is entirely inside the frustum planes</summary>
        /// <param name="frustumPlanes">defines the frustum planes to test</param>
        abstract isCompletelyInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// <summary>Tests if a point is inside the bounding box</summary>
        /// <param name="point">defines the point to test</param>
        abstract intersectsPoint: point: Vector3 -> bool
        /// <summary>Tests if the bounding box intersects with a bounding sphere</summary>
        /// <param name="sphere">defines the sphere to test</param>
        abstract intersectsSphere: sphere: BoundingSphere -> bool
        /// <summary>Tests if the bounding box intersects with a box defined by a min and max vectors</summary>
        /// <param name="min">defines the min vector to use</param>
        /// <param name="max">defines the max vector to use</param>
        abstract intersectsMinMax: min: Vector3 * max: Vector3 -> bool

    /// Class used to store bounding box information
    type [<AllowNullLiteral>] BoundingBoxStatic =
        /// <summary>Creates a new bounding box</summary>
        /// <param name="min">defines the minimum vector (in local space)</param>
        /// <param name="max">defines the maximum vector (in local space)</param>
        [<Emit "new $0($1...)">] abstract Create: min: Vector3 * max: Vector3 -> BoundingBox
        /// <summary>Tests if two bounding boxes are intersections</summary>
        /// <param name="box0">defines the first box to test</param>
        /// <param name="box1">defines the second box to test</param>
        abstract Intersects: box0: BoundingBox * box1: BoundingBox -> bool
        /// <summary>Tests if a bounding box defines by a min/max vectors intersects a sphere</summary>
        /// <param name="minPoint">defines the minimum vector of the bounding box</param>
        /// <param name="maxPoint">defines the maximum vector of the bounding box</param>
        /// <param name="sphereCenter">defines the sphere center</param>
        /// <param name="sphereRadius">defines the sphere radius</param>
        abstract IntersectsSphere: minPoint: Vector3 * maxPoint: Vector3 * sphereCenter: Vector3 * sphereRadius: float -> bool
        /// <summary>Tests if a bounding box defined with 8 vectors is entirely inside frustum planes</summary>
        /// <param name="boundingVectors">defines an array of 8 vectors representing a bounding box</param>
        /// <param name="frustumPlanes">defines the frustum planes to test</param>
        abstract IsCompletelyInFrustum: boundingVectors: ResizeArray<Vector3> * frustumPlanes: ResizeArray<Plane> -> bool
        /// <summary>Tests if a bounding box defined with 8 vectors intersects frustum planes</summary>
        /// <param name="boundingVectors">defines an array of 8 vectors representing a bounding box</param>
        /// <param name="frustumPlanes">defines the frustum planes to test</param>
        abstract IsInFrustum: boundingVectors: ResizeArray<Vector3> * frustumPlanes: ResizeArray<Plane> -> bool

    /// Interface for cullable objects
    type [<AllowNullLiteral>] ICullable =
        /// <summary>Checks if the object or part of the object is in the frustum</summary>
        /// <param name="frustumPlanes">Camera near/planes</param>
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// <summary>Checks if a cullable object (mesh...) is in the camera frustum
        /// Unlike isInFrustum this cheks the full bounding box</summary>
        /// <param name="frustumPlanes">Camera near/planes</param>
        abstract isCompletelyInFrustum: frustumPlanes: ResizeArray<Plane> -> bool

    /// Info for a bounding data of a mesh
    type [<AllowNullLiteral>] BoundingInfo =
        inherit ICullable
        /// Bounding box for the mesh
        abstract boundingBox: BoundingBox with get, set
        /// Bounding sphere for the mesh
        abstract boundingSphere: BoundingSphere with get, set
        /// min vector of the bounding box/sphere
        abstract minimum: Vector3
        /// max vector of the bounding box/sphere
        abstract maximum: Vector3
        /// If the info is locked and won't be updated to avoid perf overhead
        abstract isLocked: bool with get, set
        /// <summary>Updates the boudning sphere and box</summary>
        /// <param name="world">world matrix to be used to update</param>
        abstract update: world: Matrix -> unit
        /// <summary>Recreate the bounding info to be centered around a specific point given a specific extend.</summary>
        /// <param name="center">New center of the bounding info</param>
        /// <param name="extend">New extend of the bounding info</param>
        abstract centerOn: center: Vector3 * extend: Vector3 -> BoundingInfo
        /// <summary>Scale the current bounding info by applying a scale factor</summary>
        /// <param name="factor">defines the scale factor to apply</param>
        abstract scale: factor: float -> BoundingInfo
        /// <summary>Returns `true` if the bounding info is within the frustum defined by the passed array of planes.</summary>
        /// <param name="frustumPlanes">defines the frustum to test</param>
        /// <param name="strategy">defines the strategy to use for the culling (default is BABYLON.Scene.CULLINGSTRATEGY_STANDARD)</param>
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> * ?strategy: float -> bool
        /// Gets the world distance between the min and max points of the bounding box
        abstract diagonalLength: float
        /// <summary>Checks if a cullable object (mesh...) is in the camera frustum
        /// Unlike isInFrustum this cheks the full bounding box</summary>
        /// <param name="frustumPlanes">Camera near/planes</param>
        abstract isCompletelyInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        abstract _checkCollision: collider: Collider -> bool
        /// <summary>Checks if a point is inside the bounding box and bounding sphere or the mesh</summary>
        /// <param name="point">the point to check intersection with</param>
        abstract intersectsPoint: point: Vector3 -> bool
        /// <summary>Checks if another bounding info intersects the bounding box and bounding sphere or the mesh</summary>
        /// <param name="boundingInfo">the bounding info to check intersection with</param>
        /// <param name="precise">if the intersection should be done using OBB</param>
        abstract intersects: boundingInfo: BoundingInfo * precise: bool -> bool

    /// Info for a bounding data of a mesh
    type [<AllowNullLiteral>] BoundingInfoStatic =
        /// <summary>Constructs bounding info</summary>
        /// <param name="minimum">min vector of the bounding box/sphere</param>
        /// <param name="maximum">max vector of the bounding box/sphere</param>
        [<Emit "new $0($1...)">] abstract Create: minimum: Vector3 * maximum: Vector3 -> BoundingInfo

    /// Class used to store bounding sphere information
    type [<AllowNullLiteral>] BoundingSphere =
        /// Gets the center of the bounding sphere in local space
        abstract center: Vector3 with get, set
        /// Radius of the bounding sphere in local space
        abstract radius: float with get, set
        /// Gets the center of the bounding sphere in world space
        abstract centerWorld: Vector3 with get, set
        /// Radius of the bounding sphere in world space
        abstract radiusWorld: float with get, set
        /// Gets the minimum vector in local space
        abstract minimum: Vector3 with get, set
        /// Gets the maximum vector in local space
        abstract maximum: Vector3 with get, set
        /// <summary>Recreates the entire bounding sphere from scratch</summary>
        /// <param name="min">defines the new minimum vector (in local space)</param>
        /// <param name="max">defines the new maximum vector (in local space)</param>
        abstract reConstruct: min: Vector3 * max: Vector3 -> unit
        /// <summary>Scale the current bounding sphere by applying a scale factor</summary>
        /// <param name="factor">defines the scale factor to apply</param>
        abstract scale: factor: float -> BoundingSphere
        abstract _update: world: Matrix -> unit
        /// <summary>Tests if the bounding sphere is intersecting the frustum planes</summary>
        /// <param name="frustumPlanes">defines the frustum planes to test</param>
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// <summary>Tests if a point is inside the bounding sphere</summary>
        /// <param name="point">defines the point to test</param>
        abstract intersectsPoint: point: Vector3 -> bool

    /// Class used to store bounding sphere information
    type [<AllowNullLiteral>] BoundingSphereStatic =
        /// <summary>Creates a new bounding sphere</summary>
        /// <param name="min">defines the minimum vector (in local space)</param>
        /// <param name="max">defines the maximum vector (in local space)</param>
        [<Emit "new $0($1...)">] abstract Create: min: Vector3 * max: Vector3 -> BoundingSphere
        /// <summary>Checks if two sphere intersct</summary>
        /// <param name="sphere0">sphere 0</param>
        /// <param name="sphere1">sphere 1</param>
        abstract Intersects: sphere0: BoundingSphere * sphere1: BoundingSphere -> bool

    /// Class representing a ray with position and direction
    type [<AllowNullLiteral>] Ray =
        /// origin point 
        abstract origin: Vector3 with get, set
        /// direction 
        abstract direction: Vector3 with get, set
        /// length of the ray 
        abstract length: float with get, set
        /// <summary>Checks if the ray intersects a box</summary>
        /// <param name="minimum">bound of the box</param>
        /// <param name="maximum">bound of the box</param>
        abstract intersectsBoxMinMax: minimum: Vector3 * maximum: Vector3 -> bool
        /// <summary>Checks if the ray intersects a box</summary>
        /// <param name="box">the bounding box to check</param>
        abstract intersectsBox: box: BoundingBox -> bool
        /// <summary>If the ray hits a sphere</summary>
        /// <param name="sphere">the bounding sphere to check</param>
        abstract intersectsSphere: sphere: BoundingSphere -> bool
        /// <summary>If the ray hits a triange</summary>
        /// <param name="vertex0">triangle vertex</param>
        /// <param name="vertex1">triangle vertex</param>
        /// <param name="vertex2">triangle vertex</param>
        abstract intersectsTriangle: vertex0: Vector3 * vertex1: Vector3 * vertex2: Vector3 -> Nullable<IntersectionInfo>
        /// <summary>Checks if ray intersects a plane</summary>
        /// <param name="plane">the plane to check</param>
        abstract intersectsPlane: plane: Plane -> Nullable<float>
        /// <summary>Checks if ray intersects a mesh</summary>
        /// <param name="mesh">the mesh to check</param>
        /// <param name="fastCheck">if only the bounding box should checked</param>
        abstract intersectsMesh: mesh: AbstractMesh * ?fastCheck: bool -> PickingInfo
        /// <summary>Checks if ray intersects a mesh</summary>
        /// <param name="meshes">the meshes to check</param>
        /// <param name="fastCheck">if only the bounding box should checked</param>
        /// <param name="results">array to store result in</param>
        abstract intersectsMeshes: meshes: Array<AbstractMesh> * ?fastCheck: bool * ?results: Array<PickingInfo> -> Array<PickingInfo>
        /// <summary>Intersection test between the ray and a given segment whithin a given tolerance (threshold)</summary>
        /// <param name="sega">the first point of the segment to test the intersection against</param>
        /// <param name="segb">the second point of the segment to test the intersection against</param>
        /// <param name="threshold">the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful</param>
        abstract intersectionSegment: sega: Vector3 * segb: Vector3 * threshold: float -> float
        /// <summary>Update the ray from viewport position</summary>
        /// <param name="x">position</param>
        /// <param name="y">y position</param>
        /// <param name="viewportWidth">viewport width</param>
        /// <param name="viewportHeight">viewport height</param>
        /// <param name="world">world matrix</param>
        /// <param name="view">view matrix</param>
        /// <param name="projection">projection matrix</param>
        abstract update: x: float * y: float * viewportWidth: float * viewportHeight: float * world: Matrix * view: Matrix * projection: Matrix -> Ray

    /// Class representing a ray with position and direction
    type [<AllowNullLiteral>] RayStatic =
        /// <summary>Creates a new ray</summary>
        /// <param name="origin">origin point</param>
        /// <param name="direction">direction</param>
        /// <param name="length">length of the ray</param>
        [<Emit "new $0($1...)">] abstract Create: origin: Vector3 * direction: Vector3 * ?length: float -> Ray
        /// Creates a ray with origin and direction of 0,0,0
        abstract Zero: unit -> Ray
        /// <summary>Creates a new ray from screen space and viewport</summary>
        /// <param name="x">position</param>
        /// <param name="y">y position</param>
        /// <param name="viewportWidth">viewport width</param>
        /// <param name="viewportHeight">viewport height</param>
        /// <param name="world">world matrix</param>
        /// <param name="view">view matrix</param>
        /// <param name="projection">projection matrix</param>
        abstract CreateNew: x: float * y: float * viewportWidth: float * viewportHeight: float * world: Matrix * view: Matrix * projection: Matrix -> Ray
        /// <summary>Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
        /// transformed to the given world matrix.</summary>
        /// <param name="origin">The origin point</param>
        /// <param name="end">The end point</param>
        /// <param name="world">a matrix to transform the ray to. Default is the identity matrix.</param>
        abstract CreateNewFromTo: origin: Vector3 * ``end``: Vector3 * ?world: Matrix -> Ray
        /// <summary>Transforms a ray by a matrix</summary>
        /// <param name="ray">ray to transform</param>
        /// <param name="matrix">matrix to apply</param>
        abstract Transform: ray: Ray * matrix: Matrix -> Ray
        /// <summary>Transforms a ray by a matrix</summary>
        /// <param name="ray">ray to transform</param>
        /// <param name="matrix">matrix to apply</param>
        /// <param name="result">ray to store result in</param>
        abstract TransformToRef: ray: Ray * matrix: Matrix * result: Ray -> unit

    /// Gather the list of keyboard event types as constants.
    type [<AllowNullLiteral>] KeyboardEventTypes =
        interface end

    /// Gather the list of keyboard event types as constants.
    type [<AllowNullLiteral>] KeyboardEventTypesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> KeyboardEventTypes
        /// The keydown event is fired when a key becomes active (pressed).
        abstract KEYDOWN: float
        /// The keyup event is fired when a key has been released.
        abstract KEYUP: float

    /// This class is used to store keyboard related info for the onKeyboardObservable event.
    type [<AllowNullLiteral>] KeyboardInfo =
        /// Defines the type of event (BABYLON.KeyboardEventTypes)
        abstract ``type``: float with get, set
        /// Defines the related dom event
        abstract ``event``: KeyboardEvent with get, set

    /// This class is used to store keyboard related info for the onKeyboardObservable event.
    type [<AllowNullLiteral>] KeyboardInfoStatic =
        /// <summary>Instantiates a new keyboard info.
        /// This class is used to store keyboard related info for the onKeyboardObservable event.</summary>
        /// <param name="type">Defines the type of event (BABYLON.KeyboardEventTypes)</param>
        /// <param name="event">Defines the related dom event</param>
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * ``event``: KeyboardEvent -> KeyboardInfo

    /// This class is used to store keyboard related info for the onPreKeyboardObservable event.
    /// Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable
    type [<AllowNullLiteral>] KeyboardInfoPre =
        inherit KeyboardInfo
        /// Defines the type of event (BABYLON.KeyboardEventTypes)
        abstract ``type``: float with get, set
        /// Defines the related dom event
        abstract ``event``: KeyboardEvent with get, set
        /// Defines whether the engine should skip the next onKeyboardObservable associated to this pre.
        abstract skipOnPointerObservable: bool with get, set

    /// This class is used to store keyboard related info for the onPreKeyboardObservable event.
    /// Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable
    type [<AllowNullLiteral>] KeyboardInfoPreStatic =
        /// <summary>Instantiates a new keyboard pre info.
        /// This class is used to store keyboard related info for the onPreKeyboardObservable event.</summary>
        /// <param name="type">Defines the type of event (BABYLON.KeyboardEventTypes)</param>
        /// <param name="event">Defines the related dom event</param>
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * ``event``: KeyboardEvent -> KeyboardInfoPre

    /// Gather the list of pointer event types as constants.
    type [<AllowNullLiteral>] PointerEventTypes =
        interface end

    /// Gather the list of pointer event types as constants.
    type [<AllowNullLiteral>] PointerEventTypesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PointerEventTypes
        /// The pointerdown event is fired when a pointer becomes active. For mouse, it is fired when the device transitions from no buttons depressed to at least one button depressed. For touch, it is fired when physical contact is made with the digitizer. For pen, it is fired when the stylus makes physical contact with the digitizer.
        abstract POINTERDOWN: float
        /// The pointerup event is fired when a pointer is no longer active.
        abstract POINTERUP: float
        /// The pointermove event is fired when a pointer changes coordinates.
        abstract POINTERMOVE: float
        /// The pointerwheel event is fired when a mouse wheel has been rotated.
        abstract POINTERWHEEL: float
        /// The pointerpick event is fired when a mesh or sprite has been picked by the pointer.
        abstract POINTERPICK: float
        /// The pointertap event is fired when a the object has been touched and released without drag.
        abstract POINTERTAP: float
        /// The pointerdoubletap event is fired when a the object has been touched and released twice without drag.
        abstract POINTERDOUBLETAP: float

    /// Base class of pointer info types.
    type [<AllowNullLiteral>] PointerInfoBase =
        /// Defines the type of event (BABYLON.PointerEventTypes)
        abstract ``type``: float with get, set
        /// Defines the related dom event
        abstract ``event``: U2<PointerEvent, MouseWheelEvent> with get, set

    /// Base class of pointer info types.
    type [<AllowNullLiteral>] PointerInfoBaseStatic =
        /// <summary>Instantiates the base class of pointers info.</summary>
        /// <param name="type">Defines the type of event (BABYLON.PointerEventTypes)</param>
        /// <param name="event">Defines the related dom event</param>
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * ``event``: U2<PointerEvent, MouseWheelEvent> -> PointerInfoBase

    /// This class is used to store pointer related info for the onPrePointerObservable event.
    /// Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable
    type [<AllowNullLiteral>] PointerInfoPre =
        inherit PointerInfoBase
        /// Ray from a pointer if availible (eg. 6dof controller)
        abstract ray: Nullable<Ray> with get, set
        /// Defines the local position of the pointer on the canvas.
        abstract localPosition: Vector2 with get, set
        /// Defines whether the engine should skip the next OnPointerObservable associated to this pre.
        abstract skipOnPointerObservable: bool with get, set

    /// This class is used to store pointer related info for the onPrePointerObservable event.
    /// Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable
    type [<AllowNullLiteral>] PointerInfoPreStatic =
        /// <summary>Instantiates a PointerInfoPre to store pointer related info to the onPrePointerObservable event.</summary>
        /// <param name="type">Defines the type of event (BABYLON.PointerEventTypes)</param>
        /// <param name="event">Defines the related dom event</param>
        /// <param name="localX">Defines the local x coordinates of the pointer when the event occured</param>
        /// <param name="localY">Defines the local y coordinates of the pointer when the event occured</param>
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * ``event``: U2<PointerEvent, MouseWheelEvent> * localX: float * localY: float -> PointerInfoPre

    /// This type contains all the data related to a pointer event in Babylon.js.
    /// The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.
    type [<AllowNullLiteral>] PointerInfo =
        inherit PointerInfoBase
        /// Defines the picking info associated to the info (if any)\
        abstract pickInfo: Nullable<PickingInfo> with get, set

    /// This type contains all the data related to a pointer event in Babylon.js.
    /// The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.
    type [<AllowNullLiteral>] PointerInfoStatic =
        /// <summary>Instantiates a PointerInfo to store pointer related info to the onPointerObservable event.</summary>
        /// <param name="type">Defines the type of event (BABYLON.PointerEventTypes)</param>
        /// <param name="event">Defines the related dom event</param>
        /// <param name="pickInfo">Defines the picking info associated to the info (if any)\</param>
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * ``event``: U2<PointerEvent, MouseWheelEvent> * pickInfo: Nullable<PickingInfo> -> PointerInfo

    /// Represents a gamepad control stick position
    type [<AllowNullLiteral>] StickValues =
        /// The x component of the control stick
        abstract x: float with get, set
        /// The y component of the control stick
        abstract y: float with get, set

    /// Represents a gamepad control stick position
    type [<AllowNullLiteral>] StickValuesStatic =
        /// <summary>Initializes the gamepad x and y control stick values</summary>
        /// <param name="x">The x component of the gamepad control stick value</param>
        /// <param name="y">The y component of the gamepad control stick value</param>
        [<Emit "new $0($1...)">] abstract Create: x: float * y: float -> StickValues

    /// An interface which manages callbacks for gamepad button changes
    type [<AllowNullLiteral>] GamepadButtonChanges =
        /// Called when a gamepad has been changed
        abstract changed: bool with get, set
        /// Called when a gamepad press event has been triggered
        abstract pressChanged: bool with get, set
        /// Called when a touch event has been triggered
        abstract touchChanged: bool with get, set
        /// Called when a value has changed
        abstract valueChanged: bool with get, set

    /// Represents a gamepad
    type [<AllowNullLiteral>] Gamepad =
        /// The id of the gamepad
        abstract id: string with get, set
        /// The index of the gamepad
        abstract index: float with get, set
        /// The browser gamepad
        abstract browserGamepad: obj option with get, set
        /// Specifies what type of gamepad this represents
        abstract ``type``: float with get, set
        abstract _isConnected: bool with get, set
        /// Specifies whether the left control stick should be Y-inverted
        abstract _invertLeftStickY: bool with get, set
        /// Specifies if the gamepad has been connected
        abstract isConnected: bool
        /// <summary>Callback triggered when the left joystick has changed</summary>
        /// <param name="callback"></param>
        abstract onleftstickchanged: callback: (StickValues -> unit) -> unit
        /// <summary>Callback triggered when the right joystick has changed</summary>
        /// <param name="callback"></param>
        abstract onrightstickchanged: callback: (StickValues -> unit) -> unit
        /// Gets the left joystick
        /// Sets the left joystick values
        abstract leftStick: StickValues with get, set
        /// Gets the right joystick
        /// Sets the right joystick value
        abstract rightStick: StickValues with get, set
        /// Updates the gamepad joystick positions
        abstract update: unit -> unit
        /// Disposes the gamepad
        abstract dispose: unit -> unit

    /// Represents a gamepad
    type [<AllowNullLiteral>] GamepadStatic =
        /// Represents a gamepad controller
        abstract GAMEPAD: float with get, set
        /// Represents a generic controller
        abstract GENERIC: float with get, set
        /// Represents an XBox controller
        abstract XBOX: float with get, set
        /// Represents a pose-enabled controller
        abstract POSE_ENABLED: float with get, set
        /// <summary>Initializes the gamepad</summary>
        /// <param name="id">The id of the gamepad</param>
        /// <param name="index">The index of the gamepad</param>
        /// <param name="browserGamepad">The browser gamepad</param>
        /// <param name="leftStickX">The x component of the left joystick</param>
        /// <param name="leftStickY">The y component of the left joystick</param>
        /// <param name="rightStickX">The x component of the right joystick</param>
        /// <param name="rightStickY">The y component of the right joystick</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * index: float * browserGamepad: obj option * ?leftStickX: float * ?leftStickY: float * ?rightStickX: float * ?rightStickY: float -> Gamepad

    /// Represents a generic gamepad
    type [<AllowNullLiteral>] GenericPad =
        inherit Gamepad
        /// Observable triggered when a button has been pressed
        abstract onButtonDownObservable: Observable<float> with get, set
        /// Observable triggered when a button has been released
        abstract onButtonUpObservable: Observable<float> with get, set
        /// <summary>Callback triggered when a button has been pressed</summary>
        /// <param name="callback">Called when a button has been pressed</param>
        abstract onbuttondown: callback: (float -> unit) -> unit
        /// <summary>Callback triggered when a button has been released</summary>
        /// <param name="callback">Called when a button has been released</param>
        abstract onbuttonup: callback: (float -> unit) -> unit
        /// Updates the generic gamepad
        abstract update: unit -> unit
        /// Disposes the generic gamepad
        abstract dispose: unit -> unit

    /// Represents a generic gamepad
    type [<AllowNullLiteral>] GenericPadStatic =
        /// <summary>Initializes the generic gamepad</summary>
        /// <param name="id">The id of the generic gamepad</param>
        /// <param name="index">The index of the generic gamepad</param>
        /// <param name="browserGamepad">The browser gamepad</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * index: float * browserGamepad: obj option -> GenericPad

    /// Manager for handling gamepads
    type [<AllowNullLiteral>] GamepadManager =
        abstract _isMonitoring: bool with get, set
        /// observable to be triggered when the gamepad controller has been connected
        abstract onGamepadConnectedObservable: Observable<Gamepad> with get, set
        /// observable to be triggered when the gamepad controller has been disconnected
        abstract onGamepadDisconnectedObservable: Observable<Gamepad> with get, set
        /// The gamepads in the game pad manager
        abstract gamepads: ResizeArray<Gamepad>
        /// <summary>Get the gamepad controllers based on type</summary>
        /// <param name="type">The type of gamepad controller</param>
        abstract getGamepadByType: ?``type``: float -> Nullable<Gamepad>
        /// Disposes the gamepad manager
        abstract dispose: unit -> unit
        abstract _checkGamepadsStatus: unit -> unit

    /// Manager for handling gamepads
    type [<AllowNullLiteral>] GamepadManagerStatic =
        /// <summary>Initializes the gamepad manager</summary>
        /// <param name="_scene">BabylonJS scene</param>
        [<Emit "new $0($1...)">] abstract Create: ?_scene: Scene -> GamepadManager

    /// Defines the gamepad scene component responsible to manage gamepads in a given scene
    type [<AllowNullLiteral>] GamepadSystemSceneComponent =
        inherit ISceneComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources
        abstract dispose: unit -> unit

    /// Defines the gamepad scene component responsible to manage gamepads in a given scene
    type [<AllowNullLiteral>] GamepadSystemSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> GamepadSystemSceneComponent

    type [<RequireQualifiedAccess>] Xbox360Button =
        | A = 0
        | B = 1
        | X = 2
        | Y = 3
        | Start = 4
        | Back = 5
        | LB = 6
        | RB = 7
        | LeftStick = 8
        | RightStick = 9

    type [<RequireQualifiedAccess>] Xbox360Dpad =
        | Up = 0
        | Down = 1
        | Left = 2
        | Right = 3

    /// Defines a XBox360 gamepad
    type [<AllowNullLiteral>] Xbox360Pad =
        inherit Gamepad
        /// Observable raised when a button is pressed 
        abstract onButtonDownObservable: Observable<Xbox360Button> with get, set
        /// Observable raised when a button is released 
        abstract onButtonUpObservable: Observable<Xbox360Button> with get, set
        /// Observable raised when a pad is pressed 
        abstract onPadDownObservable: Observable<Xbox360Dpad> with get, set
        /// Observable raised when a pad is released 
        abstract onPadUpObservable: Observable<Xbox360Dpad> with get, set
        /// <summary>Defines the callback to call when left trigger is pressed</summary>
        /// <param name="callback">defines the callback to use</param>
        abstract onlefttriggerchanged: callback: (float -> unit) -> unit
        /// <summary>Defines the callback to call when right trigger is pressed</summary>
        /// <param name="callback">defines the callback to use</param>
        abstract onrighttriggerchanged: callback: (float -> unit) -> unit
        /// Gets the left trigger value
        /// Sets the left trigger value
        abstract leftTrigger: float with get, set
        /// Gets the right trigger value
        /// Sets the right trigger value
        abstract rightTrigger: float with get, set
        /// <summary>Defines the callback to call when a button is pressed</summary>
        /// <param name="callback">defines the callback to use</param>
        abstract onbuttondown: callback: (Xbox360Button -> unit) -> unit
        /// <summary>Defines the callback to call when a button is released</summary>
        /// <param name="callback">defines the callback to use</param>
        abstract onbuttonup: callback: (Xbox360Button -> unit) -> unit
        /// <summary>Defines the callback to call when a pad is pressed</summary>
        /// <param name="callback">defines the callback to use</param>
        abstract ondpaddown: callback: (Xbox360Dpad -> unit) -> unit
        /// <summary>Defines the callback to call when a pad is released</summary>
        /// <param name="callback">defines the callback to use</param>
        abstract ondpadup: callback: (Xbox360Dpad -> unit) -> unit
        /// Gets the value of the `A` button
        /// Sets the value of the `A` button
        abstract buttonA: float with get, set
        /// Gets the value of the `B` button
        /// Sets the value of the `B` button
        abstract buttonB: float with get, set
        /// Gets the value of the `X` button
        /// Sets the value of the `X` button
        abstract buttonX: float with get, set
        /// Gets the value of the `Y` button
        /// Sets the value of the `Y` button
        abstract buttonY: float with get, set
        /// Gets the value of the `Start` button
        /// Sets the value of the `Start` button
        abstract buttonStart: float with get, set
        /// Gets the value of the `Back` button
        /// Sets the value of the `Back` button
        abstract buttonBack: float with get, set
        /// Gets the value of the `Left` button
        /// Sets the value of the `Left` button
        abstract buttonLB: float with get, set
        /// Gets the value of the `Right` button
        /// Sets the value of the `Right` button
        abstract buttonRB: float with get, set
        /// Gets the value of the Left joystick
        /// Sets the value of the Left joystick
        abstract buttonLeftStick: float with get, set
        /// Gets the value of the Right joystick
        /// Sets the value of the Right joystick
        abstract buttonRightStick: float with get, set
        /// Gets the value of D-pad up
        /// Sets the value of D-pad up
        abstract dPadUp: float with get, set
        /// Gets the value of D-pad down
        /// Sets the value of D-pad down
        abstract dPadDown: float with get, set
        /// Gets the value of D-pad left
        /// Sets the value of D-pad left
        abstract dPadLeft: float with get, set
        /// Gets the value of D-pad right
        /// Sets the value of D-pad right
        abstract dPadRight: float with get, set
        /// Force the gamepad to synchronize with device values
        abstract update: unit -> unit
        /// Disposes the gamepad
        abstract dispose: unit -> unit

    /// Defines a XBox360 gamepad
    type [<AllowNullLiteral>] Xbox360PadStatic =
        /// <summary>Creates a new XBox360 gamepad object</summary>
        /// <param name="id">defines the id of this gamepad</param>
        /// <param name="index">defines its index</param>
        /// <param name="gamepad">defines the internal HTML gamepad object</param>
        /// <param name="xboxOne">defines if it is a XBox One gamepad</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * index: float * gamepad: obj option * ?xboxOne: bool -> Xbox360Pad

    /// Single axis drag gizmo
    type [<AllowNullLiteral>] AxisDragGizmo =
        inherit Gizmo
        /// Drag behavior responsible for the gizmos dragging interactions
        abstract dragBehavior: PointerDragBehavior with get, set
        /// Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
        abstract snapDistance: float with get, set
        /// Event that fires each time the gizmo snaps to a new location.
        /// * snapDistance is the the change in distance
        abstract onSnapObservable: Observable<TypeLiteral_17> with get, set
        abstract _attachedMeshChanged: value: Nullable<AbstractMesh> -> unit
        /// Disposes of the gizmo
        abstract dispose: unit -> unit

    /// Single axis drag gizmo
    type [<AllowNullLiteral>] AxisDragGizmoStatic =
        /// <summary>Creates an AxisDragGizmo</summary>
        /// <param name="dragAxis">The axis which the gizmo will be able to drag on</param>
        /// <param name="color">The color of the gizmo</param>
        /// <param name="gizmoLayer">The utility layer the gizmo will be added to</param>
        [<Emit "new $0($1...)">] abstract Create: dragAxis: Vector3 * ?color: Color3 * ?gizmoLayer: UtilityLayerRenderer -> AxisDragGizmo

    /// Single axis scale gizmo
    type [<AllowNullLiteral>] AxisScaleGizmo =
        inherit Gizmo
        /// Drag behavior responsible for the gizmos dragging interactions
        abstract dragBehavior: PointerDragBehavior with get, set
        /// Scale distance in babylon units that the gizmo will snap to when dragged (Default: 0)
        abstract snapDistance: float with get, set
        /// Event that fires each time the gizmo snaps to a new location.
        /// * snapDistance is the the change in distance
        abstract onSnapObservable: Observable<TypeLiteral_17> with get, set
        /// If the scaling operation should be done on all axis (default: false)
        abstract uniformScaling: bool with get, set
        abstract _attachedMeshChanged: value: Nullable<AbstractMesh> -> unit
        /// Disposes of the gizmo
        abstract dispose: unit -> unit
        /// <summary>Disposes and replaces the current meshes in the gizmo with the specified mesh</summary>
        /// <param name="mesh">The mesh to replace the default mesh of the gizmo</param>
        /// <param name="useGizmoMaterial">If the gizmo's default material should be used (default: false)</param>
        abstract setCustomMesh: mesh: Mesh * ?useGizmoMaterial: bool -> unit

    /// Single axis scale gizmo
    type [<AllowNullLiteral>] AxisScaleGizmoStatic =
        /// <summary>Creates an AxisScaleGizmo</summary>
        /// <param name="dragAxis">The axis which the gizmo will be able to scale on</param>
        /// <param name="color">The color of the gizmo</param>
        /// <param name="gizmoLayer">The utility layer the gizmo will be added to</param>
        [<Emit "new $0($1...)">] abstract Create: dragAxis: Vector3 * ?color: Color3 * ?gizmoLayer: UtilityLayerRenderer -> AxisScaleGizmo

    /// Bounding box gizmo
    type [<AllowNullLiteral>] BoundingBoxGizmo =
        inherit Gizmo
        /// If child meshes should be ignored when calculating the boudning box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)
        abstract ignoreChildren: bool with get, set
        /// Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)
        abstract includeChildPredicate: Nullable<(AbstractMesh -> bool)> with get, set
        /// The size of the rotation spheres attached to the bounding box (Default: 0.1)
        abstract rotationSphereSize: float with get, set
        /// The size of the scale boxes attached to the bounding box (Default: 0.1)
        abstract scaleBoxSize: float with get, set
        /// If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)
        abstract fixedDragMeshScreenSize: bool with get, set
        /// The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)
        abstract fixedDragMeshScreenSizeDistanceFactor: float with get, set
        /// Fired when a rotation sphere or scale box is dragged
        abstract onDragStartObservable: Observable<TypeLiteral_01> with get, set
        /// Fired when a scale box is dragged
        abstract onScaleBoxDragObservable: Observable<TypeLiteral_01> with get, set
        /// Fired when a scale box drag is ended
        abstract onScaleBoxDragEndObservable: Observable<TypeLiteral_01> with get, set
        /// Fired when a rotation sphere is dragged
        abstract onRotationSphereDragObservable: Observable<TypeLiteral_01> with get, set
        /// Fired when a rotation sphere drag is ended
        abstract onRotationSphereDragEndObservable: Observable<TypeLiteral_01> with get, set
        /// Relative bounding box pivot used when scaling the attached mesh. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)
        abstract scalePivot: Nullable<Vector3> with get, set
        abstract _attachedMeshChanged: value: Nullable<AbstractMesh> -> unit
        /// Updates the bounding box information for the Gizmo
        abstract updateBoundingBox: unit -> unit
        /// <summary>Enables rotation on the specified axis and disables rotation on the others</summary>
        /// <param name="axis">The list of axis that should be enabled (eg. "xy" or "xyz")</param>
        abstract setEnabledRotationAxis: axis: string -> unit
        /// Disposes of the gizmo
        abstract dispose: unit -> unit
        /// <summary>CustomMeshes are not supported by this gizmo</summary>
        /// <param name="mesh">The mesh to replace the default mesh of the gizmo</param>
        abstract setCustomMesh: mesh: Mesh -> unit

    /// Bounding box gizmo
    type [<AllowNullLiteral>] BoundingBoxGizmoStatic =
        abstract _RemoveAndStorePivotPoint: mesh: AbstractMesh -> unit
        abstract _RestorePivotPoint: mesh: AbstractMesh -> unit
        /// <summary>Creates an BoundingBoxGizmo</summary>
        /// <param name="color">The color of the gizmo</param>
        /// <param name="gizmoLayer">The utility layer the gizmo will be added to</param>
        [<Emit "new $0($1...)">] abstract Create: ?color: Color3 * ?gizmoLayer: UtilityLayerRenderer -> BoundingBoxGizmo
        /// <summary>Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)</summary>
        /// <param name="mesh">the mesh to wrap in the bounding box mesh and make not pickable</param>
        abstract MakeNotPickableAndWrapInBoundingBox: mesh: Mesh -> Mesh

    /// Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.
    type [<AllowNullLiteral>] Gizmo =
        inherit IDisposable
        /// The utility layer the gizmo will be added to 
        abstract gizmoLayer: UtilityLayerRenderer with get, set
        /// The root mesh of the gizmo
        abstract _rootMesh: Mesh with get, set
        /// Ratio for the scale of the gizmo (Default: 1)
        abstract scaleRatio: float with get, set
        /// If a custom mesh has been set (Default: false)
        abstract _customMeshSet: bool with get, set
        /// Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)
        /// * When set, interactions will be enabled
        abstract attachedMesh: Nullable<AbstractMesh> with get, set
        /// <summary>Disposes and replaces the current meshes in the gizmo with the specified mesh</summary>
        /// <param name="mesh">The mesh to replace the default mesh of the gizmo</param>
        abstract setCustomMesh: mesh: Mesh -> unit
        /// If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
        abstract updateGizmoRotationToMatchAttachedMesh: bool with get, set
        /// If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)
        abstract updateGizmoPositionToMatchAttachedMesh: bool with get, set
        /// When set, the gizmo will always appear the same size no matter where the camera is (default: false)
        abstract _updateScale: bool with get, set
        abstract _interactionsEnabled: bool with get, set
        abstract _attachedMeshChanged: value: Nullable<AbstractMesh> -> unit
        abstract _update: unit -> unit
        /// Disposes of the gizmo
        abstract dispose: unit -> unit

    /// Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.
    type [<AllowNullLiteral>] GizmoStatic =
        /// <summary>Creates a gizmo</summary>
        /// <param name="gizmoLayer">The utility layer the gizmo will be added to</param>
        [<Emit "new $0($1...)">] abstract Create: ?gizmoLayer: UtilityLayerRenderer -> Gizmo

    /// Helps setup gizmo's in the scene to rotate/scale/position meshes
    type [<AllowNullLiteral>] GizmoManager =
        inherit IDisposable
        /// Gizmo's created by the gizmo manager, gizmo will be null until gizmo has been enabled for the first time
        abstract gizmos: TypeLiteral_18 with get, set
        /// When bounding box gizmo is enabled, this can be used to track drag/end events
        abstract boundingBoxDragBehavior: SixDofDragBehavior with get, set
        /// Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)
        abstract attachableMeshes: Nullable<Array<AbstractMesh>> with get, set
        /// If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh. (Default: true)
        abstract usePointerToAttachGizmos: bool with get, set
        /// <summary>Attaches a set of gizmos to the specified mesh</summary>
        /// <param name="mesh">The mesh the gizmo's should be attached to</param>
        abstract attachToMesh: mesh: Nullable<AbstractMesh> -> unit
        /// If the position gizmo is enabled
        abstract positionGizmoEnabled: bool with get, set
        /// If the rotation gizmo is enabled
        abstract rotationGizmoEnabled: bool with get, set
        /// If the scale gizmo is enabled
        abstract scaleGizmoEnabled: bool with get, set
        /// If the boundingBox gizmo is enabled
        abstract boundingBoxGizmoEnabled: bool with get, set
        /// Disposes of the gizmo manager
        abstract dispose: unit -> unit

    /// Helps setup gizmo's in the scene to rotate/scale/position meshes
    type [<AllowNullLiteral>] GizmoManagerStatic =
        /// <summary>Instatiates a gizmo manager</summary>
        /// <param name="scene">the scene to overlay the gizmos on top of</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> GizmoManager

    /// Single plane rotation gizmo
    type [<AllowNullLiteral>] PlaneRotationGizmo =
        inherit Gizmo
        /// Drag behavior responsible for the gizmos dragging interactions
        abstract dragBehavior: PointerDragBehavior with get, set
        /// Rotation distance in radians that the gizmo will snap to (Default: 0)
        abstract snapDistance: float with get, set
        /// Event that fires each time the gizmo snaps to a new location.
        /// * snapDistance is the the change in distance
        abstract onSnapObservable: Observable<TypeLiteral_17> with get, set
        abstract _attachedMeshChanged: value: Nullable<AbstractMesh> -> unit
        /// Disposes of the gizmo
        abstract dispose: unit -> unit

    /// Single plane rotation gizmo
    type [<AllowNullLiteral>] PlaneRotationGizmoStatic =
        /// <summary>Creates a PlaneRotationGizmo</summary>
        /// <param name="planeNormal">The normal of the plane which the gizmo will be able to rotate on</param>
        /// <param name="color">The color of the gizmo</param>
        /// <param name="gizmoLayer">The utility layer the gizmo will be added to</param>
        /// <param name="tessellation">Amount of tessellation to be used when creating rotation circles</param>
        [<Emit "new $0($1...)">] abstract Create: planeNormal: Vector3 * ?color: Color3 * ?gizmoLayer: UtilityLayerRenderer * ?tessellation: float -> PlaneRotationGizmo

    /// Gizmo that enables dragging a mesh along 3 axis
    type [<AllowNullLiteral>] PositionGizmo =
        inherit Gizmo
        /// Internal gizmo used for interactions on the x axis
        abstract xGizmo: AxisDragGizmo with get, set
        /// Internal gizmo used for interactions on the y axis
        abstract yGizmo: AxisDragGizmo with get, set
        /// Internal gizmo used for interactions on the z axis
        abstract zGizmo: AxisDragGizmo with get, set
        /// Fires an event when any of it's sub gizmos are dragged 
        abstract onDragStartObservable: Observable<TypeLiteral_01> with get, set
        /// Fires an event when any of it's sub gizmos are released from dragging 
        abstract onDragEndObservable: Observable<TypeLiteral_01> with get, set
        abstract attachedMesh: Nullable<AbstractMesh> with get, set
        abstract updateGizmoRotationToMatchAttachedMesh: bool with get, set
        /// Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
        abstract snapDistance: float with get, set
        /// Ratio for the scale of the gizmo (Default: 1)
        abstract scaleRatio: float with get, set
        /// Disposes of the gizmo
        abstract dispose: unit -> unit
        /// <summary>CustomMeshes are not supported by this gizmo</summary>
        /// <param name="mesh">The mesh to replace the default mesh of the gizmo</param>
        abstract setCustomMesh: mesh: Mesh -> unit

    /// Gizmo that enables dragging a mesh along 3 axis
    type [<AllowNullLiteral>] PositionGizmoStatic =
        /// <summary>Creates a PositionGizmo</summary>
        /// <param name="gizmoLayer">The utility layer the gizmo will be added to</param>
        [<Emit "new $0($1...)">] abstract Create: ?gizmoLayer: UtilityLayerRenderer -> PositionGizmo

    /// Gizmo that enables rotating a mesh along 3 axis
    type [<AllowNullLiteral>] RotationGizmo =
        inherit Gizmo
        /// Internal gizmo used for interactions on the x axis
        abstract xGizmo: PlaneRotationGizmo with get, set
        /// Internal gizmo used for interactions on the y axis
        abstract yGizmo: PlaneRotationGizmo with get, set
        /// Internal gizmo used for interactions on the z axis
        abstract zGizmo: PlaneRotationGizmo with get, set
        /// Fires an event when any of it's sub gizmos are dragged 
        abstract onDragStartObservable: Observable<TypeLiteral_01> with get, set
        /// Fires an event when any of it's sub gizmos are released from dragging 
        abstract onDragEndObservable: Observable<TypeLiteral_01> with get, set
        abstract attachedMesh: Nullable<AbstractMesh> with get, set
        abstract updateGizmoRotationToMatchAttachedMesh: bool with get, set
        /// Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
        abstract snapDistance: float with get, set
        /// Ratio for the scale of the gizmo (Default: 1)
        abstract scaleRatio: float with get, set
        /// Disposes of the gizmo
        abstract dispose: unit -> unit
        /// <summary>CustomMeshes are not supported by this gizmo</summary>
        /// <param name="mesh">The mesh to replace the default mesh of the gizmo</param>
        abstract setCustomMesh: mesh: Mesh -> unit

    /// Gizmo that enables rotating a mesh along 3 axis
    type [<AllowNullLiteral>] RotationGizmoStatic =
        /// <summary>Creates a RotationGizmo</summary>
        /// <param name="gizmoLayer">The utility layer the gizmo will be added to</param>
        /// <param name="tessellation">Amount of tessellation to be used when creating rotation circles</param>
        [<Emit "new $0($1...)">] abstract Create: ?gizmoLayer: UtilityLayerRenderer * ?tessellation: float -> RotationGizmo

    /// Gizmo that enables scaling a mesh along 3 axis
    type [<AllowNullLiteral>] ScaleGizmo =
        inherit Gizmo
        /// Internal gizmo used for interactions on the x axis
        abstract xGizmo: AxisScaleGizmo with get, set
        /// Internal gizmo used for interactions on the y axis
        abstract yGizmo: AxisScaleGizmo with get, set
        /// Internal gizmo used for interactions on the z axis
        abstract zGizmo: AxisScaleGizmo with get, set
        /// Internal gizmo used to scale all axis equally
        abstract uniformScaleGizmo: AxisScaleGizmo with get, set
        /// Fires an event when any of it's sub gizmos are dragged 
        abstract onDragStartObservable: Observable<TypeLiteral_01> with get, set
        /// Fires an event when any of it's sub gizmos are released from dragging 
        abstract onDragEndObservable: Observable<TypeLiteral_01> with get, set
        abstract attachedMesh: Nullable<AbstractMesh> with get, set
        abstract updateGizmoRotationToMatchAttachedMesh: bool with get, set
        /// Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
        abstract snapDistance: float with get, set
        /// Ratio for the scale of the gizmo (Default: 1)
        abstract scaleRatio: float with get, set
        /// Disposes of the gizmo
        abstract dispose: unit -> unit

    /// Gizmo that enables scaling a mesh along 3 axis
    type [<AllowNullLiteral>] ScaleGizmoStatic =
        /// <summary>Creates a ScaleGizmo</summary>
        /// <param name="gizmoLayer">The utility layer the gizmo will be added to</param>
        [<Emit "new $0($1...)">] abstract Create: ?gizmoLayer: UtilityLayerRenderer -> ScaleGizmo

    /// This class can be used to get instrumentation data from a Babylon engine
    type [<AllowNullLiteral>] EngineInstrumentation =
        inherit IDisposable
        /// Define the instrumented engine.
        abstract engine: Engine with get, set
        /// Gets the perf counter used for GPU frame time
        abstract gpuFrameTimeCounter: PerfCounter
        /// Gets the GPU frame time capture status
        /// Enable or disable the GPU frame time capture
        abstract captureGPUFrameTime: bool with get, set
        /// Gets the perf counter used for shader compilation time
        abstract shaderCompilationTimeCounter: PerfCounter
        /// Gets the shader compilation time capture status
        /// Enable or disable the shader compilation time capture
        abstract captureShaderCompilationTime: bool with get, set
        /// Dispose and release associated resources.
        abstract dispose: unit -> unit

    /// This class can be used to get instrumentation data from a Babylon engine
    type [<AllowNullLiteral>] EngineInstrumentationStatic =
        /// <summary>Instantiates a new engine instrumentation.
        /// This class can be used to get instrumentation data from a Babylon engine</summary>
        /// <param name="engine">Defines the engine to instrument</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine -> EngineInstrumentation

    /// This class can be used to get instrumentation data from a Babylon engine
    type [<AllowNullLiteral>] SceneInstrumentation =
        inherit IDisposable
        /// Defines the scene to instrument
        abstract scene: Scene with get, set
        /// Gets the perf counter used for active meshes evaluation time
        abstract activeMeshesEvaluationTimeCounter: PerfCounter
        /// Gets the active meshes evaluation time capture status
        /// Enable or disable the active meshes evaluation time capture
        abstract captureActiveMeshesEvaluationTime: bool with get, set
        /// Gets the perf counter used for render targets render time
        abstract renderTargetsRenderTimeCounter: PerfCounter
        /// Gets the render targets render time capture status
        /// Enable or disable the render targets render time capture
        abstract captureRenderTargetsRenderTime: bool with get, set
        /// Gets the perf counter used for particles render time
        abstract particlesRenderTimeCounter: PerfCounter
        /// Gets the particles render time capture status
        /// Enable or disable the particles render time capture
        abstract captureParticlesRenderTime: bool with get, set
        /// Gets the perf counter used for sprites render time
        abstract spritesRenderTimeCounter: PerfCounter
        /// Gets the sprites render time capture status
        /// Enable or disable the sprites render time capture
        abstract captureSpritesRenderTime: bool with get, set
        /// Gets the perf counter used for physics time
        abstract physicsTimeCounter: PerfCounter
        /// Gets the physics time capture status
        /// Enable or disable the physics time capture
        abstract capturePhysicsTime: bool with get, set
        /// Gets the perf counter used for animations time
        abstract animationsTimeCounter: PerfCounter
        /// Gets the animations time capture status
        /// Enable or disable the animations time capture
        abstract captureAnimationsTime: bool with get, set
        /// Gets the perf counter used for frame time capture
        abstract frameTimeCounter: PerfCounter
        /// Gets the frame time capture status
        /// Enable or disable the frame time capture
        abstract captureFrameTime: bool with get, set
        /// Gets the perf counter used for inter-frames time capture
        abstract interFrameTimeCounter: PerfCounter
        /// Gets the inter-frames time capture status
        /// Enable or disable the inter-frames time capture
        abstract captureInterFrameTime: bool with get, set
        /// Gets the perf counter used for render time capture
        abstract renderTimeCounter: PerfCounter
        /// Gets the render time capture status
        /// Enable or disable the render time capture
        abstract captureRenderTime: bool with get, set
        /// Gets the perf counter used for camera render time capture
        abstract cameraRenderTimeCounter: PerfCounter
        /// Gets the camera render time capture status
        /// Enable or disable the camera render time capture
        abstract captureCameraRenderTime: bool with get, set
        /// Gets the perf counter used for draw calls
        abstract drawCallsCounter: PerfCounter
        /// Gets the perf counter used for texture collisions
        abstract textureCollisionsCounter: PerfCounter
        /// Dispose and release associated resources.
        abstract dispose: unit -> unit

    /// This class can be used to get instrumentation data from a Babylon engine
    type [<AllowNullLiteral>] SceneInstrumentationStatic =
        /// <summary>Instantiates a new scene instrumentation.
        /// This class can be used to get instrumentation data from a Babylon engine</summary>
        /// <param name="scene">Defines the scene to instrument</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> SceneInstrumentation

    type [<AllowNullLiteral>] _TimeToken =
        abstract _startTimeQuery: Nullable<WebGLQuery> with get, set
        abstract _endTimeQuery: Nullable<WebGLQuery> with get, set
        abstract _timeElapsedQuery: Nullable<WebGLQuery> with get, set
        abstract _timeElapsedQueryEnded: bool with get, set

    type [<AllowNullLiteral>] _TimeTokenStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> _TimeToken

    /// Represents the different options available during the creation of
    /// a Environment helper.
    /// 
    /// This can control the default ground, skybox and image processing setup of your scene.
    type [<AllowNullLiteral>] IEnvironmentHelperOptions =
        /// Specifies wether or not to create a ground.
        /// True by default.
        abstract createGround: bool with get, set
        /// Specifies the ground size.
        /// 15 by default.
        abstract groundSize: float with get, set
        /// The texture used on the ground for the main color.
        /// Comes from the BabylonJS CDN by default.
        /// 
        /// Remarks: Can be either a texture or a url.
        abstract groundTexture: U2<string, BaseTexture> with get, set
        /// The color mixed in the ground texture by default.
        /// BabylonJS clearColor by default.
        abstract groundColor: Color3 with get, set
        /// Specifies the ground opacity.
        /// 1 by default.
        abstract groundOpacity: float with get, set
        /// Enables the ground to receive shadows.
        /// True by default.
        abstract enableGroundShadow: bool with get, set
        /// Helps preventing the shadow to be fully black on the ground.
        /// 0.5 by default.
        abstract groundShadowLevel: float with get, set
        /// Creates a mirror texture attach to the ground.
        /// false by default.
        abstract enableGroundMirror: bool with get, set
        /// Specifies the ground mirror size ratio.
        /// 0.3 by default as the default kernel is 64.
        abstract groundMirrorSizeRatio: float with get, set
        /// Specifies the ground mirror blur kernel size.
        /// 64 by default.
        abstract groundMirrorBlurKernel: float with get, set
        /// Specifies the ground mirror visibility amount.
        /// 1 by default
        abstract groundMirrorAmount: float with get, set
        /// Specifies the ground mirror reflectance weight.
        /// This uses the standard weight of the background material to setup the fresnel effect
        /// of the mirror.
        /// 1 by default.
        abstract groundMirrorFresnelWeight: float with get, set
        /// Specifies the ground mirror Falloff distance.
        /// This can helps reducing the size of the reflection.
        /// 0 by Default.
        abstract groundMirrorFallOffDistance: float with get, set
        /// Specifies the ground mirror texture type.
        /// Unsigned Int by Default.
        abstract groundMirrorTextureType: float with get, set
        /// Specifies a bias applied to the ground vertical position to prevent z-fighting with
        /// the shown objects.
        abstract groundYBias: float with get, set
        /// Specifies wether or not to create a skybox.
        /// True by default.
        abstract createSkybox: bool with get, set
        /// Specifies the skybox size.
        /// 20 by default.
        abstract skyboxSize: float with get, set
        /// The texture used on the skybox for the main color.
        /// Comes from the BabylonJS CDN by default.
        /// 
        /// Remarks: Can be either a texture or a url.
        abstract skyboxTexture: U2<string, BaseTexture> with get, set
        /// The color mixed in the skybox texture by default.
        /// BabylonJS clearColor by default.
        abstract skyboxColor: Color3 with get, set
        /// The background rotation around the Y axis of the scene.
        /// This helps aligning the key lights of your scene with the background.
        /// 0 by default.
        abstract backgroundYRotation: float with get, set
        /// Compute automatically the size of the elements to best fit with the scene.
        abstract sizeAuto: bool with get, set
        /// Default position of the rootMesh if autoSize is not true.
        abstract rootPosition: Vector3 with get, set
        /// Sets up the image processing in the scene.
        /// true by default.
        abstract setupImageProcessing: bool with get, set
        /// The texture used as your environment texture in the scene.
        /// Comes from the BabylonJS CDN by default and in use if setupImageProcessing is true.
        /// 
        /// Remarks: Can be either a texture or a url.
        abstract environmentTexture: U2<string, BaseTexture> with get, set
        /// The value of the exposure to apply to the scene.
        /// 0.6 by default if setupImageProcessing is true.
        abstract cameraExposure: float with get, set
        /// The value of the contrast to apply to the scene.
        /// 1.6 by default if setupImageProcessing is true.
        abstract cameraContrast: float with get, set
        /// Specifies wether or not tonemapping should be enabled in the scene.
        /// true by default if setupImageProcessing is true.
        abstract toneMappingEnabled: bool with get, set

    /// The Environment helper class can be used to add a fully featuread none expensive background to your scene.
    /// It includes by default a skybox and a ground relying on the BackgroundMaterial.
    /// It also helps with the default setup of your imageProcessing configuration.
    type [<AllowNullLiteral>] EnvironmentHelper =
        /// Gets the root mesh created by the helper.
        abstract rootMesh: Mesh
        /// Gets the skybox created by the helper.
        abstract skybox: Nullable<Mesh>
        /// Gets the skybox texture created by the helper.
        abstract skyboxTexture: Nullable<BaseTexture>
        /// Gets the skybox material created by the helper.
        abstract skyboxMaterial: Nullable<BackgroundMaterial>
        /// Gets the ground mesh created by the helper.
        abstract ground: Nullable<Mesh>
        /// Gets the ground texture created by the helper.
        abstract groundTexture: Nullable<BaseTexture>
        /// Gets the ground mirror created by the helper.
        abstract groundMirror: Nullable<MirrorTexture>
        /// Gets the ground mirror render list to helps pushing the meshes
        /// you wish in the ground reflection.
        abstract groundMirrorRenderList: Nullable<ResizeArray<AbstractMesh>>
        /// Gets the ground material created by the helper.
        abstract groundMaterial: Nullable<BackgroundMaterial>
        /// This observable will be notified with any error during the creation of the environment,
        /// mainly texture creation errors.
        abstract onErrorObservable: Observable<TypeLiteral_19> with get, set
        /// <summary>Updates the background according to the new options</summary>
        /// <param name="options"></param>
        abstract updateOptions: options: obj -> unit
        /// <summary>Sets the primary color of all the available elements.</summary>
        /// <param name="color">the main color to affect to the ground and the background</param>
        abstract setMainColor: color: Color3 -> unit
        /// Dispose all the elements created by the Helper.
        abstract dispose: unit -> unit

    /// The Environment helper class can be used to add a fully featuread none expensive background to your scene.
    /// It includes by default a skybox and a ground relying on the BackgroundMaterial.
    /// It also helps with the default setup of your imageProcessing configuration.
    type [<AllowNullLiteral>] EnvironmentHelperStatic =
        /// <summary>constructor</summary>
        /// <param name="options"></param>
        /// <param name="scene">The scene to add the material to</param>
        [<Emit "new $0($1...)">] abstract Create: options: obj * scene: Scene -> EnvironmentHelper

    /// Display a 360 degree photo on an approximately spherical surface, useful for VR applications or skyboxes.
    /// As a subclass of TransformNode, this allow parenting to the camera with different locations in the scene.
    /// This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.
    /// Potential additions to this helper include zoom and and non-infinite distance rendering effects.
    type [<AllowNullLiteral>] PhotoDome =
        inherit TransformNode
        /// The texture being displayed on the sphere
        abstract _photoTexture: Texture with get, set
        /// Gets or sets the texture being displayed on the sphere
        abstract photoTexture: Texture with get, set
        /// Observable raised when an error occured while loading the 360 image
        abstract onLoadErrorObservable: Observable<string> with get, set
        /// The skybox material
        abstract _material: BackgroundMaterial with get, set
        /// The surface used for the skybox
        abstract _mesh: Mesh with get, set
        /// The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
        /// Also see the options.resolution property.
        abstract fovMultiplier: float with get, set
        /// <summary>Releases resources associated with this node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit

    /// Display a 360 degree photo on an approximately spherical surface, useful for VR applications or skyboxes.
    /// As a subclass of TransformNode, this allow parenting to the camera with different locations in the scene.
    /// This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.
    /// Potential additions to this helper include zoom and and non-infinite distance rendering effects.
    type [<AllowNullLiteral>] PhotoDomeStatic =
        /// <summary>Create an instance of this class and pass through the parameters to the relevant classes, Texture, StandardMaterial, and Mesh.</summary>
        /// <param name="name">Element's name, child elements will append suffixes for their own names.</param>
        /// <param name="options">defines an object containing optional or exposed sub element properties</param>
        /// <param name="onError">defines a callback called when an error occured while loading the texture</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * urlOfPhoto: string * options: PhotoDomeStaticOptions * scene: Scene * ?onError: (string -> obj -> unit) -> PhotoDome

    type [<AllowNullLiteral>] PhotoDomeStaticOptions =
        abstract resolution: float option with get, set
        abstract size: float option with get, set
        abstract useDirectMapping: bool option with get, set

    /// Display a 360 degree video on an approximately spherical surface, useful for VR applications or skyboxes.
    /// As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.
    /// This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.
    /// Potential additions to this helper include zoom and and non-infinite distance rendering effects.
    type [<AllowNullLiteral>] VideoDome =
        inherit TransformNode
        /// The video texture being displayed on the sphere
        abstract _videoTexture: VideoTexture with get, set
        /// Gets the video texture being displayed on the sphere
        abstract videoTexture: VideoTexture
        /// The skybox material
        abstract _material: BackgroundMaterial with get, set
        /// The surface used for the skybox
        abstract _mesh: Mesh with get, set
        /// The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
        /// Also see the options.resolution property.
        abstract fovMultiplier: float with get, set
        /// <summary>Releases resources associated with this node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit

    /// Display a 360 degree video on an approximately spherical surface, useful for VR applications or skyboxes.
    /// As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.
    /// This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.
    /// Potential additions to this helper include zoom and and non-infinite distance rendering effects.
    type [<AllowNullLiteral>] VideoDomeStatic =
        /// <summary>Create an instance of this class and pass through the parameters to the relevant classes, VideoTexture, StandardMaterial, and Mesh.</summary>
        /// <param name="name">Element's name, child elements will append suffixes for their own names.</param>
        /// <param name="urlsOrVideo">defines the url(s) or the video element to use</param>
        /// <param name="options">An object containing optional or exposed sub element properties</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * urlsOrVideo: U3<string, ResizeArray<string>, HTMLVideoElement> * options: VideoDomeStaticOptions * scene: Scene -> VideoDome

    type [<AllowNullLiteral>] VideoDomeStaticOptions =
        abstract resolution: float option with get, set
        abstract clickToPlay: bool option with get, set
        abstract autoPlay: bool option with get, set
        abstract loop: bool option with get, set
        abstract size: float option with get, set
        abstract poster: string option with get, set
        abstract useDirectMapping: bool option with get, set

    /// Effect layer options. This helps customizing the behaviour
    /// of the effect layer.
    type [<AllowNullLiteral>] IEffectLayerOptions =
        /// Multiplication factor apply to the canvas size to compute the render target size
        /// used to generated the objects (the smaller the faster).
        abstract mainTextureRatio: float with get, set
        /// Enforces a fixed size texture to ensure effect stability across devices.
        abstract mainTextureFixedSize: float option with get, set
        /// Alpha blending mode used to apply the blur. Default depends of the implementation.
        abstract alphaBlendingMode: float with get, set
        /// The camera attached to the layer.
        abstract camera: Nullable<Camera> with get, set
        /// The rendering group to draw the layer in.
        abstract renderingGroupId: float with get, set

    /// The effect layer Helps adding post process effect blended with the main pass.
    /// 
    /// This can be for instance use to generate glow or higlight effects on the scene.
    /// 
    /// The effect layer class can not be used directly and is intented to inherited from to be
    /// customized per effects.
    type [<AllowNullLiteral>] EffectLayer =
        abstract _scene: Scene with get, set
        abstract _engine: Engine with get, set
        abstract _maxSize: float with get, set
        abstract _mainTextureDesiredSize: ISize with get, set
        abstract _mainTexture: RenderTargetTexture with get, set
        abstract _shouldRender: bool with get, set
        abstract _postProcesses: ResizeArray<PostProcess> with get, set
        abstract _textures: ResizeArray<BaseTexture> with get, set
        abstract _emissiveTextureAndColor: TypeLiteral_20 with get, set
        /// The name of the layer
        abstract name: string with get, set
        /// The clear color of the texture used to generate the glow map.
        abstract neutralColor: Color4 with get, set
        /// Specifies wether the highlight layer is enabled or not.
        abstract isEnabled: bool with get, set
        /// Gets the camera attached to the layer.
        abstract camera: Nullable<Camera>
        /// Gets the rendering group id the layer should render in.
        abstract renderingGroupId: float
        /// An event triggered when the effect layer has been disposed.
        abstract onDisposeObservable: Observable<EffectLayer> with get, set
        /// An event triggered when the effect layer is about rendering the main texture with the glowy parts.
        abstract onBeforeRenderMainTextureObservable: Observable<EffectLayer> with get, set
        /// An event triggered when the generated texture is being merged in the scene.
        abstract onBeforeComposeObservable: Observable<EffectLayer> with get, set
        /// An event triggered when the generated texture has been merged in the scene.
        abstract onAfterComposeObservable: Observable<EffectLayer> with get, set
        /// An event triggered when the efffect layer changes its size.
        abstract onSizeChangedObservable: Observable<EffectLayer> with get, set
        /// Get the effect name of the layer.
        abstract getEffectName: unit -> string
        /// <summary>Checks for the readiness of the element composing the layer.</summary>
        /// <param name="subMesh">the mesh to check for</param>
        /// <param name="useInstances">specify wether or not to use instances to render the mesh</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// Returns wether or nood the layer needs stencil enabled during the mesh rendering.
        abstract needStencil: unit -> bool
        /// Create the merge effect. This is the shader use to blit the information back
        /// to the main canvas at the end of the scene rendering.
        abstract _createMergeEffect: unit -> Effect
        /// Creates the render target textures and post processes used in the effect layer.
        abstract _createTextureAndPostProcesses: unit -> unit
        /// <summary>Implementation specific of rendering the generating effect on the main canvas.</summary>
        /// <param name="effect">The effect used to render through</param>
        abstract _internalRender: effect: Effect -> unit
        /// Sets the required values for both the emissive texture and and the main color.
        abstract _setEmissiveTextureAndColor: mesh: Mesh * subMesh: SubMesh * material: Material -> unit
        /// <summary>Free any resources and references associated to a mesh.
        /// Internal use</summary>
        /// <param name="mesh">The mesh to free.</param>
        abstract _disposeMesh: mesh: Mesh -> unit
        /// Serializes this layer (Glow or Highlight for example)
        abstract serialize: unit -> obj option
        /// <summary>Initializes the effect layer with the required options.</summary>
        /// <param name="options">Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)</param>
        abstract _init: options: obj -> unit
        /// Creates the main texture for the effect layer.
        abstract _createMainTexture: unit -> unit
        /// <summary>Checks for the readiness of the element composing the layer.</summary>
        /// <param name="subMesh">the mesh to check for</param>
        /// <param name="useInstances">specify wether or not to use instances to render the mesh</param>
        /// <param name="emissiveTexture">the associated emissive texture used to generate the glow</param>
        abstract _isReady: subMesh: SubMesh * useInstances: bool * emissiveTexture: Nullable<BaseTexture> -> bool
        /// Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.
        abstract render: unit -> unit
        /// <summary>Determine if a given mesh will be used in the current effect.</summary>
        /// <param name="mesh">mesh to test</param>
        abstract hasMesh: mesh: AbstractMesh -> bool
        /// Returns true if the layer contains information to display, otherwise false.
        abstract shouldRender: unit -> bool
        /// <summary>Returns true if the mesh should render, otherwise false.</summary>
        /// <param name="mesh">The mesh to render</param>
        abstract _shouldRenderMesh: mesh: Mesh -> bool
        /// <summary>Returns true if the mesh should render, otherwise false.</summary>
        /// <param name="mesh">The mesh to render</param>
        abstract _shouldRenderEmissiveTextureForMesh: mesh: Mesh -> bool
        /// Renders the submesh passed in parameter to the generation map.
        abstract _renderSubMesh: subMesh: SubMesh -> unit
        /// Rebuild the required buffers.
        abstract _rebuild: unit -> unit
        /// Dispose the highlight layer and free resources.
        abstract dispose: unit -> unit
        /// Gets the class name of the effect layer
        abstract getClassName: unit -> string

    /// The effect layer Helps adding post process effect blended with the main pass.
    /// 
    /// This can be for instance use to generate glow or higlight effects on the scene.
    /// 
    /// The effect layer class can not be used directly and is intented to inherited from to be
    /// customized per effects.
    type [<AllowNullLiteral>] EffectLayerStatic =
        /// <summary>Instantiates a new effect Layer and references it in the scene.</summary>
        /// <param name="name">The name of the layer</param>
        /// <param name="scene">The scene to use the layer in</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> EffectLayer
        /// <summary>Creates an effect layer from parsed effect layer data</summary>
        /// <param name="parsedEffectLayer">defines effect layer data</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="rootUrl">defines the root URL containing the effect layer information</param>
        abstract Parse: parsedEffectLayer: obj option * scene: Scene * rootUrl: string -> EffectLayer

    /// Defines the layer scene component responsible to manage any effect layers
    /// in a given scene.
    type [<AllowNullLiteral>] EffectLayerSceneComponent =
        inherit ISceneSerializableComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// <summary>Serializes the component data to the specified json object</summary>
        /// <param name="serializationObject">The object to serialize to</param>
        abstract serialize: serializationObject: obj option -> unit
        /// <summary>Adds all the element from the container to the scene</summary>
        /// <param name="container">the container holding the elements</param>
        abstract addFromContainer: container: AbstractScene -> unit
        /// <summary>Removes all the elements in the container from the scene</summary>
        /// <param name="container">contains the elements to remove</param>
        abstract removeFromContainer: container: AbstractScene -> unit
        /// Disposes the component and the associated ressources.
        abstract dispose: unit -> unit

    /// Defines the layer scene component responsible to manage any effect layers
    /// in a given scene.
    type [<AllowNullLiteral>] EffectLayerSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> EffectLayerSceneComponent

    /// Glow layer options. This helps customizing the behaviour
    /// of the glow layer.
    type [<AllowNullLiteral>] IGlowLayerOptions =
        /// Multiplication factor apply to the canvas size to compute the render target size
        /// used to generated the glowing objects (the smaller the faster).
        abstract mainTextureRatio: float with get, set
        /// Enforces a fixed size texture to ensure resize independant blur.
        abstract mainTextureFixedSize: float option with get, set
        /// How big is the kernel of the blur texture.
        abstract blurKernelSize: float with get, set
        /// The camera attached to the layer.
        abstract camera: Nullable<Camera> with get, set
        /// Enable MSAA by chosing the number of samples.
        abstract mainTextureSamples: float option with get, set
        /// The rendering group to draw the layer in.
        abstract renderingGroupId: float with get, set

    /// The glow layer Helps adding a glow effect around the emissive parts of a mesh.
    /// 
    /// Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
    /// glowy meshes to your scene.
    /// 
    /// Documentation: https://doc.babylonjs.com/how_to/glow_layer
    type [<AllowNullLiteral>] GlowLayer =
        inherit EffectLayer
        /// Sets the kernel size of the blur.
        /// Gets the kernel size of the blur.
        abstract blurKernelSize: float with get, set
        /// Sets the glow intensity.
        /// Gets the glow intensity.
        abstract intensity: float with get, set
        /// Callback used to let the user override the color selection on a per mesh basis
        abstract customEmissiveColorSelector: (Mesh -> SubMesh -> Material -> Color4 -> unit) with get, set
        /// Callback used to let the user override the texture selection on a per mesh basis
        abstract customEmissiveTextureSelector: (Mesh -> SubMesh -> Material -> Texture) with get, set
        /// Get the effect name of the layer.
        abstract getEffectName: unit -> string
        /// Create the merge effect. This is the shader use to blit the information back
        /// to the main canvas at the end of the scene rendering.
        abstract _createMergeEffect: unit -> Effect
        /// Creates the render target textures and post processes used in the glow layer.
        abstract _createTextureAndPostProcesses: unit -> unit
        /// <summary>Checks for the readiness of the element composing the layer.</summary>
        /// <param name="subMesh">the mesh to check for</param>
        /// <param name="useInstances">specify wether or not to use instances to render the mesh</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// Returns wether or nood the layer needs stencil enabled during the mesh rendering.
        abstract needStencil: unit -> bool
        /// <summary>Implementation specific of rendering the generating effect on the main canvas.</summary>
        /// <param name="effect">The effect used to render through</param>
        abstract _internalRender: effect: Effect -> unit
        /// Sets the required values for both the emissive texture and and the main color.
        abstract _setEmissiveTextureAndColor: mesh: Mesh * subMesh: SubMesh * material: Material -> unit
        /// <summary>Returns true if the mesh should render, otherwise false.</summary>
        /// <param name="mesh">The mesh to render</param>
        abstract _shouldRenderMesh: mesh: Mesh -> bool
        /// <summary>Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.</summary>
        /// <param name="mesh">The mesh to exclude from the glow layer</param>
        abstract addExcludedMesh: mesh: Mesh -> unit
        /// <summary>Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.</summary>
        /// <param name="mesh">The mesh to remove</param>
        abstract removeExcludedMesh: mesh: Mesh -> unit
        /// <summary>Add a mesh in the inclusion list to impact or being impacted by the glow layer.</summary>
        /// <param name="mesh">The mesh to include in the glow layer</param>
        abstract addIncludedOnlyMesh: mesh: Mesh -> unit
        /// <summary>Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.</summary>
        /// <param name="mesh">The mesh to remove</param>
        abstract removeIncludedOnlyMesh: mesh: Mesh -> unit
        /// <summary>Determine if a given mesh will be used in the glow layer</summary>
        /// <param name="mesh">The mesh to test</param>
        abstract hasMesh: mesh: AbstractMesh -> bool
        /// <summary>Free any resources and references associated to a mesh.
        /// Internal use</summary>
        /// <param name="mesh">The mesh to free.</param>
        abstract _disposeMesh: mesh: Mesh -> unit
        /// Gets the class name of the effect layer
        abstract getClassName: unit -> string
        /// Serializes this glow layer
        abstract serialize: unit -> obj option

    /// The glow layer Helps adding a glow effect around the emissive parts of a mesh.
    /// 
    /// Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
    /// glowy meshes to your scene.
    /// 
    /// Documentation: https://doc.babylonjs.com/how_to/glow_layer
    type [<AllowNullLiteral>] GlowLayerStatic =
        /// Effect Name of the layer.
        abstract EffectName: string
        /// The default blur kernel size used for the glow.
        abstract DefaultBlurKernelSize: float with get, set
        /// The default texture size ratio used for the glow.
        abstract DefaultTextureRatio: float with get, set
        /// <summary>Instantiates a new glow Layer and references it to the scene.</summary>
        /// <param name="name">The name of the layer</param>
        /// <param name="scene">The scene to use the layer in</param>
        /// <param name="options">Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ?options: obj -> GlowLayer
        /// <summary>Creates a Glow Layer from parsed glow layer data</summary>
        /// <param name="parsedGlowLayer">defines glow layer data</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="rootUrl">defines the root URL containing the glow layer information</param>
        abstract Parse: parsedGlowLayer: obj option * scene: Scene * rootUrl: string -> GlowLayer

    /// Highlight layer options. This helps customizing the behaviour
    /// of the highlight layer.
    type [<AllowNullLiteral>] IHighlightLayerOptions =
        /// Multiplication factor apply to the canvas size to compute the render target size
        /// used to generated the glowing objects (the smaller the faster).
        abstract mainTextureRatio: float with get, set
        /// Enforces a fixed size texture to ensure resize independant blur.
        abstract mainTextureFixedSize: float option with get, set
        /// Multiplication factor apply to the main texture size in the first step of the blur to reduce the size
        /// of the picture to blur (the smaller the faster).
        abstract blurTextureSizeRatio: float with get, set
        /// How big in texel of the blur texture is the vertical blur.
        abstract blurVerticalSize: float with get, set
        /// How big in texel of the blur texture is the horizontal blur.
        abstract blurHorizontalSize: float with get, set
        /// Alpha blending mode used to apply the blur. Default is combine.
        abstract alphaBlendingMode: float with get, set
        /// The camera attached to the layer.
        abstract camera: Nullable<Camera> with get, set
        /// Should we display highlight as a solid stroke?
        abstract isStroke: bool option with get, set
        /// The rendering group to draw the layer in.
        abstract renderingGroupId: float with get, set

    /// The highlight layer Helps adding a glow effect around a mesh.
    /// 
    /// Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
    /// glowy meshes to your scene.
    /// 
    /// !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!
    type [<AllowNullLiteral>] HighlightLayer =
        inherit EffectLayer
        abstract name: string with get, set
        /// Specifies whether or not the inner glow is ACTIVE in the layer.
        abstract innerGlow: bool with get, set
        /// Specifies whether or not the outer glow is ACTIVE in the layer.
        abstract outerGlow: bool with get, set
        /// Specifies the horizontal size of the blur.
        /// Gets the horizontal size of the blur.
        abstract blurHorizontalSize: float with get, set
        /// Specifies the vertical size of the blur.
        /// Gets the vertical size of the blur.
        abstract blurVerticalSize: float with get, set
        /// An event triggered when the highlight layer is being blurred.
        abstract onBeforeBlurObservable: Observable<HighlightLayer> with get, set
        /// An event triggered when the highlight layer has been blurred.
        abstract onAfterBlurObservable: Observable<HighlightLayer> with get, set
        /// Get the effect name of the layer.
        abstract getEffectName: unit -> string
        /// Create the merge effect. This is the shader use to blit the information back
        /// to the main canvas at the end of the scene rendering.
        abstract _createMergeEffect: unit -> Effect
        /// Creates the render target textures and post processes used in the highlight layer.
        abstract _createTextureAndPostProcesses: unit -> unit
        /// Returns wether or nood the layer needs stencil enabled during the mesh rendering.
        abstract needStencil: unit -> bool
        /// <summary>Checks for the readiness of the element composing the layer.</summary>
        /// <param name="subMesh">the mesh to check for</param>
        /// <param name="useInstances">specify wether or not to use instances to render the mesh</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// <summary>Implementation specific of rendering the generating effect on the main canvas.</summary>
        /// <param name="effect">The effect used to render through</param>
        abstract _internalRender: effect: Effect -> unit
        /// Returns true if the layer contains information to display, otherwise false.
        abstract shouldRender: unit -> bool
        /// <summary>Returns true if the mesh should render, otherwise false.</summary>
        /// <param name="mesh">The mesh to render</param>
        abstract _shouldRenderMesh: mesh: Mesh -> bool
        /// Sets the required values for both the emissive texture and and the main color.
        abstract _setEmissiveTextureAndColor: mesh: Mesh * subMesh: SubMesh * material: Material -> unit
        /// <summary>Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.</summary>
        /// <param name="mesh">The mesh to exclude from the highlight layer</param>
        abstract addExcludedMesh: mesh: Mesh -> unit
        /// <summary>Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.</summary>
        /// <param name="mesh">The mesh to highlight</param>
        abstract removeExcludedMesh: mesh: Mesh -> unit
        /// <summary>Determine if a given mesh will be highlighted by the current HighlightLayer</summary>
        /// <param name="mesh">mesh to test</param>
        abstract hasMesh: mesh: AbstractMesh -> bool
        /// <summary>Add a mesh in the highlight layer in order to make it glow with the chosen color.</summary>
        /// <param name="mesh">The mesh to highlight</param>
        /// <param name="color">The color of the highlight</param>
        /// <param name="glowEmissiveOnly">Extract the glow from the emissive texture</param>
        abstract addMesh: mesh: Mesh * color: Color3 * ?glowEmissiveOnly: bool -> unit
        /// <summary>Remove a mesh from the highlight layer in order to make it stop glowing.</summary>
        /// <param name="mesh">The mesh to highlight</param>
        abstract removeMesh: mesh: Mesh -> unit
        /// <summary>Free any resources and references associated to a mesh.
        /// Internal use</summary>
        /// <param name="mesh">The mesh to free.</param>
        abstract _disposeMesh: mesh: Mesh -> unit
        /// Dispose the highlight layer and free resources.
        abstract dispose: unit -> unit
        /// Gets the class name of the effect layer
        abstract getClassName: unit -> string
        /// Serializes this Highlight layer
        abstract serialize: unit -> obj option

    /// The highlight layer Helps adding a glow effect around a mesh.
    /// 
    /// Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
    /// glowy meshes to your scene.
    /// 
    /// !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!
    type [<AllowNullLiteral>] HighlightLayerStatic =
        /// Effect Name of the highlight layer.
        abstract EffectName: string
        /// The neutral color used during the preparation of the glow effect.
        /// This is black by default as the blend operation is a blend operation.
        abstract NeutralColor: Color4 with get, set
        /// Stencil value used for glowing meshes.
        abstract GlowingMeshStencilReference: float with get, set
        /// Stencil value used for the other meshes in the scene.
        abstract NormalMeshStencilReference: float with get, set
        /// <summary>Instantiates a new highlight Layer and references it to the scene..</summary>
        /// <param name="name">The name of the layer</param>
        /// <param name="scene">The scene to use the layer in</param>
        /// <param name="options">Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ?options: obj -> HighlightLayer
        /// <summary>Creates a Highlight layer from parsed Highlight layer data</summary>
        /// <param name="parsedHightlightLayer">defines the Highlight layer data</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="rootUrl">defines the root URL containing the Highlight layer information</param>
        abstract Parse: parsedHightlightLayer: obj option * scene: Scene * rootUrl: string -> HighlightLayer

    /// This represents a full screen 2d layer.
    /// This can be usefull to display a picture in the  background of your scene for instance.
    type [<AllowNullLiteral>] Layer =
        /// Define the name of the layer.
        abstract name: string with get, set
        /// Define the texture the layer should display.
        abstract texture: Nullable<Texture> with get, set
        /// Is the layer in background or foreground.
        abstract isBackground: bool with get, set
        /// Define the color of the layer (instead of texture).
        abstract color: Color4 with get, set
        /// Define the scale of the layer in order to zoom in out of the texture.
        abstract scale: Vector2 with get, set
        /// Define an offset for the layer in order to shift the texture.
        abstract offset: Vector2 with get, set
        /// Define the alpha blending mode used in the layer in case the texture or color has an alpha.
        abstract alphaBlendingMode: float with get, set
        /// Define if the layer should alpha test or alpha blend with the rest of the scene.
        /// Alpha test will not mix with the background color in case of transparency.
        /// It will either use the texture color or the background depending on the alpha value of the current pixel.
        abstract alphaTest: bool with get, set
        /// Define a mask to restrict the layer to only some of the scene cameras.
        abstract layerMask: float with get, set
        /// An event triggered when the layer is disposed.
        abstract onDisposeObservable: Observable<Layer> with get, set
        /// Back compatibility with callback before the onDisposeObservable existed.
        /// The set callback will be triggered when the layer has been disposed.
        abstract onDispose: (unit -> unit) with get, set
        /// An event triggered before rendering the scene
        abstract onBeforeRenderObservable: Observable<Layer> with get, set
        /// Back compatibility with callback before the onBeforeRenderObservable existed.
        /// The set callback will be triggered just before rendering the layer.
        abstract onBeforeRender: (unit -> unit) with get, set
        /// An event triggered after rendering the scene
        abstract onAfterRenderObservable: Observable<Layer> with get, set
        /// Back compatibility with callback before the onAfterRenderObservable existed.
        /// The set callback will be triggered just after rendering the layer.
        abstract onAfterRender: (unit -> unit) with get, set
        abstract _rebuild: unit -> unit
        /// Renders the layer in the scene.
        abstract render: unit -> unit
        /// Disposes and releases the associated ressources.
        abstract dispose: unit -> unit

    /// This represents a full screen 2d layer.
    /// This can be usefull to display a picture in the  background of your scene for instance.
    type [<AllowNullLiteral>] LayerStatic =
        /// <summary>Instantiates a new layer.
        /// This represents a full screen 2d layer.
        /// This can be usefull to display a picture in the  background of your scene for instance.</summary>
        /// <param name="name">Define the name of the layer in the scene</param>
        /// <param name="imgUrl">Define the url of the texture to display in the layer</param>
        /// <param name="scene">Define the scene the layer belongs to</param>
        /// <param name="isBackground">Defines whether the layer is displayed in front or behind the scene</param>
        /// <param name="color">Defines a color for the layer</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * imgUrl: Nullable<string> * scene: Nullable<Scene> * ?isBackground: bool * ?color: Color4 -> Layer

    /// Defines the layer scene component responsible to manage any layers
    /// in a given scene.
    type [<AllowNullLiteral>] LayerSceneComponent =
        inherit ISceneComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources.
        abstract dispose: unit -> unit

    /// Defines the layer scene component responsible to manage any layers
    /// in a given scene.
    type [<AllowNullLiteral>] LayerSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> LayerSceneComponent

    /// This represents one of the lens effect in a `BABYLON.lensFlareSystem`.
    /// It controls one of the indiviual texture used in the effect.
    type [<AllowNullLiteral>] LensFlare =
        /// Define the size of the lens flare in the system (a floating value between 0 and 1)
        abstract size: float with get, set
        /// Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
        abstract position: float with get, set
        /// Define the lens color.
        abstract color: Color3 with get, set
        /// Define the lens texture.
        abstract texture: Nullable<Texture> with get, set
        /// Define the alpha mode to render this particular lens.
        abstract alphaMode: float with get, set
        /// Dispose and release the lens flare with its associated resources.
        abstract dispose: unit -> unit

    /// This represents one of the lens effect in a `BABYLON.lensFlareSystem`.
    /// It controls one of the indiviual texture used in the effect.
    type [<AllowNullLiteral>] LensFlareStatic =
        /// <summary>Creates a new Lens Flare.
        /// This represents one of the lens effect in a `BABYLON.lensFlareSystem`.
        /// It controls one of the indiviual texture used in the effect.</summary>
        /// <param name="size">Define the size of the lens flare (a floating value between 0 and 1)</param>
        /// <param name="position">Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.</param>
        /// <param name="color">Define the lens color</param>
        /// <param name="imgUrl">Define the lens texture url</param>
        /// <param name="system">Define the `lensFlareSystem` this flare is part of</param>
        abstract AddFlare: size: float * position: float * color: Color3 * imgUrl: string * system: LensFlareSystem -> LensFlare
        /// <summary>Instantiates a new Lens Flare.
        /// This represents one of the lens effect in a `BABYLON.lensFlareSystem`.
        /// It controls one of the indiviual texture used in the effect.</summary>
        /// <param name="size">Define the size of the lens flare in the system (a floating value between 0 and 1)</param>
        /// <param name="position">Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.</param>
        /// <param name="color">Define the lens color</param>
        /// <param name="imgUrl">Define the lens texture url</param>
        /// <param name="system">Define the `lensFlareSystem` this flare is part of</param>
        [<Emit "new $0($1...)">] abstract Create: size: float * position: float * color: Color3 * imgUrl: string * system: LensFlareSystem -> LensFlare

    /// This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.
    /// It is usually composed of several `BABYLON.lensFlare`.
    type [<AllowNullLiteral>] LensFlareSystem =
        /// Define the name of the lens flare system
        abstract name: string with get, set
        /// List of lens flares used in this system.
        abstract lensFlares: ResizeArray<LensFlare> with get, set
        /// Define a limit from the border the lens flare can be visible.
        abstract borderLimit: float with get, set
        /// Define a viewport border we do not want to see the lens flare in.
        abstract viewportBorder: float with get, set
        /// Define a predicate which could limit the list of meshes able to occlude the effect.
        abstract meshesSelectionPredicate: (AbstractMesh -> bool) with get, set
        /// Restricts the rendering of the effect to only the camera rendering this layer mask.
        abstract layerMask: float with get, set
        /// Define the id of the lens flare system in the scene.
        /// (equal to name by default)
        abstract id: string with get, set
        /// Define if the lens flare system is enabled.
        abstract isEnabled: bool with get, set
        /// Get the scene the effects belongs to.
        abstract getScene: unit -> Scene
        /// Get the emitter of the lens flare system.
        /// It defines the source of the lens flares (it can be a camera, a light or a mesh).
        abstract getEmitter: unit -> obj option
        /// <summary>Set the emitter of the lens flare system.
        /// It defines the source of the lens flares (it can be a camera, a light or a mesh).</summary>
        /// <param name="newEmitter">Define the new emitter of the system</param>
        abstract setEmitter: newEmitter: obj option -> unit
        /// Get the lens flare system emitter position.
        /// The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).
        abstract getEmitterPosition: unit -> Vector3
        abstract computeEffectivePosition: globalViewport: Viewport -> bool
        abstract _isVisible: unit -> bool
        abstract render: unit -> bool
        /// Dispose and release the lens flare with its associated resources.
        abstract dispose: unit -> unit
        /// Serialize the current Lens Flare System into a JSON representation.
        abstract serialize: unit -> obj option

    /// This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.
    /// It is usually composed of several `BABYLON.lensFlare`.
    type [<AllowNullLiteral>] LensFlareSystemStatic =
        /// <summary>Instantiates a lens flare system.
        /// This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.
        /// It is usually composed of several `BABYLON.lensFlare`.</summary>
        /// <param name="name">Define the name of the lens flare system in the scene</param>
        /// <param name="emitter">Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).</param>
        /// <param name="scene">Define the scene the lens flare system belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * emitter: obj option * scene: Scene -> LensFlareSystem
        /// <summary>Parse a lens flare system from a JSON repressentation</summary>
        /// <param name="parsedLensFlareSystem">Define the JSON to parse</param>
        /// <param name="scene">Define the scene the parsed system should be instantiated in</param>
        /// <param name="rootUrl">Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures</param>
        abstract Parse: parsedLensFlareSystem: obj option * scene: Scene * rootUrl: string -> LensFlareSystem

    /// Defines the lens flare scene component responsible to manage any lens flares
    /// in a given scene.
    type [<AllowNullLiteral>] LensFlareSystemSceneComponent =
        inherit ISceneSerializableComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// <summary>Adds all the element from the container to the scene</summary>
        /// <param name="container">the container holding the elements</param>
        abstract addFromContainer: container: AbstractScene -> unit
        /// <summary>Removes all the elements in the container from the scene</summary>
        /// <param name="container">contains the elements to remove</param>
        abstract removeFromContainer: container: AbstractScene -> unit
        /// <summary>Serializes the component data to the specified json object</summary>
        /// <param name="serializationObject">The object to serialize to</param>
        abstract serialize: serializationObject: obj option -> unit
        /// Disposes the component and the associated ressources.
        abstract dispose: unit -> unit

    /// Defines the lens flare scene component responsible to manage any lens flares
    /// in a given scene.
    type [<AllowNullLiteral>] LensFlareSystemSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> LensFlareSystemSceneComponent

    /// A directional light is defined by a direction (what a surprise!).
    /// The light is emitted from everywhere in the specified direction, and has an infinite range.
    /// An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] DirectionalLight =
        inherit ShadowLight
        /// Fix frustum size for the shadow generation. This is disabled if the value is 0.
        /// Specifies a fix frustum size for the shadow generation.
        abstract shadowFrustumSize: float with get, set
        /// Gets the shadow projection scale against the optimal computed one.
        /// 0.1 by default which means that the projection window is increase by 10% from the optimal size.
        /// This does not impact in fixed frustum size (shadowFrustumSize being set)
        /// Sets the shadow projection scale against the optimal computed one.
        /// 0.1 by default which means that the projection window is increase by 10% from the optimal size.
        /// This does not impact in fixed frustum size (shadowFrustumSize being set)
        abstract shadowOrthoScale: float with get, set
        /// Automatically compute the projection matrix to best fit (including all the casters)
        /// on each frame.
        abstract autoUpdateExtends: bool with get, set
        /// Returns the string "DirectionalLight".
        abstract getClassName: unit -> string
        /// Returns the integer 1.
        abstract getTypeID: unit -> float
        /// Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
        /// Returns the DirectionalLight Shadow projection matrix.
        abstract _setDefaultShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> unit
        /// Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
        /// Returns the DirectionalLight Shadow projection matrix.
        abstract _setDefaultFixedFrustumShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix -> unit
        /// Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
        /// Returns the DirectionalLight Shadow projection matrix.
        abstract _setDefaultAutoExtendShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> unit
        abstract _buildUniformLayout: unit -> unit
        /// <summary>Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.</summary>
        /// <param name="effect">The effect to update</param>
        /// <param name="lightIndex">The index of the light in the effect to update</param>
        abstract transferToEffect: effect: Effect * lightIndex: string -> DirectionalLight
        /// <summary>Gets the minZ used for shadow according to both the scene and the light.
        /// 
        /// Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
        /// -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.</summary>
        /// <param name="activeCamera">The camera we are returning the min for</param>
        abstract getDepthMinZ: activeCamera: Camera -> float
        /// <summary>Gets the maxZ used for shadow according to both the scene and the light.
        /// 
        /// Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
        /// -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.</summary>
        /// <param name="activeCamera">The camera we are returning the max for</param>
        abstract getDepthMaxZ: activeCamera: Camera -> float
        /// <summary>Prepares the list of defines specific to the light type.</summary>
        /// <param name="defines">the list of defines</param>
        /// <param name="lightIndex">defines the index of the light for the effect</param>
        abstract prepareLightSpecificDefines: defines: obj option * lightIndex: float -> unit

    /// A directional light is defined by a direction (what a surprise!).
    /// The light is emitted from everywhere in the specified direction, and has an infinite range.
    /// An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] DirectionalLightStatic =
        /// <summary>Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
        /// The directional light is emitted from everywhere in the given direction.
        /// It can cast shadows.
        /// Documentation : http://doc.babylonjs.com/tutorials/lights</summary>
        /// <param name="name">The friendly name of the light</param>
        /// <param name="direction">The direction of the light</param>
        /// <param name="scene">The scene the light belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * direction: Vector3 * scene: Scene -> DirectionalLight

    /// The HemisphericLight simulates the ambient environment light,
    /// so the passed direction is the light reflection direction, not the incoming direction.
    type [<AllowNullLiteral>] HemisphericLight =
        inherit Light
        /// The groundColor is the light in the opposite direction to the one specified during creation.
        /// You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.
        abstract groundColor: Color3 with get, set
        /// The light reflection direction, not the incoming direction.
        abstract direction: Vector3 with get, set
        abstract _buildUniformLayout: unit -> unit
        /// Returns the string "HemisphericLight".
        abstract getClassName: unit -> string
        /// <summary>Sets the HemisphericLight direction towards the passed target (Vector3).
        /// Returns the updated direction.</summary>
        /// <param name="target">The target the direction should point to</param>
        abstract setDirectionToTarget: target: Vector3 -> Vector3
        /// Returns the shadow generator associated to the light.
        abstract getShadowGenerator: unit -> Nullable<IShadowGenerator>
        /// <summary>Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).</summary>
        /// <param name="effect">The effect to update</param>
        /// <param name="lightIndex">The index of the light in the effect to update</param>
        abstract transferToEffect: effect: Effect * lightIndex: string -> HemisphericLight
        /// <summary>Computes the world matrix of the node</summary>
        /// <param name="force">defines if the cache version should be invalidated forcing the world matrix to be created from scratch</param>
        /// <param name="useWasUpdatedFlag">defines a reserved property</param>
        abstract computeWorldMatrix: ?force: bool * ?useWasUpdatedFlag: bool -> Matrix
        /// Returns the integer 3.
        abstract getTypeID: unit -> float
        /// <summary>Prepares the list of defines specific to the light type.</summary>
        /// <param name="defines">the list of defines</param>
        /// <param name="lightIndex">defines the index of the light for the effect</param>
        abstract prepareLightSpecificDefines: defines: obj option * lightIndex: float -> unit

    /// The HemisphericLight simulates the ambient environment light,
    /// so the passed direction is the light reflection direction, not the incoming direction.
    type [<AllowNullLiteral>] HemisphericLightStatic =
        /// <summary>Creates a HemisphericLight object in the scene according to the passed direction (Vector3).
        /// The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.
        /// The HemisphericLight can't cast shadows.
        /// Documentation : http://doc.babylonjs.com/tutorials/lights</summary>
        /// <param name="name">The friendly name of the light</param>
        /// <param name="direction">The direction of the light reflection</param>
        /// <param name="scene">The scene the light belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * direction: Vector3 * scene: Scene -> HemisphericLight

    /// Base class of all the lights in Babylon. It groups all the generic information about lights.
    /// Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.
    /// All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.
    type [<AllowNullLiteral>] Light =
        inherit Node
        /// Diffuse gives the basic color to an object.
        abstract diffuse: Color3 with get, set
        /// Specular produces a highlight color on an object.
        /// Note: This is note affecting PBR materials.
        abstract specular: Color3 with get, set
        /// Defines the falloff type for this light. This lets overrriding how punctual light are
        /// falling off base on range or angle.
        /// This can be set to any values in Light.FALLOFF_x.
        /// 
        /// Note: This is only usefull for PBR Materials at the moment. This could be extended if required to
        /// other types of materials.
        abstract falloffType: float with get, set
        /// Strength of the light.
        /// Note: By default it is define in the framework own unit.
        /// Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.
        abstract intensity: float with get, set
        abstract _inverseSquaredRange: float with get, set
        /// Defines how far from the source the light is impacting in scene units.
        /// Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
        /// Defines how far from the source the light is impacting in scene units.
        /// Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
        abstract range: float with get, set
        /// Gets the photometric scale used to interpret the intensity.
        /// This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
        /// Sets the photometric scale used to interpret the intensity.
        /// This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
        abstract intensityMode: float with get, set
        /// Gets the light radius used by PBR Materials to simulate soft area lights.
        /// sets the light radius used by PBR Materials to simulate soft area lights.
        abstract radius: float with get, set
        /// Defines the rendering priority of the lights. It can help in case of fallback or number of lights
        /// exceeding the number allowed of the materials.
        abstract renderPriority: float with get, set
        /// Gets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
        /// the current shadow generator.
        /// Sets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
        /// the current shadow generator.
        abstract shadowEnabled: bool with get, set
        /// Gets the only meshes impacted by this light.
        /// Sets the only meshes impacted by this light.
        abstract includedOnlyMeshes: ResizeArray<AbstractMesh> with get, set
        /// Gets the meshes not impacted by this light.
        /// Sets the meshes not impacted by this light.
        abstract excludedMeshes: ResizeArray<AbstractMesh> with get, set
        /// Gets the layer id use to find what meshes are not impacted by the light.
        /// Inactive if 0
        /// Sets the layer id use to find what meshes are not impacted by the light.
        /// Inactive if 0
        abstract excludeWithLayerMask: float with get, set
        /// Gets the layer id use to find what meshes are impacted by the light.
        /// Inactive if 0
        /// Sets the layer id use to find what meshes are impacted by the light.
        /// Inactive if 0
        abstract includeOnlyWithLayerMask: float with get, set
        /// Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
        /// Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
        abstract lightmapMode: float with get, set
        /// Shadow generator associted to the light.
        abstract _shadowGenerator: Nullable<IShadowGenerator> with get, set
        abstract _excludedMeshesIds: ResizeArray<string> with get, set
        abstract _includedOnlyMeshesIds: ResizeArray<string> with get, set
        /// The current light unifom buffer.
        abstract _uniformBuffer: UniformBuffer with get, set
        abstract _buildUniformLayout: unit -> unit
        /// <summary>Sets the passed Effect "effect" with the Light information.</summary>
        /// <param name="effect">The effect to update</param>
        /// <param name="lightIndex">The index of the light in the effect to update</param>
        abstract transferToEffect: effect: Effect * lightIndex: string -> Light
        /// Returns the string "Light".
        abstract getClassName: unit -> string
        /// <summary>Converts the light information to a readable string for debug purpose.</summary>
        /// <param name="fullDetails">Supports for multiple levels of logging within scene loading</param>
        abstract toString: ?fullDetails: bool -> string
        abstract _syncParentEnabledState: unit -> unit
        /// <summary>Set the enabled state of this node.</summary>
        /// <param name="value">- the new enabled state</param>
        abstract setEnabled: value: bool -> unit
        /// Returns the Light associated shadow generator if any.
        abstract getShadowGenerator: unit -> Nullable<IShadowGenerator>
        /// Returns a Vector3, the absolute light position in the World.
        abstract getAbsolutePosition: unit -> Vector3
        /// <summary>Specifies if the light will affect the passed mesh.</summary>
        /// <param name="mesh">The mesh to test against the light</param>
        abstract canAffectMesh: mesh: AbstractMesh -> bool
        /// <summary>Releases resources associated with this node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit
        /// Returns the light type ID (integer).
        abstract getTypeID: unit -> float
        /// Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
        abstract getScaledIntensity: unit -> float
        /// <summary>Returns a new Light object, named "name", from the current one.</summary>
        /// <param name="name">The name of the cloned light</param>
        abstract clone: name: string -> Nullable<Light>
        /// Serializes the current light into a Serialization object.
        abstract serialize: unit -> obj option
        /// Forces the meshes to update their light related information in their rendering used effects
        abstract _markMeshesAsLightDirty: unit -> unit
        /// Reorder the light in the scene according to their defined priority.
        abstract _reorderLightsInScene: unit -> unit
        /// <summary>Prepares the list of defines specific to the light type.</summary>
        /// <param name="defines">the list of defines</param>
        /// <param name="lightIndex">defines the index of the light for the effect</param>
        abstract prepareLightSpecificDefines: defines: obj option * lightIndex: float -> unit

    /// Base class of all the lights in Babylon. It groups all the generic information about lights.
    /// Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.
    /// All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.
    type [<AllowNullLiteral>] LightStatic =
        /// Falloff Default: light is falling off following the material specification:
        /// standard material is using standard falloff whereas pbr material can request special falloff per materials.
        abstract FALLOFF_DEFAULT: float
        /// Falloff Physical: light is falling off following the inverse squared distance law.
        abstract FALLOFF_PHYSICAL: float
        /// Falloff gltf: light is falling off as described in the gltf moving to PBR document
        /// to enhance interoperability with other engines.
        abstract FALLOFF_GLTF: float
        /// Falloff Standard: light is falling off like in the standard material
        /// to enhance interoperability with other materials.
        abstract FALLOFF_STANDARD: float
        /// If every light affecting the material is in this lightmapMode,
        /// material.lightmapTexture adds or multiplies
        /// (depends on material.useLightmapAsShadowmap)
        /// after every other light calculations.
        abstract LIGHTMAP_DEFAULT: float
        /// material.lightmapTexture as only diffuse lighting from this light
        /// adds only specular lighting from this light
        /// adds dynamic shadows
        abstract LIGHTMAP_SPECULAR: float
        /// material.lightmapTexture as only lighting
        /// no light calculation from this light
        /// only adds dynamic shadows from this light
        abstract LIGHTMAP_SHADOWSONLY: float
        /// Each light type uses the default quantity according to its type:
        ///       point/spot lights use luminous intensity
        ///       directional lights use illuminance
        abstract INTENSITYMODE_AUTOMATIC: float
        /// lumen (lm)
        abstract INTENSITYMODE_LUMINOUSPOWER: float
        /// candela (lm/sr)
        abstract INTENSITYMODE_LUMINOUSINTENSITY: float
        /// lux (lm/m^2)
        abstract INTENSITYMODE_ILLUMINANCE: float
        /// nit (cd/m^2)
        abstract INTENSITYMODE_LUMINANCE: float
        /// Light type const id of the point light.
        abstract LIGHTTYPEID_POINTLIGHT: float
        /// Light type const id of the directional light.
        abstract LIGHTTYPEID_DIRECTIONALLIGHT: float
        /// Light type const id of the spot light.
        abstract LIGHTTYPEID_SPOTLIGHT: float
        /// Light type const id of the hemispheric light.
        abstract LIGHTTYPEID_HEMISPHERICLIGHT: float
        /// <summary>Creates a Light object in the scene.
        /// Documentation : http://doc.babylonjs.com/tutorials/lights</summary>
        /// <param name="name">The firendly name of the light</param>
        /// <param name="scene">The scene the light belongs too</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> Light
        /// <summary>Sort function to order lights for rendering.</summary>
        /// <param name="a">First Light object to compare to second.</param>
        /// <param name="b">Second Light object to compare first.</param>
        abstract CompareLightsPriority: a: Light * b: Light -> float
        /// <summary>Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
        /// This new light is named "name" and added to the passed scene.</summary>
        /// <param name="type">Type according to the types available in Light.LIGHTTYPEID_x</param>
        /// <param name="name">The friendly name of the light</param>
        /// <param name="scene">The scene the new light will belong to</param>
        abstract GetConstructorFromName: ``type``: float * name: string * scene: Scene -> Nullable<(unit -> Light)>
        /// <summary>Parses the passed "parsedLight" and returns a new instanced Light from this parsing.</summary>
        /// <param name="parsedLight">The JSON representation of the light</param>
        /// <param name="scene">The scene to create the parsed light in</param>
        abstract Parse: parsedLight: obj option * scene: Scene -> Nullable<Light>

    /// A point light is a light defined by an unique point in world space.
    /// The light is emitted in every direction from this point.
    /// A good example of a point light is a standard light bulb.
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] PointLight =
        inherit ShadowLight
        /// Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
        /// This specifies what angle the shadow will use to be created.
        /// 
        /// It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
        /// Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
        /// This specifies what angle the shadow will use to be created.
        /// 
        /// It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
        abstract shadowAngle: float with get, set
        /// Gets the direction if it has been set.
        /// In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
        /// In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
        abstract direction: Vector3 with get, set
        /// Returns the string "PointLight"
        abstract getClassName: unit -> string
        /// Returns the integer 0.
        abstract getTypeID: unit -> float
        /// Specifies wether or not the shadowmap should be a cube texture.
        abstract needCube: unit -> bool
        /// <summary>Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).</summary>
        /// <param name="faceIndex">The index of the face we are computed the direction to generate shadow</param>
        abstract getShadowDirection: ?faceIndex: float -> Vector3
        /// Sets the passed matrix "matrix" as a left-handed perspective projection matrix with the following settings :
        /// - fov = PI / 2
        /// - aspect ratio : 1.0
        /// - z-near and far equal to the active camera minZ and maxZ.
        /// Returns the PointLight.
        abstract _setDefaultShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> unit
        abstract _buildUniformLayout: unit -> unit
        /// <summary>Sets the passed Effect "effect" with the PointLight transformed position (or position, if none) and passed name (string).</summary>
        /// <param name="effect">The effect to update</param>
        /// <param name="lightIndex">The index of the light in the effect to update</param>
        abstract transferToEffect: effect: Effect * lightIndex: string -> PointLight
        /// <summary>Prepares the list of defines specific to the light type.</summary>
        /// <param name="defines">the list of defines</param>
        /// <param name="lightIndex">defines the index of the light for the effect</param>
        abstract prepareLightSpecificDefines: defines: obj option * lightIndex: float -> unit

    /// A point light is a light defined by an unique point in world space.
    /// The light is emitted in every direction from this point.
    /// A good example of a point light is a standard light bulb.
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] PointLightStatic =
        /// <summary>Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.
        /// A PointLight emits the light in every direction.
        /// It can cast shadows.
        /// If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :
        /// ```javascript
        /// var pointLight = new BABYLON.PointLight("pl", camera.position, scene);
        /// ```
        /// Documentation : http://doc.babylonjs.com/tutorials/lights</summary>
        /// <param name="name">The light friendly name</param>
        /// <param name="position">The position of the point light in the scene</param>
        /// <param name="scene">The scene the lights belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> PointLight

    /// Interface describing all the common properties and methods a shadow light needs to implement.
    /// This helps both the shadow generator and materials to genrate the corresponding shadow maps
    /// as well as binding the different shadow properties to the effects.
    type [<AllowNullLiteral>] IShadowLight =
        inherit Light
        /// The light id in the scene (used in scene.findLighById for instance)
        abstract id: string with get, set
        /// The position the shdow will be casted from.
        abstract position: Vector3 with get, set
        /// In 2d mode (needCube being false), the direction used to cast the shadow.
        abstract direction: Vector3 with get, set
        /// The transformed position. Position of the light in world space taking parenting in account.
        abstract transformedPosition: Vector3 with get, set
        /// The transformed direction. Direction of the light in world space taking parenting in account.
        abstract transformedDirection: Vector3 with get, set
        /// The friendly name of the light in the scene.
        abstract name: string with get, set
        /// Defines the shadow projection clipping minimum z value.
        abstract shadowMinZ: float with get, set
        /// Defines the shadow projection clipping maximum z value.
        abstract shadowMaxZ: float with get, set
        /// Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
        abstract computeTransformedInformation: unit -> bool
        /// Gets the scene the light belongs to.
        abstract getScene: unit -> Scene
        /// Callback defining a custom Projection Matrix Builder.
        /// This can be used to override the default projection matrix computation.
        abstract customProjectionMatrixBuilder: (Matrix -> Array<AbstractMesh> -> Matrix -> unit) with get, set
        /// <summary>Sets the shadow projection matrix in parameter to the generated projection matrix.</summary>
        /// <param name="matrix">The materix to updated with the projection information</param>
        /// <param name="viewMatrix">The transform matrix of the light</param>
        /// <param name="renderList">The list of mesh to render in the map</param>
        abstract setShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> IShadowLight
        /// Gets the current depth scale used in ESM.
        abstract getDepthScale: unit -> float
        /// Returns whether or not the shadow generation require a cube texture or a 2d texture.
        abstract needCube: unit -> bool
        /// Detects if the projection matrix requires to be recomputed this frame.
        abstract needProjectionMatrixCompute: unit -> bool
        /// Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
        abstract forceProjectionMatrixCompute: unit -> unit
        /// <summary>Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.</summary>
        /// <param name="faceIndex">The index of the face we are computed the direction to generate shadow</param>
        abstract getShadowDirection: ?faceIndex: float -> Vector3
        /// <summary>Gets the minZ used for shadow according to both the scene and the light.</summary>
        /// <param name="activeCamera">The camera we are returning the min for</param>
        abstract getDepthMinZ: activeCamera: Camera -> float
        /// <summary>Gets the maxZ used for shadow according to both the scene and the light.</summary>
        /// <param name="activeCamera">The camera we are returning the max for</param>
        abstract getDepthMaxZ: activeCamera: Camera -> float

    /// Base implementation IShadowLight
    /// It groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.
    type [<AllowNullLiteral>] ShadowLight =
        inherit Light
        inherit IShadowLight
        abstract _setDefaultShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> unit
        abstract _position: Vector3 with get, set
        abstract _setPosition: value: Vector3 -> unit
        /// Sets the position the shadow will be casted from. Also use as the light position for both
        /// point and spot lights.
        /// Sets the position the shadow will be casted from. Also use as the light position for both
        /// point and spot lights.
        abstract position: Vector3 with get, set
        abstract _direction: Vector3 with get, set
        abstract _setDirection: value: Vector3 -> unit
        /// In 2d mode (needCube being false), gets the direction used to cast the shadow.
        /// Also use as the light direction on spot and directional lights.
        /// In 2d mode (needCube being false), sets the direction used to cast the shadow.
        /// Also use as the light direction on spot and directional lights.
        abstract direction: Vector3 with get, set
        /// Gets the shadow projection clipping minimum z value.
        /// Sets the shadow projection clipping minimum z value.
        abstract shadowMinZ: float with get, set
        /// Sets the shadow projection clipping maximum z value.
        /// Gets the shadow projection clipping maximum z value.
        abstract shadowMaxZ: float with get, set
        /// Callback defining a custom Projection Matrix Builder.
        /// This can be used to override the default projection matrix computation.
        abstract customProjectionMatrixBuilder: (Matrix -> Array<AbstractMesh> -> Matrix -> unit) with get, set
        /// The transformed position. Position of the light in world space taking parenting in account.
        abstract transformedPosition: Vector3 with get, set
        /// The transformed direction. Direction of the light in world space taking parenting in account.
        abstract transformedDirection: Vector3 with get, set
        /// Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
        abstract computeTransformedInformation: unit -> bool
        /// Return the depth scale used for the shadow map.
        abstract getDepthScale: unit -> float
        /// <summary>Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.</summary>
        /// <param name="faceIndex">The index of the face we are computed the direction to generate shadow</param>
        abstract getShadowDirection: ?faceIndex: float -> Vector3
        /// Returns the ShadowLight absolute position in the World.
        abstract getAbsolutePosition: unit -> Vector3
        /// <summary>Sets the ShadowLight direction toward the passed target.</summary>
        /// <param name="target">The point tot target in local space</param>
        abstract setDirectionToTarget: target: Vector3 -> Vector3
        /// Returns the light rotation in euler definition.
        abstract getRotation: unit -> Vector3
        /// Returns whether or not the shadow generation require a cube texture or a 2d texture.
        abstract needCube: unit -> bool
        /// Detects if the projection matrix requires to be recomputed this frame.
        abstract needProjectionMatrixCompute: unit -> bool
        /// Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
        abstract forceProjectionMatrixCompute: unit -> unit
        abstract _initCache: unit -> unit
        abstract _isSynchronized: unit -> bool
        /// <summary>Computes the world matrix of the node</summary>
        /// <param name="force">defines if the cache version should be invalidated forcing the world matrix to be created from scratch</param>
        abstract computeWorldMatrix: ?force: bool -> Matrix
        /// <summary>Gets the minZ used for shadow according to both the scene and the light.</summary>
        /// <param name="activeCamera">The camera we are returning the min for</param>
        abstract getDepthMinZ: activeCamera: Camera -> float
        /// <summary>Gets the maxZ used for shadow according to both the scene and the light.</summary>
        /// <param name="activeCamera">The camera we are returning the max for</param>
        abstract getDepthMaxZ: activeCamera: Camera -> float
        /// <summary>Sets the shadow projection matrix in parameter to the generated projection matrix.</summary>
        /// <param name="matrix">The materix to updated with the projection information</param>
        /// <param name="viewMatrix">The transform matrix of the light</param>
        /// <param name="renderList">The list of mesh to render in the map</param>
        abstract setShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> IShadowLight

    /// Base implementation IShadowLight
    /// It groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.
    type [<AllowNullLiteral>] ShadowLightStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ShadowLight

    /// A spot light is defined by a position, a direction, an angle, and an exponent.
    /// These values define a cone of light starting from the position, emitting toward the direction.
    /// The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,
    /// and the exponent defines the speed of the decay of the light with distance (reach).
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] SpotLight =
        inherit ShadowLight
        /// Gets the cone angle of the spot light in Radians.
        /// Sets the cone angle of the spot light in Radians.
        abstract angle: float with get, set
        /// Only used in gltf falloff mode, this defines the angle where
        /// the directional falloff will start before cutting at angle which could be seen
        /// as outer angle.
        /// Only used in gltf falloff mode, this defines the angle where
        /// the directional falloff will start before cutting at angle which could be seen
        /// as outer angle.
        abstract innerAngle: float with get, set
        /// Allows scaling the angle of the light for shadow generation only.
        /// Allows scaling the angle of the light for shadow generation only.
        abstract shadowAngleScale: float with get, set
        /// The light decay speed with the distance from the emission spot.
        abstract exponent: float with get, set
        /// Allows reading the projecton texture
        abstract projectionTextureMatrix: Matrix
        abstract _projectionTextureLightNear: float with get, set
        /// Gets the near clip of the Spotlight for texture projection.
        /// Sets the near clip of the Spotlight for texture projection.
        abstract projectionTextureLightNear: float with get, set
        abstract _projectionTextureLightFar: float with get, set
        /// Gets the far clip of the Spotlight for texture projection.
        /// Sets the far clip of the Spotlight for texture projection.
        abstract projectionTextureLightFar: float with get, set
        abstract _projectionTextureUpDirection: Vector3 with get, set
        /// Gets the Up vector of the Spotlight for texture projection.
        /// Sets the Up vector of the Spotlight for texture projection.
        abstract projectionTextureUpDirection: Vector3 with get, set
        /// Gets the projection texture of the light.
        /// Sets the projection texture of the light.
        abstract projectionTexture: Nullable<BaseTexture> with get, set
        /// Returns the string "SpotLight".
        abstract getClassName: unit -> string
        /// Returns the integer 2.
        abstract getTypeID: unit -> float
        /// Overrides the direction setter to recompute the projection texture view light Matrix.
        abstract _setDirection: value: Vector3 -> unit
        /// Overrides the position setter to recompute the projection texture view light Matrix.
        abstract _setPosition: value: Vector3 -> unit
        /// Sets the passed matrix "matrix" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.
        /// Returns the SpotLight.
        abstract _setDefaultShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> unit
        abstract _computeProjectionTextureViewLightMatrix: unit -> unit
        abstract _computeProjectionTextureProjectionLightMatrix: unit -> unit
        /// Main function for light texture projection matrix computing.
        abstract _computeProjectionTextureMatrix: unit -> unit
        abstract _buildUniformLayout: unit -> unit
        /// <summary>Sets the passed Effect object with the SpotLight transfomed position (or position if not parented) and normalized direction.</summary>
        /// <param name="effect">The effect to update</param>
        /// <param name="lightIndex">The index of the light in the effect to update</param>
        abstract transferToEffect: effect: Effect * lightIndex: string -> SpotLight
        /// Disposes the light and the associated resources.
        abstract dispose: unit -> unit
        /// <summary>Prepares the list of defines specific to the light type.</summary>
        /// <param name="defines">the list of defines</param>
        /// <param name="lightIndex">defines the index of the light for the effect</param>
        abstract prepareLightSpecificDefines: defines: obj option * lightIndex: float -> unit

    /// A spot light is defined by a position, a direction, an angle, and an exponent.
    /// These values define a cone of light starting from the position, emitting toward the direction.
    /// The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,
    /// and the exponent defines the speed of the decay of the light with distance (reach).
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] SpotLightStatic =
        /// <summary>Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.
        /// It can cast shadows.
        /// Documentation : http://doc.babylonjs.com/tutorials/lights</summary>
        /// <param name="name">The light friendly name</param>
        /// <param name="position">The position of the spot light in the scene</param>
        /// <param name="direction">The direction of the light in the scene</param>
        /// <param name="angle">The cone angle of the light in Radians</param>
        /// <param name="exponent">The light decay speed with the distance from the emission spot</param>
        /// <param name="scene">The scene the lights belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * direction: Vector3 * angle: float * exponent: float * scene: Scene -> SpotLight

    /// Interface used to present a loading screen while loading a scene
    type [<AllowNullLiteral>] ILoadingScreen =
        /// Function called to display the loading screen
        abstract displayLoadingUI: (unit -> unit) with get, set
        /// Function called to hide the loading screen
        abstract hideLoadingUI: (unit -> unit) with get, set
        /// Gets or sets the color to use for the background
        abstract loadingUIBackgroundColor: string with get, set
        /// Gets or sets the text to display while loading
        abstract loadingUIText: string with get, set

    /// Class used for the default loading screen
    type [<AllowNullLiteral>] DefaultLoadingScreen =
        inherit ILoadingScreen
        /// Function called to display the loading screen
        abstract displayLoadingUI: unit -> unit
        /// Function called to hide the loading screen
        abstract hideLoadingUI: unit -> unit
        /// Gets or sets the text to display while loading
        abstract loadingUIText: string with get, set
        /// Gets or sets the color to use for the background
        abstract loadingUIBackgroundColor: string with get, set

    /// Class used for the default loading screen
    type [<AllowNullLiteral>] DefaultLoadingScreenStatic =
        /// <summary>Creates a new default loading screen</summary>
        /// <param name="_renderingCanvas">defines the canvas used to render the scene</param>
        /// <param name="_loadingText">defines the default text to display</param>
        /// <param name="_loadingDivBackgroundColor">defines the default background color</param>
        [<Emit "new $0($1...)">] abstract Create: _renderingCanvas: HTMLCanvasElement * ?_loadingText: string * ?_loadingDivBackgroundColor: string -> DefaultLoadingScreen

    /// Class used to represent data loading progression
    type [<AllowNullLiteral>] SceneLoaderProgressEvent =
        /// defines if data length to load can be evaluated 
        abstract lengthComputable: bool
        /// defines the loaded data length 
        abstract loaded: float
        /// defines the data length to load 
        abstract total: float

    /// Class used to represent data loading progression
    type [<AllowNullLiteral>] SceneLoaderProgressEventStatic =
        /// <summary>Create a new progress event</summary>
        /// <param name="lengthComputable">defines if data length to load can be evaluated</param>
        /// <param name="loaded">defines the loaded data length</param>
        /// <param name="total">defines the data length to load</param>
        [<Emit "new $0($1...)">] abstract Create: lengthComputable: bool * loaded: float * total: float -> SceneLoaderProgressEvent
        /// <summary>Creates a new SceneLoaderProgressEvent from a ProgressEvent</summary>
        /// <param name="event">defines the source event</param>
        abstract FromProgressEvent: ``event``: ProgressEvent -> SceneLoaderProgressEvent

    /// Interface used by SceneLoader plugins to define supported file extensions
    type [<AllowNullLiteral>] ISceneLoaderPluginExtensions =
        /// Defines the list of supported extensions
        [<Emit "$0[$1]{{=$2}}">] abstract Item: extension: string -> TypeLiteral_21 with get, set

    /// Interface used by SceneLoader plugin factory
    type [<AllowNullLiteral>] ISceneLoaderPluginFactory =
        /// Defines the name of the factory
        abstract name: string with get, set
        /// Function called to create a new plugin
        abstract createPlugin: unit -> U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>
        /// Boolean indicating if the plugin can direct load specific data
        abstract canDirectLoad: (string -> bool) option with get, set

    /// Interface used to define a SceneLoader plugin
    type [<AllowNullLiteral>] ISceneLoaderPlugin =
        /// The friendly name of this plugin.
        abstract name: string with get, set
        /// The file extensions supported by this plugin.
        abstract extensions: U2<string, ISceneLoaderPluginExtensions> with get, set
        /// <summary>Import meshes into a scene.</summary>
        /// <param name="meshesNames">An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported</param>
        /// <param name="scene">The scene to import into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="meshes">The meshes array to import into</param>
        /// <param name="particleSystems">The particle systems array to import into</param>
        /// <param name="skeletons">The skeletons array to import into</param>
        /// <param name="onError">The callback when import fails</param>
        abstract importMesh: meshesNames: obj option * scene: Scene * data: obj option * rootUrl: string * meshes: ResizeArray<AbstractMesh> * particleSystems: ResizeArray<IParticleSystem> * skeletons: ResizeArray<Skeleton> * ?onError: (string -> obj -> unit) -> bool
        /// <summary>Load into a scene.</summary>
        /// <param name="scene">The scene to load into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="onError">The callback when import fails</param>
        abstract load: scene: Scene * data: string * rootUrl: string * ?onError: (string -> obj -> unit) -> bool
        /// The callback that returns true if the data can be directly loaded.
        abstract canDirectLoad: (string -> bool) option with get, set
        /// The callback that allows custom handling of the root url based on the response url.
        abstract rewriteRootURL: (string -> string -> string) option with get, set
        /// <summary>Load into an asset container.</summary>
        /// <param name="scene">The scene to load into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="onError">The callback when import fails</param>
        abstract loadAssetContainer: scene: Scene * data: string * rootUrl: string * ?onError: (string -> obj -> unit) -> AssetContainer

    /// Interface used to define an async SceneLoader plugin
    type [<AllowNullLiteral>] ISceneLoaderPluginAsync =
        /// The friendly name of this plugin.
        abstract name: string with get, set
        /// The file extensions supported by this plugin.
        abstract extensions: U2<string, ISceneLoaderPluginExtensions> with get, set
        /// <summary>Import meshes into a scene.</summary>
        /// <param name="meshesNames">An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported</param>
        /// <param name="scene">The scene to import into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="onProgress">The callback when the load progresses</param>
        /// <param name="fileName">Defines the name of the file to load</param>
        abstract importMeshAsync: meshesNames: obj option * scene: Scene * data: obj option * rootUrl: string * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?fileName: string -> Promise<TypeLiteral_22>
        /// <summary>Load into a scene.</summary>
        /// <param name="scene">The scene to load into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="onProgress">The callback when the load progresses</param>
        /// <param name="fileName">Defines the name of the file to load</param>
        abstract loadAsync: scene: Scene * data: string * rootUrl: string * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?fileName: string -> Promise<unit>
        /// The callback that returns true if the data can be directly loaded.
        abstract canDirectLoad: (string -> bool) option with get, set
        /// The callback that allows custom handling of the root url based on the response url.
        abstract rewriteRootURL: (string -> string -> string) option with get, set
        /// <summary>Load into an asset container.</summary>
        /// <param name="scene">The scene to load into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="onProgress">The callback when the load progresses</param>
        /// <param name="fileName">Defines the name of the file to load</param>
        abstract loadAssetContainerAsync: scene: Scene * data: string * rootUrl: string * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?fileName: string -> Promise<AssetContainer>

    /// Class used to load scene from various file formats using registered plugins
    type [<AllowNullLiteral>] SceneLoader =
        interface end

    /// Class used to load scene from various file formats using registered plugins
    type [<AllowNullLiteral>] SceneLoaderStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SceneLoader
        /// No logging while loading
        abstract NO_LOGGING: float
        /// Minimal logging while loading
        abstract MINIMAL_LOGGING: float
        /// Summary logging while loading
        abstract SUMMARY_LOGGING: float
        /// Detailled logging while loading
        abstract DETAILED_LOGGING: float
        /// Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data
        abstract ForceFullSceneLoadingForIncremental: bool with get, set
        /// Gets or sets a boolean indicating if loading screen must be displayed while loading a scene
        abstract ShowLoadingScreen: bool with get, set
        /// Defines the current logging level (while loading the scene)
        abstract loggingLevel: float with get, set
        /// Gets or set a boolean indicating if matrix weights must be cleaned upon loading
        abstract CleanBoneMatrixWeights: bool with get, set
        /// Event raised when a plugin is used to load a scene
        abstract OnPluginActivatedObservable: Observable<U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>> with get, set
        /// <summary>Gets a plugin that can load the given extension</summary>
        /// <param name="extension">defines the extension to load</param>
        abstract GetPluginForExtension: extension: string -> U3<ISceneLoaderPlugin, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory>
        /// <summary>Gets a boolean indicating that the given extension can be loaded</summary>
        /// <param name="extension">defines the extension to load</param>
        abstract IsPluginForExtensionAvailable: extension: string -> bool
        /// <summary>Adds a new plugin to the list of registered plugins</summary>
        /// <param name="plugin">defines the plugin to add</param>
        abstract RegisterPlugin: plugin: U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync> -> unit
        /// <summary>Import meshes into a scene</summary>
        /// <param name="meshNames">an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported</param>
        /// <param name="rootUrl">a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)</param>
        /// <param name="scene">the instance of BABYLON.Scene to append to</param>
        /// <param name="onSuccess">a callback with a list of imported meshes, particleSystems, and skeletons when import succeeds</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="onError">a callback with the scene, a message, and possibly an exception when import fails</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract ImportMesh: meshNames: obj option * rootUrl: string * ?sceneFilename: string * ?scene: Scene * ?onSuccess: (ResizeArray<AbstractMesh> -> ResizeArray<IParticleSystem> -> ResizeArray<Skeleton> -> ResizeArray<AnimationGroup> -> unit) * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?onError: (Scene -> string -> obj -> unit) * ?pluginExtension: string -> Nullable<U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>>
        /// <summary>Import meshes into a scene</summary>
        /// <param name="meshNames">an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported</param>
        /// <param name="rootUrl">a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)</param>
        /// <param name="scene">the instance of BABYLON.Scene to append to</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract ImportMeshAsync: meshNames: obj option * rootUrl: string * ?sceneFilename: string * ?scene: Scene * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?pluginExtension: string -> Promise<TypeLiteral_22>
        /// <summary>Load a scene</summary>
        /// <param name="rootUrl">a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)</param>
        /// <param name="engine">is the instance of BABYLON.Engine to use to create the scene</param>
        /// <param name="onSuccess">a callback with the scene when import succeeds</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="onError">a callback with the scene, a message, and possibly an exception when import fails</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract Load: rootUrl: string * sceneFilename: string * engine: Engine * ?onSuccess: (Scene -> unit) * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?onError: (Scene -> string -> obj -> unit) * ?pluginExtension: string -> Nullable<U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>>
        /// <summary>Load a scene</summary>
        /// <param name="rootUrl">a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)</param>
        /// <param name="engine">is the instance of BABYLON.Engine to use to create the scene</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract LoadAsync: rootUrl: string * sceneFilename: string * engine: Engine * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?pluginExtension: string -> Promise<Scene>
        /// <summary>Append a scene</summary>
        /// <param name="rootUrl">a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)</param>
        /// <param name="scene">is the instance of BABYLON.Scene to append to</param>
        /// <param name="onSuccess">a callback with the scene when import succeeds</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="onError">a callback with the scene, a message, and possibly an exception when import fails</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract Append: rootUrl: string * ?sceneFilename: string * ?scene: Scene * ?onSuccess: (Scene -> unit) * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?onError: (Scene -> string -> obj -> unit) * ?pluginExtension: string -> Nullable<U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>>
        /// <summary>Append a scene</summary>
        /// <param name="rootUrl">a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)</param>
        /// <param name="scene">is the instance of BABYLON.Scene to append to</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract AppendAsync: rootUrl: string * ?sceneFilename: string * ?scene: Scene * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?pluginExtension: string -> Promise<Scene>
        /// <summary>Load a scene into an asset container</summary>
        /// <param name="rootUrl">a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)</param>
        /// <param name="scene">is the instance of BABYLON.Scene to append to (default: last created scene)</param>
        /// <param name="onSuccess">a callback with the scene when import succeeds</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="onError">a callback with the scene, a message, and possibly an exception when import fails</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract LoadAssetContainer: rootUrl: string * ?sceneFilename: string * ?scene: Scene * ?onSuccess: (AssetContainer -> unit) * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?onError: (Scene -> string -> obj -> unit) * ?pluginExtension: string -> Nullable<U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>>
        /// <summary>Load a scene into an asset container</summary>
        /// <param name="rootUrl">a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)</param>
        /// <param name="scene">is the instance of BABYLON.Scene to append to</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract LoadAssetContainerAsync: rootUrl: string * ?sceneFilename: string * ?scene: Scene * ?onProgress: (SceneLoaderProgressEvent -> unit) * ?pluginExtension: string -> Promise<AssetContainer>

    /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
    /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
    /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
    /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
    type [<AllowNullLiteral>] ColorCurves =
        /// Gets the global Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        /// Sets the global Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        abstract globalHue: float with get, set
        /// Gets the global Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        /// Sets the global Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        abstract globalDensity: float with get, set
        /// Gets the global Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        /// Sets the global Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        abstract globalSaturation: float with get, set
        /// Gets the global Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        /// Sets the global Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        abstract globalExposure: float with get, set
        /// Gets the highlights Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        /// Sets the highlights Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        abstract highlightsHue: float with get, set
        /// Gets the highlights Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        /// Sets the highlights Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        abstract highlightsDensity: float with get, set
        /// Gets the highlights Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        /// Sets the highlights Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        abstract highlightsSaturation: float with get, set
        /// Gets the highlights Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        /// Sets the highlights Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        abstract highlightsExposure: float with get, set
        /// Gets the midtones Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        /// Sets the midtones Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        abstract midtonesHue: float with get, set
        /// Gets the midtones Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        /// Sets the midtones Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        abstract midtonesDensity: float with get, set
        /// Gets the midtones Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        /// Sets the midtones Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        abstract midtonesSaturation: float with get, set
        /// Gets the midtones Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        /// Sets the midtones Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        abstract midtonesExposure: float with get, set
        /// Gets the shadows Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        /// Sets the shadows Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        abstract shadowsHue: float with get, set
        /// Gets the shadows Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        /// Sets the shadows Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        abstract shadowsDensity: float with get, set
        /// Gets the shadows Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        /// Sets the shadows Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        abstract shadowsSaturation: float with get, set
        /// Gets the shadows Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        /// Sets the shadows Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        abstract shadowsExposure: float with get, set
        /// Returns the class name
        abstract getClassName: unit -> string
        /// Clones the current color curve instance.
        abstract clone: unit -> ColorCurves
        /// Serializes the current color curve instance to a json representation.
        abstract serialize: unit -> obj option

    /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
    /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
    /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
    /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
    type [<AllowNullLiteral>] ColorCurvesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ColorCurves
        /// <summary>Binds the color curves to the shader.</summary>
        /// <param name="colorCurves">The color curve to bind</param>
        /// <param name="effect">The effect to bind to</param>
        /// <param name="positiveUniform">The positive uniform shader parameter</param>
        /// <param name="neutralUniform">The neutral uniform shader parameter</param>
        /// <param name="negativeUniform">The negative uniform shader parameter</param>
        abstract Bind: colorCurves: ColorCurves * effect: Effect * ?positiveUniform: string * ?neutralUniform: string * ?negativeUniform: string -> unit
        /// <summary>Prepare the list of uniforms associated with the ColorCurves effects.</summary>
        /// <param name="uniformsList">The list of uniforms used in the effect</param>
        abstract PrepareUniforms: uniformsList: ResizeArray<string> -> unit
        /// <summary>Parses the color curve from a json representation.</summary>
        /// <param name="source">the JSON source to parse</param>
        abstract Parse: source: obj option -> ColorCurves

    /// EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.
    /// (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)
    type [<AllowNullLiteral>] EffectFallbacks =
        /// Removes the fallback from the bound mesh.
        abstract unBindMesh: unit -> unit
        /// <summary>Adds a fallback on the specified property.</summary>
        /// <param name="rank">The rank of the fallback (Lower ranks will be fallbacked to first)</param>
        /// <param name="define">The name of the define in the shader</param>
        abstract addFallback: rank: float * define: string -> unit
        /// <summary>Sets the mesh to use CPU skinning when needing to fallback.</summary>
        /// <param name="rank">The rank of the fallback (Lower ranks will be fallbacked to first)</param>
        /// <param name="mesh">The mesh to use the fallbacks.</param>
        abstract addCPUSkinningFallback: rank: float * mesh: AbstractMesh -> unit
        /// Checks to see if more fallbacks are still availible.
        abstract isMoreFallbacks: bool
        /// <summary>Removes the defines that shoould be removed when falling back.</summary>
        /// <param name="currentDefines">defines the current define statements for the shader.</param>
        /// <param name="effect">defines the current effect we try to compile</param>
        abstract reduce: currentDefines: string * effect: Effect -> string

    /// EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.
    /// (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)
    type [<AllowNullLiteral>] EffectFallbacksStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> EffectFallbacks

    /// Options to be used when creating an effect.
    type [<AllowNullLiteral>] EffectCreationOptions =
        /// Atrributes that will be used in the shader.
        abstract attributes: ResizeArray<string> with get, set
        /// Uniform varible names that will be set in the shader.
        abstract uniformsNames: ResizeArray<string> with get, set
        /// Uniform buffer varible names that will be set in the shader.
        abstract uniformBuffersNames: ResizeArray<string> with get, set
        /// Sampler texture variable names that will be set in the shader.
        abstract samplers: ResizeArray<string> with get, set
        /// Define statements that will be set in the shader.
        abstract defines: obj option with get, set
        /// Possible fallbacks for this effect to improve performance when needed.
        abstract fallbacks: Nullable<EffectFallbacks> with get, set
        /// Callback that will be called when the shader is compiled.
        abstract onCompiled: Nullable<(Effect -> unit)> with get, set
        /// Callback that will be called if an error occurs during shader compilation.
        abstract onError: Nullable<(Effect -> string -> unit)> with get, set
        /// Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})
        abstract indexParameters: obj option with get, set
        /// Max number of lights that can be used in the shader.
        abstract maxSimultaneousLights: float with get, set
        /// See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings
        abstract transformFeedbackVaryings: Nullable<ResizeArray<string>> with get, set

    /// Options to be used when creating an effect.
    type [<AllowNullLiteral>] EffectCreationOptionsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> EffectCreationOptions

    /// Effect containing vertex and fragment shader that can be executed on an object.
    type [<AllowNullLiteral>] Effect =
        /// Name of the effect.
        abstract name: obj option with get, set
        /// String container all the define statements that should be set on the shader.
        abstract defines: string with get, set
        /// Callback that will be called when the shader is compiled.
        abstract onCompiled: Nullable<(Effect -> unit)> with get, set
        /// Callback that will be called if an error occurs during shader compilation.
        abstract onError: Nullable<(Effect -> string -> unit)> with get, set
        /// Callback that will be called when effect is bound.
        abstract onBind: Nullable<(Effect -> unit)> with get, set
        /// Unique ID of the effect.
        abstract uniqueId: float with get, set
        /// Observable that will be called when the shader is compiled.
        abstract onCompileObservable: Observable<Effect> with get, set
        /// Observable that will be called if an error occurs during shader compilation.
        abstract onErrorObservable: Observable<Effect> with get, set
        abstract _onBindObservable: Nullable<Observable<Effect>> with get, set
        /// Observable that will be called when effect is bound.
        abstract onBindObservable: Observable<Effect>
        abstract _bonesComputationForcedToCPU: bool with get, set
        /// Key for the effect.
        abstract _key: string with get, set
        /// Compiled shader to webGL program.
        abstract _program: WebGLProgram with get, set
        /// Unique key for this effect
        abstract key: string
        /// If the effect has been compiled and prepared.
        abstract isReady: unit -> bool
        /// The engine the effect was initialized with.
        abstract getEngine: unit -> Engine
        /// The compiled webGL program for the effect
        abstract getProgram: unit -> WebGLProgram
        /// The set of names of attribute variables for the shader.
        abstract getAttributesNames: unit -> ResizeArray<string>
        /// <summary>Returns the attribute at the given index.</summary>
        /// <param name="index">The index of the attribute.</param>
        abstract getAttributeLocation: index: float -> float
        /// <summary>Returns the attribute based on the name of the variable.</summary>
        /// <param name="name">of the attribute to look up.</param>
        abstract getAttributeLocationByName: name: string -> float
        /// The number of attributes.
        abstract getAttributesCount: unit -> float
        /// <summary>Gets the index of a uniform variable.</summary>
        /// <param name="uniformName">of the uniform to look up.</param>
        abstract getUniformIndex: uniformName: string -> float
        /// <summary>Returns the attribute based on the name of the variable.</summary>
        /// <param name="uniformName">of the uniform to look up.</param>
        abstract getUniform: uniformName: string -> Nullable<WebGLUniformLocation>
        /// Returns an array of sampler variable names
        abstract getSamplers: unit -> ResizeArray<string>
        /// The error from the last compilation.
        abstract getCompilationError: unit -> string
        /// <summary>Adds a callback to the onCompiled observable and call the callback imediatly if already ready.</summary>
        /// <param name="func">The callback to be used.</param>
        abstract executeWhenCompiled: func: (Effect -> unit) -> unit
        abstract _loadVertexShader: vertex: obj option * callback: (obj option -> unit) -> unit
        abstract _loadFragmentShader: fragment: obj option * callback: (obj option -> unit) -> unit
        abstract _dumpShadersSource: vertexCode: string * fragmentCode: string * defines: string -> unit
        /// <summary>Recompiles the webGL program</summary>
        /// <param name="vertexSourceCode">The source code for the vertex shader.</param>
        /// <param name="fragmentSourceCode">The source code for the fragment shader.</param>
        /// <param name="onCompiled">Callback called when completed.</param>
        /// <param name="onError">Callback called on error.</param>
        abstract _rebuildProgram: vertexSourceCode: string * fragmentSourceCode: string * onCompiled: (WebGLProgram -> unit) * onError: (string -> unit) -> unit
        /// <summary>Gets the uniform locations of the the specified variable names</summary>
        /// <param name="names">THe names of the variables to lookup.</param>
        abstract getSpecificUniformLocations: names: ResizeArray<string> -> ResizeArray<Nullable<WebGLUniformLocation>>
        /// Prepares the effect
        abstract _prepareEffect: unit -> unit
        /// Checks if the effect is supported. (Must be called after compilation)
        abstract isSupported: bool
        /// <summary>Binds a texture to the engine to be used as output of the shader.</summary>
        /// <param name="channel">Name of the output variable.</param>
        /// <param name="texture">Texture to bind.</param>
        abstract _bindTexture: channel: string * texture: InternalTexture -> unit
        /// <summary>Sets a texture on the engine to be used in the shader.</summary>
        /// <param name="channel">Name of the sampler variable.</param>
        /// <param name="texture">Texture to set.</param>
        abstract setTexture: channel: string * texture: Nullable<BaseTexture> -> unit
        /// <summary>Sets a depth stencil texture from a render target on the engine to be used in the shader.</summary>
        /// <param name="channel">Name of the sampler variable.</param>
        /// <param name="texture">Texture to set.</param>
        abstract setDepthStencilTexture: channel: string * texture: Nullable<RenderTargetTexture> -> unit
        /// <summary>Sets an array of textures on the engine to be used in the shader.</summary>
        /// <param name="channel">Name of the variable.</param>
        /// <param name="textures">Textures to set.</param>
        abstract setTextureArray: channel: string * textures: ResizeArray<BaseTexture> -> unit
        /// <summary>Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)</summary>
        /// <param name="channel">Name of the sampler variable.</param>
        /// <param name="postProcess">Post process to get the input texture from.</param>
        abstract setTextureFromPostProcess: channel: string * postProcess: Nullable<PostProcess> -> unit
        /// <summary>(Warning! setTextureFromPostProcessOutput may be desired instead)
        /// Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)</summary>
        /// <param name="channel">Name of the sampler variable.</param>
        /// <param name="postProcess">Post process to get the output texture from.</param>
        abstract setTextureFromPostProcessOutput: channel: string * postProcess: Nullable<PostProcess> -> unit
        abstract _cacheMatrix: uniformName: string * matrix: Matrix -> bool
        abstract _cacheFloat2: uniformName: string * x: float * y: float -> bool
        abstract _cacheFloat3: uniformName: string * x: float * y: float * z: float -> bool
        abstract _cacheFloat4: uniformName: string * x: float * y: float * z: float * w: float -> bool
        /// <summary>Binds a buffer to a uniform.</summary>
        /// <param name="buffer">Buffer to bind.</param>
        /// <param name="name">Name of the uniform variable to bind to.</param>
        abstract bindUniformBuffer: buffer: WebGLBuffer * name: string -> unit
        /// <summary>Binds block to a uniform.</summary>
        /// <param name="blockName">Name of the block to bind.</param>
        /// <param name="index">Index to bind.</param>
        abstract bindUniformBlock: blockName: string * index: float -> unit
        /// <summary>Sets an interger value on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="value">Value to be set.</param>
        abstract setInt: uniformName: string * value: float -> Effect
        /// <summary>Sets an int array on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setIntArray: uniformName: string * array: Int32Array -> Effect
        /// <summary>Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setIntArray2: uniformName: string * array: Int32Array -> Effect
        /// <summary>Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setIntArray3: uniformName: string * array: Int32Array -> Effect
        /// <summary>Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setIntArray4: uniformName: string * array: Int32Array -> Effect
        /// <summary>Sets an float array on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setFloatArray: uniformName: string * array: Float32Array -> Effect
        /// <summary>Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setFloatArray2: uniformName: string * array: Float32Array -> Effect
        /// <summary>Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setFloatArray3: uniformName: string * array: Float32Array -> Effect
        /// <summary>Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setFloatArray4: uniformName: string * array: Float32Array -> Effect
        /// <summary>Sets an array on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setArray: uniformName: string * array: ResizeArray<float> -> Effect
        /// <summary>Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setArray2: uniformName: string * array: ResizeArray<float> -> Effect
        /// <summary>Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setArray3: uniformName: string * array: ResizeArray<float> -> Effect
        /// <summary>Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setArray4: uniformName: string * array: ResizeArray<float> -> Effect
        /// <summary>Sets matrices on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="matrices">matrices to be set.</param>
        abstract setMatrices: uniformName: string * matrices: Float32Array -> Effect
        /// <summary>Sets matrix on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="matrix">matrix to be set.</param>
        abstract setMatrix: uniformName: string * matrix: Matrix -> Effect
        /// <summary>Sets a 3x3 matrix on a uniform variable. (Speicified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="matrix">matrix to be set.</param>
        abstract setMatrix3x3: uniformName: string * matrix: Float32Array -> Effect
        /// <summary>Sets a 2x2 matrix on a uniform variable. (Speicified as [1,2,3,4] will result in [1,2][3,4] matrix)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="matrix">matrix to be set.</param>
        abstract setMatrix2x2: uniformName: string * matrix: Float32Array -> Effect
        /// <summary>Sets a float on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="value">value to be set.</param>
        abstract setFloat: uniformName: string * value: float -> Effect
        /// <summary>Sets a boolean on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="bool">value to be set.</param>
        abstract setBool: uniformName: string * bool: bool -> Effect
        /// <summary>Sets a Vector2 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="vector2">vector2 to be set.</param>
        abstract setVector2: uniformName: string * vector2: Vector2 -> Effect
        /// <summary>Sets a float2 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="x">First float in float2.</param>
        /// <param name="y">Second float in float2.</param>
        abstract setFloat2: uniformName: string * x: float * y: float -> Effect
        /// <summary>Sets a Vector3 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="vector3">Value to be set.</param>
        abstract setVector3: uniformName: string * vector3: Vector3 -> Effect
        /// <summary>Sets a float3 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="x">First float in float3.</param>
        /// <param name="y">Second float in float3.</param>
        /// <param name="z">Third float in float3.</param>
        abstract setFloat3: uniformName: string * x: float * y: float * z: float -> Effect
        /// <summary>Sets a Vector4 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="vector4">Value to be set.</param>
        abstract setVector4: uniformName: string * vector4: Vector4 -> Effect
        /// <summary>Sets a float4 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="x">First float in float4.</param>
        /// <param name="y">Second float in float4.</param>
        /// <param name="z">Third float in float4.</param>
        /// <param name="w">Fourth float in float4.</param>
        abstract setFloat4: uniformName: string * x: float * y: float * z: float * w: float -> Effect
        /// <summary>Sets a Color3 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="color3">Value to be set.</param>
        abstract setColor3: uniformName: string * color3: Color3 -> Effect
        /// <summary>Sets a Color4 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="color3">Value to be set.</param>
        /// <param name="alpha">Alpha value to be set.</param>
        abstract setColor4: uniformName: string * color3: Color3 * alpha: float -> Effect
        /// <summary>Sets a Color4 on a uniform variable</summary>
        /// <param name="uniformName">defines the name of the variable</param>
        /// <param name="color4">defines the value to be set</param>
        abstract setDirectColor4: uniformName: string * color4: Color4 -> Effect

    /// Effect containing vertex and fragment shader that can be executed on an object.
    type [<AllowNullLiteral>] EffectStatic =
        /// <summary>Instantiates an effect.
        /// An effect can be used to create/manage/execute vertex and fragment shaders.</summary>
        /// <param name="baseName">Name of the effect.</param>
        /// <param name="attributesNamesOrOptions">List of attribute names that will be passed to the shader or set of all options to create the effect.</param>
        /// <param name="uniformsNamesOrEngine">List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.</param>
        /// <param name="samplers">List of sampler variables that will be passed to the shader.</param>
        /// <param name="engine">Engine to be used to render the effect</param>
        /// <param name="defines">Define statements to be added to the shader.</param>
        /// <param name="fallbacks">Possible fallbacks for this effect to improve performance when needed.</param>
        /// <param name="onCompiled">Callback that will be called when the shader is compiled.</param>
        /// <param name="onError">Callback that will be called if an error occurs during shader compilation.</param>
        /// <param name="indexParameters">Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})</param>
        [<Emit "new $0($1...)">] abstract Create: baseName: obj option * attributesNamesOrOptions: U2<ResizeArray<string>, EffectCreationOptions> * uniformsNamesOrEngine: U2<ResizeArray<string>, Engine> * ?samplers: ResizeArray<string> * ?engine: Engine * ?defines: string * ?fallbacks: EffectFallbacks * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) * ?indexParameters: obj -> Effect
        /// <summary>This function will add a new shader to the shader store</summary>
        /// <param name="name">the name of the shader</param>
        /// <param name="pixelShader">optional pixel shader content</param>
        /// <param name="vertexShader">optional vertex shader content</param>
        abstract RegisterShader: name: string * ?pixelShader: string * ?vertexShader: string -> unit
        /// Store of each shader (The can be looked up using effect.key)
        abstract ShadersStore: TypeLiteral_23 with get, set
        /// Store of each included file for a shader (The can be looked up using effect.key)
        abstract IncludesShadersStore: TypeLiteral_23 with get, set
        /// Resets the cache of effects.
        abstract ResetCache: unit -> unit

    /// This represents all the required information to add a fresnel effect on a material:
    type [<AllowNullLiteral>] FresnelParameters =
        /// Define if the fresnel effect is enable or not.
        abstract isEnabled: bool with get, set
        /// Define the color used on edges (grazing angle)
        abstract leftColor: Color3 with get, set
        /// Define the color used on center
        abstract rightColor: Color3 with get, set
        /// Define bias applied to computed fresnel term
        abstract bias: float with get, set
        /// Defined the power exponent applied to fresnel term
        abstract power: float with get, set
        /// Clones the current fresnel and its valuues
        abstract clone: unit -> FresnelParameters
        /// Serializes the current fresnel parameters to a JSON representation.
        abstract serialize: unit -> obj option

    /// This represents all the required information to add a fresnel effect on a material:
    type [<AllowNullLiteral>] FresnelParametersStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FresnelParameters
        /// <summary>Parse a JSON object and deserialize it to a new Fresnel parameter object.</summary>
        /// <param name="parsedFresnelParameters">Define the JSON representation</param>
        abstract Parse: parsedFresnelParameters: obj option -> FresnelParameters

    /// Interface to follow in your material defines to integrate easily the
    /// Image proccessing functions.
    type [<AllowNullLiteral>] IImageProcessingConfigurationDefines =
        abstract IMAGEPROCESSING: bool with get, set
        abstract VIGNETTE: bool with get, set
        abstract VIGNETTEBLENDMODEMULTIPLY: bool with get, set
        abstract VIGNETTEBLENDMODEOPAQUE: bool with get, set
        abstract TONEMAPPING: bool with get, set
        abstract TONEMAPPING_ACES: bool with get, set
        abstract CONTRAST: bool with get, set
        abstract EXPOSURE: bool with get, set
        abstract COLORCURVES: bool with get, set
        abstract COLORGRADING: bool with get, set
        abstract COLORGRADING3D: bool with get, set
        abstract SAMPLER3DGREENDEPTH: bool with get, set
        abstract SAMPLER3DBGRMAP: bool with get, set
        abstract IMAGEPROCESSINGPOSTPROCESS: bool with get, set

    type [<AllowNullLiteral>] ImageProcessingConfigurationDefines =
        inherit MaterialDefines
        inherit IImageProcessingConfigurationDefines
        abstract IMAGEPROCESSING: bool with get, set
        abstract VIGNETTE: bool with get, set
        abstract VIGNETTEBLENDMODEMULTIPLY: bool with get, set
        abstract VIGNETTEBLENDMODEOPAQUE: bool with get, set
        abstract TONEMAPPING: bool with get, set
        abstract TONEMAPPING_ACES: bool with get, set
        abstract CONTRAST: bool with get, set
        abstract COLORCURVES: bool with get, set
        abstract COLORGRADING: bool with get, set
        abstract COLORGRADING3D: bool with get, set
        abstract SAMPLER3DGREENDEPTH: bool with get, set
        abstract SAMPLER3DBGRMAP: bool with get, set
        abstract IMAGEPROCESSINGPOSTPROCESS: bool with get, set
        abstract EXPOSURE: bool with get, set

    type [<AllowNullLiteral>] ImageProcessingConfigurationDefinesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ImageProcessingConfigurationDefines

    /// This groups together the common properties used for image processing either in direct forward pass
    /// or through post processing effect depending on the use of the image processing pipeline in your scene
    /// or not.
    type [<AllowNullLiteral>] ImageProcessingConfiguration =
        /// Color curves setup used in the effect if colorCurvesEnabled is set to true
        abstract colorCurves: Nullable<ColorCurves> with get, set
        /// Gets wether the color curves effect is enabled.
        /// Sets wether the color curves effect is enabled.
        abstract colorCurvesEnabled: bool with get, set
        /// Color grading LUT texture used in the effect if colorGradingEnabled is set to true
        /// Color grading LUT texture used in the effect if colorGradingEnabled is set to true
        abstract colorGradingTexture: Nullable<BaseTexture> with get, set
        /// Gets wether the color grading effect is enabled.
        /// Sets wether the color grading effect is enabled.
        abstract colorGradingEnabled: bool with get, set
        /// Gets wether the color grading effect is using a green depth for the 3d Texture.
        /// Sets wether the color grading effect is using a green depth for the 3d Texture.
        abstract colorGradingWithGreenDepth: bool with get, set
        /// Gets wether the color grading texture contains BGR values.
        /// Sets wether the color grading texture contains BGR values.
        abstract colorGradingBGR: bool with get, set
        abstract _exposure: float with get, set
        /// Gets the Exposure used in the effect.
        /// Sets the Exposure used in the effect.
        abstract exposure: float with get, set
        /// Gets wether the tone mapping effect is enabled.
        /// Sets wether the tone mapping effect is enabled.
        abstract toneMappingEnabled: bool with get, set
        /// Gets the type of tone mapping effect.
        /// Sets the type of tone mapping effect used in BabylonJS.
        abstract toneMappingType: float with get, set
        abstract _contrast: float with get, set
        /// Gets the contrast used in the effect.
        /// Sets the contrast used in the effect.
        abstract contrast: float with get, set
        /// Vignette stretch size.
        abstract vignetteStretch: float with get, set
        /// Vignette centre X Offset.
        abstract vignetteCentreX: float with get, set
        /// Vignette centre Y Offset.
        abstract vignetteCentreY: float with get, set
        /// Vignette weight or intensity of the vignette effect.
        abstract vignetteWeight: float with get, set
        /// Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
        /// if vignetteEnabled is set to true.
        abstract vignetteColor: Color4 with get, set
        /// Camera field of view used by the Vignette effect.
        abstract vignetteCameraFov: float with get, set
        /// Gets the vignette blend mode allowing different kind of effect.
        /// Sets the vignette blend mode allowing different kind of effect.
        abstract vignetteBlendMode: float with get, set
        /// Gets wether the vignette effect is enabled.
        /// Sets wether the vignette effect is enabled.
        abstract vignetteEnabled: bool with get, set
        /// Gets wether the image processing is applied through a post process or not.
        /// Sets wether the image processing is applied through a post process or not.
        abstract applyByPostProcess: bool with get, set
        /// Gets wether the image processing is enabled or not.
        /// Sets wether the image processing is enabled or not.
        abstract isEnabled: bool with get, set
        /// An event triggered when the configuration changes and requires Shader to Update some parameters.
        abstract onUpdateParameters: Observable<ImageProcessingConfiguration> with get, set
        /// Method called each time the image processing information changes requires to recompile the effect.
        abstract _updateParameters: unit -> unit
        /// Gets the current class name.
        abstract getClassName: unit -> string
        /// <summary>Prepare the list of defines associated to the shader.</summary>
        /// <param name="defines">the list of defines to complete</param>
        /// <param name="forPostProcess">Define if we are currently in post process mode or not</param>
        abstract prepareDefines: defines: IImageProcessingConfigurationDefines * ?forPostProcess: bool -> unit
        /// Returns true if all the image processing information are ready.
        abstract isReady: unit -> bool
        /// <summary>Binds the image processing to the shader.</summary>
        /// <param name="effect">The effect to bind to</param>
        /// <param name="aspectRatio">Define the current aspect ratio of the effect</param>
        abstract bind: effect: Effect * ?aspectRatio: float -> unit
        /// Clones the current image processing instance.
        abstract clone: unit -> ImageProcessingConfiguration
        /// Serializes the current image processing instance to a json representation.
        abstract serialize: unit -> obj option

    /// This groups together the common properties used for image processing either in direct forward pass
    /// or through post processing effect depending on the use of the image processing pipeline in your scene
    /// or not.
    type [<AllowNullLiteral>] ImageProcessingConfigurationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ImageProcessingConfiguration
        /// Default tone mapping applied in BabylonJS.
        abstract TONEMAPPING_STANDARD: float
        /// ACES Tone mapping (used by default in unreal and unity). This can help getting closer
        /// to other engines rendering to increase portability.
        abstract TONEMAPPING_ACES: float
        /// <summary>Prepare the list of uniforms associated with the Image Processing effects.</summary>
        /// <param name="uniforms">The list of uniforms used in the effect</param>
        /// <param name="defines">the list of defines currently in use</param>
        abstract PrepareUniforms: uniforms: ResizeArray<string> * defines: IImageProcessingConfigurationDefines -> unit
        /// <summary>Prepare the list of samplers associated with the Image Processing effects.</summary>
        /// <param name="samplersList">The list of uniforms used in the effect</param>
        /// <param name="defines">the list of defines currently in use</param>
        abstract PrepareSamplers: samplersList: ResizeArray<string> * defines: IImageProcessingConfigurationDefines -> unit
        /// <summary>Parses the image processing from a json representation.</summary>
        /// <param name="source">the JSON source to parse</param>
        abstract Parse: source: obj option -> ImageProcessingConfiguration
        /// Used to apply the vignette as a mix with the pixel color.
        abstract VIGNETTEMODE_MULTIPLY: float
        /// Used to apply the vignette as a replacement of the pixel color.
        abstract VIGNETTEMODE_OPAQUE: float

    /// Manages the defines for the Material
    type [<AllowNullLiteral>] MaterialDefines =
        abstract _renderId: float with get, set
        abstract _areLightsDirty: bool with get, set
        abstract _areAttributesDirty: bool with get, set
        abstract _areTexturesDirty: bool with get, set
        abstract _areFresnelDirty: bool with get, set
        abstract _areMiscDirty: bool with get, set
        abstract _areImageProcessingDirty: bool with get, set
        abstract _normals: bool with get, set
        abstract _uvs: bool with get, set
        abstract _needNormals: bool with get, set
        abstract _needUVs: bool with get, set
        /// Specifies if the material needs to be re-calculated
        abstract isDirty: bool
        /// Marks the material to indicate that it has been re-calculated
        abstract markAsProcessed: unit -> unit
        /// Marks the material to indicate that it needs to be re-calculated
        abstract markAsUnprocessed: unit -> unit
        /// Marks the material to indicate all of its defines need to be re-calculated
        abstract markAllAsDirty: unit -> unit
        /// Marks the material to indicate that image processing needs to be re-calculated
        abstract markAsImageProcessingDirty: unit -> unit
        /// Marks the material to indicate the lights need to be re-calculated
        abstract markAsLightDirty: unit -> unit
        /// Marks the attribute state as changed
        abstract markAsAttributesDirty: unit -> unit
        /// Marks the texture state as changed
        abstract markAsTexturesDirty: unit -> unit
        /// Marks the fresnel state as changed
        abstract markAsFresnelDirty: unit -> unit
        /// Marks the misc state as changed
        abstract markAsMiscDirty: unit -> unit
        /// Rebuilds the material defines
        abstract rebuild: unit -> unit
        /// <summary>Specifies if two material defines are equal</summary>
        /// <param name="other">- A material define instance to compare to</param>
        abstract isEqual: other: MaterialDefines -> bool
        /// <summary>Clones this instance's defines to another instance</summary>
        /// <param name="other">- material defines to clone values to</param>
        abstract cloneTo: other: MaterialDefines -> unit
        /// Resets the material define values
        abstract reset: unit -> unit
        /// Converts the material define values to a string
        abstract toString: unit -> string

    /// Manages the defines for the Material
    type [<AllowNullLiteral>] MaterialDefinesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> MaterialDefines

    /// Base class for the main features of a material in Babylon.js
    type [<AllowNullLiteral>] Material =
        inherit IAnimatable
        /// The ID of the material
        abstract id: string with get, set
        /// Gets or sets the unique id of the material
        abstract uniqueId: float with get, set
        /// The name of the material
        abstract name: string with get, set
        /// Specifies if the ready state should be checked on each call
        abstract checkReadyOnEveryCall: bool with get, set
        /// Specifies if the ready state should be checked once
        abstract checkReadyOnlyOnce: bool with get, set
        /// The state of the material
        abstract state: string with get, set
        /// The alpha value of the material
        abstract _alpha: float with get, set
        /// Sets the alpha value of the material
        /// Gets the alpha value of the material
        abstract alpha: float with get, set
        /// Specifies if back face culling is enabled
        abstract _backFaceCulling: bool with get, set
        /// Sets the back-face culling state
        /// Gets the back-face culling state
        abstract backFaceCulling: bool with get, set
        /// Stores the value for side orientation
        abstract sideOrientation: float with get, set
        /// Callback triggered when the material is compiled
        abstract onCompiled: (Effect -> unit) with get, set
        /// Callback triggered when an error occurs
        abstract onError: (Effect -> string -> unit) with get, set
        /// Callback triggered to get the render target textures
        abstract getRenderTargetTextures: (unit -> SmartArray<RenderTargetTexture>) with get, set
        /// Gets a boolean indicating that current material needs to register RTT
        abstract hasRenderTargetTextures: bool
        /// Specifies if the material should be serialized
        abstract doNotSerialize: bool with get, set
        /// Specifies if the effect should be stored on sub meshes
        abstract storeEffectOnSubMeshes: bool with get, set
        /// Stores the animations for the material
        abstract animations: Array<Animation> with get, set
        /// An event triggered when the material is disposed
        abstract onDisposeObservable: Observable<Material> with get, set
        /// Called during a dispose event
        abstract onDispose: (unit -> unit) with get, set
        /// An event triggered when the material is bound
        abstract onBindObservable: Observable<AbstractMesh>
        /// Called during a bind event
        abstract onBind: (AbstractMesh -> unit) with get, set
        /// An event triggered when the material is unbound
        abstract onUnBindObservable: Observable<Material>
        /// Sets the value of the alpha mode.
        /// 
        /// | Value | Type | Description |
        /// | --- | --- | --- |
        /// | 0 | ALPHA_DISABLE |   |
        /// | 1 | ALPHA_ADD |   |
        /// | 2 | ALPHA_COMBINE |   |
        /// | 3 | ALPHA_SUBTRACT |   |
        /// | 4 | ALPHA_MULTIPLY |   |
        /// | 5 | ALPHA_MAXIMIZED |   |
        /// | 6 | ALPHA_ONEONE |   |
        /// | 7 | ALPHA_PREMULTIPLIED |   |
        /// | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |
        /// | 9 | ALPHA_INTERPOLATE |   |
        /// | 10 | ALPHA_SCREENMODE |   |
        /// Gets the value of the alpha mode
        abstract alphaMode: float with get, set
        /// Sets the need depth pre-pass value
        /// Gets the depth pre-pass value
        abstract needDepthPrePass: bool with get, set
        /// Specifies if depth writing should be disabled
        abstract disableDepthWrite: bool with get, set
        /// Specifies if depth writing should be forced
        abstract forceDepthWrite: bool with get, set
        /// Specifies if there should be a separate pass for culling
        abstract separateCullingPass: bool with get, set
        /// Sets the state for enabling fog
        /// Gets the value of the fog enabled state
        abstract fogEnabled: bool with get, set
        /// Stores the size of points
        abstract pointSize: float with get, set
        /// Stores the z offset value
        abstract zOffset: float with get, set
        /// Gets a value specifying if wireframe mode is enabled
        /// Sets the state of wireframe mode
        abstract wireframe: bool with get, set
        /// Gets the value specifying if point clouds are enabled
        /// Sets the state of point cloud mode
        abstract pointsCloud: bool with get, set
        /// Gets the material fill mode
        /// Sets the material fill mode
        abstract fillMode: float with get, set
        abstract _effect: Nullable<Effect> with get, set
        abstract _wasPreviouslyReady: bool with get, set
        /// Stores the uniform buffer
        abstract _uniformBuffer: UniformBuffer with get, set
        /// <summary>Returns a string representation of the current material</summary>
        /// <param name="fullDetails">defines a boolean indicating which levels of logging is desired</param>
        abstract toString: ?fullDetails: bool -> string
        /// Gets the class name of the material
        abstract getClassName: unit -> string
        /// Specifies if updates for the material been locked
        abstract isFrozen: bool
        /// Locks updates for the material
        abstract freeze: unit -> unit
        /// Unlocks updates for the material
        abstract unfreeze: unit -> unit
        /// <summary>Specifies if the material is ready to be used</summary>
        /// <param name="mesh">defines the mesh to check</param>
        /// <param name="useInstances">specifies if instances should be used</param>
        abstract isReady: ?mesh: AbstractMesh * ?useInstances: bool -> bool
        /// <summary>Specifies that the submesh is ready to be used</summary>
        /// <param name="mesh">defines the mesh to check</param>
        /// <param name="subMesh">defines which submesh to check</param>
        /// <param name="useInstances">specifies that instances should be used</param>
        abstract isReadyForSubMesh: mesh: AbstractMesh * subMesh: BaseSubMesh * ?useInstances: bool -> bool
        /// Returns the material effect
        abstract getEffect: unit -> Nullable<Effect>
        /// Returns the current scene
        abstract getScene: unit -> Scene
        /// Specifies if the material will require alpha blending
        abstract needAlphaBlending: unit -> bool
        /// <summary>Specifies if the mesh will require alpha blending</summary>
        /// <param name="mesh">defines the mesh to check</param>
        abstract needAlphaBlendingForMesh: mesh: AbstractMesh -> bool
        /// Specifies if this material should be rendered in alpha test mode
        abstract needAlphaTesting: unit -> bool
        /// Gets the texture used for the alpha test
        abstract getAlphaTestTexture: unit -> Nullable<BaseTexture>
        /// Marks the material to indicate that it needs to be re-calculated
        abstract markDirty: unit -> unit
        abstract _preBind: ?effect: Effect * ?overrideOrientation: float -> bool
        /// <summary>Binds the material to the mesh</summary>
        /// <param name="world">defines the world transformation matrix</param>
        /// <param name="mesh">defines the mesh to bind the material to</param>
        abstract bind: world: Matrix * ?mesh: Mesh -> unit
        /// <summary>Binds the submesh to the material</summary>
        /// <param name="world">defines the world transformation matrix</param>
        /// <param name="mesh">defines the mesh containing the submesh</param>
        /// <param name="subMesh">defines the submesh to bind the material to</param>
        abstract bindForSubMesh: world: Matrix * mesh: Mesh * subMesh: SubMesh -> unit
        /// <summary>Binds the world matrix to the material</summary>
        /// <param name="world">defines the world transformation matrix</param>
        abstract bindOnlyWorldMatrix: world: Matrix -> unit
        /// <summary>Binds the scene's uniform buffer to the effect.</summary>
        /// <param name="effect">defines the effect to bind to the scene uniform buffer</param>
        /// <param name="sceneUbo">defines the uniform buffer storing scene data</param>
        abstract bindSceneUniformBuffer: effect: Effect * sceneUbo: UniformBuffer -> unit
        /// <summary>Binds the view matrix to the effect</summary>
        /// <param name="effect">defines the effect to bind the view matrix to</param>
        abstract bindView: effect: Effect -> unit
        /// <summary>Binds the view projection matrix to the effect</summary>
        /// <param name="effect">defines the effect to bind the view projection matrix to</param>
        abstract bindViewProjection: effect: Effect -> unit
        /// <summary>Specifies if material alpha testing should be turned on for the mesh</summary>
        /// <param name="mesh">defines the mesh to check</param>
        abstract _shouldTurnAlphaTestOn: mesh: AbstractMesh -> bool
        /// <summary>Processes to execute after binding the material to a mesh</summary>
        /// <param name="mesh">defines the rendered mesh</param>
        abstract _afterBind: ?mesh: Mesh -> unit
        /// Unbinds the material from the mesh
        abstract unbind: unit -> unit
        /// Gets the active textures from the material
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// <summary>Specifies if the material uses a texture</summary>
        /// <param name="texture">defines the texture to check against the material</param>
        abstract hasTexture: texture: BaseTexture -> bool
        /// <summary>Makes a duplicate of the material, and gives it a new name</summary>
        /// <param name="name">defines the new name for the duplicated material</param>
        abstract clone: name: string -> Nullable<Material>
        /// Gets the meshes bound to the material
        abstract getBindedMeshes: unit -> ResizeArray<AbstractMesh>
        /// <summary>Force shader compilation</summary>
        /// <param name="mesh">defines the mesh associated with this material</param>
        /// <param name="onCompiled">defines a function to execute once the material is compiled</param>
        /// <param name="options">defines the options to configure the compilation</param>
        abstract forceCompilation: mesh: AbstractMesh * ?onCompiled: (Material -> unit) * ?options: obj -> unit
        /// <summary>Force shader compilation</summary>
        /// <param name="mesh">defines the mesh that will use this material</param>
        /// <param name="options">defines additional options for compiling the shaders</param>
        abstract forceCompilationAsync: mesh: AbstractMesh * ?options: obj -> Promise<unit>
        /// <summary>Marks a define in the material to indicate that it needs to be re-computed</summary>
        /// <param name="flag">defines a flag used to determine which parts of the material have to be marked as dirty</param>
        abstract markAsDirty: flag: float -> unit
        /// <summary>Marks all submeshes of a material to indicate that their material defines need to be re-calculated</summary>
        /// <param name="func">defines a function which checks material defines against the submeshes</param>
        abstract _markAllSubMeshesAsDirty: func: (MaterialDefines -> unit) -> unit
        /// Indicates that image processing needs to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsImageProcessingDirty: unit -> unit
        /// Indicates that textures need to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsTexturesDirty: unit -> unit
        /// Indicates that fresnel needs to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsFresnelDirty: unit -> unit
        /// Indicates that fresnel and misc need to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsFresnelAndMiscDirty: unit -> unit
        /// Indicates that lights need to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsLightsDirty: unit -> unit
        /// Indicates that attributes need to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsAttributesDirty: unit -> unit
        /// Indicates that misc needs to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsMiscDirty: unit -> unit
        /// Indicates that textures and misc need to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsTexturesAndMiscDirty: unit -> unit
        /// <summary>Disposes the material</summary>
        /// <param name="forceDisposeEffect">specifies if effects should be forcefully disposed</param>
        /// <param name="forceDisposeTextures">specifies if textures should be forcefully disposed</param>
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit
        /// Serializes this material
        abstract serialize: unit -> obj option

    /// Base class for the main features of a material in Babylon.js
    type [<AllowNullLiteral>] MaterialStatic =
        /// Returns the triangle fill mode
        abstract TriangleFillMode: float
        /// Returns the wireframe mode
        abstract WireFrameFillMode: float
        /// Returns the point fill mode
        abstract PointFillMode: float
        /// Returns the point list draw mode
        abstract PointListDrawMode: float
        /// Returns the line list draw mode
        abstract LineListDrawMode: float
        /// Returns the line loop draw mode
        abstract LineLoopDrawMode: float
        /// Returns the line strip draw mode
        abstract LineStripDrawMode: float
        /// Returns the triangle strip draw mode
        abstract TriangleStripDrawMode: float
        /// Returns the triangle fan draw mode
        abstract TriangleFanDrawMode: float
        /// Returns the clock-wise side orientation
        abstract ClockWiseSideOrientation: float
        /// Returns the counter clock-wise side orientation
        abstract CounterClockWiseSideOrientation: float
        /// The dirty texture flag value
        abstract TextureDirtyFlag: float
        /// The dirty light flag value
        abstract LightDirtyFlag: float
        /// The dirty fresnel flag value
        abstract FresnelDirtyFlag: float
        /// The dirty attribute flag value
        abstract AttributesDirtyFlag: float
        /// The dirty misc flag value
        abstract MiscDirtyFlag: float
        /// The all dirty flag value
        abstract AllDirtyFlag: float
        /// <summary>Creates a material instance</summary>
        /// <param name="name">defines the name of the material</param>
        /// <param name="scene">defines the scene to reference</param>
        /// <param name="doNotAdd">specifies if the material should be added to the scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ?doNotAdd: bool -> Material
        /// <summary>Creates a MultiMaterial from parsed MultiMaterial data.</summary>
        /// <param name="parsedMultiMaterial">defines parsed MultiMaterial data.</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract ParseMultiMaterial: parsedMultiMaterial: obj option * scene: Scene -> MultiMaterial
        /// <summary>Creates a material from parsed material data</summary>
        /// <param name="parsedMaterial">defines parsed material data</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="rootUrl">defines the root URL to use to load textures</param>
        abstract Parse: parsedMaterial: obj option * scene: Scene * rootUrl: string -> obj option

    /// "Static Class" containing the most commonly used helper while dealing with material for
    /// rendering purpose.
    /// 
    /// It contains the basic tools to help defining defines, binding uniform for the common part of the materials.
    /// 
    /// This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.
    type [<AllowNullLiteral>] MaterialHelper =
        interface end

    /// "Static Class" containing the most commonly used helper while dealing with material for
    /// rendering purpose.
    /// 
    /// It contains the basic tools to help defining defines, binding uniform for the common part of the materials.
    /// 
    /// This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.
    type [<AllowNullLiteral>] MaterialHelperStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> MaterialHelper
        /// <summary>Bind the current view position to an effect.</summary>
        /// <param name="effect">The effect to be bound</param>
        /// <param name="scene">The scene the eyes position is used from</param>
        abstract BindEyePosition: effect: Effect * scene: Scene -> unit
        /// <summary>Helps preparing the defines values about the UVs in used in the effect.
        /// UVs are shared as much as we can accross channels in the shaders.</summary>
        /// <param name="texture">The texture we are preparing the UVs for</param>
        /// <param name="defines">The defines to update</param>
        /// <param name="key">The channel key "diffuse", "specular"... used in the shader</param>
        abstract PrepareDefinesForMergedUV: texture: BaseTexture * defines: obj option * key: string -> unit
        /// <summary>Binds a texture matrix value to its corrsponding uniform</summary>
        /// <param name="texture">The texture to bind the matrix for</param>
        /// <param name="uniformBuffer">The uniform buffer receivin the data</param>
        /// <param name="key">The channel key "diffuse", "specular"... used in the shader</param>
        abstract BindTextureMatrix: texture: BaseTexture * uniformBuffer: UniformBuffer * key: string -> unit
        /// <summary>Helper used to prepare the list of defines associated with misc. values for shader compilation</summary>
        /// <param name="mesh">defines the current mesh</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="useLogarithmicDepth">defines if logarithmic depth has to be turned on</param>
        /// <param name="pointsCloud">defines if point cloud rendering has to be turned on</param>
        /// <param name="fogEnabled">defines if fog has to be turned on</param>
        /// <param name="alphaTest">defines if alpha testing has to be turned on</param>
        /// <param name="defines">defines the current list of defines</param>
        abstract PrepareDefinesForMisc: mesh: AbstractMesh * scene: Scene * useLogarithmicDepth: bool * pointsCloud: bool * fogEnabled: bool * alphaTest: bool * defines: obj option -> unit
        /// <summary>Helper used to prepare the list of defines associated with frame values for shader compilation</summary>
        /// <param name="scene">defines the current scene</param>
        /// <param name="engine">defines the current engine</param>
        /// <param name="defines">specifies the list of active defines</param>
        /// <param name="useInstances">defines if instances have to be turned on</param>
        /// <param name="useClipPlane">defines if clip plane have to be turned on</param>
        abstract PrepareDefinesForFrameBoundValues: scene: Scene * engine: Engine * defines: obj option * useInstances: bool * ?useClipPlane: bool -> unit
        /// <summary>Prepares the defines used in the shader depending on the attributes data available in the mesh</summary>
        /// <param name="mesh">The mesh containing the geometry data we will draw</param>
        /// <param name="defines">The defines to update</param>
        /// <param name="useVertexColor">Precise whether vertex colors should be used or not (override mesh info)</param>
        /// <param name="useBones">Precise whether bones should be used or not (override mesh info)</param>
        /// <param name="useMorphTargets">Precise whether morph targets should be used or not (override mesh info)</param>
        /// <param name="useVertexAlpha">Precise whether vertex alpha should be used or not (override mesh info)</param>
        abstract PrepareDefinesForAttributes: mesh: AbstractMesh * defines: obj option * useVertexColor: bool * useBones: bool * ?useMorphTargets: bool * ?useVertexAlpha: bool -> bool
        /// <summary>Prepares the defines related to the light information passed in parameter</summary>
        /// <param name="scene">The scene we are intending to draw</param>
        /// <param name="mesh">The mesh the effect is compiling for</param>
        /// <param name="defines">The defines to update</param>
        /// <param name="specularSupported">Specifies whether specular is supported or not (override lights data)</param>
        /// <param name="maxSimultaneousLights">Specfies how manuy lights can be added to the effect at max</param>
        /// <param name="disableLighting">Specifies whether the lighting is disabled (override scene and light)</param>
        abstract PrepareDefinesForLights: scene: Scene * mesh: AbstractMesh * defines: obj option * specularSupported: bool * ?maxSimultaneousLights: float * ?disableLighting: bool -> bool
        /// <summary>Prepares the uniforms and samplers list to be used in the effect. This can automatically remove from the list uniforms
        /// that won t be acctive due to defines being turned off.</summary>
        /// <param name="uniformsListOrOptions">The uniform names to prepare or an EffectCreationOptions containing the liist and extra information</param>
        /// <param name="samplersList">The samplers list</param>
        /// <param name="defines">The defines helping in the list generation</param>
        /// <param name="maxSimultaneousLights">The maximum number of simultanous light allowed in the effect</param>
        abstract PrepareUniformsAndSamplersList: uniformsListOrOptions: U2<ResizeArray<string>, EffectCreationOptions> * ?samplersList: ResizeArray<string> * ?defines: obj * ?maxSimultaneousLights: float -> unit
        /// <summary>This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)</summary>
        /// <param name="defines">The defines to update while falling back</param>
        /// <param name="fallbacks">The authorized effect fallbacks</param>
        /// <param name="maxSimultaneousLights">The maximum number of lights allowed</param>
        /// <param name="rank">the current rank of the Effect</param>
        abstract HandleFallbacksForShadows: defines: obj option * fallbacks: EffectFallbacks * ?maxSimultaneousLights: float * ?rank: float -> float
        /// <summary>Prepares the list of attributes required for morph targets according to the effect defines.</summary>
        /// <param name="attribs">The current list of supported attribs</param>
        /// <param name="mesh">The mesh to prepare the morph targets attributes for</param>
        /// <param name="defines">The current Defines of the effect</param>
        abstract PrepareAttributesForMorphTargets: attribs: ResizeArray<string> * mesh: AbstractMesh * defines: obj option -> unit
        /// <summary>Prepares the list of attributes required for bones according to the effect defines.</summary>
        /// <param name="attribs">The current list of supported attribs</param>
        /// <param name="mesh">The mesh to prepare the bones attributes for</param>
        /// <param name="defines">The current Defines of the effect</param>
        /// <param name="fallbacks">The current efffect fallback strategy</param>
        abstract PrepareAttributesForBones: attribs: ResizeArray<string> * mesh: AbstractMesh * defines: obj option * fallbacks: EffectFallbacks -> unit
        /// <summary>Prepares the list of attributes required for instances according to the effect defines.</summary>
        /// <param name="attribs">The current list of supported attribs</param>
        /// <param name="defines">The current Defines of the effect</param>
        abstract PrepareAttributesForInstances: attribs: ResizeArray<string> * defines: obj option -> unit
        /// <summary>Binds the light shadow information to the effect for the given mesh.</summary>
        /// <param name="light">The light containing the generator</param>
        /// <param name="scene">The scene the lights belongs to</param>
        /// <param name="mesh">The mesh we are binding the information to render</param>
        /// <param name="lightIndex">The light index in the effect used to render the mesh</param>
        /// <param name="effect">The effect we are binding the data to</param>
        abstract BindLightShadow: light: Light * scene: Scene * mesh: AbstractMesh * lightIndex: string * effect: Effect -> unit
        /// <summary>Binds the light information to the effect.</summary>
        /// <param name="light">The light containing the generator</param>
        /// <param name="effect">The effect we are binding the data to</param>
        /// <param name="lightIndex">The light index in the effect used to render</param>
        abstract BindLightProperties: light: Light * effect: Effect * lightIndex: float -> unit
        /// <summary>Binds the lights information from the scene to the effect for the given mesh.</summary>
        /// <param name="scene">The scene the lights belongs to</param>
        /// <param name="mesh">The mesh we are binding the information to render</param>
        /// <param name="effect">The effect we are binding the data to</param>
        /// <param name="defines">The generated defines for the effect</param>
        /// <param name="maxSimultaneousLights">The maximum number of light that can be bound to the effect</param>
        /// <param name="usePhysicalLightFalloff">Specifies whether the light falloff is defined physically or not</param>
        abstract BindLights: scene: Scene * mesh: AbstractMesh * effect: Effect * defines: obj option * ?maxSimultaneousLights: float * ?usePhysicalLightFalloff: bool -> unit
        /// <summary>Binds the fog information from the scene to the effect for the given mesh.</summary>
        /// <param name="scene">The scene the lights belongs to</param>
        /// <param name="mesh">The mesh we are binding the information to render</param>
        /// <param name="effect">The effect we are binding the data to</param>
        /// <param name="linearSpace">Defines if the fog effect is applied in linear space</param>
        abstract BindFogParameters: scene: Scene * mesh: AbstractMesh * effect: Effect * ?linearSpace: bool -> unit
        /// <summary>Binds the bones information from the mesh to the effect.</summary>
        /// <param name="mesh">The mesh we are binding the information to render</param>
        /// <param name="effect">The effect we are binding the data to</param>
        abstract BindBonesParameters: ?mesh: AbstractMesh * ?effect: Effect -> unit
        /// <summary>Binds the morph targets information from the mesh to the effect.</summary>
        /// <param name="abstractMesh">The mesh we are binding the information to render</param>
        /// <param name="effect">The effect we are binding the data to</param>
        abstract BindMorphTargetParameters: abstractMesh: AbstractMesh * effect: Effect -> unit
        /// <summary>Binds the logarithmic depth information from the scene to the effect for the given defines.</summary>
        /// <param name="defines">The generated defines used in the effect</param>
        /// <param name="effect">The effect we are binding the data to</param>
        /// <param name="scene">The scene we are willing to render with logarithmic scale for</param>
        abstract BindLogDepth: defines: obj option * effect: Effect * scene: Scene -> unit
        /// <summary>Binds the clip plane information from the scene to the effect.</summary>
        /// <param name="effect">The effect we are binding the data to</param>
        /// <param name="scene">The scene the clip plane information are extracted from</param>
        abstract BindClipPlane: effect: Effect * scene: Scene -> unit

    /// A multi-material is used to apply different materials to different parts of the same object without the need of
    /// separate meshes. This can be use to improve performances.
    type [<AllowNullLiteral>] MultiMaterial =
        inherit Material
        /// Gets or Sets the list of Materials used within the multi material.
        /// They need to be ordered according to the submeshes order in the associated mesh
        abstract subMaterials: ResizeArray<Nullable<Material>> with get, set
        /// <summary>Get one of the submaterial by its index in the submaterials array</summary>
        /// <param name="index">The index to look the sub material at</param>
        abstract getSubMaterial: index: float -> Nullable<Material>
        /// Get the list of active textures for the whole sub materials list.
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// Gets the current class name of the material e.g. "MultiMaterial"
        /// Mainly use in serialization.
        abstract getClassName: unit -> string
        /// <summary>Checks if the material is ready to render the requested sub mesh</summary>
        /// <param name="mesh">Define the mesh the submesh belongs to</param>
        /// <param name="subMesh">Define the sub mesh to look readyness for</param>
        /// <param name="useInstances">Define whether or not the material is used with instances</param>
        abstract isReadyForSubMesh: mesh: AbstractMesh * subMesh: BaseSubMesh * ?useInstances: bool -> bool
        /// <summary>Clones the current material and its related sub materials</summary>
        /// <param name="name">Define the name of the newly cloned material</param>
        /// <param name="cloneChildren">Define if submaterial will be cloned or shared with the parent instance</param>
        abstract clone: name: string * ?cloneChildren: bool -> MultiMaterial
        /// Serializes the materials into a JSON representation.
        abstract serialize: unit -> obj option
        /// <summary>Dispose the material and release its associated resources</summary>
        /// <param name="forceDisposeEffect">Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)</param>
        /// <param name="forceDisposeTextures">Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)</param>
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit

    /// A multi-material is used to apply different materials to different parts of the same object without the need of
    /// separate meshes. This can be use to improve performances.
    type [<AllowNullLiteral>] MultiMaterialStatic =
        /// <summary>Instantiates a new Multi Material
        /// A multi-material is used to apply different materials to different parts of the same object without the need of
        /// separate meshes. This can be use to improve performances.</summary>
        /// <param name="name">Define the name in the scene</param>
        /// <param name="scene">Define the scene the material belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> MultiMaterial

    /// Base class of materials working in push mode in babylon JS
    type [<AllowNullLiteral>] PushMaterial =
        inherit Material
        abstract _activeEffect: Effect with get, set
        abstract _normalMatrix: Matrix with get, set
        abstract getEffect: unit -> Effect
        abstract isReady: ?mesh: AbstractMesh * ?useInstances: bool -> bool
        /// <summary>Binds the given world matrix to the active effect</summary>
        /// <param name="world">the matrix to bind</param>
        abstract bindOnlyWorldMatrix: world: Matrix -> unit
        /// <summary>Binds the given normal matrix to the active effect</summary>
        /// <param name="normalMatrix">the matrix to bind</param>
        abstract bindOnlyNormalMatrix: normalMatrix: Matrix -> unit
        abstract bind: world: Matrix * ?mesh: Mesh -> unit
        abstract _afterBind: mesh: Mesh * ?effect: Effect -> unit
        abstract _mustRebind: scene: Scene * effect: Effect * ?visibility: float -> bool

    /// Base class of materials working in push mode in babylon JS
    type [<AllowNullLiteral>] PushMaterialStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PushMaterial

    /// Defines the options associated with the creation of a shader material.
    type [<AllowNullLiteral>] IShaderMaterialOptions =
        /// Does the material work in alpha blend mode
        abstract needAlphaBlending: bool with get, set
        /// Does the material work in alpha test mode
        abstract needAlphaTesting: bool with get, set
        /// The list of attribute names used in the shader
        abstract attributes: ResizeArray<string> with get, set
        /// The list of unifrom names used in the shader
        abstract uniforms: ResizeArray<string> with get, set
        /// The list of UBO names used in the shader
        abstract uniformBuffers: ResizeArray<string> with get, set
        /// The list of sampler names used in the shader
        abstract samplers: ResizeArray<string> with get, set
        /// The list of defines used in the shader
        abstract defines: ResizeArray<string> with get, set

    /// The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
    /// 
    /// This returned material effects how the mesh will look based on the code in the shaders.
    type [<AllowNullLiteral>] ShaderMaterial =
        inherit Material
        /// Gets the current class name of the material e.g. "ShaderMaterial"
        /// Mainly use in serialization.
        abstract getClassName: unit -> string
        /// Specifies if the material will require alpha blending
        abstract needAlphaBlending: unit -> bool
        /// Specifies if this material should be rendered in alpha test mode
        abstract needAlphaTesting: unit -> bool
        /// <summary>Set a texture in the shader.</summary>
        /// <param name="name">Define the name of the uniform samplers as defined in the shader</param>
        /// <param name="texture">Define the texture to bind to this sampler</param>
        abstract setTexture: name: string * texture: Texture -> ShaderMaterial
        /// <summary>Set a texture array in the shader.</summary>
        /// <param name="name">Define the name of the uniform sampler array as defined in the shader</param>
        /// <param name="textures">Define the list of textures to bind to this sampler</param>
        abstract setTextureArray: name: string * textures: ResizeArray<Texture> -> ShaderMaterial
        /// <summary>Set a float in the shader.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setFloat: name: string * value: float -> ShaderMaterial
        /// <summary>Set a int in the shader.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setInt: name: string * value: float -> ShaderMaterial
        /// <summary>Set an array of floats in the shader.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setFloats: name: string * value: ResizeArray<float> -> ShaderMaterial
        /// <summary>Set a vec3 in the shader from a Color3.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setColor3: name: string * value: Color3 -> ShaderMaterial
        /// <summary>Set a vec3 array in the shader from a Color3 array.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setColor3Array: name: string * value: ResizeArray<Color3> -> ShaderMaterial
        /// <summary>Set a vec4 in the shader from a Color4.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setColor4: name: string * value: Color4 -> ShaderMaterial
        /// <summary>Set a vec2 in the shader from a Vector2.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setVector2: name: string * value: Vector2 -> ShaderMaterial
        /// <summary>Set a vec3 in the shader from a Vector3.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setVector3: name: string * value: Vector3 -> ShaderMaterial
        /// <summary>Set a vec4 in the shader from a Vector4.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setVector4: name: string * value: Vector4 -> ShaderMaterial
        /// <summary>Set a mat4 in the shader from a Matrix.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setMatrix: name: string * value: Matrix -> ShaderMaterial
        /// <summary>Set a mat3 in the shader from a Float32Array.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setMatrix3x3: name: string * value: Float32Array -> ShaderMaterial
        /// <summary>Set a mat2 in the shader from a Float32Array.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setMatrix2x2: name: string * value: Float32Array -> ShaderMaterial
        /// <summary>Set a vec2 array in the shader from a number array.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setArray2: name: string * value: ResizeArray<float> -> ShaderMaterial
        /// <summary>Set a vec3 array in the shader from a number array.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setArray3: name: string * value: ResizeArray<float> -> ShaderMaterial
        /// <summary>Checks if the material is ready to render the requested mesh</summary>
        /// <param name="mesh">Define the mesh to render</param>
        /// <param name="useInstances">Define whether or not the material is used with instances</param>
        abstract isReady: ?mesh: AbstractMesh * ?useInstances: bool -> bool
        /// <summary>Binds the world matrix to the material</summary>
        /// <param name="world">defines the world transformation matrix</param>
        abstract bindOnlyWorldMatrix: world: Matrix -> unit
        /// <summary>Binds the material to the mesh</summary>
        /// <param name="world">defines the world transformation matrix</param>
        /// <param name="mesh">defines the mesh to bind the material to</param>
        abstract bind: world: Matrix * ?mesh: Mesh -> unit
        /// Gets the active textures from the material
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// <summary>Specifies if the material uses a texture</summary>
        /// <param name="texture">defines the texture to check against the material</param>
        abstract hasTexture: texture: BaseTexture -> bool
        /// <summary>Makes a duplicate of the material, and gives it a new name</summary>
        /// <param name="name">defines the new name for the duplicated material</param>
        abstract clone: name: string -> ShaderMaterial
        /// <summary>Disposes the material</summary>
        /// <param name="forceDisposeEffect">specifies if effects should be forcefully disposed</param>
        /// <param name="forceDisposeTextures">specifies if textures should be forcefully disposed</param>
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit
        /// Serializes this material in a JSON representation
        abstract serialize: unit -> obj option

    /// The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
    /// 
    /// This returned material effects how the mesh will look based on the code in the shaders.
    type [<AllowNullLiteral>] ShaderMaterialStatic =
        /// <summary>Instantiate a new shader material.
        /// The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
        /// This returned material effects how the mesh will look based on the code in the shaders.</summary>
        /// <param name="name">Define the name of the material in the scene</param>
        /// <param name="scene">Define the scene the material belongs to</param>
        /// <param name="shaderPath">Defines  the route to the shader code in one of three ways:
        /// - object - { vertex: "custom", fragment: "custom" }, used with BABYLON.Effect.ShadersStore["customVertexShader"] and BABYLON.Effect.ShadersStore["customFragmentShader"]
        /// - object - { vertexElement: "vertexShaderCode", fragmentElement: "fragmentShaderCode" }, used with shader code in <script> tags
        /// - string - "./COMMON_NAME", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.</param>
        /// <param name="options">Define the options used to create the shader</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * shaderPath: obj option * ?options: obj -> ShaderMaterial
        /// <summary>Creates a shader material from parsed shader material data</summary>
        /// <param name="source">defines the JSON represnetation of the material</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="rootUrl">defines the root URL to use to load textures and relative dependencies</param>
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> ShaderMaterial

    type [<AllowNullLiteral>] StandardMaterialDefines =
        inherit MaterialDefines
        inherit IImageProcessingConfigurationDefines
        abstract MAINUV1: bool with get, set
        abstract MAINUV2: bool with get, set
        abstract DIFFUSE: bool with get, set
        abstract DIFFUSEDIRECTUV: float with get, set
        abstract AMBIENT: bool with get, set
        abstract AMBIENTDIRECTUV: float with get, set
        abstract OPACITY: bool with get, set
        abstract OPACITYDIRECTUV: float with get, set
        abstract OPACITYRGB: bool with get, set
        abstract REFLECTION: bool with get, set
        abstract EMISSIVE: bool with get, set
        abstract EMISSIVEDIRECTUV: float with get, set
        abstract SPECULAR: bool with get, set
        abstract SPECULARDIRECTUV: float with get, set
        abstract BUMP: bool with get, set
        abstract BUMPDIRECTUV: float with get, set
        abstract PARALLAX: bool with get, set
        abstract PARALLAXOCCLUSION: bool with get, set
        abstract SPECULAROVERALPHA: bool with get, set
        abstract CLIPPLANE: bool with get, set
        abstract CLIPPLANE2: bool with get, set
        abstract CLIPPLANE3: bool with get, set
        abstract CLIPPLANE4: bool with get, set
        abstract ALPHATEST: bool with get, set
        abstract DEPTHPREPASS: bool with get, set
        abstract ALPHAFROMDIFFUSE: bool with get, set
        abstract POINTSIZE: bool with get, set
        abstract FOG: bool with get, set
        abstract SPECULARTERM: bool with get, set
        abstract DIFFUSEFRESNEL: bool with get, set
        abstract OPACITYFRESNEL: bool with get, set
        abstract REFLECTIONFRESNEL: bool with get, set
        abstract REFRACTIONFRESNEL: bool with get, set
        abstract EMISSIVEFRESNEL: bool with get, set
        abstract FRESNEL: bool with get, set
        abstract NORMAL: bool with get, set
        abstract UV1: bool with get, set
        abstract UV2: bool with get, set
        abstract VERTEXCOLOR: bool with get, set
        abstract VERTEXALPHA: bool with get, set
        abstract NUM_BONE_INFLUENCERS: float with get, set
        abstract BonesPerMesh: float with get, set
        abstract INSTANCES: bool with get, set
        abstract GLOSSINESS: bool with get, set
        abstract ROUGHNESS: bool with get, set
        abstract EMISSIVEASILLUMINATION: bool with get, set
        abstract LINKEMISSIVEWITHDIFFUSE: bool with get, set
        abstract REFLECTIONFRESNELFROMSPECULAR: bool with get, set
        abstract LIGHTMAP: bool with get, set
        abstract LIGHTMAPDIRECTUV: float with get, set
        abstract OBJECTSPACE_NORMALMAP: bool with get, set
        abstract USELIGHTMAPASSHADOWMAP: bool with get, set
        abstract REFLECTIONMAP_3D: bool with get, set
        abstract REFLECTIONMAP_SPHERICAL: bool with get, set
        abstract REFLECTIONMAP_PLANAR: bool with get, set
        abstract REFLECTIONMAP_CUBIC: bool with get, set
        abstract USE_LOCAL_REFLECTIONMAP_CUBIC: bool with get, set
        abstract REFLECTIONMAP_PROJECTION: bool with get, set
        abstract REFLECTIONMAP_SKYBOX: bool with get, set
        abstract REFLECTIONMAP_SKYBOX_TRANSFORMED: bool with get, set
        abstract REFLECTIONMAP_EXPLICIT: bool with get, set
        abstract REFLECTIONMAP_EQUIRECTANGULAR: bool with get, set
        abstract REFLECTIONMAP_EQUIRECTANGULAR_FIXED: bool with get, set
        abstract REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED: bool with get, set
        abstract INVERTCUBICMAP: bool with get, set
        abstract LOGARITHMICDEPTH: bool with get, set
        abstract REFRACTION: bool with get, set
        abstract REFRACTIONMAP_3D: bool with get, set
        abstract REFLECTIONOVERALPHA: bool with get, set
        abstract TWOSIDEDLIGHTING: bool with get, set
        abstract SHADOWFLOAT: bool with get, set
        abstract MORPHTARGETS: bool with get, set
        abstract MORPHTARGETS_NORMAL: bool with get, set
        abstract MORPHTARGETS_TANGENT: bool with get, set
        abstract NUM_MORPH_INFLUENCERS: float with get, set
        abstract NONUNIFORMSCALING: bool with get, set
        abstract PREMULTIPLYALPHA: bool with get, set
        abstract IMAGEPROCESSING: bool with get, set
        abstract VIGNETTE: bool with get, set
        abstract VIGNETTEBLENDMODEMULTIPLY: bool with get, set
        abstract VIGNETTEBLENDMODEOPAQUE: bool with get, set
        abstract TONEMAPPING: bool with get, set
        abstract TONEMAPPING_ACES: bool with get, set
        abstract CONTRAST: bool with get, set
        abstract COLORCURVES: bool with get, set
        abstract COLORGRADING: bool with get, set
        abstract COLORGRADING3D: bool with get, set
        abstract SAMPLER3DGREENDEPTH: bool with get, set
        abstract SAMPLER3DBGRMAP: bool with get, set
        abstract IMAGEPROCESSINGPOSTPROCESS: bool with get, set
        /// If the reflection texture on this material is in linear color space
        abstract IS_REFLECTION_LINEAR: bool with get, set
        /// If the refraction texture on this material is in linear color space
        abstract IS_REFRACTION_LINEAR: bool with get, set
        abstract EXPOSURE: bool with get, set
        abstract setReflectionMode: modeToEnable: string -> unit

    type [<AllowNullLiteral>] StandardMaterialDefinesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> StandardMaterialDefines

    /// This is the default material used in Babylon. It is the best trade off between quality
    /// and performances.
    type [<AllowNullLiteral>] StandardMaterial =
        inherit PushMaterial
        /// The basic texture of the material as viewed under a light.
        abstract diffuseTexture: Nullable<BaseTexture> with get, set
        /// AKA Occlusion Texture in other nomenclature, it helps adding baked shadows into your material.
        abstract ambientTexture: Nullable<BaseTexture> with get, set
        /// Define the transparency of the material from a texture.
        /// The final alpha value can be read either from the red channel (if texture.getAlphaFromRGB is false)
        /// or from the luminance or the current texel (if texture.getAlphaFromRGB is true)
        abstract opacityTexture: Nullable<BaseTexture> with get, set
        /// Define the texture used to display the reflection.
        abstract reflectionTexture: Nullable<BaseTexture> with get, set
        /// Define texture of the material as if self lit.
        /// This will be mixed in the final result even in the absence of light.
        abstract emissiveTexture: Nullable<BaseTexture> with get, set
        /// Define how the color and intensity of the highlight given by the light in the material.
        abstract specularTexture: Nullable<BaseTexture> with get, set
        /// Bump mapping is a technique to simulate bump and dents on a rendered surface.
        /// These are made by creating a normal map from an image. The means to do this can be found on the web, a search for 'normal map generator' will bring up free and paid for methods of doing this.
        abstract bumpTexture: Nullable<BaseTexture> with get, set
        /// Complex lighting can be computationally expensive to compute at runtime.
        /// To save on computation, lightmaps may be used to store calculated lighting in a texture which will be applied to a given mesh.
        abstract lightmapTexture: Nullable<BaseTexture> with get, set
        /// Define the texture used to display the refraction.
        abstract refractionTexture: Nullable<BaseTexture> with get, set
        /// The color of the material lit by the environmental background lighting.
        abstract ambientColor: Color3 with get, set
        /// The basic color of the material as viewed under a light.
        abstract diffuseColor: Color3 with get, set
        /// Define how the color and intensity of the highlight given by the light in the material.
        abstract specularColor: Color3 with get, set
        /// Define the color of the material as if self lit.
        /// This will be mixed in the final result even in the absence of light.
        abstract emissiveColor: Color3 with get, set
        /// Defines how sharp are the highlights in the material.
        /// The bigger the value the sharper giving a more glossy feeling to the result.
        /// Reversely, the smaller the value the blurrier giving a more rough feeling to the result.
        abstract specularPower: float with get, set
        /// Does the transparency come from the diffuse texture alpha channel.
        abstract useAlphaFromDiffuseTexture: bool with get, set
        /// If true, the emissive value is added into the end result, otherwise it is multiplied in.
        abstract useEmissiveAsIllumination: bool with get, set
        /// If true, some kind of energy conservation will prevent the end result to be more than 1 by reducing
        /// the emissive level when the final color is close to one.
        abstract linkEmissiveWithDiffuse: bool with get, set
        /// Specifies that the material will keep the specular highlights over a transparent surface (only the most limunous ones).
        /// A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
        abstract useSpecularOverAlpha: bool with get, set
        /// Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
        /// A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
        abstract useReflectionOverAlpha: bool with get, set
        /// Does lights from the scene impacts this material.
        /// It can be a nice trick for performance to disable lighting on a fully emissive material.
        abstract disableLighting: bool with get, set
        /// Allows using an object space normal map (instead of tangent space).
        abstract useObjectSpaceNormalMap: bool with get, set
        /// Is parallax enabled or not.
        abstract useParallax: bool with get, set
        /// Is parallax occlusion enabled or not.
        /// If true, the outcome is way more realistic than traditional Parallax but you can expect a performance hit that worthes consideration.
        abstract useParallaxOcclusion: bool with get, set
        /// Apply a scaling factor that determine which "depth" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.
        abstract parallaxScaleBias: float with get, set
        /// Helps to define how blurry the reflections should appears in the material.
        abstract roughness: float with get, set
        /// In case of refraction, define the value of the indice of refraction.
        abstract indexOfRefraction: float with get, set
        /// Invert the refraction texture alongside the y axis.
        /// It can be usefull with procedural textures or probe for instance.
        abstract invertRefractionY: bool with get, set
        /// Defines the alpha limits in alpha test mode.
        abstract alphaCutOff: float with get, set
        /// In case of light mapping, define whether the map contains light or shadow informations.
        abstract useLightmapAsShadowmap: bool with get, set
        /// Define the diffuse fresnel parameters of the material.
        abstract diffuseFresnelParameters: FresnelParameters with get, set
        /// Define the opacity fresnel parameters of the material.
        abstract opacityFresnelParameters: FresnelParameters with get, set
        /// Define the reflection fresnel parameters of the material.
        abstract reflectionFresnelParameters: FresnelParameters with get, set
        /// Define the refraction fresnel parameters of the material.
        abstract refractionFresnelParameters: FresnelParameters with get, set
        /// Define the emissive fresnel parameters of the material.
        abstract emissiveFresnelParameters: FresnelParameters with get, set
        /// If true automatically deducts the fresnels values from the material specularity.
        abstract useReflectionFresnelFromSpecular: bool with get, set
        /// Defines if the glossiness/roughness of the material should be read from the specular map alpha channel
        abstract useGlossinessFromSpecularMapAlpha: bool with get, set
        /// Defines the maximum number of lights that can be used in the material
        abstract maxSimultaneousLights: float with get, set
        /// If sets to true, x component of normal map value will invert (x = 1.0 - x).
        abstract invertNormalMapX: bool with get, set
        /// If sets to true, y component of normal map value will invert (y = 1.0 - y).
        abstract invertNormalMapY: bool with get, set
        /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
        abstract twoSidedLighting: bool with get, set
        /// Default configuration related to image processing available in the standard Material.
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Gets the image processing configuration used either in this material.
        /// Sets the Default image processing configuration used either in the this material.
        /// 
        /// If sets to null, the scene one is in use.
        abstract imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// <summary>Attaches a new image processing configuration to the Standard Material.</summary>
        /// <param name="configuration"></param>
        abstract _attachImageProcessingConfiguration: configuration: Nullable<ImageProcessingConfiguration> -> unit
        /// Gets wether the color curves effect is enabled.
        /// Sets wether the color curves effect is enabled.
        abstract cameraColorCurvesEnabled: bool with get, set
        /// Gets wether the color grading effect is enabled.
        /// Gets wether the color grading effect is enabled.
        abstract cameraColorGradingEnabled: bool with get, set
        /// Gets wether tonemapping is enabled or not.
        /// Sets wether tonemapping is enabled or not
        abstract cameraToneMappingEnabled: bool with get, set
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        abstract cameraExposure: float with get, set
        /// Gets The camera contrast used on this material.
        /// Sets The camera contrast used on this material.
        abstract cameraContrast: float with get, set
        /// Gets the Color Grading 2D Lookup Texture.
        /// Sets the Color Grading 2D Lookup Texture.
        abstract cameraColorGradingTexture: Nullable<BaseTexture> with get, set
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        abstract cameraColorCurves: Nullable<ColorCurves> with get, set
        /// Custom callback helping to override the default shader used in the material.
        abstract customShaderNameResolve: (string -> ResizeArray<string> -> ResizeArray<string> -> ResizeArray<string> -> StandardMaterialDefines -> string) with get, set
        abstract _renderTargets: SmartArray<RenderTargetTexture> with get, set
        abstract _worldViewProjectionMatrix: Matrix with get, set
        abstract _globalAmbientColor: Color3 with get, set
        abstract _useLogarithmicDepth: bool with get, set
        /// Gets a boolean indicating that current material needs to register RTT
        abstract hasRenderTargetTextures: bool
        /// Gets the current class name of the material e.g. "StandardMaterial"
        /// Mainly use in serialization.
        abstract getClassName: unit -> string
        /// In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)
        /// You can try switching to logarithmic depth.
        abstract useLogarithmicDepth: bool with get, set
        /// Specifies if the material will require alpha blending
        abstract needAlphaBlending: unit -> bool
        /// Specifies if this material should be rendered in alpha test mode
        abstract needAlphaTesting: unit -> bool
        abstract _shouldUseAlphaFromDiffuseTexture: unit -> bool
        /// Get the texture used for alpha test purpose.
        abstract getAlphaTestTexture: unit -> Nullable<BaseTexture>
        /// <summary>Get if the submesh is ready to be used and all its information available.
        /// Child classes can use it to update shaders</summary>
        /// <param name="mesh">defines the mesh to check</param>
        /// <param name="subMesh">defines which submesh to check</param>
        /// <param name="useInstances">specifies that instances should be used</param>
        abstract isReadyForSubMesh: mesh: AbstractMesh * subMesh: SubMesh * ?useInstances: bool -> bool
        /// Builds the material UBO layouts.
        /// Used internally during the effect preparation.
        abstract buildUniformLayout: unit -> unit
        /// Unbinds the material from the mesh
        abstract unbind: unit -> unit
        /// <summary>Binds the submesh to this material by preparing the effect and shader to draw</summary>
        /// <param name="world">defines the world transformation matrix</param>
        /// <param name="mesh">defines the mesh containing the submesh</param>
        /// <param name="subMesh">defines the submesh to bind the material to</param>
        abstract bindForSubMesh: world: Matrix * mesh: Mesh * subMesh: SubMesh -> unit
        /// Get the list of animatables in the material.
        abstract getAnimatables: unit -> ResizeArray<IAnimatable>
        /// Gets the active textures from the material
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// <summary>Specifies if the material uses a texture</summary>
        /// <param name="texture">defines the texture to check against the material</param>
        abstract hasTexture: texture: BaseTexture -> bool
        /// <summary>Disposes the material</summary>
        /// <param name="forceDisposeEffect">specifies if effects should be forcefully disposed</param>
        /// <param name="forceDisposeTextures">specifies if textures should be forcefully disposed</param>
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit
        /// <summary>Makes a duplicate of the material, and gives it a new name</summary>
        /// <param name="name">defines the new name for the duplicated material</param>
        abstract clone: name: string -> StandardMaterial
        /// Serializes this material in a JSON representation
        abstract serialize: unit -> obj option

    /// This is the default material used in Babylon. It is the best trade off between quality
    /// and performances.
    type [<AllowNullLiteral>] StandardMaterialStatic =
        /// <summary>Instantiates a new standard material.
        /// This is the default material used in Babylon. It is the best trade off between quality
        /// and performances.</summary>
        /// <param name="name">Define the name of the material in the scene</param>
        /// <param name="scene">Define the scene the material belong to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> StandardMaterial
        /// <summary>Creates a standard material from parsed material data</summary>
        /// <param name="source">defines the JSON represnetation of the material</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="rootUrl">defines the root URL to use to load textures and relative dependencies</param>
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> StandardMaterial
        /// Are diffuse textures enabled in the application.
        abstract DiffuseTextureEnabled: bool with get, set
        /// Are ambient textures enabled in the application.
        abstract AmbientTextureEnabled: bool with get, set
        /// Are opacity textures enabled in the application.
        abstract OpacityTextureEnabled: bool with get, set
        /// Are reflection textures enabled in the application.
        abstract ReflectionTextureEnabled: bool with get, set
        /// Are emissive textures enabled in the application.
        abstract EmissiveTextureEnabled: bool with get, set
        /// Are specular textures enabled in the application.
        abstract SpecularTextureEnabled: bool with get, set
        /// Are bump textures enabled in the application.
        abstract BumpTextureEnabled: bool with get, set
        /// Are lightmap textures enabled in the application.
        abstract LightmapTextureEnabled: bool with get, set
        /// Are refraction textures enabled in the application.
        abstract RefractionTextureEnabled: bool with get, set
        /// Are color grading textures enabled in the application.
        abstract ColorGradingTextureEnabled: bool with get, set
        /// Are fresnels enabled in the application.
        abstract FresnelEnabled: bool with get, set

    /// Uniform buffer objects.
    /// 
    /// Handles blocks of uniform on the GPU.
    /// 
    /// If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.
    /// 
    /// For more information, please refer to :
    /// https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
    type [<AllowNullLiteral>] UniformBuffer =
        /// Lambda to Update a 3x3 Matrix in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateMatrix3x3: (string -> Float32Array -> unit) with get, set
        /// Lambda to Update a 2x2 Matrix in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateMatrix2x2: (string -> Float32Array -> unit) with get, set
        /// Lambda to Update a single float in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateFloat: (string -> float -> unit) with get, set
        /// Lambda to Update a vec2 of float in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateFloat2: (string -> float -> float -> string -> unit) with get, set
        /// Lambda to Update a vec3 of float in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateFloat3: (string -> float -> float -> float -> string -> unit) with get, set
        /// Lambda to Update a vec4 of float in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateFloat4: (string -> float -> float -> float -> float -> string -> unit) with get, set
        /// Lambda to Update a 4x4 Matrix in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateMatrix: (string -> Matrix -> unit) with get, set
        /// Lambda to Update vec3 of float from a Vector in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateVector3: (string -> Vector3 -> unit) with get, set
        /// Lambda to Update vec4 of float from a Vector in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateVector4: (string -> Vector4 -> unit) with get, set
        /// Lambda to Update vec3 of float from a Color in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateColor3: (string -> Color3 -> string -> unit) with get, set
        /// Lambda to Update vec4 of float from a Color in a uniform buffer.
        /// This is dynamic to allow compat with webgl 1 and 2.
        /// You will need to pass the name of the uniform as well as the value.
        abstract updateColor4: (string -> Color3 -> float -> string -> unit) with get, set
        /// Indicates if the buffer is using the WebGL2 UBO implementation,
        /// or just falling back on setUniformXXX calls.
        abstract useUbo: bool
        /// Indicates if the WebGL underlying uniform buffer is in sync
        /// with the javascript cache data.
        abstract isSync: bool
        /// Indicates if the WebGL underlying uniform buffer is dynamic.
        /// Also, a dynamic UniformBuffer will disable cache verification and always
        /// update the underlying WebGL uniform buffer to the GPU.
        abstract isDynamic: unit -> bool
        /// The data cache on JS side.
        abstract getData: unit -> Float32Array
        /// The underlying WebGL Uniform buffer.
        abstract getBuffer: unit -> Nullable<WebGLBuffer>
        /// <summary>Adds an uniform in the buffer.
        /// Warning : the subsequents calls of this function must be in the same order as declared in the shader
        /// for the layout to be correct !</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="size">Data size, or data directly.</param>
        abstract addUniform: name: string * size: U2<float, ResizeArray<float>> -> unit
        /// <summary>Adds a Matrix 4x4 to the uniform buffer.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="mat">A 4x4 matrix.</param>
        abstract addMatrix: name: string * mat: Matrix -> unit
        /// <summary>Adds a vec2 to the uniform buffer.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="x">Define the x component value of the vec2</param>
        /// <param name="y">Define the y component value of the vec2</param>
        abstract addFloat2: name: string * x: float * y: float -> unit
        /// <summary>Adds a vec3 to the uniform buffer.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="x">Define the x component value of the vec3</param>
        /// <param name="y">Define the y component value of the vec3</param>
        /// <param name="z">Define the z component value of the vec3</param>
        abstract addFloat3: name: string * x: float * y: float * z: float -> unit
        /// <summary>Adds a vec3 to the uniform buffer.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="color">Define the vec3 from a Color</param>
        abstract addColor3: name: string * color: Color3 -> unit
        /// <summary>Adds a vec4 to the uniform buffer.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="color">Define the rgb components from a Color</param>
        /// <param name="alpha">Define the a component of the vec4</param>
        abstract addColor4: name: string * color: Color3 * alpha: float -> unit
        /// <summary>Adds a vec3 to the uniform buffer.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="vector">Define the vec3 components from a Vector</param>
        abstract addVector3: name: string * vector: Vector3 -> unit
        /// <summary>Adds a Matrix 3x3 to the uniform buffer.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        abstract addMatrix3x3: name: string -> unit
        /// <summary>Adds a Matrix 2x2 to the uniform buffer.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        abstract addMatrix2x2: name: string -> unit
        /// Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.
        abstract create: unit -> unit
        abstract _rebuild: unit -> unit
        /// Updates the WebGL Uniform Buffer on the GPU.
        /// If the `dynamic` flag is set to true, no cache comparison is done.
        /// Otherwise, the buffer will be updated only if the cache differs.
        abstract update: unit -> unit
        /// <summary>Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.</summary>
        /// <param name="uniformName">Define the name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="data">Define the flattened data</param>
        /// <param name="size">Define the size of the data.</param>
        abstract updateUniform: uniformName: string * data: FloatArray * size: float -> unit
        /// <summary>Sets a sampler uniform on the effect.</summary>
        /// <param name="name">Define the name of the sampler.</param>
        /// <param name="texture">Define the texture to set in the sampler</param>
        abstract setTexture: name: string * texture: Nullable<BaseTexture> -> unit
        /// <summary>Directly updates the value of the uniform in the cache AND on the GPU.</summary>
        /// <param name="uniformName">Define the name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="data">Define the flattened data</param>
        abstract updateUniformDirectly: uniformName: string * data: FloatArray -> unit
        /// <summary>Binds this uniform buffer to an effect.</summary>
        /// <param name="effect">Define the effect to bind the buffer to</param>
        /// <param name="name">Name of the uniform block in the shader.</param>
        abstract bindToEffect: effect: Effect * name: string -> unit
        /// Disposes the uniform buffer.
        abstract dispose: unit -> unit

    /// Uniform buffer objects.
    /// 
    /// Handles blocks of uniform on the GPU.
    /// 
    /// If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.
    /// 
    /// For more information, please refer to :
    /// https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
    type [<AllowNullLiteral>] UniformBufferStatic =
        /// <summary>Instantiates a new Uniform buffer objects.
        /// 
        /// Handles blocks of uniform on the GPU.
        /// 
        /// If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.
        /// 
        /// For more information, please refer to :</summary>
        /// <param name="engine">Define the engine the buffer is associated with</param>
        /// <param name="data">Define the data contained in the buffer</param>
        /// <param name="dynamic">Define if the buffer is updatable</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * ?data: ResizeArray<float> * ?dynamic: bool -> UniformBuffer

    /// Scalar computation library
    type [<AllowNullLiteral>] Scalar =
        interface end

    /// Scalar computation library
    type [<AllowNullLiteral>] ScalarStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Scalar
        /// Two pi constants convenient for computation.
        abstract TwoPi: float with get, set
        /// <summary>Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)</summary>
        /// <param name="a">number</param>
        /// <param name="b">number</param>
        /// <param name="epsilon">(default = 1.401298E-45)</param>
        abstract WithinEpsilon: a: float * b: float * ?epsilon: float -> bool
        /// <summary>Returns a string : the upper case translation of the number i to hexadecimal.</summary>
        /// <param name="i">number</param>
        abstract ToHex: i: float -> string
        /// <summary>Returns -1 if value is negative and +1 is value is positive.</summary>
        /// <param name="value">the value</param>
        abstract Sign: value: float -> float
        /// <summary>Returns the value itself if it's between min and max.
        /// Returns min if the value is lower than min.
        /// Returns max if the value is greater than max.</summary>
        /// <param name="value">the value to clmap</param>
        /// <param name="min">the min value to clamp to (default: 0)</param>
        /// <param name="max">the max value to clamp to (default: 1)</param>
        abstract Clamp: value: float * ?min: float * ?max: float -> float
        /// <summary>the log2 of value.</summary>
        /// <param name="value">the value to compute log2 of</param>
        abstract Log2: value: float -> float
        /// <summary>Loops the value, so that it is never larger than length and never smaller than 0.
        /// 
        /// This is similar to the modulo operator but it works with floating point numbers.
        /// For example, using 3.0 for t and 2.5 for length, the result would be 0.5.
        /// With t = 5 and length = 2.5, the result would be 0.0.
        /// Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator</summary>
        /// <param name="value">the value</param>
        /// <param name="length">the length</param>
        abstract Repeat: value: float * length: float -> float
        /// <summary>Normalize the value between 0.0 and 1.0 using min and max values</summary>
        /// <param name="value">value to normalize</param>
        /// <param name="min">max to normalize between</param>
        /// <param name="max">min to normalize between</param>
        abstract Normalize: value: float * min: float * max: float -> float
        /// <summary>Denormalize the value from 0.0 and 1.0 using min and max values</summary>
        /// <param name="normalized">value to denormalize</param>
        /// <param name="min">max to denormalize between</param>
        /// <param name="max">min to denormalize between</param>
        abstract Denormalize: normalized: float * min: float * max: float -> float
        /// <summary>Calculates the shortest difference between two given angles given in degrees.</summary>
        /// <param name="current">current angle in degrees</param>
        /// <param name="target">target angle in degrees</param>
        abstract DeltaAngle: current: float * target: float -> float
        /// <summary>PingPongs the value t, so that it is never larger than length and never smaller than 0.</summary>
        /// <param name="tx">value</param>
        /// <param name="length">length</param>
        abstract PingPong: tx: float * length: float -> float
        /// <summary>Interpolates between min and max with smoothing at the limits.
        /// 
        /// This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up
        /// from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.</summary>
        /// <param name="from">from</param>
        /// <param name="to">to</param>
        /// <param name="tx">value</param>
        abstract SmoothStep: from: float * ``to``: float * tx: float -> float
        /// <summary>Moves a value current towards target.
        /// 
        /// This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.
        /// Negative values of maxDelta pushes the value away from target.</summary>
        /// <param name="current">current value</param>
        /// <param name="target">target value</param>
        /// <param name="maxDelta">max distance to move</param>
        abstract MoveTowards: current: float * target: float * maxDelta: float -> float
        /// <summary>Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
        /// 
        /// Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta
        ///   are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.</summary>
        /// <param name="current">current value</param>
        /// <param name="target">target value</param>
        /// <param name="maxDelta">max distance to move</param>
        abstract MoveTowardsAngle: current: float * target: float * maxDelta: float -> float
        /// <summary>Creates a new scalar with values linearly interpolated of "amount" between the start scalar and the end scalar.</summary>
        /// <param name="start">start value</param>
        /// <param name="end">target value</param>
        /// <param name="amount">amount to lerp between</param>
        abstract Lerp: start: float * ``end``: float * amount: float -> float
        /// <summary>Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
        /// The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.</summary>
        /// <param name="start">start value</param>
        /// <param name="end">target value</param>
        /// <param name="amount">amount to lerp between</param>
        abstract LerpAngle: start: float * ``end``: float * amount: float -> float
        /// <summary>Calculates the linear parameter t that produces the interpolant value within the range [a, b].</summary>
        /// <param name="a">start value</param>
        /// <param name="b">target value</param>
        /// <param name="value">value between a and b</param>
        abstract InverseLerp: a: float * b: float * value: float -> float
        /// <summary>Returns a new scalar located for "amount" (float) on the Hermite spline defined by the scalars "value1", "value3", "tangent1", "tangent2".</summary>
        /// <param name="value1">spline value</param>
        /// <param name="tangent1">spline value</param>
        /// <param name="value2">spline value</param>
        /// <param name="tangent2">spline value</param>
        /// <param name="amount">input value</param>
        abstract Hermite: value1: float * tangent1: float * value2: float * tangent2: float * amount: float -> float
        /// <summary>Returns a random float number between and min and max values</summary>
        /// <param name="min">min value of random</param>
        /// <param name="max">max value of random</param>
        abstract RandomRange: min: float * max: float -> float
        /// <summary>This function returns percentage of a number in a given range.
        /// 
        /// RangeToPercent(40,20,60) will return 0.5 (50%)
        /// RangeToPercent(34,0,100) will return 0.34 (34%)</summary>
        /// <param name="number">to convert to percentage</param>
        /// <param name="min">min range</param>
        /// <param name="max">max range</param>
        abstract RangeToPercent: number: float * min: float * max: float -> float
        /// <summary>This function returns number that corresponds to the percentage in a given range.
        /// 
        /// PercentToRange(0.34,0,100) will return 34.</summary>
        /// <param name="percent">to convert to number</param>
        /// <param name="min">min range</param>
        /// <param name="max">max range</param>
        abstract PercentToRange: percent: float * min: float * max: float -> float
        /// <summary>Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.</summary>
        /// <param name="angle">The angle to normalize in radian.</param>
        abstract NormalizeRadians: angle: float -> float

    /// Class used to hold a RBG color
    type [<AllowNullLiteral>] Color3 =
        /// Defines the red component (between 0 and 1, default is 0)
        abstract r: float with get, set
        /// Defines the green component (between 0 and 1, default is 0)
        abstract g: float with get, set
        /// Defines the blue component (between 0 and 1, default is 0)
        abstract b: float with get, set
        /// Creates a string with the Color3 current values
        abstract toString: unit -> string
        /// Returns the string "Color3"
        abstract getClassName: unit -> string
        /// Compute the Color3 hash code
        abstract getHashCode: unit -> float
        /// <summary>Stores in the given array from the given starting index the red, green, blue values as successive elements</summary>
        /// <param name="array">defines the array where to store the r,g,b components</param>
        /// <param name="index">defines an optional index in the target array to define where to start storing values</param>
        abstract toArray: array: FloatArray * ?index: float -> Color3
        /// <summary>Returns a new Color4 object from the current Color3 and the given alpha</summary>
        /// <param name="alpha">defines the alpha component on the new Color4 object (default is 1)</param>
        abstract toColor4: ?alpha: float -> Color4
        /// Returns a new array populated with 3 numeric elements : red, green and blue values
        abstract asArray: unit -> ResizeArray<float>
        /// Returns the luminance value
        abstract toLuminance: unit -> float
        /// <summary>Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object</summary>
        /// <param name="otherColor">defines the second operand</param>
        abstract multiply: otherColor: Color3 -> Color3
        /// <summary>Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object "result"</summary>
        /// <param name="otherColor">defines the second operand</param>
        /// <param name="result">defines the Color3 object where to store the result</param>
        abstract multiplyToRef: otherColor: Color3 * result: Color3 -> Color3
        /// <summary>Determines equality between Color3 objects</summary>
        /// <param name="otherColor">defines the second operand</param>
        abstract equals: otherColor: Color3 -> bool
        /// <summary>Determines equality between the current Color3 object and a set of r,b,g values</summary>
        /// <param name="r">defines the red component to check</param>
        /// <param name="g">defines the green component to check</param>
        /// <param name="b">defines the blue component to check</param>
        abstract equalsFloats: r: float * g: float * b: float -> bool
        /// <summary>Multiplies in place each rgb value by scale</summary>
        /// <param name="scale">defines the scaling factor</param>
        abstract scale: scale: float -> Color3
        /// <summary>Multiplies the rgb values by scale and stores the result into "result"</summary>
        /// <param name="scale">defines the scaling factor</param>
        /// <param name="result">defines the Color3 object where to store the result</param>
        abstract scaleToRef: scale: float * result: Color3 -> Color3
        /// <summary>Scale the current Color3 values by a factor and add the result to a given Color3</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines color to store the result into</param>
        abstract scaleAndAddToRef: scale: float * result: Color3 -> Color3
        /// <summary>Clamps the rgb values by the min and max values and stores the result into "result"</summary>
        /// <param name="min">defines minimum clamping value (default is 0)</param>
        /// <param name="max">defines maximum clamping value (default is 1)</param>
        /// <param name="result">defines color to store the result into</param>
        abstract clampToRef: min: float option * max: float option * result: Color3 -> Color3
        /// <summary>Creates a new Color3 set with the added values of the current Color3 and of the given one</summary>
        /// <param name="otherColor">defines the second operand</param>
        abstract add: otherColor: Color3 -> Color3
        /// <summary>Stores the result of the addition of the current Color3 and given one rgb values into "result"</summary>
        /// <param name="otherColor">defines the second operand</param>
        /// <param name="result">defines Color3 object to store the result into</param>
        abstract addToRef: otherColor: Color3 * result: Color3 -> Color3
        /// <summary>Returns a new Color3 set with the subtracted values of the given one from the current Color3</summary>
        /// <param name="otherColor">defines the second operand</param>
        abstract subtract: otherColor: Color3 -> Color3
        /// <summary>Stores the result of the subtraction of given one from the current Color3 rgb values into "result"</summary>
        /// <param name="otherColor">defines the second operand</param>
        /// <param name="result">defines Color3 object to store the result into</param>
        abstract subtractToRef: otherColor: Color3 * result: Color3 -> Color3
        /// Copy the current object
        abstract clone: unit -> Color3
        /// <summary>Copies the rgb values from the source in the current Color3</summary>
        /// <param name="source">defines the source Color3 object</param>
        abstract copyFrom: source: Color3 -> Color3
        /// <summary>Updates the Color3 rgb values from the given floats</summary>
        /// <param name="r">defines the red component to read from</param>
        /// <param name="g">defines the green component to read from</param>
        /// <param name="b">defines the blue component to read from</param>
        abstract copyFromFloats: r: float * g: float * b: float -> Color3
        /// <summary>Updates the Color3 rgb values from the given floats</summary>
        /// <param name="r">defines the red component to read from</param>
        /// <param name="g">defines the green component to read from</param>
        /// <param name="b">defines the blue component to read from</param>
        abstract set: r: float * g: float * b: float -> Color3
        /// Compute the Color3 hexadecimal code as a string
        abstract toHexString: unit -> string
        /// Computes a new Color3 converted from the current one to linear space
        abstract toLinearSpace: unit -> Color3
        /// <summary>Converts the Color3 values to linear space and stores the result in "convertedColor"</summary>
        /// <param name="convertedColor">defines the Color3 object where to store the linear space version</param>
        abstract toLinearSpaceToRef: convertedColor: Color3 -> Color3
        /// Computes a new Color3 converted from the current one to gamma space
        abstract toGammaSpace: unit -> Color3
        /// <summary>Converts the Color3 values to gamma space and stores the result in "convertedColor"</summary>
        /// <param name="convertedColor">defines the Color3 object where to store the gamma space version</param>
        abstract toGammaSpaceToRef: convertedColor: Color3 -> Color3

    /// Class used to hold a RBG color
    type [<AllowNullLiteral>] Color3Static =
        /// <summary>Creates a new Color3 object from red, green, blue values, all between 0 and 1</summary>
        /// <param name="r">defines the red component (between 0 and 1, default is 0)</param>
        /// <param name="g">defines the green component (between 0 and 1, default is 0)</param>
        /// <param name="b">defines the blue component (between 0 and 1, default is 0)</param>
        [<Emit "new $0($1...)">] abstract Create: ?r: float * ?g: float * ?b: float -> Color3
        /// <summary>Creates a new Color3 from the string containing valid hexadecimal values</summary>
        /// <param name="hex">defines a string containing valid hexadecimal values</param>
        abstract FromHexString: hex: string -> Color3
        /// <summary>Creates a new Vector3 from the starting index of the given array</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines an offset in the source array</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Color3
        /// <summary>Creates a new Color3 from integer values (< 256)</summary>
        /// <param name="r">defines the red component to read from (value between 0 and 255)</param>
        /// <param name="g">defines the green component to read from (value between 0 and 255)</param>
        /// <param name="b">defines the blue component to read from (value between 0 and 255)</param>
        abstract FromInts: r: float * g: float * b: float -> Color3
        /// <summary>Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3</summary>
        /// <param name="start">defines the start Color3 value</param>
        /// <param name="end">defines the end Color3 value</param>
        /// <param name="amount">defines the gradient value between start and end</param>
        abstract Lerp: start: Color3 * ``end``: Color3 * amount: float -> Color3
        /// <summary>Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3</summary>
        /// <param name="left">defines the start value</param>
        /// <param name="right">defines the end value</param>
        /// <param name="amount">defines the gradient factor</param>
        /// <param name="result">defines the Color3 object where to store the result</param>
        abstract LerpToRef: left: Color3 * right: Color3 * amount: float * result: Color3 -> unit
        /// Returns a Color3 value containing a red color
        abstract Red: unit -> Color3
        /// Returns a Color3 value containing a green color
        abstract Green: unit -> Color3
        /// Returns a Color3 value containing a blue color
        abstract Blue: unit -> Color3
        /// Returns a Color3 value containing a black color
        abstract Black: unit -> Color3
        /// Returns a Color3 value containing a white color
        abstract White: unit -> Color3
        /// Returns a Color3 value containing a purple color
        abstract Purple: unit -> Color3
        /// Returns a Color3 value containing a magenta color
        abstract Magenta: unit -> Color3
        /// Returns a Color3 value containing a yellow color
        abstract Yellow: unit -> Color3
        /// Returns a Color3 value containing a gray color
        abstract Gray: unit -> Color3
        /// Returns a Color3 value containing a teal color
        abstract Teal: unit -> Color3
        /// Returns a Color3 value containing a random color
        abstract Random: unit -> Color3

    /// Class used to hold a RBGA color
    type [<AllowNullLiteral>] Color4 =
        /// Defines the red component (between 0 and 1, default is 0)
        abstract r: float with get, set
        /// Defines the green component (between 0 and 1, default is 0)
        abstract g: float with get, set
        /// Defines the blue component (between 0 and 1, default is 0)
        abstract b: float with get, set
        /// Defines the alpha component (between 0 and 1, default is 1)
        abstract a: float with get, set
        /// <summary>Adds in place the given Color4 values to the current Color4 object</summary>
        /// <param name="right">defines the second operand</param>
        abstract addInPlace: right: Color4 -> Color4
        /// Creates a new array populated with 4 numeric elements : red, green, blue, alpha values
        abstract asArray: unit -> ResizeArray<float>
        /// <summary>Stores from the starting index in the given array the Color4 successive values</summary>
        /// <param name="array">defines the array where to store the r,g,b components</param>
        /// <param name="index">defines an optional index in the target array to define where to start storing values</param>
        abstract toArray: array: ResizeArray<float> * ?index: float -> Color4
        /// <summary>Creates a new Color4 set with the added values of the current Color4 and of the given one</summary>
        /// <param name="right">defines the second operand</param>
        abstract add: right: Color4 -> Color4
        /// <summary>Creates a new Color4 set with the subtracted values of the given one from the current Color4</summary>
        /// <param name="right">defines the second operand</param>
        abstract subtract: right: Color4 -> Color4
        /// <summary>Subtracts the given ones from the current Color4 values and stores the results in "result"</summary>
        /// <param name="right">defines the second operand</param>
        /// <param name="result">defines the Color4 object where to store the result</param>
        abstract subtractToRef: right: Color4 * result: Color4 -> Color4
        /// <summary>Creates a new Color4 with the current Color4 values multiplied by scale</summary>
        /// <param name="scale">defines the scaling factor to apply</param>
        abstract scale: scale: float -> Color4
        /// <summary>Multiplies the current Color4 values by scale and stores the result in "result"</summary>
        /// <param name="scale">defines the scaling factor to apply</param>
        /// <param name="result">defines the Color4 object where to store the result</param>
        abstract scaleToRef: scale: float * result: Color4 -> Color4
        /// <summary>Scale the current Color4 values by a factor and add the result to a given Color4</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Color4 object where to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Color4 -> Color4
        /// <summary>Clamps the rgb values by the min and max values and stores the result into "result"</summary>
        /// <param name="min">defines minimum clamping value (default is 0)</param>
        /// <param name="max">defines maximum clamping value (default is 1)</param>
        /// <param name="result">defines color to store the result into.</param>
        abstract clampToRef: min: float option * max: float option * result: Color4 -> Color4
        /// <summary>Multipy an Color4 value by another and return a new Color4 object</summary>
        /// <param name="color">defines the Color4 value to multiply by</param>
        abstract multiply: color: Color4 -> Color4
        /// <summary>Multipy a Color4 value by another and push the result in a reference value</summary>
        /// <param name="color">defines the Color4 value to multiply by</param>
        /// <param name="result">defines the Color4 to fill the result in</param>
        abstract multiplyToRef: color: Color4 * result: Color4 -> Color4
        /// Creates a string with the Color4 current values
        abstract toString: unit -> string
        /// Returns the string "Color4"
        abstract getClassName: unit -> string
        /// Compute the Color4 hash code
        abstract getHashCode: unit -> float
        /// Creates a new Color4 copied from the current one
        abstract clone: unit -> Color4
        /// <summary>Copies the given Color4 values into the current one</summary>
        /// <param name="source">defines the source Color4 object</param>
        abstract copyFrom: source: Color4 -> Color4
        /// <summary>Copies the given float values into the current one</summary>
        /// <param name="r">defines the red component to read from</param>
        /// <param name="g">defines the green component to read from</param>
        /// <param name="b">defines the blue component to read from</param>
        /// <param name="a">defines the alpha component to read from</param>
        abstract copyFromFloats: r: float * g: float * b: float * a: float -> Color4
        /// <summary>Copies the given float values into the current one</summary>
        /// <param name="r">defines the red component to read from</param>
        /// <param name="g">defines the green component to read from</param>
        /// <param name="b">defines the blue component to read from</param>
        /// <param name="a">defines the alpha component to read from</param>
        abstract set: r: float * g: float * b: float * a: float -> Color4
        /// Compute the Color4 hexadecimal code as a string
        abstract toHexString: unit -> string
        /// Computes a new Color4 converted from the current one to linear space
        abstract toLinearSpace: unit -> Color4
        /// <summary>Converts the Color4 values to linear space and stores the result in "convertedColor"</summary>
        /// <param name="convertedColor">defines the Color4 object where to store the linear space version</param>
        abstract toLinearSpaceToRef: convertedColor: Color4 -> Color4
        /// Computes a new Color4 converted from the current one to gamma space
        abstract toGammaSpace: unit -> Color4
        /// <summary>Converts the Color4 values to gamma space and stores the result in "convertedColor"</summary>
        /// <param name="convertedColor">defines the Color4 object where to store the gamma space version</param>
        abstract toGammaSpaceToRef: convertedColor: Color4 -> Color4

    /// Class used to hold a RBGA color
    type [<AllowNullLiteral>] Color4Static =
        /// <summary>Creates a new Color4 object from red, green, blue values, all between 0 and 1</summary>
        /// <param name="r">defines the red component (between 0 and 1, default is 0)</param>
        /// <param name="g">defines the green component (between 0 and 1, default is 0)</param>
        /// <param name="b">defines the blue component (between 0 and 1, default is 0)</param>
        /// <param name="a">defines the alpha component (between 0 and 1, default is 1)</param>
        [<Emit "new $0($1...)">] abstract Create: ?r: float * ?g: float * ?b: float * ?a: float -> Color4
        /// <summary>Creates a new Color4 from the string containing valid hexadecimal values</summary>
        /// <param name="hex">defines a string containing valid hexadecimal values</param>
        abstract FromHexString: hex: string -> Color4
        /// <summary>Creates a new Color4 object set with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object</summary>
        /// <param name="left">defines the start value</param>
        /// <param name="right">defines the end value</param>
        /// <param name="amount">defines the gradient factor</param>
        abstract Lerp: left: Color4 * right: Color4 * amount: float -> Color4
        /// <summary>Set the given "result" with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object</summary>
        /// <param name="left">defines the start value</param>
        /// <param name="right">defines the end value</param>
        /// <param name="amount">defines the gradient factor</param>
        /// <param name="result">defines the Color4 object where to store data</param>
        abstract LerpToRef: left: Color4 * right: Color4 * amount: float * result: Color4 -> unit
        /// <summary>Creates a new Color4 from a Color3 and an alpha value</summary>
        /// <param name="color3">defines the source Color3 to read from</param>
        /// <param name="alpha">defines the alpha component (1.0 by default)</param>
        abstract FromColor3: color3: Color3 * ?alpha: float -> Color4
        /// <summary>Creates a new Color4 from the starting index element of the given array</summary>
        /// <param name="array">defines the source array to read from</param>
        /// <param name="offset">defines the offset in the source array</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Color4
        /// <summary>Creates a new Color3 from integer values (< 256)</summary>
        /// <param name="r">defines the red component to read from (value between 0 and 255)</param>
        /// <param name="g">defines the green component to read from (value between 0 and 255)</param>
        /// <param name="b">defines the blue component to read from (value between 0 and 255)</param>
        /// <param name="a">defines the alpha component to read from (value between 0 and 255)</param>
        abstract FromInts: r: float * g: float * b: float * a: float -> Color4
        /// <summary>Check the content of a given array and convert it to an array containing RGBA data
        /// If the original array was already containing count * 4 values then it is returned directly</summary>
        /// <param name="colors">defines the array to check</param>
        /// <param name="count">defines the number of RGBA data to expect</param>
        abstract CheckColors4: colors: ResizeArray<float> * count: float -> ResizeArray<float>

    /// Class representing a vector containing 2 coordinates
    type [<AllowNullLiteral>] Vector2 =
        /// defines the first coordinate 
        abstract x: float with get, set
        /// defines the second coordinate 
        abstract y: float with get, set
        /// Gets a string with the Vector2 coordinates
        abstract toString: unit -> string
        /// Gets class name
        abstract getClassName: unit -> string
        /// Gets current vector hash code
        abstract getHashCode: unit -> float
        /// <summary>Sets the Vector2 coordinates in the given array or Float32Array from the given index.</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="index">defines the offset in source array</param>
        abstract toArray: array: FloatArray * ?index: float -> Vector2
        /// Copy the current vector to an array
        abstract asArray: unit -> ResizeArray<float>
        /// <summary>Sets the Vector2 coordinates with the given Vector2 coordinates</summary>
        /// <param name="source">defines the source Vector2</param>
        abstract copyFrom: source: Vector2 -> Vector2
        /// <summary>Sets the Vector2 coordinates with the given floats</summary>
        /// <param name="x">defines the first coordinate</param>
        /// <param name="y">defines the second coordinate</param>
        abstract copyFromFloats: x: float * y: float -> Vector2
        /// <summary>Sets the Vector2 coordinates with the given floats</summary>
        /// <param name="x">defines the first coordinate</param>
        /// <param name="y">defines the second coordinate</param>
        abstract set: x: float * y: float -> Vector2
        /// <summary>Add another vector with the current one</summary>
        /// <param name="otherVector">defines the other vector</param>
        abstract add: otherVector: Vector2 -> Vector2
        /// <summary>Sets the "result" coordinates with the addition of the current Vector2 and the given one coordinates</summary>
        /// <param name="otherVector">defines the other vector</param>
        /// <param name="result">defines the target vector</param>
        abstract addToRef: otherVector: Vector2 * result: Vector2 -> Vector2
        /// <summary>Set the Vector2 coordinates by adding the given Vector2 coordinates</summary>
        /// <param name="otherVector">defines the other vector</param>
        abstract addInPlace: otherVector: Vector2 -> Vector2
        /// <summary>Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates</summary>
        /// <param name="otherVector">defines the other vector</param>
        abstract addVector3: otherVector: Vector3 -> Vector2
        /// <summary>Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2</summary>
        /// <param name="otherVector">defines the other vector</param>
        abstract subtract: otherVector: Vector2 -> Vector2
        /// <summary>Sets the "result" coordinates with the subtraction of the given one from the current Vector2 coordinates.</summary>
        /// <param name="otherVector">defines the other vector</param>
        /// <param name="result">defines the target vector</param>
        abstract subtractToRef: otherVector: Vector2 * result: Vector2 -> Vector2
        /// <summary>Sets the current Vector2 coordinates by subtracting from it the given one coordinates</summary>
        /// <param name="otherVector">defines the other vector</param>
        abstract subtractInPlace: otherVector: Vector2 -> Vector2
        /// <summary>Multiplies in place the current Vector2 coordinates by the given ones</summary>
        /// <param name="otherVector">defines the other vector</param>
        abstract multiplyInPlace: otherVector: Vector2 -> Vector2
        /// <summary>Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates</summary>
        /// <param name="otherVector">defines the other vector</param>
        abstract multiply: otherVector: Vector2 -> Vector2
        /// <summary>Sets "result" coordinates with the multiplication of the current Vector2 and the given one coordinates</summary>
        /// <param name="otherVector">defines the other vector</param>
        /// <param name="result">defines the target vector</param>
        abstract multiplyToRef: otherVector: Vector2 * result: Vector2 -> Vector2
        /// <summary>Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats</summary>
        /// <param name="x">defines the first coordinate</param>
        /// <param name="y">defines the second coordinate</param>
        abstract multiplyByFloats: x: float * y: float -> Vector2
        /// <summary>Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates</summary>
        /// <param name="otherVector">defines the other vector</param>
        abstract divide: otherVector: Vector2 -> Vector2
        /// <summary>Sets the "result" coordinates with the Vector2 divided by the given one coordinates</summary>
        /// <param name="otherVector">defines the other vector</param>
        /// <param name="result">defines the target vector</param>
        abstract divideToRef: otherVector: Vector2 * result: Vector2 -> Vector2
        /// <summary>Divides the current Vector2 coordinates by the given ones</summary>
        /// <param name="otherVector">defines the other vector</param>
        abstract divideInPlace: otherVector: Vector2 -> Vector2
        /// Gets a new Vector2 with current Vector2 negated coordinates
        abstract negate: unit -> Vector2
        /// <summary>Multiply the Vector2 coordinates by scale</summary>
        /// <param name="scale">defines the scaling factor</param>
        abstract scaleInPlace: scale: float -> Vector2
        /// <summary>Returns a new Vector2 scaled by "scale" from the current Vector2</summary>
        /// <param name="scale">defines the scaling factor</param>
        abstract scale: scale: float -> Vector2
        /// <summary>Scale the current Vector2 values by a factor to a given Vector2</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Vector2 object where to store the result</param>
        abstract scaleToRef: scale: float * result: Vector2 -> Vector2
        /// <summary>Scale the current Vector2 values by a factor and add the result to a given Vector2</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Vector2 object where to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Vector2 -> Vector2
        /// <summary>Gets a boolean if two vectors are equals</summary>
        /// <param name="otherVector">defines the other vector</param>
        abstract equals: otherVector: Vector2 -> bool
        /// <summary>Gets a boolean if two vectors are equals (using an epsilon value)</summary>
        /// <param name="otherVector">defines the other vector</param>
        /// <param name="epsilon">defines the minimal distance to consider equality</param>
        abstract equalsWithEpsilon: otherVector: Vector2 * ?epsilon: float -> bool
        /// Gets a new Vector2 from current Vector2 floored values
        abstract floor: unit -> Vector2
        /// Gets a new Vector2 from current Vector2 floored values
        abstract fract: unit -> Vector2
        /// Gets the length of the vector
        abstract length: unit -> float
        /// Gets the vector squared length
        abstract lengthSquared: unit -> float
        /// Normalize the vector
        abstract normalize: unit -> Vector2
        /// Gets a new Vector2 copied from the Vector2
        abstract clone: unit -> Vector2

    /// Class representing a vector containing 2 coordinates
    type [<AllowNullLiteral>] Vector2Static =
        /// <summary>Creates a new Vector2 from the given x and y coordinates</summary>
        /// <param name="x">defines the first coordinate</param>
        /// <param name="y">defines the second coordinate</param>
        [<Emit "new $0($1...)">] abstract Create: ?x: float * ?y: float -> Vector2
        /// Gets a new Vector2(0, 0)
        abstract Zero: unit -> Vector2
        /// Gets a new Vector2(1, 1)
        abstract One: unit -> Vector2
        /// <summary>Gets a new Vector2 set from the given index element of the given array</summary>
        /// <param name="array">defines the data source</param>
        /// <param name="offset">defines the offset in the data source</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Vector2
        /// <summary>Sets "result" from the given index element of the given array</summary>
        /// <param name="array">defines the data source</param>
        /// <param name="offset">defines the offset in the data source</param>
        /// <param name="result">defines the target vector</param>
        abstract FromArrayToRef: array: ArrayLike<float> * offset: float * result: Vector2 -> unit
        /// <summary>Gets a new Vector2 located for "amount" (float) on the CatmullRom spline defined by the given four Vector2</summary>
        /// <param name="value1">defines 1st point of control</param>
        /// <param name="value2">defines 2nd point of control</param>
        /// <param name="value3">defines 3rd point of control</param>
        /// <param name="value4">defines 4th point of control</param>
        /// <param name="amount">defines the interpolation factor</param>
        abstract CatmullRom: value1: Vector2 * value2: Vector2 * value3: Vector2 * value4: Vector2 * amount: float -> Vector2
        /// <summary>Returns a new Vector2 set with same the coordinates than "value" ones if the vector "value" is in the square defined by "min" and "max".
        /// If a coordinate of "value" is lower than "min" coordinates, the returned Vector2 is given this "min" coordinate.
        /// If a coordinate of "value" is greater than "max" coordinates, the returned Vector2 is given this "max" coordinate</summary>
        /// <param name="value">defines the value to clamp</param>
        /// <param name="min">defines the lower limit</param>
        /// <param name="max">defines the upper limit</param>
        abstract Clamp: value: Vector2 * min: Vector2 * max: Vector2 -> Vector2
        /// <summary>Returns a new Vector2 located for "amount" (float) on the Hermite spline defined by the vectors "value1", "value3", "tangent1", "tangent2"</summary>
        /// <param name="value1">defines the 1st control point</param>
        /// <param name="tangent1">defines the outgoing tangent</param>
        /// <param name="value2">defines the 2nd control point</param>
        /// <param name="tangent2">defines the incoming tangent</param>
        /// <param name="amount">defines the interpolation factor</param>
        abstract Hermite: value1: Vector2 * tangent1: Vector2 * value2: Vector2 * tangent2: Vector2 * amount: float -> Vector2
        /// <summary>Returns a new Vector2 located for "amount" (float) on the linear interpolation between the vector "start" adn the vector "end".</summary>
        /// <param name="start">defines the start vector</param>
        /// <param name="end">defines the end vector</param>
        /// <param name="amount">defines the interpolation factor</param>
        abstract Lerp: start: Vector2 * ``end``: Vector2 * amount: float -> Vector2
        /// <summary>Gets the dot product of the vector "left" and the vector "right"</summary>
        /// <param name="left">defines first vector</param>
        /// <param name="right">defines second vector</param>
        abstract Dot: left: Vector2 * right: Vector2 -> float
        /// <summary>Returns a new Vector2 equal to the normalized given vector</summary>
        /// <param name="vector">defines the vector to normalize</param>
        abstract Normalize: vector: Vector2 -> Vector2
        /// <summary>Gets a new Vector2 set with the minimal coordinate values from the "left" and "right" vectors</summary>
        /// <param name="left">defines 1st vector</param>
        /// <param name="right">defines 2nd vector</param>
        abstract Minimize: left: Vector2 * right: Vector2 -> Vector2
        /// <summary>Gets a new Vecto2 set with the maximal coordinate values from the "left" and "right" vectors</summary>
        /// <param name="left">defines 1st vector</param>
        /// <param name="right">defines 2nd vector</param>
        abstract Maximize: left: Vector2 * right: Vector2 -> Vector2
        /// <summary>Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix</summary>
        /// <param name="vector">defines the vector to transform</param>
        /// <param name="transformation">defines the matrix to apply</param>
        abstract Transform: vector: Vector2 * transformation: Matrix -> Vector2
        /// <summary>Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector "result" coordinates</summary>
        /// <param name="vector">defines the vector to transform</param>
        /// <param name="transformation">defines the matrix to apply</param>
        /// <param name="result">defines the target vector</param>
        abstract TransformToRef: vector: Vector2 * transformation: Matrix * result: Vector2 -> unit
        /// <summary>Determines if a given vector is included in a triangle</summary>
        /// <param name="p">defines the vector to test</param>
        /// <param name="p0">defines 1st triangle point</param>
        /// <param name="p1">defines 2nd triangle point</param>
        /// <param name="p2">defines 3rd triangle point</param>
        abstract PointInTriangle: p: Vector2 * p0: Vector2 * p1: Vector2 * p2: Vector2 -> bool
        /// <summary>Gets the distance between the vectors "value1" and "value2"</summary>
        /// <param name="value1">defines first vector</param>
        /// <param name="value2">defines second vector</param>
        abstract Distance: value1: Vector2 * value2: Vector2 -> float
        /// <summary>Returns the squared distance between the vectors "value1" and "value2"</summary>
        /// <param name="value1">defines first vector</param>
        /// <param name="value2">defines second vector</param>
        abstract DistanceSquared: value1: Vector2 * value2: Vector2 -> float
        /// <summary>Gets a new Vector2 located at the center of the vectors "value1" and "value2"</summary>
        /// <param name="value1">defines first vector</param>
        /// <param name="value2">defines second vector</param>
        abstract Center: value1: Vector2 * value2: Vector2 -> Vector2
        /// <summary>Gets the shortest distance (float) between the point "p" and the segment defined by the two points "segA" and "segB".</summary>
        /// <param name="p">defines the middle point</param>
        /// <param name="segA">defines one point of the segment</param>
        /// <param name="segB">defines the other point of the segment</param>
        abstract DistanceOfPointFromSegment: p: Vector2 * segA: Vector2 * segB: Vector2 -> float

    /// Classed used to store (x,y,z) vector representation
    /// A Vector3 is the main object used in 3D geometry
    /// It can represent etiher the coordinates of a point the space, either a direction
    /// Reminder: Babylon.js uses a left handed forward facing system
    type [<AllowNullLiteral>] Vector3 =
        /// Defines the first coordinates (on X axis)
        abstract x: float with get, set
        /// Defines the second coordinates (on Y axis)
        abstract y: float with get, set
        /// Defines the third coordinates (on Z axis)
        abstract z: float with get, set
        /// Creates a string representation of the Vector3
        abstract toString: unit -> string
        /// Gets the class name
        abstract getClassName: unit -> string
        /// Creates the Vector3 hash code
        abstract getHashCode: unit -> float
        /// Creates an array containing three elements : the coordinates of the Vector3
        abstract asArray: unit -> ResizeArray<float>
        /// <summary>Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3</summary>
        /// <param name="array">defines the destination array</param>
        /// <param name="index">defines the offset in the destination array</param>
        abstract toArray: array: FloatArray * ?index: float -> Vector3
        /// Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)
        abstract toQuaternion: unit -> Quaternion
        /// <summary>Adds the given vector to the current Vector3</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract addInPlace: otherVector: Vector3 -> Vector3
        /// <summary>Gets a new Vector3, result of the addition the current Vector3 and the given vector</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract add: otherVector: Vector3 -> Vector3
        /// <summary>Adds the current Vector3 to the given one and stores the result in the vector "result"</summary>
        /// <param name="otherVector">defines the second operand</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract addToRef: otherVector: Vector3 * result: Vector3 -> Vector3
        /// <summary>Subtract the given vector from the current Vector3</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract subtractInPlace: otherVector: Vector3 -> Vector3
        /// <summary>Returns a new Vector3, result of the subtraction of the given vector from the current Vector3</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract subtract: otherVector: Vector3 -> Vector3
        /// <summary>Subtracts the given vector from the current Vector3 and stores the result in the vector "result".</summary>
        /// <param name="otherVector">defines the second operand</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract subtractToRef: otherVector: Vector3 * result: Vector3 -> Vector3
        /// <summary>Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract subtractFromFloats: x: float * y: float * z: float -> Vector3
        /// <summary>Subtracts the given floats from the current Vector3 coordinates and set the given vector "result" with this result</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract subtractFromFloatsToRef: x: float * y: float * z: float * result: Vector3 -> Vector3
        /// Gets a new Vector3 set with the current Vector3 negated coordinates
        abstract negate: unit -> Vector3
        /// <summary>Multiplies the Vector3 coordinates by the float "scale"</summary>
        /// <param name="scale">defines the multiplier factor</param>
        abstract scaleInPlace: scale: float -> Vector3
        /// <summary>Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float "scale"</summary>
        /// <param name="scale">defines the multiplier factor</param>
        abstract scale: scale: float -> Vector3
        /// <summary>Multiplies the current Vector3 coordinates by the float "scale" and stores the result in the given vector "result" coordinates</summary>
        /// <param name="scale">defines the multiplier factor</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract scaleToRef: scale: float * result: Vector3 -> Vector3
        /// <summary>Scale the current Vector3 values by a factor and add the result to a given Vector3</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Vector3 -> Vector3
        /// <summary>Returns true if the current Vector3 and the given vector coordinates are strictly equal</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract equals: otherVector: Vector3 -> bool
        /// <summary>Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon</summary>
        /// <param name="otherVector">defines the second operand</param>
        /// <param name="epsilon">defines the minimal distance to define values as equals</param>
        abstract equalsWithEpsilon: otherVector: Vector3 * ?epsilon: float -> bool
        /// <summary>Returns true if the current Vector3 coordinates equals the given floats</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract equalsToFloats: x: float * y: float * z: float -> bool
        /// <summary>Multiplies the current Vector3 coordinates by the given ones</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract multiplyInPlace: otherVector: Vector3 -> Vector3
        /// <summary>Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract multiply: otherVector: Vector3 -> Vector3
        /// <summary>Multiplies the current Vector3 by the given one and stores the result in the given vector "result"</summary>
        /// <param name="otherVector">defines the second operand</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract multiplyToRef: otherVector: Vector3 * result: Vector3 -> Vector3
        /// <summary>Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract multiplyByFloats: x: float * y: float * z: float -> Vector3
        /// <summary>Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract divide: otherVector: Vector3 -> Vector3
        /// <summary>Divides the current Vector3 coordinates by the given ones and stores the result in the given vector "result"</summary>
        /// <param name="otherVector">defines the second operand</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract divideToRef: otherVector: Vector3 * result: Vector3 -> Vector3
        /// <summary>Divides the current Vector3 coordinates by the given ones.</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract divideInPlace: otherVector: Vector3 -> Vector3
        /// <summary>Updates the current Vector3 with the minimal coordinate values between its and the given vector ones</summary>
        /// <param name="other">defines the second operand</param>
        abstract minimizeInPlace: other: Vector3 -> Vector3
        /// <summary>Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.</summary>
        /// <param name="other">defines the second operand</param>
        abstract maximizeInPlace: other: Vector3 -> Vector3
        /// <summary>Updates the current Vector3 with the minimal coordinate values between its and the given coordinates</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract minimizeInPlaceFromFloats: x: float * y: float * z: float -> Vector3
        /// <summary>Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract maximizeInPlaceFromFloats: x: float * y: float * z: float -> Vector3
        /// Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same
        abstract isNonUniform: bool
        /// Gets a new Vector3 from current Vector3 floored values
        abstract floor: unit -> Vector3
        /// Gets a new Vector3 from current Vector3 floored values
        abstract fract: unit -> Vector3
        /// Gets the length of the Vector3
        abstract length: unit -> float
        /// Gets the squared length of the Vector3
        abstract lengthSquared: unit -> float
        /// Normalize the current Vector3.
        /// Please note that this is an in place operation.
        abstract normalize: unit -> Vector3
        /// Normalize the current Vector3 to a new vector
        abstract normalizeToNew: unit -> Vector3
        /// <summary>Normalize the current Vector3 to the reference</summary>
        /// <param name="reference">define the Vector3 to update</param>
        abstract normalizeToRef: reference: Vector3 -> Vector3
        /// Creates a new Vector3 copied from the current Vector3
        abstract clone: unit -> Vector3
        /// <summary>Copies the given vector coordinates to the current Vector3 ones</summary>
        /// <param name="source">defines the source Vector3</param>
        abstract copyFrom: source: Vector3 -> Vector3
        /// <summary>Copies the given floats to the current Vector3 coordinates</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract copyFromFloats: x: float * y: float * z: float -> Vector3
        /// <summary>Copies the given floats to the current Vector3 coordinates</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract set: x: float * y: float * z: float -> Vector3

    /// Classed used to store (x,y,z) vector representation
    /// A Vector3 is the main object used in 3D geometry
    /// It can represent etiher the coordinates of a point the space, either a direction
    /// Reminder: Babylon.js uses a left handed forward facing system
    type [<AllowNullLiteral>] Vector3Static =
        /// <summary>Creates a new Vector3 object from the given x, y, z (floats) coordinates.</summary>
        /// <param name="x">defines the first coordinates (on X axis)</param>
        /// <param name="y">defines the second coordinates (on Y axis)</param>
        /// <param name="z">defines the third coordinates (on Z axis)</param>
        [<Emit "new $0($1...)">] abstract Create: ?x: float * ?y: float * ?z: float -> Vector3
        /// <summary>Get the clip factor between two vectors</summary>
        /// <param name="vector0">defines the first operand</param>
        /// <param name="vector1">defines the second operand</param>
        /// <param name="axis">defines the axis to use</param>
        /// <param name="size">defines the size along the axis</param>
        abstract GetClipFactor: vector0: Vector3 * vector1: Vector3 * axis: Vector3 * size: float -> float
        /// <summary>Get angle between two vectors</summary>
        /// <param name="vector0">angle between vector0 and vector1</param>
        /// <param name="vector1">angle between vector0 and vector1</param>
        /// <param name="normal">direction of the normal</param>
        abstract GetAngleBetweenVectors: vector0: Vector3 * vector1: Vector3 * normal: Vector3 -> float
        /// <summary>Returns a new Vector3 set from the index "offset" of the given array</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines the offset in the source array</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Vector3
        /// <summary>Returns a new Vector3 set from the index "offset" of the given Float32Array
        /// This function is deprecated.  Use FromArray instead</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines the offset in the source array</param>
        abstract FromFloatArray: array: Float32Array * ?offset: float -> Vector3
        /// <summary>Sets the given vector "result" with the element values from the index "offset" of the given array</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines the offset in the source array</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract FromArrayToRef: array: ArrayLike<float> * offset: float * result: Vector3 -> unit
        /// <summary>Sets the given vector "result" with the element values from the index "offset" of the given Float32Array
        /// This function is deprecated.  Use FromArrayToRef instead.</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines the offset in the source array</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract FromFloatArrayToRef: array: Float32Array * offset: float * result: Vector3 -> unit
        /// <summary>Sets the given vector "result" with the given floats.</summary>
        /// <param name="x">defines the x coordinate of the source</param>
        /// <param name="y">defines the y coordinate of the source</param>
        /// <param name="z">defines the z coordinate of the source</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract FromFloatsToRef: x: float * y: float * z: float * result: Vector3 -> unit
        /// Returns a new Vector3 set to (0.0, 0.0, 0.0)
        abstract Zero: unit -> Vector3
        /// Returns a new Vector3 set to (1.0, 1.0, 1.0)
        abstract One: unit -> Vector3
        /// Returns a new Vector3 set to (0.0, 1.0, 0.0)
        abstract Up: unit -> Vector3
        /// Returns a new Vector3 set to (0.0, -1.0, 0.0)
        abstract Down: unit -> Vector3
        /// Returns a new Vector3 set to (0.0, 0.0, 1.0)
        abstract Forward: unit -> Vector3
        /// Returns a new Vector3 set to (0.0, 0.0, -1.0)
        abstract Backward: unit -> Vector3
        /// Returns a new Vector3 set to (1.0, 0.0, 0.0)
        abstract Right: unit -> Vector3
        /// Returns a new Vector3 set to (-1.0, 0.0, 0.0)
        abstract Left: unit -> Vector3
        /// <summary>Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.
        /// This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)</summary>
        /// <param name="vector">defines the Vector3 to transform</param>
        /// <param name="transformation">defines the transformation matrix</param>
        abstract TransformCoordinates: vector: Vector3 * transformation: Matrix -> Vector3
        /// <summary>Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given vector
        /// This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)</summary>
        /// <param name="vector">defines the Vector3 to transform</param>
        /// <param name="transformation">defines the transformation matrix</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract TransformCoordinatesToRef: vector: Vector3 * transformation: Matrix * result: Vector3 -> unit
        /// <summary>Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)
        /// This method computes tranformed coordinates only, not transformed direction vectors</summary>
        /// <param name="x">define the x coordinate of the source vector</param>
        /// <param name="y">define the y coordinate of the source vector</param>
        /// <param name="z">define the z coordinate of the source vector</param>
        /// <param name="transformation">defines the transformation matrix</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract TransformCoordinatesFromFloatsToRef: x: float * y: float * z: float * transformation: Matrix * result: Vector3 -> unit
        /// <summary>Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector
        /// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)</summary>
        /// <param name="vector">defines the Vector3 to transform</param>
        /// <param name="transformation">defines the transformation matrix</param>
        abstract TransformNormal: vector: Vector3 * transformation: Matrix -> Vector3
        /// <summary>Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector
        /// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)</summary>
        /// <param name="vector">defines the Vector3 to transform</param>
        /// <param name="transformation">defines the transformation matrix</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract TransformNormalToRef: vector: Vector3 * transformation: Matrix * result: Vector3 -> unit
        /// <summary>Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z)
        /// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)</summary>
        /// <param name="x">define the x coordinate of the source vector</param>
        /// <param name="y">define the y coordinate of the source vector</param>
        /// <param name="z">define the z coordinate of the source vector</param>
        /// <param name="transformation">defines the transformation matrix</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract TransformNormalFromFloatsToRef: x: float * y: float * z: float * transformation: Matrix * result: Vector3 -> unit
        /// <summary>Returns a new Vector3 located for "amount" on the CatmullRom interpolation spline defined by the vectors "value1", "value2", "value3", "value4"</summary>
        /// <param name="value1">defines the first control point</param>
        /// <param name="value2">defines the second control point</param>
        /// <param name="value3">defines the third control point</param>
        /// <param name="value4">defines the fourth control point</param>
        /// <param name="amount">defines the amount on the spline to use</param>
        abstract CatmullRom: value1: Vector3 * value2: Vector3 * value3: Vector3 * value4: Vector3 * amount: float -> Vector3
        /// <summary>Returns a new Vector3 set with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
        /// If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
        /// If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one</summary>
        /// <param name="value">defines the current value</param>
        /// <param name="min">defines the lower range value</param>
        /// <param name="max">defines the upper range value</param>
        abstract Clamp: value: Vector3 * min: Vector3 * max: Vector3 -> Vector3
        /// <summary>Returns a new Vector3 located for "amount" (float) on the Hermite interpolation spline defined by the vectors "value1", "tangent1", "value2", "tangent2"</summary>
        /// <param name="value1">defines the first control point</param>
        /// <param name="tangent1">defines the first tangent vector</param>
        /// <param name="value2">defines the second control point</param>
        /// <param name="tangent2">defines the second tangent vector</param>
        /// <param name="amount">defines the amount on the interpolation spline (between 0 and 1)</param>
        abstract Hermite: value1: Vector3 * tangent1: Vector3 * value2: Vector3 * tangent2: Vector3 * amount: float -> Vector3
        /// <summary>Returns a new Vector3 located for "amount" (float) on the linear interpolation between the vectors "start" and "end"</summary>
        /// <param name="start">defines the start value</param>
        /// <param name="end">defines the end value</param>
        /// <param name="amount">max defines amount between both (between 0 and 1)</param>
        abstract Lerp: start: Vector3 * ``end``: Vector3 * amount: float -> Vector3
        /// <summary>Sets the given vector "result" with the result of the linear interpolation from the vector "start" for "amount" to the vector "end"</summary>
        /// <param name="start">defines the start value</param>
        /// <param name="end">defines the end value</param>
        /// <param name="amount">max defines amount between both (between 0 and 1)</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract LerpToRef: start: Vector3 * ``end``: Vector3 * amount: float * result: Vector3 -> unit
        /// <summary>Returns the dot product (float) between the vectors "left" and "right"</summary>
        /// <param name="left">defines the left operand</param>
        /// <param name="right">defines the right operand</param>
        abstract Dot: left: Vector3 * right: Vector3 -> float
        /// <summary>Returns a new Vector3 as the cross product of the vectors "left" and "right"
        /// The cross product is then orthogonal to both "left" and "right"</summary>
        /// <param name="left">defines the left operand</param>
        /// <param name="right">defines the right operand</param>
        abstract Cross: left: Vector3 * right: Vector3 -> Vector3
        /// <summary>Sets the given vector "result" with the cross product of "left" and "right"
        /// The cross product is then orthogonal to both "left" and "right"</summary>
        /// <param name="left">defines the left operand</param>
        /// <param name="right">defines the right operand</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract CrossToRef: left: Vector3 * right: Vector3 * result: Vector3 -> unit
        /// <summary>Returns a new Vector3 as the normalization of the given vector</summary>
        /// <param name="vector">defines the Vector3 to normalize</param>
        abstract Normalize: vector: Vector3 -> Vector3
        /// <summary>Sets the given vector "result" with the normalization of the given first vector</summary>
        /// <param name="vector">defines the Vector3 to normalize</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract NormalizeToRef: vector: Vector3 * result: Vector3 -> unit
        /// <summary>Project a Vector3 onto screen space</summary>
        /// <param name="vector">defines the Vector3 to project</param>
        /// <param name="world">defines the world matrix to use</param>
        /// <param name="transform">defines the transform (view x projection) matrix to use</param>
        /// <param name="viewport">defines the screen viewport to use</param>
        abstract Project: vector: Vector3 * world: Matrix * transform: Matrix * viewport: Viewport -> Vector3
        /// <summary>Unproject from screen space to object space</summary>
        /// <param name="source">defines the screen space Vector3 to use</param>
        /// <param name="viewportWidth">defines the current width of the viewport</param>
        /// <param name="viewportHeight">defines the current height of the viewport</param>
        /// <param name="world">defines the world matrix to use (can be set to Identity to go to world space)</param>
        /// <param name="transform">defines the transform (view x projection) matrix to use</param>
        abstract UnprojectFromTransform: source: Vector3 * viewportWidth: float * viewportHeight: float * world: Matrix * transform: Matrix -> Vector3
        /// <summary>Unproject from screen space to object space</summary>
        /// <param name="source">defines the screen space Vector3 to use</param>
        /// <param name="viewportWidth">defines the current width of the viewport</param>
        /// <param name="viewportHeight">defines the current height of the viewport</param>
        /// <param name="world">defines the world matrix to use (can be set to Identity to go to world space)</param>
        /// <param name="view">defines the view matrix to use</param>
        /// <param name="projection">defines the projection matrix to use</param>
        abstract Unproject: source: Vector3 * viewportWidth: float * viewportHeight: float * world: Matrix * view: Matrix * projection: Matrix -> Vector3
        /// <summary>Unproject from screen space to object space</summary>
        /// <param name="source">defines the screen space Vector3 to use</param>
        /// <param name="viewportWidth">defines the current width of the viewport</param>
        /// <param name="viewportHeight">defines the current height of the viewport</param>
        /// <param name="world">defines the world matrix to use (can be set to Identity to go to world space)</param>
        /// <param name="view">defines the view matrix to use</param>
        /// <param name="projection">defines the projection matrix to use</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract UnprojectToRef: source: Vector3 * viewportWidth: float * viewportHeight: float * world: Matrix * view: Matrix * projection: Matrix * result: Vector3 -> unit
        /// <summary>Unproject from screen space to object space</summary>
        /// <param name="sourceX">defines the screen space x coordinate to use</param>
        /// <param name="sourceY">defines the screen space y coordinate to use</param>
        /// <param name="sourceZ">defines the screen space z coordinate to use</param>
        /// <param name="viewportWidth">defines the current width of the viewport</param>
        /// <param name="viewportHeight">defines the current height of the viewport</param>
        /// <param name="world">defines the world matrix to use (can be set to Identity to go to world space)</param>
        /// <param name="view">defines the view matrix to use</param>
        /// <param name="projection">defines the projection matrix to use</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract UnprojectFloatsToRef: sourceX: float * sourceY: float * sourceZ: float * viewportWidth: float * viewportHeight: float * world: Matrix * view: Matrix * projection: Matrix * result: Vector3 -> unit
        /// <summary>Gets the minimal coordinate values between two Vector3</summary>
        /// <param name="left">defines the first operand</param>
        /// <param name="right">defines the second operand</param>
        abstract Minimize: left: Vector3 * right: Vector3 -> Vector3
        /// <summary>Gets the maximal coordinate values between two Vector3</summary>
        /// <param name="left">defines the first operand</param>
        /// <param name="right">defines the second operand</param>
        abstract Maximize: left: Vector3 * right: Vector3 -> Vector3
        /// <summary>Returns the distance between the vectors "value1" and "value2"</summary>
        /// <param name="value1">defines the first operand</param>
        /// <param name="value2">defines the second operand</param>
        abstract Distance: value1: Vector3 * value2: Vector3 -> float
        /// <summary>Returns the squared distance between the vectors "value1" and "value2"</summary>
        /// <param name="value1">defines the first operand</param>
        /// <param name="value2">defines the second operand</param>
        abstract DistanceSquared: value1: Vector3 * value2: Vector3 -> float
        /// <summary>Returns a new Vector3 located at the center between "value1" and "value2"</summary>
        /// <param name="value1">defines the first operand</param>
        /// <param name="value2">defines the second operand</param>
        abstract Center: value1: Vector3 * value2: Vector3 -> Vector3
        /// <summary>Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),
        /// RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply
        /// to something in order to rotate it from its local system to the given target system
        /// Note: axis1, axis2 and axis3 are normalized during this operation</summary>
        /// <param name="axis1">defines the first axis</param>
        /// <param name="axis2">defines the second axis</param>
        /// <param name="axis3">defines the third axis</param>
        abstract RotationFromAxis: axis1: Vector3 * axis2: Vector3 * axis3: Vector3 -> Vector3
        /// <summary>The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3</summary>
        /// <param name="axis1">defines the first axis</param>
        /// <param name="axis2">defines the second axis</param>
        /// <param name="axis3">defines the third axis</param>
        /// <param name="ref">defines the Vector3 where to store the result</param>
        abstract RotationFromAxisToRef: axis1: Vector3 * axis2: Vector3 * axis3: Vector3 * ref: Vector3 -> unit

    /// Vector4 class created for EulerAngle class conversion to Quaternion
    type [<AllowNullLiteral>] Vector4 =
        /// x value of the vector 
        abstract x: float with get, set
        /// y value of the vector 
        abstract y: float with get, set
        /// z value of the vector 
        abstract z: float with get, set
        /// w value of the vector 
        abstract w: float with get, set
        /// Returns the string with the Vector4 coordinates.
        abstract toString: unit -> string
        /// Returns the string "Vector4".
        abstract getClassName: unit -> string
        /// Returns the Vector4 hash code.
        abstract getHashCode: unit -> float
        /// Returns a new array populated with 4 elements : the Vector4 coordinates.
        abstract asArray: unit -> ResizeArray<float>
        /// <summary>Populates the given array from the given index with the Vector4 coordinates.</summary>
        /// <param name="array">array to populate</param>
        /// <param name="index">index of the array to start at (default: 0)</param>
        abstract toArray: array: FloatArray * ?index: float -> Vector4
        /// <summary>Adds the given vector to the current Vector4.</summary>
        /// <param name="otherVector">the vector to add</param>
        abstract addInPlace: otherVector: Vector4 -> Vector4
        /// <summary>Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.</summary>
        /// <param name="otherVector">the vector to add</param>
        abstract add: otherVector: Vector4 -> Vector4
        /// <summary>Updates the given vector "result" with the result of the addition of the current Vector4 and the given one.</summary>
        /// <param name="otherVector">the vector to add</param>
        /// <param name="result">the vector to store the result</param>
        abstract addToRef: otherVector: Vector4 * result: Vector4 -> Vector4
        /// <summary>Subtract in place the given vector from the current Vector4.</summary>
        /// <param name="otherVector">the vector to subtract</param>
        abstract subtractInPlace: otherVector: Vector4 -> Vector4
        /// <summary>Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.</summary>
        /// <param name="otherVector">the vector to add</param>
        abstract subtract: otherVector: Vector4 -> Vector4
        /// <summary>Sets the given vector "result" with the result of the subtraction of the given vector from the current Vector4.</summary>
        /// <param name="otherVector">the vector to subtract</param>
        /// <param name="result">the vector to store the result</param>
        abstract subtractToRef: otherVector: Vector4 * result: Vector4 -> Vector4
        /// <summary>Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.
        /// Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.</summary>
        /// <param name="x">value to subtract</param>
        /// <param name="y">value to subtract</param>
        /// <param name="z">value to subtract</param>
        /// <param name="w">value to subtract</param>
        abstract subtractFromFloats: x: float * y: float * z: float * w: float -> Vector4
        /// <summary>Sets the given vector "result" set with the result of the subtraction of the given floats from the current Vector4 coordinates.</summary>
        /// <param name="x">value to subtract</param>
        /// <param name="y">value to subtract</param>
        /// <param name="z">value to subtract</param>
        /// <param name="w">value to subtract</param>
        /// <param name="result">the vector to store the result in</param>
        abstract subtractFromFloatsToRef: x: float * y: float * z: float * w: float * result: Vector4 -> Vector4
        /// Returns a new Vector4 set with the current Vector4 negated coordinates.
        abstract negate: unit -> Vector4
        /// <summary>Multiplies the current Vector4 coordinates by scale (float).</summary>
        /// <param name="scale">the number to scale with</param>
        abstract scaleInPlace: scale: float -> Vector4
        /// <summary>Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).</summary>
        /// <param name="scale">the number to scale with</param>
        abstract scale: scale: float -> Vector4
        /// <summary>Sets the given vector "result" with the current Vector4 coordinates multiplied by scale (float).</summary>
        /// <param name="scale">the number to scale with</param>
        /// <param name="result">a vector to store the result in</param>
        abstract scaleToRef: scale: float * result: Vector4 -> Vector4
        /// <summary>Scale the current Vector4 values by a factor and add the result to a given Vector4</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Vector4 object where to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Vector4 -> Vector4
        /// <summary>Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.</summary>
        /// <param name="otherVector">the vector to compare against</param>
        abstract equals: otherVector: Vector4 -> bool
        /// <summary>Boolean : True if the current Vector4 coordinates are each beneath the distance "epsilon" from the given vector ones.</summary>
        /// <param name="otherVector">vector to compare against</param>
        /// <param name="epsilon">(Default: very small number)</param>
        abstract equalsWithEpsilon: otherVector: Vector4 * ?epsilon: float -> bool
        /// <summary>Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.</summary>
        /// <param name="x">x value to compare against</param>
        /// <param name="y">y value to compare against</param>
        /// <param name="z">z value to compare against</param>
        /// <param name="w">w value to compare against</param>
        abstract equalsToFloats: x: float * y: float * z: float * w: float -> bool
        /// <summary>Multiplies in place the current Vector4 by the given one.</summary>
        /// <param name="otherVector">vector to multiple with</param>
        abstract multiplyInPlace: otherVector: Vector4 -> Vector4
        /// <summary>Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.</summary>
        /// <param name="otherVector">vector to multiple with</param>
        abstract multiply: otherVector: Vector4 -> Vector4
        /// <summary>Updates the given vector "result" with the multiplication result of the current Vector4 and the given one.</summary>
        /// <param name="otherVector">vector to multiple with</param>
        /// <param name="result">vector to store the result</param>
        abstract multiplyToRef: otherVector: Vector4 * result: Vector4 -> Vector4
        /// <summary>Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.</summary>
        /// <param name="x">x value multiply with</param>
        /// <param name="y">y value multiply with</param>
        /// <param name="z">z value multiply with</param>
        /// <param name="w">w value multiply with</param>
        abstract multiplyByFloats: x: float * y: float * z: float * w: float -> Vector4
        /// <summary>Returns a new Vector4 set with the division result of the current Vector4 by the given one.</summary>
        /// <param name="otherVector">vector to devide with</param>
        abstract divide: otherVector: Vector4 -> Vector4
        /// <summary>Updates the given vector "result" with the division result of the current Vector4 by the given one.</summary>
        /// <param name="otherVector">vector to devide with</param>
        /// <param name="result">vector to store the result</param>
        abstract divideToRef: otherVector: Vector4 * result: Vector4 -> Vector4
        /// <summary>Divides the current Vector3 coordinates by the given ones.</summary>
        /// <param name="otherVector">vector to devide with</param>
        abstract divideInPlace: otherVector: Vector4 -> Vector4
        /// <summary>Updates the Vector4 coordinates with the minimum values between its own and the given vector ones</summary>
        /// <param name="other">defines the second operand</param>
        abstract minimizeInPlace: other: Vector4 -> Vector4
        /// <summary>Updates the Vector4 coordinates with the maximum values between its own and the given vector ones</summary>
        /// <param name="other">defines the second operand</param>
        abstract maximizeInPlace: other: Vector4 -> Vector4
        /// Gets a new Vector4 from current Vector4 floored values
        abstract floor: unit -> Vector4
        /// Gets a new Vector4 from current Vector3 floored values
        abstract fract: unit -> Vector4
        /// Returns the Vector4 length (float).
        abstract length: unit -> float
        /// Returns the Vector4 squared length (float).
        abstract lengthSquared: unit -> float
        /// Normalizes in place the Vector4.
        abstract normalize: unit -> Vector4
        /// Returns a new Vector3 from the Vector4 (x, y, z) coordinates.
        abstract toVector3: unit -> Vector3
        /// Returns a new Vector4 copied from the current one.
        abstract clone: unit -> Vector4
        /// <summary>Updates the current Vector4 with the given one coordinates.</summary>
        /// <param name="source">the source vector to copy from</param>
        abstract copyFrom: source: Vector4 -> Vector4
        /// <summary>Updates the current Vector4 coordinates with the given floats.</summary>
        /// <param name="x">float to copy from</param>
        /// <param name="y">float to copy from</param>
        /// <param name="z">float to copy from</param>
        /// <param name="w">float to copy from</param>
        abstract copyFromFloats: x: float * y: float * z: float * w: float -> Vector4
        /// <summary>Updates the current Vector4 coordinates with the given floats.</summary>
        /// <param name="x">float to set from</param>
        /// <param name="y">float to set from</param>
        /// <param name="z">float to set from</param>
        /// <param name="w">float to set from</param>
        abstract set: x: float * y: float * z: float * w: float -> Vector4

    /// Vector4 class created for EulerAngle class conversion to Quaternion
    type [<AllowNullLiteral>] Vector4Static =
        /// <summary>Creates a Vector4 object from the given floats.</summary>
        /// <param name="x">x value of the vector</param>
        /// <param name="y">y value of the vector</param>
        /// <param name="z">z value of the vector</param>
        /// <param name="w">w value of the vector</param>
        [<Emit "new $0($1...)">] abstract Create: x: float * y: float * z: float * w: float -> Vector4
        /// <summary>Returns a new Vector4 set from the starting index of the given array.</summary>
        /// <param name="array">the array to pull values from</param>
        /// <param name="offset">the offset into the array to start at</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Vector4
        /// <summary>Updates the given vector "result" from the starting index of the given array.</summary>
        /// <param name="array">the array to pull values from</param>
        /// <param name="offset">the offset into the array to start at</param>
        /// <param name="result">the vector to store the result in</param>
        abstract FromArrayToRef: array: ArrayLike<float> * offset: float * result: Vector4 -> unit
        /// <summary>Updates the given vector "result" from the starting index of the given Float32Array.</summary>
        /// <param name="array">the array to pull values from</param>
        /// <param name="offset">the offset into the array to start at</param>
        /// <param name="result">the vector to store the result in</param>
        abstract FromFloatArrayToRef: array: Float32Array * offset: float * result: Vector4 -> unit
        /// <summary>Updates the given vector "result" coordinates from the given floats.</summary>
        /// <param name="x">float to set from</param>
        /// <param name="y">float to set from</param>
        /// <param name="z">float to set from</param>
        /// <param name="w">float to set from</param>
        /// <param name="result">the vector to the floats in</param>
        abstract FromFloatsToRef: x: float * y: float * z: float * w: float * result: Vector4 -> unit
        /// Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)
        abstract Zero: unit -> Vector4
        /// Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)
        abstract One: unit -> Vector4
        /// <summary>Returns a new normalized Vector4 from the given one.</summary>
        /// <param name="vector">the vector to normalize</param>
        abstract Normalize: vector: Vector4 -> Vector4
        /// <summary>Updates the given vector "result" from the normalization of the given one.</summary>
        /// <param name="vector">the vector to normalize</param>
        /// <param name="result">the vector to store the result in</param>
        abstract NormalizeToRef: vector: Vector4 * result: Vector4 -> unit
        /// <summary>Returns a vector with the minimum values from the left and right vectors</summary>
        /// <param name="left">left vector to minimize</param>
        /// <param name="right">right vector to minimize</param>
        abstract Minimize: left: Vector4 * right: Vector4 -> Vector4
        /// <summary>Returns a vector with the maximum values from the left and right vectors</summary>
        /// <param name="left">left vector to maximize</param>
        /// <param name="right">right vector to maximize</param>
        abstract Maximize: left: Vector4 * right: Vector4 -> Vector4
        /// <summary>Returns the distance (float) between the vectors "value1" and "value2".</summary>
        /// <param name="value1">value to calulate the distance between</param>
        /// <param name="value2">value to calulate the distance between</param>
        abstract Distance: value1: Vector4 * value2: Vector4 -> float
        /// <summary>Returns the squared distance (float) between the vectors "value1" and "value2".</summary>
        /// <param name="value1">value to calulate the distance between</param>
        /// <param name="value2">value to calulate the distance between</param>
        abstract DistanceSquared: value1: Vector4 * value2: Vector4 -> float
        /// <summary>Returns a new Vector4 located at the center between the vectors "value1" and "value2".</summary>
        /// <param name="value1">value to calulate the center between</param>
        /// <param name="value2">value to calulate the center between</param>
        abstract Center: value1: Vector4 * value2: Vector4 -> Vector4
        /// <summary>Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.
        /// This methods computes transformed normalized direction vectors only.</summary>
        /// <param name="vector">the vector to transform</param>
        /// <param name="transformation">the transformation matrix to apply</param>
        abstract TransformNormal: vector: Vector4 * transformation: Matrix -> Vector4
        /// <summary>Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector.
        /// This methods computes transformed normalized direction vectors only.</summary>
        /// <param name="vector">the vector to transform</param>
        /// <param name="transformation">the transformation matrix to apply</param>
        /// <param name="result">the vector to store the result in</param>
        abstract TransformNormalToRef: vector: Vector4 * transformation: Matrix * result: Vector4 -> unit
        /// <summary>Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).
        /// This methods computes transformed normalized direction vectors only.</summary>
        /// <param name="x">value to transform</param>
        /// <param name="y">value to transform</param>
        /// <param name="z">value to transform</param>
        /// <param name="w">value to transform</param>
        /// <param name="transformation">the transformation matrix to apply</param>
        /// <param name="result">the vector to store the results in</param>
        abstract TransformNormalFromFloatsToRef: x: float * y: float * z: float * w: float * transformation: Matrix * result: Vector4 -> unit

    /// Interface for the size containing width and height
    type [<AllowNullLiteral>] ISize =
        /// Width
        abstract width: float with get, set
        /// Heighht
        abstract height: float with get, set

    /// Size containing widht and height
    type [<AllowNullLiteral>] Size =
        inherit ISize
        /// Width
        abstract width: float with get, set
        /// Height
        abstract height: float with get, set
        /// Returns a string with the Size width and height
        abstract toString: unit -> string
        /// "Size"
        abstract getClassName: unit -> string
        /// Returns the Size hash code.
        abstract getHashCode: unit -> float
        /// <summary>Updates the current size from the given one.</summary>
        /// <param name="src">the given size</param>
        abstract copyFrom: src: Size -> unit
        /// <summary>Updates in place the current Size from the given floats.</summary>
        /// <param name="width">width of the new size</param>
        /// <param name="height">height of the new size</param>
        abstract copyFromFloats: width: float * height: float -> Size
        /// <summary>Updates in place the current Size from the given floats.</summary>
        /// <param name="width">width to set</param>
        /// <param name="height">height to set</param>
        abstract set: width: float * height: float -> Size
        /// <summary>Multiplies the width and height by numbers</summary>
        /// <param name="w">factor to multiple the width by</param>
        /// <param name="h">factor to multiple the height by</param>
        abstract multiplyByFloats: w: float * h: float -> Size
        /// Clones the size
        abstract clone: unit -> Size
        /// <summary>True if the current Size and the given one width and height are strictly equal.</summary>
        /// <param name="other">the other size to compare against</param>
        abstract equals: other: Size -> bool
        /// The surface of the Size : width * height (float).
        abstract surface: float
        /// <summary>Sums the width and height of two sizes</summary>
        /// <param name="otherSize">size to add to this size</param>
        abstract add: otherSize: Size -> Size
        /// <summary>Subtracts the width and height of two</summary>
        /// <param name="otherSize">size to subtract to this size</param>
        abstract subtract: otherSize: Size -> Size

    /// Size containing widht and height
    type [<AllowNullLiteral>] SizeStatic =
        /// <summary>Creates a Size object from the given width and height (floats).</summary>
        /// <param name="width">width of the new size</param>
        /// <param name="height">height of the new size</param>
        [<Emit "new $0($1...)">] abstract Create: width: float * height: float -> Size
        /// Create a new size of zero
        abstract Zero: unit -> Size
        /// <summary>Creates a new Size set at the linear interpolation "amount" between "start" and "end"</summary>
        /// <param name="start">starting size to lerp between</param>
        /// <param name="end">end size to lerp between</param>
        /// <param name="amount">amount to lerp between the start and end values</param>
        abstract Lerp: start: Size * ``end``: Size * amount: float -> Size

    /// Class used to store quaternion data
    type [<AllowNullLiteral>] Quaternion =
        /// defines the first component (0 by default) 
        abstract x: float with get, set
        /// defines the second component (0 by default) 
        abstract y: float with get, set
        /// defines the third component (0 by default) 
        abstract z: float with get, set
        /// defines the fourth component (1.0 by default) 
        abstract w: float with get, set
        /// Gets a string representation for the current quaternion
        abstract toString: unit -> string
        /// Gets the class name of the quaternion
        abstract getClassName: unit -> string
        /// Gets a hash code for this quaternion
        abstract getHashCode: unit -> float
        /// Copy the quaternion to an array
        abstract asArray: unit -> ResizeArray<float>
        /// <summary>Check if two quaternions are equals</summary>
        /// <param name="otherQuaternion">defines the second operand</param>
        abstract equals: otherQuaternion: Quaternion -> bool
        /// Clone the current quaternion
        abstract clone: unit -> Quaternion
        /// <summary>Copy a quaternion to the current one</summary>
        /// <param name="other">defines the other quaternion</param>
        abstract copyFrom: other: Quaternion -> Quaternion
        /// <summary>Updates the current quaternion with the given float coordinates</summary>
        /// <param name="x">defines the x coordinate</param>
        /// <param name="y">defines the y coordinate</param>
        /// <param name="z">defines the z coordinate</param>
        /// <param name="w">defines the w coordinate</param>
        abstract copyFromFloats: x: float * y: float * z: float * w: float -> Quaternion
        /// <summary>Updates the current quaternion from the given float coordinates</summary>
        /// <param name="x">defines the x coordinate</param>
        /// <param name="y">defines the y coordinate</param>
        /// <param name="z">defines the z coordinate</param>
        /// <param name="w">defines the w coordinate</param>
        abstract set: x: float * y: float * z: float * w: float -> Quaternion
        /// <summary>Adds two quaternions</summary>
        /// <param name="other">defines the second operand</param>
        abstract add: other: Quaternion -> Quaternion
        /// <summary>Add a quaternion to the current one</summary>
        /// <param name="other">defines the quaternion to add</param>
        abstract addInPlace: other: Quaternion -> Quaternion
        /// <summary>Subtract two quaternions</summary>
        /// <param name="other">defines the second operand</param>
        abstract subtract: other: Quaternion -> Quaternion
        /// <summary>Multiplies the current quaternion by a scale factor</summary>
        /// <param name="value">defines the scale factor</param>
        abstract scale: value: float -> Quaternion
        /// <summary>Scale the current quaternion values by a factor and stores the result to a given quaternion</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Quaternion object where to store the result</param>
        abstract scaleToRef: scale: float * result: Quaternion -> Quaternion
        /// <summary>Multiplies in place the current quaternion by a scale factor</summary>
        /// <param name="value">defines the scale factor</param>
        abstract scaleInPlace: value: float -> Quaternion
        /// <summary>Scale the current quaternion values by a factor and add the result to a given quaternion</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Quaternion object where to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Quaternion -> Quaternion
        /// <summary>Multiplies two quaternions</summary>
        /// <param name="q1">defines the second operand</param>
        abstract multiply: q1: Quaternion -> Quaternion
        /// <summary>Sets the given "result" as the the multiplication result of the current one with the given one "q1"</summary>
        /// <param name="q1">defines the second operand</param>
        /// <param name="result">defines the target quaternion</param>
        abstract multiplyToRef: q1: Quaternion * result: Quaternion -> Quaternion
        /// <summary>Updates the current quaternion with the multiplication of itself with the given one "q1"</summary>
        /// <param name="q1">defines the second operand</param>
        abstract multiplyInPlace: q1: Quaternion -> Quaternion
        /// <summary>Conjugates (1-q) the current quaternion and stores the result in the given quaternion</summary>
        /// <param name="ref">defines the target quaternion</param>
        abstract conjugateToRef: ref: Quaternion -> Quaternion
        /// Conjugates in place (1-q) the current quaternion
        abstract conjugateInPlace: unit -> Quaternion
        /// Conjugates in place (1-q) the current quaternion
        abstract conjugate: unit -> Quaternion
        /// Gets length of current quaternion
        abstract length: unit -> float
        /// Normalize in place the current quaternion
        abstract normalize: unit -> Quaternion
        /// <summary>Returns a new Vector3 set with the Euler angles translated from the current quaternion</summary>
        /// <param name="order">is a reserved parameter and is ignore for now</param>
        abstract toEulerAngles: ?order: string -> Vector3
        /// <summary>Sets the given vector3 "result" with the Euler angles translated from the current quaternion</summary>
        /// <param name="result">defines the vector which will be filled with the Euler angles</param>
        /// <param name="order">is a reserved parameter and is ignore for now</param>
        abstract toEulerAnglesToRef: result: Vector3 * ?order: string -> Quaternion
        /// <summary>Updates the given rotation matrix with the current quaternion values</summary>
        /// <param name="result">defines the target matrix</param>
        abstract toRotationMatrix: result: Matrix -> Quaternion
        /// <summary>Updates the current quaternion from the given rotation matrix values</summary>
        /// <param name="matrix">defines the source matrix</param>
        abstract fromRotationMatrix: matrix: Matrix -> Quaternion

    /// Class used to store quaternion data
    type [<AllowNullLiteral>] QuaternionStatic =
        /// <summary>Creates a new Quaternion from the given floats</summary>
        /// <param name="x">defines the first component (0 by default)</param>
        /// <param name="y">defines the second component (0 by default)</param>
        /// <param name="z">defines the third component (0 by default)</param>
        /// <param name="w">defines the fourth component (1.0 by default)</param>
        [<Emit "new $0($1...)">] abstract Create: ?x: float * ?y: float * ?z: float * ?w: float -> Quaternion
        /// <summary>Creates a new quaternion from a rotation matrix</summary>
        /// <param name="matrix">defines the source matrix</param>
        abstract FromRotationMatrix: matrix: Matrix -> Quaternion
        /// <summary>Updates the given quaternion with the given rotation matrix values</summary>
        /// <param name="matrix">defines the source matrix</param>
        /// <param name="result">defines the target quaternion</param>
        abstract FromRotationMatrixToRef: matrix: Matrix * result: Quaternion -> unit
        /// <summary>Returns the dot product (float) between the quaternions "left" and "right"</summary>
        /// <param name="left">defines the left operand</param>
        /// <param name="right">defines the right operand</param>
        abstract Dot: left: Quaternion * right: Quaternion -> float
        /// <summary>Checks if the two quaternions are close to each other</summary>
        /// <param name="quat0">defines the first quaternion to check</param>
        /// <param name="quat1">defines the second quaternion to check</param>
        abstract AreClose: quat0: Quaternion * quat1: Quaternion -> bool
        /// Creates an empty quaternion
        abstract Zero: unit -> Quaternion
        /// <summary>Inverse a given quaternion</summary>
        /// <param name="q">defines the source quaternion</param>
        abstract Inverse: q: Quaternion -> Quaternion
        /// Creates an identity quaternion
        abstract Identity: unit -> Quaternion
        /// <summary>Gets a boolean indicating if the given quaternion is identity</summary>
        /// <param name="quaternion">defines the quaternion to check</param>
        abstract IsIdentity: quaternion: Quaternion -> bool
        /// <summary>Creates a quaternion from a rotation around an axis</summary>
        /// <param name="axis">defines the axis to use</param>
        /// <param name="angle">defines the angle to use</param>
        abstract RotationAxis: axis: Vector3 * angle: float -> Quaternion
        /// <summary>Creates a rotation around an axis and stores it into the given quaternion</summary>
        /// <param name="axis">defines the axis to use</param>
        /// <param name="angle">defines the angle to use</param>
        /// <param name="result">defines the target quaternion</param>
        abstract RotationAxisToRef: axis: Vector3 * angle: float * result: Quaternion -> Quaternion
        /// <summary>Creates a new quaternion from data stored into an array</summary>
        /// <param name="array">defines the data source</param>
        /// <param name="offset">defines the offset in the source array where the data starts</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Quaternion
        /// <summary>Creates a new quaternion from the given Euler float angles (y, x, z)</summary>
        /// <param name="yaw">defines the rotation around Y axis</param>
        /// <param name="pitch">defines the rotation around X axis</param>
        /// <param name="roll">defines the rotation around Z axis</param>
        abstract RotationYawPitchRoll: yaw: float * pitch: float * roll: float -> Quaternion
        /// <summary>Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion</summary>
        /// <param name="yaw">defines the rotation around Y axis</param>
        /// <param name="pitch">defines the rotation around X axis</param>
        /// <param name="roll">defines the rotation around Z axis</param>
        /// <param name="result">defines the target quaternion</param>
        abstract RotationYawPitchRollToRef: yaw: float * pitch: float * roll: float * result: Quaternion -> unit
        /// <summary>Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation</summary>
        /// <param name="alpha">defines the rotation around first axis</param>
        /// <param name="beta">defines the rotation around second axis</param>
        /// <param name="gamma">defines the rotation around third axis</param>
        abstract RotationAlphaBetaGamma: alpha: float * beta: float * gamma: float -> Quaternion
        /// <summary>Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion</summary>
        /// <param name="alpha">defines the rotation around first axis</param>
        /// <param name="beta">defines the rotation around second axis</param>
        /// <param name="gamma">defines the rotation around third axis</param>
        /// <param name="result">defines the target quaternion</param>
        abstract RotationAlphaBetaGammaToRef: alpha: float * beta: float * gamma: float * result: Quaternion -> unit
        /// <summary>Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)</summary>
        /// <param name="axis1">defines the first axis</param>
        /// <param name="axis2">defines the second axis</param>
        /// <param name="axis3">defines the third axis</param>
        abstract RotationQuaternionFromAxis: axis1: Vector3 * axis2: Vector3 * axis3: Vector3 -> Quaternion
        /// <summary>Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion</summary>
        /// <param name="axis1">defines the first axis</param>
        /// <param name="axis2">defines the second axis</param>
        /// <param name="axis3">defines the third axis</param>
        /// <param name="ref">defines the target quaternion</param>
        abstract RotationQuaternionFromAxisToRef: axis1: Vector3 * axis2: Vector3 * axis3: Vector3 * ref: Quaternion -> unit
        /// <summary>Interpolates between two quaternions</summary>
        /// <param name="left">defines first quaternion</param>
        /// <param name="right">defines second quaternion</param>
        /// <param name="amount">defines the gradient to use</param>
        abstract Slerp: left: Quaternion * right: Quaternion * amount: float -> Quaternion
        /// <summary>Interpolates between two quaternions and stores it into a target quaternion</summary>
        /// <param name="left">defines first quaternion</param>
        /// <param name="right">defines second quaternion</param>
        /// <param name="amount">defines the gradient to use</param>
        /// <param name="result">defines the target quaternion</param>
        abstract SlerpToRef: left: Quaternion * right: Quaternion * amount: float * result: Quaternion -> unit
        /// <summary>Interpolate between two quaternions using Hermite interpolation</summary>
        /// <param name="value1">defines first quaternion</param>
        /// <param name="tangent1">defines the incoming tangent</param>
        /// <param name="value2">defines second quaternion</param>
        /// <param name="tangent2">defines the outgoing tangent</param>
        /// <param name="amount">defines the target quaternion</param>
        abstract Hermite: value1: Quaternion * tangent1: Quaternion * value2: Quaternion * tangent2: Quaternion * amount: float -> Quaternion

    /// Class used to store matrix data (4x4)
    type [<AllowNullLiteral>] Matrix =
        /// Gets the update flag of the matrix which is an unique number for the matrix.
        /// It will be incremented every time the matrix data change.
        /// You can use it to speed the comparison between two versions of the same matrix.
        abstract updateFlag: float with get, set
        /// Gets or sets the internal data of the matrix
        abstract m: Float32Array with get, set
        abstract _markAsUpdated: unit -> unit
        /// <summary>Check if the current matrix is indentity</summary>
        /// <param name="considerAsTextureMatrix">defines if the current matrix must be considered as a texture matrix (3x2)</param>
        abstract isIdentity: ?considerAsTextureMatrix: bool -> bool
        /// Gets the determinant of the matrix
        abstract determinant: unit -> float
        /// Returns the matrix as a Float32Array
        abstract toArray: unit -> Float32Array
        /// Returns the matrix as a Float32Array
        abstract asArray: unit -> Float32Array
        /// Inverts the current matrix in place
        abstract invert: unit -> Matrix
        /// Sets all the matrix elements to zero
        abstract reset: unit -> Matrix
        /// <summary>Adds the current matrix with a second one</summary>
        /// <param name="other">defines the matrix to add</param>
        abstract add: other: Matrix -> Matrix
        /// <summary>Sets the given matrix "result" to the addition of the current matrix and the given one</summary>
        /// <param name="other">defines the matrix to add</param>
        /// <param name="result">defines the target matrix</param>
        abstract addToRef: other: Matrix * result: Matrix -> Matrix
        /// <summary>Adds in place the given matrix to the current matrix</summary>
        /// <param name="other">defines the second operand</param>
        abstract addToSelf: other: Matrix -> Matrix
        /// <summary>Sets the given matrix to the current inverted Matrix</summary>
        /// <param name="other">defines the target matrix</param>
        abstract invertToRef: other: Matrix -> Matrix
        /// <summary>Inserts the translation vector (using 3 floats) in the current matrix</summary>
        /// <param name="x">defines the 1st component of the translation</param>
        /// <param name="y">defines the 2nd component of the translation</param>
        /// <param name="z">defines the 3rd component of the translation</param>
        abstract setTranslationFromFloats: x: float * y: float * z: float -> Matrix
        /// <summary>Inserts the translation vector in the current matrix</summary>
        /// <param name="vector3">defines the translation to insert</param>
        abstract setTranslation: vector3: Vector3 -> Matrix
        /// Gets the translation value of the current matrix
        abstract getTranslation: unit -> Vector3
        /// <summary>Fill a Vector3 with the extracted translation from the matrix</summary>
        /// <param name="result">defines the Vector3 where to store the translation</param>
        abstract getTranslationToRef: result: Vector3 -> Matrix
        /// Remove rotation and scaling part from the matrix
        abstract removeRotationAndScaling: unit -> Matrix
        /// <summary>Multiply two matrices</summary>
        /// <param name="other">defines the second operand</param>
        abstract multiply: other: Matrix -> Matrix
        /// <summary>Copy the current matrix from the given one</summary>
        /// <param name="other">defines the source matrix</param>
        abstract copyFrom: other: Matrix -> Matrix
        /// <summary>Populates the given array from the starting index with the current matrix values</summary>
        /// <param name="array">defines the target array</param>
        /// <param name="offset">defines the offset in the target array where to start storing values</param>
        abstract copyToArray: array: Float32Array * ?offset: float -> Matrix
        /// <summary>Sets the given matrix "result" with the multiplication result of the current Matrix and the given one</summary>
        /// <param name="other">defines the second operand</param>
        /// <param name="result">defines the matrix where to store the multiplication</param>
        abstract multiplyToRef: other: Matrix * result: Matrix -> Matrix
        /// <summary>Sets the Float32Array "result" from the given index "offset" with the multiplication of the current matrix and the given one</summary>
        /// <param name="other">defines the second operand</param>
        /// <param name="result">defines the array where to store the multiplication</param>
        /// <param name="offset">defines the offset in the target array where to start storing values</param>
        abstract multiplyToArray: other: Matrix * result: Float32Array * offset: float -> Matrix
        /// <summary>Check equality between this matrix and a second one</summary>
        /// <param name="value">defines the second matrix to compare</param>
        abstract equals: value: Matrix -> bool
        /// Clone the current matrix
        abstract clone: unit -> Matrix
        /// Returns the name of the current matrix class
        abstract getClassName: unit -> string
        /// Gets the hash code of the current matrix
        abstract getHashCode: unit -> float
        /// <summary>Decomposes the current Matrix into a translation, rotation and scaling components</summary>
        /// <param name="scale">defines the scale vector3 given as a reference to update</param>
        /// <param name="rotation">defines the rotation quaternion given as a reference to update</param>
        /// <param name="translation">defines the translation vector3 given as a reference to update</param>
        abstract decompose: ?scale: Vector3 * ?rotation: Quaternion * ?translation: Vector3 -> bool
        /// <summary>Gets specific row of the matrix</summary>
        /// <param name="index">defines the number of the row to get</param>
        abstract getRow: index: float -> Nullable<Vector4>
        /// <summary>Sets the index-th row of the current matrix to the vector4 values</summary>
        /// <param name="index">defines the number of the row to set</param>
        /// <param name="row">defines the target vector4</param>
        abstract setRow: index: float * row: Vector4 -> Matrix
        /// Compute the transpose of the matrix
        abstract transpose: unit -> Matrix
        /// <summary>Compute the transpose of the matrix and store it in a given matrix</summary>
        /// <param name="result">defines the target matrix</param>
        abstract transposeToRef: result: Matrix -> Matrix
        /// <summary>Sets the index-th row of the current matrix with the given 4 x float values</summary>
        /// <param name="index">defines the row index</param>
        /// <param name="x">defines the x component to set</param>
        /// <param name="y">defines the y component to set</param>
        /// <param name="z">defines the z component to set</param>
        /// <param name="w">defines the w component to set</param>
        abstract setRowFromFloats: index: float * x: float * y: float * z: float * w: float -> Matrix
        /// <summary>Compute a new matrix set with the current matrix values multiplied by scale (float)</summary>
        /// <param name="scale">defines the scale factor</param>
        abstract scale: scale: float -> Matrix
        /// <summary>Scale the current matrix values by a factor to a given result matrix</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the matrix to store the result</param>
        abstract scaleToRef: scale: float * result: Matrix -> Matrix
        /// <summary>Scale the current matrix values by a factor and add the result to a given matrix</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Matrix to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Matrix -> Matrix
        /// <summary>Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).</summary>
        /// <param name="ref">matrix to store the result</param>
        abstract toNormalMatrix: ref: Matrix -> unit
        /// Gets only rotation part of the current matrix
        abstract getRotationMatrix: unit -> Matrix
        /// <summary>Extracts the rotation matrix from the current one and sets it as the given "result"</summary>
        /// <param name="result">defines the target matrix to store data to</param>
        abstract getRotationMatrixToRef: result: Matrix -> Matrix

    /// Class used to store matrix data (4x4)
    type [<AllowNullLiteral>] MatrixStatic =
        /// Creates an empty matrix (filled with zeros)
        [<Emit "new $0($1...)">] abstract Create: unit -> Matrix
        /// <summary>Creates a matrix from an array</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines an offset in the source array</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Matrix
        /// <summary>Copy the content of an array into a given matrix</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines an offset in the source array</param>
        /// <param name="result">defines the target matrix</param>
        abstract FromArrayToRef: array: ArrayLike<float> * offset: float * result: Matrix -> unit
        /// <summary>Stores an array into a matrix after having multiplied each component by a given factor</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines the offset in the source array</param>
        /// <param name="scale">defines the scaling factor</param>
        /// <param name="result">defines the target matrix</param>
        abstract FromFloat32ArrayToRefScaled: array: Float32Array * offset: float * scale: float * result: Matrix -> unit
        /// <summary>Stores a list of values (16) inside a given matrix</summary>
        /// <param name="initialM11">defines 1st value of 1st row</param>
        /// <param name="initialM12">defines 2nd value of 1st row</param>
        /// <param name="initialM13">defines 3rd value of 1st row</param>
        /// <param name="initialM14">defines 4th value of 1st row</param>
        /// <param name="initialM21">defines 1st value of 2nd row</param>
        /// <param name="initialM22">defines 2nd value of 2nd row</param>
        /// <param name="initialM23">defines 3rd value of 2nd row</param>
        /// <param name="initialM24">defines 4th value of 2nd row</param>
        /// <param name="initialM31">defines 1st value of 3rd row</param>
        /// <param name="initialM32">defines 2nd value of 3rd row</param>
        /// <param name="initialM33">defines 3rd value of 3rd row</param>
        /// <param name="initialM34">defines 4th value of 3rd row</param>
        /// <param name="initialM41">defines 1st value of 4th row</param>
        /// <param name="initialM42">defines 2nd value of 4th row</param>
        /// <param name="initialM43">defines 3rd value of 4th row</param>
        /// <param name="initialM44">defines 4th value of 4th row</param>
        /// <param name="result">defines the target matrix</param>
        abstract FromValuesToRef: initialM11: float * initialM12: float * initialM13: float * initialM14: float * initialM21: float * initialM22: float * initialM23: float * initialM24: float * initialM31: float * initialM32: float * initialM33: float * initialM34: float * initialM41: float * initialM42: float * initialM43: float * initialM44: float * result: Matrix -> unit
        /// Gets an identity matrix that must not be updated
        abstract IdentityReadOnly: Matrix
        /// <summary>Creates new matrix from a list of values (16)</summary>
        /// <param name="initialM11">defines 1st value of 1st row</param>
        /// <param name="initialM12">defines 2nd value of 1st row</param>
        /// <param name="initialM13">defines 3rd value of 1st row</param>
        /// <param name="initialM14">defines 4th value of 1st row</param>
        /// <param name="initialM21">defines 1st value of 2nd row</param>
        /// <param name="initialM22">defines 2nd value of 2nd row</param>
        /// <param name="initialM23">defines 3rd value of 2nd row</param>
        /// <param name="initialM24">defines 4th value of 2nd row</param>
        /// <param name="initialM31">defines 1st value of 3rd row</param>
        /// <param name="initialM32">defines 2nd value of 3rd row</param>
        /// <param name="initialM33">defines 3rd value of 3rd row</param>
        /// <param name="initialM34">defines 4th value of 3rd row</param>
        /// <param name="initialM41">defines 1st value of 4th row</param>
        /// <param name="initialM42">defines 2nd value of 4th row</param>
        /// <param name="initialM43">defines 3rd value of 4th row</param>
        /// <param name="initialM44">defines 4th value of 4th row</param>
        abstract FromValues: initialM11: float * initialM12: float * initialM13: float * initialM14: float * initialM21: float * initialM22: float * initialM23: float * initialM24: float * initialM31: float * initialM32: float * initialM33: float * initialM34: float * initialM41: float * initialM42: float * initialM43: float * initialM44: float -> Matrix
        /// <summary>Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)</summary>
        /// <param name="scale">defines the scale vector3</param>
        /// <param name="rotation">defines the rotation quaternion</param>
        /// <param name="translation">defines the translation vector3</param>
        abstract Compose: scale: Vector3 * rotation: Quaternion * translation: Vector3 -> Matrix
        /// <summary>Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)</summary>
        /// <param name="scale">defines the scale vector3</param>
        /// <param name="rotation">defines the rotation quaternion</param>
        /// <param name="translation">defines the translation vector3</param>
        /// <param name="result">defines the target matrix</param>
        abstract ComposeToRef: scale: Vector3 * rotation: Quaternion * translation: Vector3 * result: Matrix -> unit
        /// Creates a new identity matrix
        abstract Identity: unit -> Matrix
        /// <summary>Creates a new identity matrix and stores the result in a given matrix</summary>
        /// <param name="result">defines the target matrix</param>
        abstract IdentityToRef: result: Matrix -> unit
        /// Creates a new zero matrix
        abstract Zero: unit -> Matrix
        /// <summary>Creates a new rotation matrix for "angle" radians around the X axis</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        abstract RotationX: angle: float -> Matrix
        /// <summary>Creates a new matrix as the invert of a given matrix</summary>
        /// <param name="source">defines the source matrix</param>
        abstract Invert: source: Matrix -> Matrix
        /// <summary>Creates a new rotation matrix for "angle" radians around the X axis and stores it in a given matrix</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        /// <param name="result">defines the target matrix</param>
        abstract RotationXToRef: angle: float * result: Matrix -> unit
        /// <summary>Creates a new rotation matrix for "angle" radians around the Y axis</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        abstract RotationY: angle: float -> Matrix
        /// <summary>Creates a new rotation matrix for "angle" radians around the Y axis and stores it in a given matrix</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        /// <param name="result">defines the target matrix</param>
        abstract RotationYToRef: angle: float * result: Matrix -> unit
        /// <summary>Creates a new rotation matrix for "angle" radians around the Z axis</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        abstract RotationZ: angle: float -> Matrix
        /// <summary>Creates a new rotation matrix for "angle" radians around the Z axis and stores it in a given matrix</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        /// <param name="result">defines the target matrix</param>
        abstract RotationZToRef: angle: float * result: Matrix -> unit
        /// <summary>Creates a new rotation matrix for "angle" radians around the given axis</summary>
        /// <param name="axis">defines the axis to use</param>
        /// <param name="angle">defines the angle (in radians) to use</param>
        abstract RotationAxis: axis: Vector3 * angle: float -> Matrix
        /// <summary>Creates a new rotation matrix for "angle" radians around the given axis and stores it in a given matrix</summary>
        /// <param name="axis">defines the axis to use</param>
        /// <param name="angle">defines the angle (in radians) to use</param>
        /// <param name="result">defines the target matrix</param>
        abstract RotationAxisToRef: axis: Vector3 * angle: float * result: Matrix -> unit
        /// <summary>Creates a rotation matrix</summary>
        /// <param name="yaw">defines the yaw angle in radians (Y axis)</param>
        /// <param name="pitch">defines the pitch angle in radians (X axis)</param>
        /// <param name="roll">defines the roll angle in radians (X axis)</param>
        abstract RotationYawPitchRoll: yaw: float * pitch: float * roll: float -> Matrix
        /// <summary>Creates a rotation matrix and stores it in a given matrix</summary>
        /// <param name="yaw">defines the yaw angle in radians (Y axis)</param>
        /// <param name="pitch">defines the pitch angle in radians (X axis)</param>
        /// <param name="roll">defines the roll angle in radians (X axis)</param>
        /// <param name="result">defines the target matrix</param>
        abstract RotationYawPitchRollToRef: yaw: float * pitch: float * roll: float * result: Matrix -> unit
        /// <summary>Creates a scaling matrix</summary>
        /// <param name="x">defines the scale factor on X axis</param>
        /// <param name="y">defines the scale factor on Y axis</param>
        /// <param name="z">defines the scale factor on Z axis</param>
        abstract Scaling: x: float * y: float * z: float -> Matrix
        /// <summary>Creates a scaling matrix and stores it in a given matrix</summary>
        /// <param name="x">defines the scale factor on X axis</param>
        /// <param name="y">defines the scale factor on Y axis</param>
        /// <param name="z">defines the scale factor on Z axis</param>
        /// <param name="result">defines the target matrix</param>
        abstract ScalingToRef: x: float * y: float * z: float * result: Matrix -> unit
        /// <summary>Creates a translation matrix</summary>
        /// <param name="x">defines the translation on X axis</param>
        /// <param name="y">defines the translation on Y axis</param>
        /// <param name="z">defines the translationon Z axis</param>
        abstract Translation: x: float * y: float * z: float -> Matrix
        /// <summary>Creates a translation matrix and stores it in a given matrix</summary>
        /// <param name="x">defines the translation on X axis</param>
        /// <param name="y">defines the translation on Y axis</param>
        /// <param name="z">defines the translationon Z axis</param>
        /// <param name="result">defines the target matrix</param>
        abstract TranslationToRef: x: float * y: float * z: float * result: Matrix -> unit
        /// <summary>Returns a new Matrix whose values are the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".</summary>
        /// <param name="startValue">defines the start value</param>
        /// <param name="endValue">defines the end value</param>
        /// <param name="gradient">defines the gradient factor</param>
        abstract Lerp: startValue: Matrix * endValue: Matrix * gradient: float -> Matrix
        /// <summary>Set the given matrix "result" as the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".</summary>
        /// <param name="startValue">defines the start value</param>
        /// <param name="endValue">defines the end value</param>
        /// <param name="gradient">defines the gradient factor</param>
        /// <param name="result">defines the Matrix object where to store data</param>
        abstract LerpToRef: startValue: Matrix * endValue: Matrix * gradient: float * result: Matrix -> unit
        /// <summary>Builds a new matrix whose values are computed by:
        /// * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
        /// * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
        /// * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices</summary>
        /// <param name="startValue">defines the first matrix</param>
        /// <param name="endValue">defines the second matrix</param>
        /// <param name="gradient">defines the gradient between the two matrices</param>
        abstract DecomposeLerp: startValue: Matrix * endValue: Matrix * gradient: float -> Matrix
        /// <summary>Update a matrix to values which are computed by:
        /// * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
        /// * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
        /// * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices</summary>
        /// <param name="startValue">defines the first matrix</param>
        /// <param name="endValue">defines the second matrix</param>
        /// <param name="gradient">defines the gradient between the two matrices</param>
        /// <param name="result">defines the target matrix</param>
        abstract DecomposeLerpToRef: startValue: Matrix * endValue: Matrix * gradient: float * result: Matrix -> unit
        /// <summary>Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
        /// This function works in left handed mode</summary>
        /// <param name="eye">defines the final position of the entity</param>
        /// <param name="target">defines where the entity should look at</param>
        /// <param name="up">defines the up vector for the entity</param>
        abstract LookAtLH: eye: Vector3 * target: Vector3 * up: Vector3 -> Matrix
        /// <summary>Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
        /// This function works in left handed mode</summary>
        /// <param name="eye">defines the final position of the entity</param>
        /// <param name="target">defines where the entity should look at</param>
        /// <param name="up">defines the up vector for the entity</param>
        /// <param name="result">defines the target matrix</param>
        abstract LookAtLHToRef: eye: Vector3 * target: Vector3 * up: Vector3 * result: Matrix -> unit
        /// <summary>Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
        /// This function works in right handed mode</summary>
        /// <param name="eye">defines the final position of the entity</param>
        /// <param name="target">defines where the entity should look at</param>
        /// <param name="up">defines the up vector for the entity</param>
        abstract LookAtRH: eye: Vector3 * target: Vector3 * up: Vector3 -> Matrix
        /// <summary>Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
        /// This function works in right handed mode</summary>
        /// <param name="eye">defines the final position of the entity</param>
        /// <param name="target">defines where the entity should look at</param>
        /// <param name="up">defines the up vector for the entity</param>
        /// <param name="result">defines the target matrix</param>
        abstract LookAtRHToRef: eye: Vector3 * target: Vector3 * up: Vector3 * result: Matrix -> unit
        /// <summary>Create a left-handed orthographic projection matrix</summary>
        /// <param name="width">defines the viewport width</param>
        /// <param name="height">defines the viewport height</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract OrthoLH: width: float * height: float * znear: float * zfar: float -> Matrix
        /// <summary>Store a left-handed orthographic projection to a given matrix</summary>
        /// <param name="width">defines the viewport width</param>
        /// <param name="height">defines the viewport height</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        abstract OrthoLHToRef: width: float * height: float * znear: float * zfar: float * result: Matrix -> unit
        /// <summary>Create a left-handed orthographic projection matrix</summary>
        /// <param name="left">defines the viewport left coordinate</param>
        /// <param name="right">defines the viewport right coordinate</param>
        /// <param name="bottom">defines the viewport bottom coordinate</param>
        /// <param name="top">defines the viewport top coordinate</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract OrthoOffCenterLH: left: float * right: float * bottom: float * top: float * znear: float * zfar: float -> Matrix
        /// <summary>Stores a left-handed orthographic projection into a given matrix</summary>
        /// <param name="left">defines the viewport left coordinate</param>
        /// <param name="right">defines the viewport right coordinate</param>
        /// <param name="bottom">defines the viewport bottom coordinate</param>
        /// <param name="top">defines the viewport top coordinate</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        abstract OrthoOffCenterLHToRef: left: float * right: float * bottom: float * top: float * znear: float * zfar: float * result: Matrix -> unit
        /// <summary>Creates a right-handed orthographic projection matrix</summary>
        /// <param name="left">defines the viewport left coordinate</param>
        /// <param name="right">defines the viewport right coordinate</param>
        /// <param name="bottom">defines the viewport bottom coordinate</param>
        /// <param name="top">defines the viewport top coordinate</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract OrthoOffCenterRH: left: float * right: float * bottom: float * top: float * znear: float * zfar: float -> Matrix
        /// <summary>Stores a right-handed orthographic projection into a given matrix</summary>
        /// <param name="left">defines the viewport left coordinate</param>
        /// <param name="right">defines the viewport right coordinate</param>
        /// <param name="bottom">defines the viewport bottom coordinate</param>
        /// <param name="top">defines the viewport top coordinate</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        abstract OrthoOffCenterRHToRef: left: float * right: float * bottom: float * top: float * znear: float * zfar: float * result: Matrix -> unit
        /// <summary>Creates a left-handed perspective projection matrix</summary>
        /// <param name="width">defines the viewport width</param>
        /// <param name="height">defines the viewport height</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract PerspectiveLH: width: float * height: float * znear: float * zfar: float -> Matrix
        /// <summary>Creates a left-handed perspective projection matrix</summary>
        /// <param name="fov">defines the horizontal field of view</param>
        /// <param name="aspect">defines the aspect ratio</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract PerspectiveFovLH: fov: float * aspect: float * znear: float * zfar: float -> Matrix
        /// <summary>Stores a left-handed perspective projection into a given matrix</summary>
        /// <param name="fov">defines the horizontal field of view</param>
        /// <param name="aspect">defines the aspect ratio</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        /// <param name="isVerticalFovFixed">defines it the fov is vertically fixed (default) or horizontally</param>
        abstract PerspectiveFovLHToRef: fov: float * aspect: float * znear: float * zfar: float * result: Matrix * ?isVerticalFovFixed: bool -> unit
        /// <summary>Creates a right-handed perspective projection matrix</summary>
        /// <param name="fov">defines the horizontal field of view</param>
        /// <param name="aspect">defines the aspect ratio</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract PerspectiveFovRH: fov: float * aspect: float * znear: float * zfar: float -> Matrix
        /// <summary>Stores a right-handed perspective projection into a given matrix</summary>
        /// <param name="fov">defines the horizontal field of view</param>
        /// <param name="aspect">defines the aspect ratio</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        /// <param name="isVerticalFovFixed">defines it the fov is vertically fixed (default) or horizontally</param>
        abstract PerspectiveFovRHToRef: fov: float * aspect: float * znear: float * zfar: float * result: Matrix * ?isVerticalFovFixed: bool -> unit
        /// <summary>Stores a perspective projection for WebVR info a given matrix</summary>
        /// <param name="fov">defines the field of view</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        /// <param name="rightHanded">defines if the matrix must be in right-handed mode (false by default)</param>
        abstract PerspectiveFovWebVRToRef: fov: MatrixStaticPerspectiveFovWebVRToRefFov * znear: float * zfar: float * result: Matrix * ?rightHanded: bool -> unit
        /// <summary>Computes a complete transformation matrix</summary>
        /// <param name="viewport">defines the viewport to use</param>
        /// <param name="world">defines the world matrix</param>
        /// <param name="view">defines the view matrix</param>
        /// <param name="projection">defines the projection matrix</param>
        /// <param name="zmin">defines the near clip plane</param>
        /// <param name="zmax">defines the far clip plane</param>
        abstract GetFinalMatrix: viewport: Viewport * world: Matrix * view: Matrix * projection: Matrix * zmin: float * zmax: float -> Matrix
        /// <summary>Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array</summary>
        /// <param name="matrix">defines the matrix to use</param>
        abstract GetAsMatrix2x2: matrix: Matrix -> Float32Array
        /// <summary>Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array</summary>
        /// <param name="matrix">defines the matrix to use</param>
        abstract GetAsMatrix3x3: matrix: Matrix -> Float32Array
        /// <summary>Compute the transpose of a given matrix</summary>
        /// <param name="matrix">defines the matrix to transpose</param>
        abstract Transpose: matrix: Matrix -> Matrix
        /// <summary>Compute the transpose of a matrix and store it in a target matrix</summary>
        /// <param name="matrix">defines the matrix to transpose</param>
        /// <param name="result">defines the target matrix</param>
        abstract TransposeToRef: matrix: Matrix * result: Matrix -> unit
        /// <summary>Computes a reflection matrix from a plane</summary>
        /// <param name="plane">defines the reflection plane</param>
        abstract Reflection: plane: Plane -> Matrix
        /// <summary>Computes a reflection matrix from a plane</summary>
        /// <param name="plane">defines the reflection plane</param>
        /// <param name="result">defines the target matrix</param>
        abstract ReflectionToRef: plane: Plane * result: Matrix -> unit
        /// <summary>Sets the given matrix as a rotation matrix composed from the 3 left handed axes</summary>
        /// <param name="xaxis">defines the value of the 1st axis</param>
        /// <param name="yaxis">defines the value of the 2nd axis</param>
        /// <param name="zaxis">defines the value of the 3rd axis</param>
        /// <param name="result">defines the target matrix</param>
        abstract FromXYZAxesToRef: xaxis: Vector3 * yaxis: Vector3 * zaxis: Vector3 * result: Matrix -> unit
        /// <summary>Creates a rotation matrix from a quaternion and stores it in a target matrix</summary>
        /// <param name="quat">defines the quaternion to use</param>
        /// <param name="result">defines the target matrix</param>
        abstract FromQuaternionToRef: quat: Quaternion * result: Matrix -> unit

    type [<AllowNullLiteral>] MatrixStaticPerspectiveFovWebVRToRefFov =
        abstract upDegrees: float with get, set
        abstract downDegrees: float with get, set
        abstract leftDegrees: float with get, set
        abstract rightDegrees: float with get, set

    /// Represens a plane by the equation ax + by + cz + d = 0
    type [<AllowNullLiteral>] Plane =
        /// Normal of the plane (a,b,c)
        abstract normal: Vector3 with get, set
        /// d component of the plane
        abstract d: float with get, set
        abstract asArray: unit -> ResizeArray<float>
        abstract clone: unit -> Plane
        abstract getClassName: unit -> string
        abstract getHashCode: unit -> float
        /// Normalize the current Plane in place.
        abstract normalize: unit -> Plane
        /// <summary>Applies a transformation the plane and returns the result</summary>
        /// <param name="transformation">the transformation matrix to be applied to the plane</param>
        abstract transform: transformation: Matrix -> Plane
        /// <summary>Calcualtte the dot product between the point and the plane normal</summary>
        /// <param name="point">point to calculate the dot product with</param>
        abstract dotCoordinate: point: Vector3 -> float
        /// <summary>Updates the current Plane from the plane defined by the three given points.</summary>
        /// <param name="point1">one of the points used to contruct the plane</param>
        /// <param name="point2">one of the points used to contruct the plane</param>
        /// <param name="point3">one of the points used to contruct the plane</param>
        abstract copyFromPoints: point1: Vector3 * point2: Vector3 * point3: Vector3 -> Plane
        /// <summary>Checks if the plane is facing a given direction</summary>
        /// <param name="direction">the direction to check if the plane is facing</param>
        /// <param name="epsilon">value the dot product is compared against (returns true if dot <= epsilon)</param>
        abstract isFrontFacingTo: direction: Vector3 * epsilon: float -> bool
        /// <summary>Calculates the distance to a point</summary>
        /// <param name="point">point to calculate distance to</param>
        abstract signedDistanceTo: point: Vector3 -> float

    /// Represens a plane by the equation ax + by + cz + d = 0
    type [<AllowNullLiteral>] PlaneStatic =
        /// <summary>Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0</summary>
        /// <param name="a">a component of the plane</param>
        /// <param name="b">b component of the plane</param>
        /// <param name="c">c component of the plane</param>
        /// <param name="d">d component of the plane</param>
        [<Emit "new $0($1...)">] abstract Create: a: float * b: float * c: float * d: float -> Plane
        /// <summary>Creates a plane from an  array</summary>
        /// <param name="array">the array to create a plane from</param>
        abstract FromArray: array: ArrayLike<float> -> Plane
        /// <summary>Creates a plane from three points</summary>
        /// <param name="point1">point used to create the plane</param>
        /// <param name="point2">point used to create the plane</param>
        /// <param name="point3">point used to create the plane</param>
        abstract FromPoints: point1: Vector3 * point2: Vector3 * point3: Vector3 -> Plane
        /// <summary>Creates a plane from an origin point and a normal</summary>
        /// <param name="origin">origin of the plane to be constructed</param>
        /// <param name="normal">normal of the plane to be constructed</param>
        abstract FromPositionAndNormal: origin: Vector3 * normal: Vector3 -> Plane
        /// <summary>Calculates the distance from a plane and a point</summary>
        /// <param name="origin">origin of the plane to be constructed</param>
        /// <param name="normal">normal of the plane to be constructed</param>
        /// <param name="point">point to calculate distance to</param>
        abstract SignedDistanceToPlaneFromPositionAndNormal: origin: Vector3 * normal: Vector3 * point: Vector3 -> float

    /// Class used to represent a viewport on screen
    type [<AllowNullLiteral>] Viewport =
        /// viewport left coordinate 
        abstract x: float with get, set
        /// viewport top coordinate 
        abstract y: float with get, set
        /// viewport width 
        abstract width: float with get, set
        /// viewport height 
        abstract height: float with get, set
        /// <summary>Creates a new viewport using absolute sizing (from 0-> width, 0-> height instead of 0->1)</summary>
        /// <param name="renderWidthOrEngine">defines either an engine or the rendering width</param>
        /// <param name="renderHeight">defines the rendering height</param>
        abstract toGlobal: renderWidthOrEngine: U2<float, Engine> * renderHeight: float -> Viewport
        /// Returns a new Viewport copied from the current one
        abstract clone: unit -> Viewport

    /// Class used to represent a viewport on screen
    type [<AllowNullLiteral>] ViewportStatic =
        /// <summary>Creates a Viewport object located at (x, y) and sized (width, height)</summary>
        /// <param name="x">defines viewport left coordinate</param>
        /// <param name="y">defines viewport top coordinate</param>
        /// <param name="width">defines the viewport width</param>
        /// <param name="height">defines the viewport height</param>
        [<Emit "new $0($1...)">] abstract Create: x: float * y: float * width: float * height: float -> Viewport

    /// Reprasents a camera frustum
    type [<AllowNullLiteral>] Frustum =
        interface end

    /// Reprasents a camera frustum
    type [<AllowNullLiteral>] FrustumStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Frustum
        /// <summary>Gets the planes representing the frustum</summary>
        /// <param name="transform">matrix to be applied to the returned planes</param>
        abstract GetPlanes: transform: Matrix -> ResizeArray<Plane>
        /// <summary>Gets the near frustum plane transformed by the transform matrix</summary>
        /// <param name="transform">transformation matrix to be applied to the resulting frustum plane</param>
        /// <param name="frustumPlane">the resuling frustum plane</param>
        abstract GetNearPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        /// <summary>Gets the far frustum plane transformed by the transform matrix</summary>
        /// <param name="transform">transformation matrix to be applied to the resulting frustum plane</param>
        /// <param name="frustumPlane">the resuling frustum plane</param>
        abstract GetFarPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        /// <summary>Gets the left frustum plane transformed by the transform matrix</summary>
        /// <param name="transform">transformation matrix to be applied to the resulting frustum plane</param>
        /// <param name="frustumPlane">the resuling frustum plane</param>
        abstract GetLeftPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        /// <summary>Gets the right frustum plane transformed by the transform matrix</summary>
        /// <param name="transform">transformation matrix to be applied to the resulting frustum plane</param>
        /// <param name="frustumPlane">the resuling frustum plane</param>
        abstract GetRightPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        /// <summary>Gets the top frustum plane transformed by the transform matrix</summary>
        /// <param name="transform">transformation matrix to be applied to the resulting frustum plane</param>
        /// <param name="frustumPlane">the resuling frustum plane</param>
        abstract GetTopPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        /// <summary>Gets the bottom frustum plane transformed by the transform matrix</summary>
        /// <param name="transform">transformation matrix to be applied to the resulting frustum plane</param>
        /// <param name="frustumPlane">the resuling frustum plane</param>
        abstract GetBottomPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        /// <summary>Sets the given array "frustumPlanes" with the 6 Frustum planes computed by the given transformation matrix.</summary>
        /// <param name="transform">transformation matrix to be applied to the resulting frustum planes</param>
        /// <param name="frustumPlanes">the resuling frustum planes</param>
        abstract GetPlanesToRef: transform: Matrix * frustumPlanes: ResizeArray<Plane> -> unit

    type [<RequireQualifiedAccess>] Space =
        | LOCAL = 0
        | WORLD = 1
        | BONE = 2

    /// Defines the 3 main axes 
    type [<AllowNullLiteral>] Axis =
        interface end

    /// Defines the 3 main axes 
    type [<AllowNullLiteral>] AxisStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Axis
        /// X axis 
        abstract X: Vector3 with get, set
        /// Y axis 
        abstract Y: Vector3 with get, set
        /// Z axis 
        abstract Z: Vector3 with get, set

    /// Class used to represent a Bezier curve 
    type [<AllowNullLiteral>] BezierCurve =
        interface end

    /// Class used to represent a Bezier curve 
    type [<AllowNullLiteral>] BezierCurveStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> BezierCurve
        /// <summary>Returns the cubic Bezier interpolated value (float) at "t" (float) from the given x1, y1, x2, y2 floats</summary>
        /// <param name="t">defines the time</param>
        /// <param name="x1">defines the left coordinate on X axis</param>
        /// <param name="y1">defines the left coordinate on Y axis</param>
        /// <param name="x2">defines the right coordinate on X axis</param>
        /// <param name="y2">defines the right coordinate on Y axis</param>
        abstract Interpolate: t: float * x1: float * y1: float * x2: float * y2: float -> float

    type [<RequireQualifiedAccess>] Orientation =
        | CW = 0
        | CCW = 1

    /// Defines angle representation
    type [<AllowNullLiteral>] Angle =
        /// Get value in degrees
        abstract degrees: unit -> float
        /// Get value in radians
        abstract radians: unit -> float

    /// Defines angle representation
    type [<AllowNullLiteral>] AngleStatic =
        /// Creates an Angle object of "radians" radians (float).
        [<Emit "new $0($1...)">] abstract Create: radians: float -> Angle
        /// <summary>Gets a new Angle object valued with the angle value in radians between the two given vectors</summary>
        /// <param name="a">defines first vector</param>
        /// <param name="b">defines second vector</param>
        abstract BetweenTwoPoints: a: Vector2 * b: Vector2 -> Angle
        /// <summary>Gets a new Angle object from the given float in radians</summary>
        /// <param name="radians">defines the angle value in radians</param>
        abstract FromRadians: radians: float -> Angle
        /// <summary>Gets a new Angle object from the given float in degrees</summary>
        /// <param name="degrees">defines the angle value in degrees</param>
        abstract FromDegrees: degrees: float -> Angle

    /// This represents an arc in a 2d space.
    type [<AllowNullLiteral>] Arc2 =
        /// Defines the start point of the arc 
        abstract startPoint: Vector2 with get, set
        /// Defines the mid point of the arc 
        abstract midPoint: Vector2 with get, set
        /// Defines the end point of the arc 
        abstract endPoint: Vector2 with get, set
        /// Defines the center point of the arc.
        abstract centerPoint: Vector2 with get, set
        /// Defines the radius of the arc.
        abstract radius: float with get, set
        /// Defines the angle of the arc (from mid point to end point).
        abstract angle: Angle with get, set
        /// Defines the start angle of the arc (from start point to middle point).
        abstract startAngle: Angle with get, set
        /// Defines the orientation of the arc (clock wise/counter clock wise).
        abstract orientation: Orientation with get, set

    /// This represents an arc in a 2d space.
    type [<AllowNullLiteral>] Arc2Static =
        /// <summary>Creates an Arc object from the three given points : start, middle and end.</summary>
        /// <param name="startPoint">Defines the start point of the arc</param>
        /// <param name="midPoint">Defines the midlle point of the arc</param>
        /// <param name="endPoint">Defines the end point of the arc</param>
        [<Emit "new $0($1...)">] abstract Create: startPoint: Vector2 * midPoint: Vector2 * endPoint: Vector2 -> Arc2

    /// Represents a 2D path made up of multiple 2D points
    type [<AllowNullLiteral>] Path2 =
        /// If the path start and end point are the same
        abstract closed: bool with get, set
        /// <summary>Adds a new segment until the given coordinates (x, y) to the current Path2.</summary>
        /// <param name="x">the added points x value</param>
        /// <param name="y">the added points y value</param>
        abstract addLineTo: x: float * y: float -> Path2
        /// <summary>Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.</summary>
        /// <param name="midX">middle point x value</param>
        /// <param name="midY">middle point y value</param>
        /// <param name="endX">end point x value</param>
        /// <param name="endY">end point y value</param>
        /// <param name="numberOfSegments">(default: 36)</param>
        abstract addArcTo: midX: float * midY: float * endX: float * endY: float * ?numberOfSegments: float -> Path2
        /// Closes the Path2.
        abstract close: unit -> Path2
        /// Gets the sum of the distance between each sequential point in the path
        abstract length: unit -> float
        /// Gets the points which construct the path
        abstract getPoints: unit -> ResizeArray<Vector2>
        /// <summary>Retreives the point at the distance aways from the starting point</summary>
        /// <param name="normalizedLengthPosition">the length along the path to retreive the point from</param>
        abstract getPointAtLengthPosition: normalizedLengthPosition: float -> Vector2

    /// Represents a 2D path made up of multiple 2D points
    type [<AllowNullLiteral>] Path2Static =
        /// <summary>Creates a Path2 object from the starting 2D coordinates x and y.</summary>
        /// <param name="x">the starting points x value</param>
        /// <param name="y">the starting points y value</param>
        [<Emit "new $0($1...)">] abstract Create: x: float * y: float -> Path2
        /// <summary>Creates a new path starting from an x and y position</summary>
        /// <param name="x">starting x value</param>
        /// <param name="y">starting y value</param>
        abstract StartingAt: x: float * y: float -> Path2

    /// Represents a 3D path made up of multiple 3D points
    type [<AllowNullLiteral>] Path3D =
        /// an array of Vector3, the curve axis of the Path3D
        abstract path: ResizeArray<Vector3> with get, set
        /// Returns the Path3D array of successive Vector3 designing its curve.
        abstract getCurve: unit -> ResizeArray<Vector3>
        /// Returns an array populated with tangent vectors on each Path3D curve point.
        abstract getTangents: unit -> ResizeArray<Vector3>
        /// Returns an array populated with normal vectors on each Path3D curve point.
        abstract getNormals: unit -> ResizeArray<Vector3>
        /// Returns an array populated with binormal vectors on each Path3D curve point.
        abstract getBinormals: unit -> ResizeArray<Vector3>
        /// Returns an array populated with distances (float) of the i-th point from the first curve point.
        abstract getDistances: unit -> ResizeArray<float>
        /// <summary>Forces the Path3D tangent, normal, binormal and distance recomputation.</summary>
        /// <param name="path">path which all values are copied into the curves points</param>
        /// <param name="firstNormal">which should be projected onto the curve</param>
        abstract update: path: ResizeArray<Vector3> * ?firstNormal: Vector3 -> Path3D

    /// Represents a 3D path made up of multiple 3D points
    type [<AllowNullLiteral>] Path3DStatic =
        /// <summary>new Path3D(path, normal, raw)
        /// Creates a Path3D. A Path3D is a logical math object, so not a mesh.
        /// please read the description in the tutorial :  http://doc.babylonjs.com/tutorials/How_to_use_Path3D</summary>
        /// <param name="path">an array of Vector3, the curve axis of the Path3D</param>
        /// <param name="raw">(optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.</param>
        [<Emit "new $0($1...)">] abstract Create: path: ResizeArray<Vector3> * ?firstNormal: Vector3 * ?raw: bool -> Path3D

    /// A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
    /// A Curve3 is designed from a series of successive Vector3.
    type [<AllowNullLiteral>] Curve3 =
        abstract getPoints: unit -> ResizeArray<Vector3>
        abstract length: unit -> float
        /// <summary>Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);
        /// This new Curve3 is built by translating and sticking the curveB at the end of the curveA.
        /// curveA and curveB keep unchanged.</summary>
        /// <param name="curve">the curve to continue from this curve</param>
        abstract ``continue``: curve: Curve3 -> Curve3

    /// A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
    /// A Curve3 is designed from a series of successive Vector3.
    type [<AllowNullLiteral>] Curve3Static =
        /// <summary>Returns a Curve3 object along a Quadratic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#quadratic-bezier-curve</summary>
        /// <param name="v0">(Vector3) the origin point of the Quadratic Bezier</param>
        /// <param name="v1">(Vector3) the control point</param>
        /// <param name="v2">(Vector3) the end point of the Quadratic Bezier</param>
        /// <param name="nbPoints">(integer) the wanted number of points in the curve</param>
        abstract CreateQuadraticBezier: v0: Vector3 * v1: Vector3 * v2: Vector3 * nbPoints: float -> Curve3
        /// <summary>Returns a Curve3 object along a Cubic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#cubic-bezier-curve</summary>
        /// <param name="v0">(Vector3) the origin point of the Cubic Bezier</param>
        /// <param name="v1">(Vector3) the first control point</param>
        /// <param name="v2">(Vector3) the second control point</param>
        /// <param name="v3">(Vector3) the end point of the Cubic Bezier</param>
        /// <param name="nbPoints">(integer) the wanted number of points in the curve</param>
        abstract CreateCubicBezier: v0: Vector3 * v1: Vector3 * v2: Vector3 * v3: Vector3 * nbPoints: float -> Curve3
        /// <summary>Returns a Curve3 object along a Hermite Spline curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#hermite-spline</summary>
        /// <param name="p1">(Vector3) the origin point of the Hermite Spline</param>
        /// <param name="t1">(Vector3) the tangent vector at the origin point</param>
        /// <param name="p2">(Vector3) the end point of the Hermite Spline</param>
        /// <param name="t2">(Vector3) the tangent vector at the end point</param>
        /// <param name="nbPoints">(integer) the wanted number of points in the curve</param>
        abstract CreateHermiteSpline: p1: Vector3 * t1: Vector3 * p2: Vector3 * t2: Vector3 * nbPoints: float -> Curve3
        /// <summary>Returns a Curve3 object along a CatmullRom Spline curve :</summary>
        /// <param name="points">(array of Vector3) the points the spline must pass through. At least, four points required</param>
        /// <param name="nbPoints">(integer) the wanted number of points between each curve control points</param>
        /// <param name="closed">(boolean) optional with default false, when true forms a closed loop from the points</param>
        abstract CreateCatmullRomSpline: points: ResizeArray<Vector3> * nbPoints: float * ?closed: bool -> Curve3
        /// <summary>A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
        /// A Curve3 is designed from a series of successive Vector3.
        /// Tuto : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#curve3-object</summary>
        /// <param name="points">points which make up the curve</param>
        [<Emit "new $0($1...)">] abstract Create: points: ResizeArray<Vector3> -> Curve3

    /// Contains position and normal vectors for a vertex
    type [<AllowNullLiteral>] PositionNormalVertex =
        /// the position of the vertex (defaut: 0,0,0) 
        abstract position: Vector3 with get, set
        /// the normal of the vertex (defaut: 0,1,0) 
        abstract normal: Vector3 with get, set
        /// Clones the PositionNormalVertex
        abstract clone: unit -> PositionNormalVertex

    /// Contains position and normal vectors for a vertex
    type [<AllowNullLiteral>] PositionNormalVertexStatic =
        /// <summary>Creates a PositionNormalVertex</summary>
        /// <param name="position">the position of the vertex (defaut: 0,0,0)</param>
        /// <param name="normal">the normal of the vertex (defaut: 0,1,0)</param>
        [<Emit "new $0($1...)">] abstract Create: ?position: Vector3 * ?normal: Vector3 -> PositionNormalVertex

    /// Contains position, normal and uv vectors for a vertex
    type [<AllowNullLiteral>] PositionNormalTextureVertex =
        /// the position of the vertex (defaut: 0,0,0) 
        abstract position: Vector3 with get, set
        /// the normal of the vertex (defaut: 0,1,0) 
        abstract normal: Vector3 with get, set
        /// the uv of the vertex (default: 0,0) 
        abstract uv: Vector2 with get, set
        /// Clones the PositionNormalTextureVertex
        abstract clone: unit -> PositionNormalTextureVertex

    /// Contains position, normal and uv vectors for a vertex
    type [<AllowNullLiteral>] PositionNormalTextureVertexStatic =
        /// <summary>Creates a PositionNormalTextureVertex</summary>
        /// <param name="position">the position of the vertex (defaut: 0,0,0)</param>
        /// <param name="normal">the normal of the vertex (defaut: 0,1,0)</param>
        /// <param name="uv">the uv of the vertex (default: 0,0)</param>
        [<Emit "new $0($1...)">] abstract Create: ?position: Vector3 * ?normal: Vector3 * ?uv: Vector2 -> PositionNormalTextureVertex

    type [<AllowNullLiteral>] Tmp =
        interface end

    type [<AllowNullLiteral>] TmpStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Tmp
        abstract Color3: ResizeArray<Color3> with get, set
        abstract Color4: ResizeArray<Color4> with get, set
        abstract Vector2: ResizeArray<Vector2> with get, set
        abstract Vector3: ResizeArray<Vector3> with get, set
        abstract Vector4: ResizeArray<Vector4> with get, set
        abstract Quaternion: ResizeArray<Quaternion> with get, set
        abstract Matrix: ResizeArray<Matrix> with get, set

    /// Class representing spherical polynomial coefficients to the 3rd degree
    type [<AllowNullLiteral>] SphericalPolynomial =
        /// The x coefficients of the spherical polynomial
        abstract x: Vector3 with get, set
        /// The y coefficients of the spherical polynomial
        abstract y: Vector3 with get, set
        /// The z coefficients of the spherical polynomial
        abstract z: Vector3 with get, set
        /// The xx coefficients of the spherical polynomial
        abstract xx: Vector3 with get, set
        /// The yy coefficients of the spherical polynomial
        abstract yy: Vector3 with get, set
        /// The zz coefficients of the spherical polynomial
        abstract zz: Vector3 with get, set
        /// The xy coefficients of the spherical polynomial
        abstract xy: Vector3 with get, set
        /// The yz coefficients of the spherical polynomial
        abstract yz: Vector3 with get, set
        /// The zx coefficients of the spherical polynomial
        abstract zx: Vector3 with get, set
        /// <summary>Adds an ambient color to the spherical polynomial</summary>
        /// <param name="color">the color to add</param>
        abstract addAmbient: color: Color3 -> unit
        /// <summary>Scales the spherical polynomial by the given amount</summary>
        /// <param name="scale">the amount to scale</param>
        abstract scale: scale: float -> unit

    /// Class representing spherical polynomial coefficients to the 3rd degree
    type [<AllowNullLiteral>] SphericalPolynomialStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SphericalPolynomial
        /// <summary>Gets the spherical polynomial from harmonics</summary>
        /// <param name="harmonics">the spherical harmonics</param>
        abstract FromHarmonics: harmonics: SphericalHarmonics -> SphericalPolynomial
        /// <summary>Constructs a spherical polynomial from an array.</summary>
        /// <param name="data">defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)</param>
        abstract FromArray: data: ArrayLike<ArrayLike<float>> -> SphericalPolynomial

    /// Class representing spherical harmonics coefficients to the 3rd degree
    type [<AllowNullLiteral>] SphericalHarmonics =
        /// The l0,0 coefficients of the spherical harmonics
        abstract l00: Vector3 with get, set
        /// The l1,-1 coefficients of the spherical harmonics
        abstract l1_1: Vector3 with get, set
        /// The l1,0 coefficients of the spherical harmonics
        abstract l10: Vector3 with get, set
        /// The l1,1 coefficients of the spherical harmonics
        abstract l11: Vector3 with get, set
        /// The l2,-2 coefficients of the spherical harmonics
        abstract l2_2: Vector3 with get, set
        /// The l2,-1 coefficients of the spherical harmonics
        abstract l2_1: Vector3 with get, set
        /// The l2,0 coefficients of the spherical harmonics
        abstract l20: Vector3 with get, set
        /// The l2,1 coefficients of the spherical harmonics
        abstract l21: Vector3 with get, set
        /// The l2,2 coefficients of the spherical harmonics
        abstract lL22: Vector3 with get, set
        /// <summary>Adds a light to the spherical harmonics</summary>
        /// <param name="direction">the direction of the light</param>
        /// <param name="color">the color of the light</param>
        /// <param name="deltaSolidAngle">the delta solid angle of the light</param>
        abstract addLight: direction: Vector3 * color: Color3 * deltaSolidAngle: float -> unit
        /// <summary>Scales the spherical harmonics by the given amount</summary>
        /// <param name="scale">the amount to scale</param>
        abstract scale: scale: float -> unit
        /// Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.
        /// 
        /// ```
        /// E_lm = A_l * L_lm
        /// ```
        /// 
        /// In spherical harmonics this convolution amounts to scaling factors for each frequency band.
        /// This corresponds to equation 5 in "An Efficient Representation for Irradiance Environment Maps", where
        /// the scaling factors are given in equation 9.
        abstract convertIncidentRadianceToIrradiance: unit -> unit
        /// Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.
        /// 
        /// ```
        /// L = (1/pi) * E * rho
        /// ```
        /// 
        /// This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.
        abstract convertIrradianceToLambertianRadiance: unit -> unit

    /// Class representing spherical harmonics coefficients to the 3rd degree
    type [<AllowNullLiteral>] SphericalHarmonicsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SphericalHarmonics
        /// <summary>Gets the spherical harmonics from polynomial</summary>
        /// <param name="polynomial">the spherical polynomial</param>
        abstract FromPolynomial: polynomial: SphericalPolynomial -> SphericalHarmonics
        /// <summary>Constructs a spherical harmonics from an array.</summary>
        /// <param name="data">defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)</param>
        abstract FromArray: data: ArrayLike<ArrayLike<float>> -> SphericalHarmonics

    /// Class used to store all common mesh properties
    type [<AllowNullLiteral>] AbstractMesh =
        inherit TransformNode
        inherit IDisposable
        inherit ICullable
        inherit IGetSetVerticesData
        /// Gets ot sets the culling strategy to use to find visible meshes 
        abstract cullingStrategy: float with get, set
        /// Gets the number of facets in the mesh
        abstract facetNb: float
        /// Gets or set the number (integer) of subdivisions per axis in the partioning space
        abstract partitioningSubdivisions: float with get, set
        /// The ratio (float) to apply to the bouding box size to set to the partioning space.
        /// Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box
        abstract partitioningBBoxRatio: float with get, set
        /// Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.
        /// Works only for updatable meshes.
        /// Doesn't work with multi-materials
        abstract mustDepthSortFacets: bool with get, set
        /// The location (Vector3) where the facet depth sort must be computed from.
        /// By default, the active camera position.
        /// Used only when facet depth sort is enabled
        abstract facetDepthSortFrom: Vector3 with get, set
        /// gets a boolean indicating if facetData is enabled
        abstract isFacetDataEnabled: bool
        abstract _updateNonUniformScalingState: value: bool -> bool
        /// An event triggered when this mesh collides with another one
        abstract onCollideObservable: Observable<AbstractMesh> with get, set
        /// Set a function to call when this mesh collides with another one 
        abstract onCollide: (unit -> unit) with get, set
        /// An event triggered when the collision's position changes
        abstract onCollisionPositionChangeObservable: Observable<Vector3> with get, set
        /// Set a function to call when the collision's position changes 
        abstract onCollisionPositionChange: (unit -> unit) with get, set
        /// An event triggered when material is changed
        abstract onMaterialChangedObservable: Observable<AbstractMesh> with get, set
        /// Gets or sets the orientation for POV movement & rotation
        abstract definedFacingForward: bool with get, set
        abstract _occlusionQuery: Nullable<WebGLQuery> with get, set
        /// Gets or sets mesh visibility between 0 and 1 (default is 1)
        /// Gets or sets mesh visibility between 0 and 1 (default is 1)
        abstract visibility: float with get, set
        /// Gets or sets the alpha index used to sort transparent meshes
        abstract alphaIndex: float with get, set
        /// Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true
        abstract isVisible: bool with get, set
        /// Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true
        abstract isPickable: bool with get, set
        /// Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) 
        abstract showSubMeshesBoundingBox: bool with get, set
        /// Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)
        abstract isBlocker: bool with get, set
        /// Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)
        abstract enablePointerMoveEvents: bool with get, set
        /// Specifies the rendering group id for this mesh (0 by default)
        abstract renderingGroupId: float with get, set
        /// Gets or sets current material 
        abstract material: Nullable<Material> with get, set
        /// Gets or sets a boolean indicating that this mesh can receive realtime shadows
        abstract receiveShadows: bool with get, set
        /// Defines color to use when rendering outline 
        abstract outlineColor: Color3 with get, set
        /// Define width to use when rendering outline 
        abstract outlineWidth: float with get, set
        /// Defines color to use when rendering overlay 
        abstract overlayColor: Color3 with get, set
        /// Defines alpha to use when rendering overlay 
        abstract overlayAlpha: float with get, set
        /// Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values 
        abstract hasVertexAlpha: bool with get, set
        /// Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) 
        abstract useVertexColors: bool with get, set
        /// Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)
        abstract computeBonesUsingShaders: bool with get, set
        /// Gets or sets the number of allowed bone influences per vertex (4 by default) 
        abstract numBoneInfluencers: float with get, set
        /// Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) 
        abstract applyFog: bool with get, set
        /// Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) 
        abstract useOctreeForRenderingSelection: bool with get, set
        /// Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) 
        abstract useOctreeForPicking: bool with get, set
        /// Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) 
        abstract useOctreeForCollisions: bool with get, set
        /// Gets or sets the current layer mask (default is 0x0FFFFFFF)
        abstract layerMask: float with get, set
        /// True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)
        abstract alwaysSelectAsActiveMesh: bool with get, set
        /// Gets or sets the current action manager
        abstract actionManager: Nullable<ActionManager> with get, set
        /// Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))
        abstract ellipsoid: Vector3 with get, set
        /// Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))
        abstract ellipsoidOffset: Vector3 with get, set
        /// Gets or sets a collision mask used to mask collisions (default is -1).
        /// A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
        abstract collisionMask: float with get, set
        /// Gets or sets the current collision group mask (-1 by default).
        /// A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
        abstract collisionGroup: float with get, set
        /// Defines edge width used when edgesRenderer is enabled
        abstract edgesWidth: float with get, set
        /// Defines edge color used when edgesRenderer is enabled
        abstract edgesColor: Color4 with get, set
        abstract _edgesRenderer: Nullable<IEdgesRenderer> with get, set
        abstract _masterMesh: Nullable<AbstractMesh> with get, set
        abstract _boundingInfo: Nullable<BoundingInfo> with get, set
        abstract _renderId: float with get, set
        /// Gets or sets the list of subMeshes
        abstract subMeshes: ResizeArray<SubMesh> with get, set
        abstract _intersectionsInProgress: ResizeArray<AbstractMesh> with get, set
        abstract _unIndexed: bool with get, set
        abstract _lightSources: ResizeArray<Light> with get, set
        abstract _positions: Nullable<ResizeArray<Vector3>>
        abstract _waitingActions: obj option with get, set
        abstract _waitingFreezeWorldMatrix: Nullable<bool> with get, set
        abstract _bonesTransformMatrices: Nullable<Float32Array> with get, set
        /// Gets or sets a skeleton to apply skining transformations
        abstract skeleton: Nullable<Skeleton> with get, set
        /// An event triggered when the mesh is rebuilt.
        abstract onRebuildObservable: Observable<AbstractMesh> with get, set
        /// Returns the string "AbstractMesh"
        abstract getClassName: unit -> string
        /// <summary>Gets a string representation of the current mesh</summary>
        /// <param name="fullDetails">defines a boolean indicating if full details must be included</param>
        abstract toString: ?fullDetails: bool -> string
        abstract _rebuild: unit -> unit
        abstract _resyncLightSources: unit -> unit
        abstract _resyncLighSource: light: Light -> unit
        abstract _unBindEffect: unit -> unit
        abstract _removeLightSource: light: Light -> unit
        abstract _markSubMeshesAsLightDirty: unit -> unit
        abstract _markSubMeshesAsAttributesDirty: unit -> unit
        abstract _markSubMeshesAsMiscDirty: unit -> unit
        /// Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)
        abstract scaling: Vector3 with get, set
        /// Returns true if the mesh is blocked. Implemented by child classes
        abstract isBlocked: bool
        /// <summary>Returns the mesh itself by default. Implemented by child classes</summary>
        /// <param name="camera">defines the camera to use to pick the right LOD level</param>
        abstract getLOD: camera: Camera -> Nullable<AbstractMesh>
        /// Returns 0 by default. Implemented by child classes
        abstract getTotalVertices: unit -> float
        /// Returns null by default. Implemented by child classes
        abstract getIndices: unit -> Nullable<IndicesArray>
        /// <summary>Returns the array of the requested vertex data kind. Implemented by child classes</summary>
        /// <param name="kind">defines the vertex data kind to use</param>
        abstract getVerticesData: kind: string -> Nullable<FloatArray>
        /// <summary>Sets the vertex data of the mesh geometry for the requested `kind`.
        /// If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
        /// Note that a new underlying VertexBuffer object is created each call.
        /// If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.</summary>
        /// <param name="kind">defines vertex data kind:
        /// * BABYLON.VertexBuffer.PositionKind
        /// * BABYLON.VertexBuffer.UVKind
        /// * BABYLON.VertexBuffer.UV2Kind
        /// * BABYLON.VertexBuffer.UV3Kind
        /// * BABYLON.VertexBuffer.UV4Kind
        /// * BABYLON.VertexBuffer.UV5Kind
        /// * BABYLON.VertexBuffer.UV6Kind
        /// * BABYLON.VertexBuffer.ColorKind
        /// * BABYLON.VertexBuffer.MatricesIndicesKind
        /// * BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// * BABYLON.VertexBuffer.MatricesWeightsKind
        /// * BABYLON.VertexBuffer.MatricesWeightsExtraKind</param>
        /// <param name="data">defines the data source</param>
        /// <param name="updatable">defines if the data must be flagged as updatable (or static)</param>
        /// <param name="stride">defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind</param>
        abstract setVerticesData: kind: string * data: FloatArray * ?updatable: bool * ?stride: float -> AbstractMesh
        /// <summary>Updates the existing vertex data of the mesh geometry for the requested `kind`.
        /// If the mesh has no geometry, it is simply returned as it is.</summary>
        /// <param name="kind">defines vertex data kind:
        /// * BABYLON.VertexBuffer.PositionKind
        /// * BABYLON.VertexBuffer.UVKind
        /// * BABYLON.VertexBuffer.UV2Kind
        /// * BABYLON.VertexBuffer.UV3Kind
        /// * BABYLON.VertexBuffer.UV4Kind
        /// * BABYLON.VertexBuffer.UV5Kind
        /// * BABYLON.VertexBuffer.UV6Kind
        /// * BABYLON.VertexBuffer.ColorKind
        /// * BABYLON.VertexBuffer.MatricesIndicesKind
        /// * BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// * BABYLON.VertexBuffer.MatricesWeightsKind
        /// * BABYLON.VertexBuffer.MatricesWeightsExtraKind</param>
        /// <param name="data">defines the data source</param>
        /// <param name="updateExtends">If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed</param>
        /// <param name="makeItUnique">If true, a new global geometry is created from this data and is set to the mesh</param>
        abstract updateVerticesData: kind: string * data: FloatArray * ?updateExtends: bool * ?makeItUnique: bool -> AbstractMesh
        /// <summary>Sets the mesh indices,
        /// If the mesh has no geometry, a new Geometry object is created and set to the mesh.</summary>
        /// <param name="indices">Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)</param>
        /// <param name="totalVertices">Defines the total number of vertices</param>
        abstract setIndices: indices: IndicesArray * totalVertices: Nullable<float> -> AbstractMesh
        /// <summary>Gets a boolean indicating if specific vertex data is present</summary>
        /// <param name="kind">defines the vertex data kind to use</param>
        abstract isVerticesDataPresent: kind: string -> bool
        /// Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined
        abstract getBoundingInfo: unit -> BoundingInfo
        /// <summary>Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)</summary>
        /// <param name="includeDescendants">Use the hierarchy's bounding box instead of the mesh's bounding box</param>
        abstract normalizeToUnitCube: ?includeDescendants: bool -> AbstractMesh
        /// <summary>Overwrite the current bounding info</summary>
        /// <param name="boundingInfo">defines the new bounding info</param>
        abstract setBoundingInfo: boundingInfo: BoundingInfo -> AbstractMesh
        /// Gets a boolean indicating if this mesh has skinning data and an attached skeleton 
        abstract useBones: bool
        abstract _preActivate: unit -> unit
        abstract _preActivateForIntermediateRendering: renderId: float -> unit
        abstract _activate: renderId: float -> unit
        /// Gets the current world matrix
        abstract getWorldMatrix: unit -> Matrix
        abstract _getWorldMatrixDeterminant: unit -> float
        /// <summary>Perform relative position change from the point of view of behind the front of the mesh.
        /// This is performed taking into account the meshes current rotation, so you do not have to care.
        /// Supports definition of mesh facing forward or backward</summary>
        /// <param name="amountRight">defines the distance on the right axis</param>
        /// <param name="amountUp">defines the distance on the up axis</param>
        /// <param name="amountForward">defines the distance on the forward axis</param>
        abstract movePOV: amountRight: float * amountUp: float * amountForward: float -> AbstractMesh
        /// <summary>Calculate relative position change from the point of view of behind the front of the mesh.
        /// This is performed taking into account the meshes current rotation, so you do not have to care.
        /// Supports definition of mesh facing forward or backward</summary>
        /// <param name="amountRight">defines the distance on the right axis</param>
        /// <param name="amountUp">defines the distance on the up axis</param>
        /// <param name="amountForward">defines the distance on the forward axis</param>
        abstract calcMovePOV: amountRight: float * amountUp: float * amountForward: float -> Vector3
        /// <summary>Perform relative rotation change from the point of view of behind the front of the mesh.
        /// Supports definition of mesh facing forward or backward</summary>
        /// <param name="flipBack">defines the flip</param>
        /// <param name="twirlClockwise">defines the twirl</param>
        /// <param name="tiltRight">defines the tilt</param>
        abstract rotatePOV: flipBack: float * twirlClockwise: float * tiltRight: float -> AbstractMesh
        /// <summary>Calculate relative rotation change from the point of view of behind the front of the mesh.
        /// Supports definition of mesh facing forward or backward.</summary>
        /// <param name="flipBack">defines the flip</param>
        /// <param name="twirlClockwise">defines the twirl</param>
        /// <param name="tiltRight">defines the tilt</param>
        abstract calcRotatePOV: flipBack: float * twirlClockwise: float * tiltRight: float -> Vector3
        /// <summary>Return the minimum and maximum world vectors of the entire hierarchy under current mesh</summary>
        /// <param name="includeDescendants">Include bounding info from descendants as well (true by default)</param>
        /// <param name="predicate">defines a callback function that can be customize to filter what meshes should be included in the list used to compute the bounding vectors</param>
        abstract getHierarchyBoundingVectors: ?includeDescendants: bool * ?predicate: (AbstractMesh -> bool) -> AbstractMeshGetHierarchyBoundingVectorsReturn
        abstract _updateBoundingInfo: unit -> AbstractMesh
        abstract _updateSubMeshesBoundingInfo: matrix: Matrix -> AbstractMesh
        abstract _afterComputeWorldMatrix: unit -> unit
        /// <summary>Returns `true` if the mesh is within the frustum defined by the passed array of planes.
        /// A mesh is in the frustum if its bounding box intersects the frustum</summary>
        /// <param name="frustumPlanes">defines the frustum to test</param>
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// <summary>Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.
        /// A mesh is completely in the frustum if its bounding box it completely inside the frustum.</summary>
        /// <param name="frustumPlanes">defines the frustum to test</param>
        abstract isCompletelyInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// <summary>True if the mesh intersects another mesh or a SolidParticle object</summary>
        /// <param name="mesh">defines a target mesh or SolidParticle to test</param>
        /// <param name="precise">Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)</param>
        /// <param name="includeDescendants">Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes</param>
        abstract intersectsMesh: mesh: U2<AbstractMesh, SolidParticle> * ?precise: bool * ?includeDescendants: bool -> bool
        /// <summary>Returns true if the passed point (Vector3) is inside the mesh bounding box</summary>
        /// <param name="point">defines the point to test</param>
        abstract intersectsPoint: point: Vector3 -> bool
        /// <summary>Gets the position of the current mesh in camera space</summary>
        /// <param name="camera">defines the camera to use</param>
        abstract getPositionInCameraSpace: ?camera: Camera -> Vector3
        /// <summary>Returns the distance from the mesh to the active camera</summary>
        /// <param name="camera">defines the camera to use</param>
        abstract getDistanceToCamera: ?camera: Camera -> float
        /// Gets or sets a boolean indicating that this mesh can be used in the collision engine
        abstract checkCollisions: bool with get, set
        /// Gets Collider object used to compute collisions (not physics)
        abstract collider: Collider
        /// <summary>Move the mesh using collision engine</summary>
        /// <param name="displacement">defines the requested displacement vector</param>
        abstract moveWithCollisions: displacement: Vector3 -> AbstractMesh
        abstract _collideForSubMesh: subMesh: SubMesh * transformMatrix: Matrix * collider: Collider -> AbstractMesh
        abstract _processCollisionsForSubMeshes: collider: Collider * transformMatrix: Matrix -> AbstractMesh
        abstract _checkCollision: collider: Collider -> AbstractMesh
        abstract _generatePointsArray: unit -> bool
        /// <summary>Checks if the passed Ray intersects with the mesh</summary>
        /// <param name="ray">defines the ray to use</param>
        /// <param name="fastCheck">defines if fast mode (but less precise) must be used (false by default)</param>
        abstract intersects: ray: Ray * ?fastCheck: bool -> PickingInfo
        /// <summary>Clones the current mesh</summary>
        /// <param name="name">defines the mesh name</param>
        /// <param name="newParent">defines the new mesh parent</param>
        /// <param name="doNotCloneChildren">defines a boolean indicating that children must not be cloned (false by default)</param>
        abstract clone: name: string * newParent: Node * ?doNotCloneChildren: bool -> Nullable<AbstractMesh>
        /// Disposes all the submeshes of the current meshnp
        abstract releaseSubMeshes: unit -> AbstractMesh
        /// <summary>Releases resources associated with this abstract mesh.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit
        /// <summary>Adds the passed mesh as a child to the current mesh</summary>
        /// <param name="mesh">defines the child mesh</param>
        abstract addChild: mesh: AbstractMesh -> AbstractMesh
        /// <summary>Removes the passed mesh from the current mesh children list</summary>
        /// <param name="mesh">defines the child mesh</param>
        abstract removeChild: mesh: AbstractMesh -> AbstractMesh
        /// Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.
        /// This method can be called within the render loop.
        /// You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation
        abstract updateFacetData: unit -> AbstractMesh
        /// Returns the facetLocalNormals array.
        /// The normals are expressed in the mesh local spac
        abstract getFacetLocalNormals: unit -> ResizeArray<Vector3>
        /// Returns the facetLocalPositions array.
        /// The facet positions are expressed in the mesh local space
        abstract getFacetLocalPositions: unit -> ResizeArray<Vector3>
        /// Returns the facetLocalPartioning array
        abstract getFacetLocalPartitioning: unit -> ResizeArray<ResizeArray<float>>
        /// <summary>Returns the i-th facet position in the world system.
        /// This method allocates a new Vector3 per call</summary>
        /// <param name="i">defines the facet index</param>
        abstract getFacetPosition: i: float -> Vector3
        /// <summary>Sets the reference Vector3 with the i-th facet position in the world system</summary>
        /// <param name="i">defines the facet index</param>
        /// <param name="ref">defines the target vector</param>
        abstract getFacetPositionToRef: i: float * ref: Vector3 -> AbstractMesh
        /// <summary>Returns the i-th facet normal in the world system.
        /// This method allocates a new Vector3 per call</summary>
        /// <param name="i">defines the facet index</param>
        abstract getFacetNormal: i: float -> Vector3
        /// <summary>Sets the reference Vector3 with the i-th facet normal in the world system</summary>
        /// <param name="i">defines the facet index</param>
        /// <param name="ref">defines the target vector</param>
        abstract getFacetNormalToRef: i: float * ref: Vector3 -> AbstractMesh
        /// <summary>Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)</summary>
        /// <param name="x">defines x coordinate</param>
        /// <param name="y">defines y coordinate</param>
        /// <param name="z">defines z coordinate</param>
        abstract getFacetsAtLocalCoordinates: x: float * y: float * z: float -> Nullable<ResizeArray<float>>
        /// <summary>Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found</summary>
        /// <param name="x">defines x coordinate</param>
        /// <param name="y">defines y coordinate</param>
        /// <param name="z">defines z coordinate</param>
        /// <param name="projected">sets as the (x,y,z) world projection on the facet</param>
        /// <param name="checkFace">if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned</param>
        /// <param name="facing">if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position</param>
        abstract getClosestFacetAtCoordinates: x: float * y: float * z: float * ?projected: Vector3 * ?checkFace: bool * ?facing: bool -> Nullable<float>
        /// <summary>Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found</summary>
        /// <param name="x">defines x coordinate</param>
        /// <param name="y">defines y coordinate</param>
        /// <param name="z">defines z coordinate</param>
        /// <param name="projected">sets as the (x,y,z) local projection on the facet</param>
        /// <param name="checkFace">if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned</param>
        /// <param name="facing">if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position</param>
        abstract getClosestFacetAtLocalCoordinates: x: float * y: float * z: float * ?projected: Vector3 * ?checkFace: bool * ?facing: bool -> Nullable<float>
        /// Returns the object "parameter" set with all the expected parameters for facetData computation by ComputeNormals()
        abstract getFacetDataParameters: unit -> obj option
        /// Disables the feature FacetData and frees the related memory
        abstract disableFacetData: unit -> AbstractMesh
        /// <summary>Updates the AbstractMesh indices array</summary>
        /// <param name="indices">defines the data source</param>
        abstract updateIndices: indices: IndicesArray -> AbstractMesh
        /// <summary>Creates new normals data for the mesh</summary>
        /// <param name="updatable">defines if the normal vertex buffer must be flagged as updatable</param>
        abstract createNormals: updatable: bool -> AbstractMesh
        /// <summary>Align the mesh with a normal</summary>
        /// <param name="normal">defines the normal to use</param>
        /// <param name="upDirection">can be used to redefined the up vector to use (will use the (0, 1, 0) by default)</param>
        abstract alignWithNormal: normal: Vector3 * ?upDirection: Vector3 -> AbstractMesh
        abstract _checkOcclusionQuery: unit -> bool
        abstract _physicsImpostor: Nullable<PhysicsImpostor> with get, set
        /// Gets or sets impostor used for physic simulation
        abstract physicsImpostor: Nullable<PhysicsImpostor> with get, set
        /// Gets the current physics impostor
        abstract getPhysicsImpostor: unit -> Nullable<PhysicsImpostor>
        /// <summary>Apply a physic impulse to the mesh</summary>
        /// <param name="force">defines the force to apply</param>
        /// <param name="contactPoint">defines where to apply the force</param>
        abstract applyImpulse: force: Vector3 * contactPoint: Vector3 -> AbstractMesh
        /// <summary>Creates a physic joint between two meshes</summary>
        /// <param name="otherMesh">defines the other mesh to use</param>
        /// <param name="pivot1">defines the pivot to use on this mesh</param>
        /// <param name="pivot2">defines the pivot to use on the other mesh</param>
        /// <param name="options">defines additional options (can be plugin dependent)</param>
        abstract setPhysicsLinkWith: otherMesh: Mesh * pivot1: Vector3 * pivot2: Vector3 * ?options: obj -> AbstractMesh
        abstract _disposePhysicsObserver: Nullable<Observer<Node>> with get, set
        abstract _showBoundingBox: bool with get, set
        /// Gets or sets a boolean indicating if the bounding box must be rendered as well (false by default)
        abstract showBoundingBox: bool with get, set
        /// Disables the mesh edge rendering mode
        abstract disableEdgesRendering: unit -> AbstractMesh
        /// <summary>Enables the edge rendering mode on the mesh.
        /// This mode makes the mesh edges visible</summary>
        /// <param name="epsilon">defines the maximal distance between two angles to detect a face</param>
        /// <param name="checkVerticesInsteadOfIndices">indicates that we should check vertex list directly instead of faces</param>
        abstract enableEdgesRendering: ?epsilon: float * ?checkVerticesInsteadOfIndices: bool -> AbstractMesh
        /// Gets the edgesRenderer associated with the mesh
        abstract edgesRenderer: Nullable<EdgesRenderer> with get, set
        abstract _renderOutline: bool with get, set
        /// Gets or sets a boolean indicating if the outline must be rendered as well
        abstract renderOutline: bool with get, set
        abstract _renderOverlay: bool with get, set
        /// Gets or sets a boolean indicating if the overlay must be rendered as well
        abstract renderOverlay: bool with get, set
        /// Backing filed
        abstract __occlusionDataStorage: _OcclusionDataStorage with get, set
        /// Access property
        abstract _occlusionDataStorage: _OcclusionDataStorage with get, set
        /// This number indicates the number of allowed retries before stop the occlusion query, this is useful if the occlusion query is taking long time before to the query result is retireved, the query result indicates if the object is visible within the scene or not and based on that Babylon.Js engine decideds to show or hide the object.
        /// The default value is -1 which means don't break the query and wait till the result
        abstract occlusionRetryCount: float with get, set
        /// This property is responsible for starting the occlusion query within the Mesh or not, this property is also used to determine what should happen when the occlusionRetryCount is reached. It has supports 3 values:
        /// * OCCLUSION_TYPE_NONE (Default Value): this option means no occlusion query whith the Mesh.
        /// * OCCLUSION_TYPE_OPTIMISTIC: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken show the mesh.
        /// * OCCLUSION_TYPE_STRICT: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken restore the last state of the mesh occlusion if the mesh was visible then show the mesh if was hidden then hide don't show.
        abstract occlusionType: float with get, set
        /// This property determines the type of occlusion query algorithm to run in WebGl, you can use:
        /// * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE which is mapped to GL_ANY_SAMPLES_PASSED.
        /// * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE (Default Value) which is mapped to GL_ANY_SAMPLES_PASSED_CONSERVATIVE which is a false positive algorithm that is faster than GL_ANY_SAMPLES_PASSED but less accurate.
        abstract occlusionQueryAlgorithmType: float with get, set
        /// Gets or sets whether the mesh is occluded or not, it is used also to set the intial state of the mesh to be occluded or not
        abstract isOccluded: bool with get, set
        /// Flag to check the progress status of the query
        abstract isOcclusionQueryInProgress: bool with get, set
        abstract _submeshesOctree: Octree<SubMesh> with get, set
        /// <summary>This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.
        /// Please note that you must have a decent number of submeshes to get performance improvements when using an octree</summary>
        /// <param name="maxCapacity">defines the maximum size of each block (64 by default)</param>
        /// <param name="maxDepth">defines the maximum depth to use (no more than 2 levels by default)</param>
        abstract createOrUpdateSubmeshesOctree: ?maxCapacity: float * ?maxDepth: float -> Octree<SubMesh>

    type [<AllowNullLiteral>] AbstractMeshGetHierarchyBoundingVectorsReturn =
        abstract min: Vector3 with get, set
        abstract max: Vector3 with get, set

    /// Class used to store all common mesh properties
    type [<AllowNullLiteral>] AbstractMeshStatic =
        /// No occlusion 
        abstract OCCLUSION_TYPE_NONE: float with get, set
        /// Occlusion set to optimisitic 
        abstract OCCLUSION_TYPE_OPTIMISTIC: float with get, set
        /// Occlusion set to strict 
        abstract OCCLUSION_TYPE_STRICT: float with get, set
        /// Use an accurante occlusion algorithm 
        abstract OCCLUSION_ALGORITHM_TYPE_ACCURATE: float with get, set
        /// Use a conservative occlusion algorithm 
        abstract OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE: float with get, set
        /// Default culling strategy with bounding box and bounding sphere and then frustum culling 
        abstract CULLINGSTRATEGY_STANDARD: float
        /// Culling strategy with bounding sphere only and then frustum culling 
        abstract CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY: float
        /// No billboard
        abstract BILLBOARDMODE_NONE: float
        /// Billboard on X axis 
        abstract BILLBOARDMODE_X: float
        /// Billboard on Y axis 
        abstract BILLBOARDMODE_Y: float
        /// Billboard on Z axis 
        abstract BILLBOARDMODE_Z: float
        /// Billboard on all axes 
        abstract BILLBOARDMODE_ALL: float
        /// <summary>Creates a new AbstractMesh</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Scene -> AbstractMesh

    /// Class used to store data that will be store in GPU memory
    type [<AllowNullLiteral>] Buffer =
        abstract _data: Nullable<DataArray> with get, set
        /// Gets the byte stride.
        abstract byteStride: float
        /// <summary>Create a new VertexBuffer based on the current buffer</summary>
        /// <param name="kind">defines the vertex buffer kind (position, normal, etc.)</param>
        /// <param name="offset">defines offset in the buffer (0 by default)</param>
        /// <param name="size">defines the size in floats of attributes (position is 3 for instance)</param>
        /// <param name="stride">defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)</param>
        /// <param name="instanced">defines if the vertex buffer contains indexed data</param>
        /// <param name="useBytes">defines if the offset and stride are in bytes</param>
        abstract createVertexBuffer: kind: string * offset: float * size: float * ?stride: float * ?instanced: bool * ?useBytes: bool -> VertexBuffer
        /// Gets a boolean indicating if the Buffer is updatable?
        abstract isUpdatable: unit -> bool
        /// Gets current buffer's data
        abstract getData: unit -> Nullable<DataArray>
        /// Gets underlying native buffer
        abstract getBuffer: unit -> Nullable<WebGLBuffer>
        /// Gets the stride in float32 units (i.e. byte stride / 4).
        /// May not be an integer if the byte stride is not divisible by 4.
        /// DEPRECATED. Use byteStride instead.
        abstract getStrideSize: unit -> float
        /// <summary>Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property</summary>
        /// <param name="data">defines the data to store</param>
        abstract create: ?data: DataArray -> unit
        abstract _rebuild: unit -> unit
        /// <summary>Update current buffer data</summary>
        /// <param name="data">defines the data to store</param>
        abstract update: data: DataArray -> unit
        /// <summary>Updates the data directly.</summary>
        /// <param name="data">the new data</param>
        /// <param name="offset">the new offset</param>
        /// <param name="vertexCount">the vertex count (optional)</param>
        /// <param name="useBytes">set to true if the offset is in bytes</param>
        abstract updateDirectly: data: DataArray * offset: float * ?vertexCount: float * ?useBytes: bool -> unit
        /// Release all resources
        abstract dispose: unit -> unit

    /// Class used to store data that will be store in GPU memory
    type [<AllowNullLiteral>] BufferStatic =
        /// <summary>Constructor</summary>
        /// <param name="engine">the engine</param>
        /// <param name="data">the data to use for this buffer</param>
        /// <param name="updatable">whether the data is updatable</param>
        /// <param name="stride">the stride (optional)</param>
        /// <param name="postponeInternalCreation">whether to postpone creating the internal WebGL buffer (optional)</param>
        /// <param name="instanced">whether the buffer is instanced (optional)</param>
        /// <param name="useBytes">set to true if the stride in in bytes (optional)</param>
        [<Emit "new $0($1...)">] abstract Create: engine: obj option * data: DataArray * updatable: bool * ?stride: float * ?postponeInternalCreation: bool * ?instanced: bool * ?useBytes: bool -> Buffer

    /// Class for building Constructive Solid Geometry
    type [<AllowNullLiteral>] CSG =
        /// The world matrix
        abstract matrix: Matrix with get, set
        /// Stores the position
        abstract position: Vector3 with get, set
        /// Stores the rotation
        abstract rotation: Vector3 with get, set
        /// Stores the rotation quaternion
        abstract rotationQuaternion: Nullable<Quaternion> with get, set
        /// Stores the scaling vector
        abstract scaling: Vector3 with get, set
        /// Clones, or makes a deep copy, of the BABYLON.CSG
        abstract clone: unit -> CSG
        /// <summary>Unions this CSG with another CSG</summary>
        /// <param name="csg">The CSG to union against this CSG</param>
        abstract union: csg: CSG -> CSG
        /// <summary>Unions this CSG with another CSG in place</summary>
        /// <param name="csg">The CSG to union against this CSG</param>
        abstract unionInPlace: csg: CSG -> unit
        /// <summary>Subtracts this CSG with another CSG</summary>
        /// <param name="csg">The CSG to subtract against this CSG</param>
        abstract subtract: csg: CSG -> CSG
        /// <summary>Subtracts this CSG with another CSG in place</summary>
        /// <param name="csg">The CSG to subtact against this CSG</param>
        abstract subtractInPlace: csg: CSG -> unit
        /// <summary>Intersect this CSG with another CSG</summary>
        /// <param name="csg">The CSG to intersect against this CSG</param>
        abstract intersect: csg: CSG -> CSG
        /// <summary>Intersects this CSG with another CSG in place</summary>
        /// <param name="csg">The CSG to intersect against this CSG</param>
        abstract intersectInPlace: csg: CSG -> unit
        /// Return a new BABYLON.CSG solid with solid and empty space switched. This solid is
        /// not modified.
        abstract inverse: unit -> CSG
        /// Inverses the BABYLON.CSG in place
        abstract inverseInPlace: unit -> unit
        /// <summary>This is used to keep meshes transformations so they can be restored
        /// when we build back a Babylon Mesh
        /// NB : All CSG operations are performed in world coordinates</summary>
        /// <param name="csg">The BABYLON.CSG to copy the transform attributes from</param>
        abstract copyTransformAttributes: csg: CSG -> CSG
        /// <summary>Build Raw mesh from CSG
        /// Coordinates here are in world space</summary>
        /// <param name="name">The name of the mesh geometry</param>
        /// <param name="scene">The BABYLON.Scene</param>
        /// <param name="keepSubMeshes">Specifies if the submeshes should be kept</param>
        abstract buildMeshGeometry: name: string * scene: Scene * keepSubMeshes: bool -> Mesh
        /// <summary>Build Mesh from CSG taking material and transforms into account</summary>
        /// <param name="name">The name of the BABYLON.Mesh</param>
        /// <param name="material">The material of the BABYLON.Mesh</param>
        /// <param name="scene">The BABYLON.Scene</param>
        /// <param name="keepSubMeshes">Specifies if submeshes should be kept</param>
        abstract toMesh: name: string * material: Nullable<Material> * scene: Scene * keepSubMeshes: bool -> Mesh

    /// Class for building Constructive Solid Geometry
    type [<AllowNullLiteral>] CSGStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CSG
        /// <summary>Convert the BABYLON.Mesh to BABYLON.CSG</summary>
        /// <param name="mesh">The BABYLON.Mesh to convert to BABYLON.CSG</param>
        abstract FromMesh: mesh: Mesh -> CSG

    /// Class used to store geometry data (vertex buffers + index buffer)
    type [<AllowNullLiteral>] Geometry =
        inherit IGetSetVerticesData
        /// Gets or sets the unique ID of the geometry
        abstract id: string with get, set
        /// Gets the delay loading state of the geometry (none by default which means not delayed)
        abstract delayLoadState: float with get, set
        /// Gets the file containing the data to load when running in delay load state
        abstract delayLoadingFile: Nullable<string> with get, set
        /// Callback called when the geometry is updated
        abstract onGeometryUpdated: (Geometry -> string -> unit) with get, set
        abstract _indices: IndicesArray with get, set
        abstract _vertexBuffers: TypeLiteral_24 with get, set
        abstract _delayInfo: Array<string> with get, set
        abstract _boundingInfo: Nullable<BoundingInfo> with get, set
        abstract _delayLoadingFunction: Nullable<(obj option -> Geometry -> unit)> with get, set
        abstract _softwareSkinningFrameId: float with get, set
        abstract _positions: Nullable<ResizeArray<Vector3>> with get, set
        /// Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
        /// Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
        abstract boundingBias: Vector2 with get, set
        /// Gets the current extend of the geometry
        abstract extend: TypeLiteral_25
        /// Gets the hosting scene
        abstract getScene: unit -> Scene
        /// Gets the hosting engine
        abstract getEngine: unit -> Engine
        /// Defines if the geometry is ready to use
        abstract isReady: unit -> bool
        /// Gets a value indicating that the geometry should not be serialized
        abstract doNotSerialize: bool
        abstract _rebuild: unit -> unit
        /// <summary>Affects all geometry data in one call</summary>
        /// <param name="vertexData">defines the geometry data</param>
        /// <param name="updatable">defines if the geometry must be flagged as updatable (false as default)</param>
        abstract setAllVerticesData: vertexData: VertexData * ?updatable: bool -> unit
        /// <summary>Set specific vertex data</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        /// <param name="data">defines the vertex data to use</param>
        /// <param name="updatable">defines if the vertex must be flagged as updatable (false as default)</param>
        /// <param name="stride">defines the stride to use (0 by default). This value is deduced from the kind value if not specified</param>
        abstract setVerticesData: kind: string * data: FloatArray * ?updatable: bool * ?stride: float -> unit
        /// <summary>Removes a specific vertex data</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        abstract removeVerticesData: kind: string -> unit
        /// <summary>Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data</summary>
        /// <param name="buffer">defines the vertex buffer to use</param>
        /// <param name="totalVertices">defines the total number of vertices for position kind (could be null)</param>
        abstract setVerticesBuffer: buffer: VertexBuffer * ?totalVertices: float -> unit
        /// <summary>Update a specific vertex buffer
        /// This function will directly update the underlying WebGLBuffer according to the passed numeric array or Float32Array
        /// It will do nothing if the buffer is not updatable</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        /// <param name="data">defines the data to use</param>
        /// <param name="offset">defines the offset in the target buffer where to store the data</param>
        /// <param name="useBytes">set to true if the offset is in bytes</param>
        abstract updateVerticesDataDirectly: kind: string * data: DataArray * offset: float * ?useBytes: bool -> unit
        /// <summary>Update a specific vertex buffer
        /// This function will create a new buffer if the current one is not updatable</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        /// <param name="data">defines the data to use</param>
        /// <param name="updateExtends">defines if the geometry extends must be recomputed (false by default)</param>
        abstract updateVerticesData: kind: string * data: FloatArray * ?updateExtends: bool -> unit
        abstract _bind: effect: Nullable<Effect> * ?indexToBind: WebGLBuffer -> unit
        /// Gets total number of vertices
        abstract getTotalVertices: unit -> float
        /// <summary>Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        /// <param name="copyWhenShared">defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes</param>
        /// <param name="forceCopy">defines a boolean indicating that the returned array must be cloned upon returning it</param>
        abstract getVerticesData: kind: string * ?copyWhenShared: bool * ?forceCopy: bool -> Nullable<FloatArray>
        /// <summary>Returns a boolean defining if the vertex data for the requested `kind` is updatable</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        abstract isVertexBufferUpdatable: kind: string -> bool
        /// <summary>Gets a specific vertex buffer</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        abstract getVertexBuffer: kind: string -> Nullable<VertexBuffer>
        /// Returns all vertex buffers
        abstract getVertexBuffers: unit -> Nullable<TypeLiteral_24>
        /// <summary>Gets a boolean indicating if specific vertex buffer is present</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        abstract isVerticesDataPresent: kind: string -> bool
        /// Gets a list of all attached data kinds (Position, normal, etc...)
        abstract getVerticesDataKinds: unit -> ResizeArray<string>
        /// <summary>Update index buffer</summary>
        /// <param name="indices">defines the indices to store in the index buffer</param>
        /// <param name="offset">defines the offset in the target buffer where to store the data</param>
        abstract updateIndices: indices: IndicesArray * ?offset: float -> unit
        /// <summary>Creates a new index buffer</summary>
        /// <param name="indices">defines the indices to store in the index buffer</param>
        /// <param name="totalVertices">defines the total number of vertices (could be null)</param>
        /// <param name="updatable">defines if the index buffer must be flagged as updatable (false by default)</param>
        abstract setIndices: indices: IndicesArray * ?totalVertices: float * ?updatable: bool -> unit
        /// Return the total number of indices
        abstract getTotalIndices: unit -> float
        /// <summary>Gets the index buffer array</summary>
        /// <param name="copyWhenShared">defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes</param>
        /// <param name="forceCopy">defines a boolean indicating that the returned array must be cloned upon returning it</param>
        abstract getIndices: ?copyWhenShared: bool * ?forceCopy: bool -> Nullable<IndicesArray>
        /// Gets the index buffer
        abstract getIndexBuffer: unit -> Nullable<WebGLBuffer>
        abstract _releaseVertexArrayObject: ?effect: Effect -> unit
        /// <summary>Release the associated resources for a specific mesh</summary>
        /// <param name="mesh">defines the source mesh</param>
        /// <param name="shouldDispose">defines if the geometry must be disposed if there is no more mesh pointing to it</param>
        abstract releaseForMesh: mesh: Mesh * ?shouldDispose: bool -> unit
        /// <summary>Apply current geometry to a given mesh</summary>
        /// <param name="mesh">defines the mesh to apply geometry to</param>
        abstract applyToMesh: mesh: Mesh -> unit
        /// <summary>Load the geometry if it was flagged as delay loaded</summary>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="onLoaded">defines a callback called when the geometry is loaded</param>
        abstract load: scene: Scene * ?onLoaded: (unit -> unit) -> unit
        /// Invert the geometry to move from a right handed system to a left handed one.
        abstract toLeftHanded: unit -> unit
        abstract _resetPointsArrayCache: unit -> unit
        abstract _generatePointsArray: unit -> bool
        /// Gets a value indicating if the geometry is disposed
        abstract isDisposed: unit -> bool
        /// Free all associated resources
        abstract dispose: unit -> unit
        /// <summary>Clone the current geometry into a new geometry</summary>
        /// <param name="id">defines the unique ID of the new geometry</param>
        abstract copy: id: string -> Geometry
        /// Serialize the current geometry info (and not the vertices data) into a JSON object
        abstract serialize: unit -> obj option
        /// Serialize all vertices data into a JSON oject
        abstract serializeVerticeData: unit -> obj option

    /// Class used to store geometry data (vertex buffers + index buffer)
    type [<AllowNullLiteral>] GeometryStatic =
        /// <summary>Static function used to attach a new empty geometry to a mesh</summary>
        /// <param name="mesh">defines the mesh to attach the geometry to</param>
        abstract CreateGeometryForMesh: mesh: Mesh -> Geometry
        /// <summary>Creates a new geometry</summary>
        /// <param name="id">defines the unique ID</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="vertexData">defines the VertexData used to get geometry data</param>
        /// <param name="updatable">defines if geometry must be updatable (false by default)</param>
        /// <param name="mesh">defines the mesh that will be associated with the geometry</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * ?vertexData: VertexData * ?updatable: bool * ?mesh: Mesh -> Geometry
        /// <summary>Extracts a clone of a mesh geometry</summary>
        /// <param name="mesh">defines the source mesh</param>
        /// <param name="id">defines the unique ID of the new geometry object</param>
        abstract ExtractFromMesh: mesh: Mesh * id: string -> Nullable<Geometry>
        /// You should now use Tools.RandomId(), this method is still here for legacy reasons.
        /// Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
        /// Be aware Math.random() could cause collisions, but:
        /// "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
        abstract RandomId: unit -> string
        abstract _ImportGeometry: parsedGeometry: obj option * mesh: Mesh -> unit
        /// <summary>Create a new geometry from persisted data (Using .babylon file format)</summary>
        /// <param name="parsedVertexData">defines the persisted data</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="rootUrl">defines the root url to use to load assets (like delayed data)</param>
        abstract Parse: parsedVertexData: obj option * scene: Scene * rootUrl: string -> Nullable<Geometry>

    /// Abstract class used to provide common services for all typed geometries
    type [<AllowNullLiteral>] _PrimitiveGeometry =
        inherit Geometry
        /// Gets a value indicating if the geometry supports being regenerated with new parameters (false by default)
        abstract canBeRegenerated: unit -> bool
        /// If the geometry supports regeneration, the function will recreates the geometry with updated parameter values
        abstract regenerate: unit -> unit
        /// <summary>Clone the geometry</summary>
        /// <param name="id">defines the unique ID of the new geometry</param>
        abstract asNewGeometry: id: string -> Geometry
        abstract setAllVerticesData: vertexData: VertexData * ?updatable: bool -> unit
        abstract setVerticesData: kind: string * data: FloatArray * ?updatable: bool -> unit
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Abstract class used to provide common services for all typed geometries
    type [<AllowNullLiteral>] _PrimitiveGeometryStatic =
        /// <summary>Creates a new typed geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="_canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * ?_canBeRegenerated: bool * ?mesh: Mesh -> _PrimitiveGeometry

    /// Creates a ribbon geometry
    type [<AllowNullLiteral>] RibbonGeometry =
        inherit _PrimitiveGeometry
        /// Defines the array of paths to use
        abstract pathArray: ResizeArray<ResizeArray<Vector3>> with get, set
        /// Defines if the last and first points of each path in your pathArray must be joined
        abstract closeArray: bool with get, set
        /// Defines if the last and first points of each path in your pathArray must be joined
        abstract closePath: bool with get, set
        /// Defines the offset between points
        abstract offset: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry

    /// Creates a ribbon geometry
    type [<AllowNullLiteral>] RibbonGeometryStatic =
        /// <summary>Creates a ribbon geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="pathArray">defines the array of paths to use</param>
        /// <param name="closeArray">defines if the last path and the first path must be  joined</param>
        /// <param name="closePath">defines if the last and first points of each path in your pathArray must be joined</param>
        /// <param name="offset">defines the offset between points</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * pathArray: ResizeArray<ResizeArray<Vector3>> * closeArray: bool * closePath: bool * offset: float * ?canBeRegenerated: bool * ?mesh: Mesh * ?side: float -> RibbonGeometry

    /// Creates a box geometry
    type [<AllowNullLiteral>] BoxGeometry =
        inherit _PrimitiveGeometry
        /// Defines the zise of the box (width, height and depth are the same)
        abstract size: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a box geometry
    type [<AllowNullLiteral>] BoxGeometryStatic =
        /// <summary>Creates a box geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="size">defines the zise of the box (width, height and depth are the same)</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * size: float * ?canBeRegenerated: bool * ?mesh: Mesh * ?side: float -> BoxGeometry
        abstract Parse: parsedBox: obj option * scene: Scene -> Nullable<BoxGeometry>

    /// Creates a sphere geometry
    type [<AllowNullLiteral>] SphereGeometry =
        inherit _PrimitiveGeometry
        /// Defines the number of segments to use to create the sphere
        abstract segments: float with get, set
        /// Defines the diameter of the sphere
        abstract diameter: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a sphere geometry
    type [<AllowNullLiteral>] SphereGeometryStatic =
        /// <summary>Create a new sphere geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="segments">defines the number of segments to use to create the sphere</param>
        /// <param name="diameter">defines the diameter of the sphere</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * segments: float * diameter: float * ?canBeRegenerated: bool * ?mesh: Mesh * ?side: float -> SphereGeometry
        abstract Parse: parsedSphere: obj option * scene: Scene -> Nullable<SphereGeometry>

    /// Creates a disc geometry
    type [<AllowNullLiteral>] DiscGeometry =
        inherit _PrimitiveGeometry
        /// Defines the radius of the disc
        abstract radius: float with get, set
        /// Defines the tesselation factor to apply to the disc
        abstract tessellation: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry

    /// Creates a disc geometry
    type [<AllowNullLiteral>] DiscGeometryStatic =
        /// <summary>Creates a new disc geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="radius">defines the radius of the disc</param>
        /// <param name="tessellation">defines the tesselation factor to apply to the disc</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * radius: float * tessellation: float * ?canBeRegenerated: bool * ?mesh: Mesh * ?side: float -> DiscGeometry

    /// Creates a new cylinder geometry
    type [<AllowNullLiteral>] CylinderGeometry =
        inherit _PrimitiveGeometry
        /// Defines the height of the cylinder
        abstract height: float with get, set
        /// Defines the diameter of the cylinder's top cap
        abstract diameterTop: float with get, set
        /// Defines the diameter of the cylinder's bottom cap
        abstract diameterBottom: float with get, set
        /// Defines the tessellation factor to apply to the cylinder
        abstract tessellation: float with get, set
        /// Defines the number of subdivisions to apply to the cylinder (1 by default)
        abstract subdivisions: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a new cylinder geometry
    type [<AllowNullLiteral>] CylinderGeometryStatic =
        /// <summary>Creates a new cylinder geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="height">defines the height of the cylinder</param>
        /// <param name="diameterTop">defines the diameter of the cylinder's top cap</param>
        /// <param name="diameterBottom">defines the diameter of the cylinder's bottom cap</param>
        /// <param name="tessellation">defines the tessellation factor to apply to the cylinder (number of radial sides)</param>
        /// <param name="subdivisions">defines the number of subdivisions to apply to the cylinder (number of rings) (1 by default)</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * height: float * diameterTop: float * diameterBottom: float * tessellation: float * ?subdivisions: float * ?canBeRegenerated: bool * ?mesh: Mesh * ?side: float -> CylinderGeometry
        abstract Parse: parsedCylinder: obj option * scene: Scene -> Nullable<CylinderGeometry>

    /// Creates a new torus geometry
    type [<AllowNullLiteral>] TorusGeometry =
        inherit _PrimitiveGeometry
        /// Defines the diameter of the torus
        abstract diameter: float with get, set
        /// Defines the thickness of the torus (ie. internal diameter)
        abstract thickness: float with get, set
        /// Defines the tesselation factor to apply to the torus
        abstract tessellation: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a new torus geometry
    type [<AllowNullLiteral>] TorusGeometryStatic =
        /// <summary>Creates a new torus geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="diameter">defines the diameter of the torus</param>
        /// <param name="thickness">defines the thickness of the torus (ie. internal diameter)</param>
        /// <param name="tessellation">defines the tesselation factor to apply to the torus (number of segments along the circle)</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * diameter: float * thickness: float * tessellation: float * ?canBeRegenerated: bool * ?mesh: Mesh * ?side: float -> TorusGeometry
        abstract Parse: parsedTorus: obj option * scene: Scene -> Nullable<TorusGeometry>

    /// Creates a new ground geometry
    type [<AllowNullLiteral>] GroundGeometry =
        inherit _PrimitiveGeometry
        /// Defines the width of the ground
        abstract width: float with get, set
        /// Defines the height of the ground
        abstract height: float with get, set
        /// Defines the subdivisions to apply to the ground
        abstract subdivisions: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a new ground geometry
    type [<AllowNullLiteral>] GroundGeometryStatic =
        /// <summary>Creates a new ground geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="width">defines the width of the ground</param>
        /// <param name="height">defines the height of the ground</param>
        /// <param name="subdivisions">defines the subdivisions to apply to the ground</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * width: float * height: float * subdivisions: float * ?canBeRegenerated: bool * ?mesh: Mesh -> GroundGeometry
        abstract Parse: parsedGround: obj option * scene: Scene -> Nullable<GroundGeometry>

    /// Creates a tiled ground geometry
    type [<AllowNullLiteral>] TiledGroundGeometry =
        inherit _PrimitiveGeometry
        /// Defines the minimum value on X axis
        abstract xmin: float with get, set
        /// Defines the minimum value on Z axis
        abstract zmin: float with get, set
        /// Defines the maximum value on X axis
        abstract xmax: float with get, set
        /// Defines the maximum value on Z axis
        abstract zmax: float with get, set
        /// Defines the subdivisions to apply to the ground
        abstract subdivisions: TypeLiteral_26 with get, set
        /// Defines the precision to use when computing the tiles
        abstract precision: TypeLiteral_26 with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry

    /// Creates a tiled ground geometry
    type [<AllowNullLiteral>] TiledGroundGeometryStatic =
        /// <summary>Creates a tiled ground geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="xmin">defines the minimum value on X axis</param>
        /// <param name="zmin">defines the minimum value on Z axis</param>
        /// <param name="xmax">defines the maximum value on X axis</param>
        /// <param name="zmax">defines the maximum value on Z axis</param>
        /// <param name="subdivisions">defines the subdivisions to apply to the ground (number of subdivisions (tiles) on the height and the width of the map)</param>
        /// <param name="precision">defines the precision to use when computing the tiles</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * xmin: float * zmin: float * xmax: float * zmax: float * subdivisions: TiledGroundGeometryStaticSubdivisions * precision: TiledGroundGeometryStaticPrecision * ?canBeRegenerated: bool * ?mesh: Mesh -> TiledGroundGeometry

    type [<AllowNullLiteral>] TiledGroundGeometryStaticSubdivisions =
        abstract w: float with get, set
        abstract h: float with get, set

    type [<AllowNullLiteral>] TiledGroundGeometryStaticPrecision =
        abstract w: float with get, set
        abstract h: float with get, set

    /// Creates a plane geometry
    type [<AllowNullLiteral>] PlaneGeometry =
        inherit _PrimitiveGeometry
        /// Defines the size of the plane (width === height)
        abstract size: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a plane geometry
    type [<AllowNullLiteral>] PlaneGeometryStatic =
        /// <summary>Creates a plane geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="size">defines the size of the plane (width === height)</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * size: float * ?canBeRegenerated: bool * ?mesh: Mesh * ?side: float -> PlaneGeometry
        abstract Parse: parsedPlane: obj option * scene: Scene -> Nullable<PlaneGeometry>

    /// Creates a torus knot geometry
    type [<AllowNullLiteral>] TorusKnotGeometry =
        inherit _PrimitiveGeometry
        /// Defines the radius of the torus knot
        abstract radius: float with get, set
        /// Defines the thickness of the torus knot tube
        abstract tube: float with get, set
        /// Defines the number of radial segments
        abstract radialSegments: float with get, set
        /// Defines the number of tubular segments
        abstract tubularSegments: float with get, set
        /// Defines the first number of windings
        abstract p: float with get, set
        /// Defines the second number of windings
        abstract q: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a torus knot geometry
    type [<AllowNullLiteral>] TorusKnotGeometryStatic =
        /// <summary>Creates a torus knot geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="radius">defines the radius of the torus knot</param>
        /// <param name="tube">defines the thickness of the torus knot tube</param>
        /// <param name="radialSegments">defines the number of radial segments</param>
        /// <param name="tubularSegments">defines the number of tubular segments</param>
        /// <param name="p">defines the first number of windings</param>
        /// <param name="q">defines the second number of windings</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * radius: float * tube: float * radialSegments: float * tubularSegments: float * p: float * q: float * ?canBeRegenerated: bool * ?mesh: Mesh * ?side: float -> TorusKnotGeometry
        abstract Parse: parsedTorusKnot: obj option * scene: Scene -> Nullable<TorusKnotGeometry>

    /// Mesh representing the gorund
    type [<AllowNullLiteral>] GroundMesh =
        inherit Mesh
        /// If octree should be generated 
        abstract generateOctree: bool with get, set
        abstract _subdivisionsX: float with get, set
        abstract _subdivisionsY: float with get, set
        abstract _width: float with get, set
        abstract _height: float with get, set
        abstract _minX: float with get, set
        abstract _maxX: float with get, set
        abstract _minZ: float with get, set
        abstract _maxZ: float with get, set
        /// "GroundMesh"
        abstract getClassName: unit -> string
        /// The minimum of x and y subdivisions
        abstract subdivisions: float
        /// X subdivisions
        abstract subdivisionsX: float
        /// Y subdivisions
        abstract subdivisionsY: float
        /// <summary>This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.
        /// Please note that you must have a decent number of submeshes to get performance improvements when using an octree</summary>
        /// <param name="chunksCount">the number of subdivisions for x and y</param>
        /// <param name="octreeBlocksSize">(Default: 32)</param>
        abstract optimize: chunksCount: float * ?octreeBlocksSize: float -> unit
        /// <summary>Returns a height (y) value in the Worl system :
        /// the ground altitude at the coordinates (x, z) expressed in the World system.</summary>
        /// <param name="x">x coordinate</param>
        /// <param name="z">z coordinate</param>
        abstract getHeightAtCoordinates: x: float * z: float -> float
        /// <summary>Returns a normalized vector (Vector3) orthogonal to the ground
        /// at the ground coordinates (x, z) expressed in the World system.</summary>
        /// <param name="x">x coordinate</param>
        /// <param name="z">z coordinate</param>
        abstract getNormalAtCoordinates: x: float * z: float -> Vector3
        /// <summary>Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
        /// at the ground coordinates (x, z) expressed in the World system.
        /// Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.</summary>
        /// <param name="x">x coordinate</param>
        /// <param name="z">z coordinate</param>
        /// <param name="ref">vector to store the result</param>
        abstract getNormalAtCoordinatesToRef: x: float * z: float * ref: Vector3 -> GroundMesh
        /// Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
        /// if the ground has been updated.
        /// This can be used in the render loop.
        abstract updateCoordinateHeights: unit -> GroundMesh
        /// <summary>Serializes this ground mesh</summary>
        /// <param name="serializationObject">object to write serialization to</param>
        abstract serialize: serializationObject: obj option -> unit

    /// Mesh representing the gorund
    type [<AllowNullLiteral>] GroundMeshStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> GroundMesh
        /// <summary>Parses a serialized ground mesh</summary>
        /// <param name="parsedMesh">the serialized mesh</param>
        /// <param name="scene">the scene to create the ground mesh in</param>
        abstract Parse: parsedMesh: obj option * scene: Scene -> GroundMesh

    /// Creates an instance based on a source mesh.
    type [<AllowNullLiteral>] InstancedMesh =
        inherit AbstractMesh
        /// Returns the string "InstancedMesh".
        abstract getClassName: unit -> string
        /// If the source mesh receives shadows
        abstract receiveShadows: bool
        /// The material of the source mesh
        abstract material: Nullable<Material>
        /// Visibility of the source mesh
        abstract visibility: float
        /// Skeleton of the source mesh
        abstract skeleton: Nullable<Skeleton>
        /// Rendering ground id of the source mesh
        abstract renderingGroupId: float with get, set
        /// Returns the total number of vertices (integer).
        abstract getTotalVertices: unit -> float
        /// The source mesh of the instance
        abstract sourceMesh: Mesh
        /// <summary>Is this node ready to be used/rendered</summary>
        /// <param name="completeCheck">defines if a complete check (including materials and lights) has to be done (false by default)</param>
        abstract isReady: ?completeCheck: bool -> bool
        /// <summary>Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.</summary>
        /// <param name="kind">kind of verticies to retreive (eg. positons, normals, uvs, etc.)</param>
        /// <param name="copyWhenShared">If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.</param>
        abstract getVerticesData: kind: string * ?copyWhenShared: bool -> Nullable<FloatArray>
        /// Sets the vertex data of the mesh geometry for the requested `kind`.
        /// If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
        /// The `data` are either a numeric array either a Float32Array.
        /// The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.
        /// The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
        /// Note that a new underlying VertexBuffer object is created each call.
        /// If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
        /// 
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        /// 
        /// Returns the Mesh.
        abstract setVerticesData: kind: string * data: FloatArray * ?updatable: bool * ?stride: float -> Mesh
        /// Updates the existing vertex data of the mesh geometry for the requested `kind`.
        /// If the mesh has no geometry, it is simply returned as it is.
        /// The `data` are either a numeric array either a Float32Array.
        /// No new underlying VertexBuffer object is created.
        /// If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
        /// If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
        /// 
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        /// 
        /// Returns the Mesh.
        abstract updateVerticesData: kind: string * data: FloatArray * ?updateExtends: bool * ?makeItUnique: bool -> Mesh
        /// Sets the mesh indices.
        /// Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
        /// If the mesh has no geometry, a new Geometry object is created and set to the mesh.
        /// This method creates a new index buffer each call.
        /// Returns the Mesh.
        abstract setIndices: indices: IndicesArray * ?totalVertices: float -> Mesh
        /// Boolean : True if the mesh owns the requested kind of data.
        abstract isVerticesDataPresent: kind: string -> bool
        /// Returns an array of indices (IndicesArray).
        abstract getIndices: unit -> Nullable<IndicesArray>
        abstract _positions: Nullable<ResizeArray<Vector3>>
        /// Sets a new updated BoundingInfo to the mesh.
        abstract refreshBoundingInfo: unit -> InstancedMesh
        abstract _preActivate: unit -> InstancedMesh
        abstract _activate: renderId: float -> InstancedMesh
        /// Returns the current associated LOD AbstractMesh.
        abstract getLOD: camera: Camera -> AbstractMesh
        abstract _syncSubMeshes: unit -> InstancedMesh
        abstract _generatePointsArray: unit -> bool
        /// Creates a new InstancedMesh from the current mesh.
        /// - name (string) : the cloned mesh name
        /// - newParent (optional Node) : the optional Node to parent the clone to.
        /// - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.
        /// 
        /// Returns the clone.
        abstract clone: name: string * newParent: Node * ?doNotCloneChildren: bool -> InstancedMesh
        /// Disposes the InstancedMesh.
        /// Returns nothing.
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit

    /// Creates an instance based on a source mesh.
    type [<AllowNullLiteral>] InstancedMeshStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * source: Mesh -> InstancedMesh

    /// Line mesh
    type [<AllowNullLiteral>] LinesMesh =
        inherit Mesh
        /// If vertex color should be applied to the mesh
        abstract useVertexColor: bool option with get, set
        /// If vertex alpha should be applied to the mesh
        abstract useVertexAlpha: bool option with get, set
        /// Color of the line (Default: White)
        abstract color: Color3 with get, set
        /// Alpha of the line (Default: 1)
        abstract alpha: float with get, set
        /// The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
        /// This margin is expressed in world space coordinates, so its value may vary.
        /// Default value is 0.1
        /// The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
        /// This margin is expressed in world space coordinates, so its value may vary.
        abstract intersectionThreshold: float with get, set
        /// Returns the string "LineMesh"
        abstract getClassName: unit -> string
        abstract material: Material with get, set
        abstract checkCollisions: bool
        abstract _bind: subMesh: SubMesh * effect: Effect * fillMode: float -> LinesMesh
        abstract _draw: subMesh: SubMesh * fillMode: float * ?instancesCount: float -> LinesMesh
        /// <summary>Disposes of the line mesh</summary>
        /// <param name="doNotRecurse">If children should be disposed</param>
        abstract dispose: ?doNotRecurse: bool -> unit
        /// Returns a new LineMesh object cloned from the current one.
        abstract clone: name: string * ?newParent: Node * ?doNotCloneChildren: bool -> LinesMesh
        /// <summary>Enables the edge rendering mode on the mesh.
        /// This mode makes the mesh edges visible</summary>
        /// <param name="epsilon">defines the maximal distance between two angles to detect a face</param>
        /// <param name="checkVerticesInsteadOfIndices">indicates that we should check vertex list directly instead of faces</param>
        abstract enableEdgesRendering: ?epsilon: float * ?checkVerticesInsteadOfIndices: bool -> AbstractMesh

    /// Line mesh
    type [<AllowNullLiteral>] LinesMeshStatic =
        /// <summary>Creates a new LinesMesh</summary>
        /// <param name="name">defines the name</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="parent">defines the parent mesh if any</param>
        /// <param name="source">defines the optional source LinesMesh used to clone data from</param>
        /// <param name="doNotCloneChildren">When cloning, skip cloning child meshes of source, default False.
        /// When false, achieved by calling a clone(), also passing False.
        /// This will make creation of children, recursive.</param>
        /// <param name="useVertexColor">defines if this LinesMesh supports vertex color</param>
        /// <param name="useVertexAlpha">defines if this LinesMesh supports vertex alpha</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Scene * ?parent: Node * ?source: LinesMesh * ?doNotCloneChildren: bool * ?useVertexColor: bool * ?useVertexAlpha: bool -> LinesMesh

    type [<AllowNullLiteral>] _CreationDataStorage =
        abstract closePath: bool option with get, set
        abstract closeArray: bool option with get, set
        abstract idx: ResizeArray<float> with get, set
        abstract dashSize: float with get, set
        abstract gapSize: float with get, set
        abstract path3D: Path3D with get, set
        abstract pathArray: ResizeArray<ResizeArray<Vector3>> with get, set
        abstract arc: float with get, set
        abstract radius: float with get, set
        abstract cap: float with get, set
        abstract tessellation: float with get, set

    type [<AllowNullLiteral>] _CreationDataStorageStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> _CreationDataStorage

    type [<AllowNullLiteral>] _InstanceDataStorage =
        abstract visibleInstances: obj option with get, set
        abstract renderIdForInstances: ResizeArray<float> with get, set
        abstract batchCache: _InstancesBatch with get, set
        abstract instancesBufferSize: float with get, set
        abstract instancesBuffer: Nullable<Buffer> with get, set
        abstract instancesData: Float32Array with get, set
        abstract overridenInstanceCount: float with get, set

    type [<AllowNullLiteral>] _InstanceDataStorageStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> _InstanceDataStorage

    type [<AllowNullLiteral>] _InstancesBatch =
        abstract mustReturn: bool with get, set
        abstract visibleInstances: ResizeArray<Nullable<ResizeArray<InstancedMesh>>> with get, set
        abstract renderSelf: ResizeArray<bool> with get, set

    type [<AllowNullLiteral>] _InstancesBatchStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> _InstancesBatch

    /// Class used to represent renderable models
    type [<AllowNullLiteral>] Mesh =
        inherit AbstractMesh
        inherit IGetSetVerticesData
        /// An event triggered before rendering the mesh
        abstract onBeforeRenderObservable: Observable<Mesh>
        /// An event triggered after rendering the mesh
        abstract onAfterRenderObservable: Observable<Mesh>
        /// An event triggered before drawing the mesh
        abstract onBeforeDrawObservable: Observable<Mesh>
        /// Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead
        abstract onBeforeDraw: (unit -> unit) with get, set
        /// Gets the delay loading state of the mesh (when delay loading is turned on)
        abstract delayLoadState: float with get, set
        /// Gets the list of instances created from this mesh
        abstract instances: ResizeArray<InstancedMesh> with get, set
        /// Gets the file containing delay loading data for this mesh
        abstract delayLoadingFile: string with get, set
        abstract _binaryInfo: obj option with get, set
        /// User defined function used to change how LOD level selection is done
        abstract onLODLevelSelection: (float -> Mesh -> Nullable<Mesh> -> unit) with get, set
        /// Gets or sets the morph target manager
        abstract morphTargetManager: Nullable<MorphTargetManager> with get, set
        abstract _creationDataStorage: Nullable<_CreationDataStorage> with get, set
        abstract _geometry: Nullable<Geometry> with get, set
        abstract _delayInfo: Array<string> with get, set
        abstract _delayLoadingFunction: (obj option -> Mesh -> unit) with get, set
        abstract _instanceDataStorage: _InstanceDataStorage with get, set
        abstract _shouldGenerateFlatShading: bool with get, set
        abstract _originalBuilderSideOrientation: float with get, set
        /// Use this property to change the original side orientation defined at construction time
        abstract overrideMaterialSideOrientation: Nullable<float> with get, set
        /// Gets the source mesh (the one used to clone this one from)
        abstract source: Nullable<Mesh>
        /// Gets or sets a boolean indicating that this mesh does not use index buffer
        abstract isUnIndexed: bool with get, set
        /// Gets the class name
        abstract getClassName: unit -> string
        /// <summary>Returns a description of this mesh</summary>
        /// <param name="fullDetails">define if full details about this mesh must be used</param>
        abstract toString: ?fullDetails: bool -> string
        abstract _unBindEffect: unit -> unit
        /// Gets a boolean indicating if this mesh has LOD
        abstract hasLODLevels: bool
        /// Gets the list of MeshLODLevel associated with the current mesh
        abstract getLODLevels: unit -> ResizeArray<MeshLODLevel>
        /// <summary>Add a mesh as LOD level triggered at the given distance.</summary>
        /// <param name="distance">The distance from the center of the object to show this level</param>
        /// <param name="mesh">The mesh to be added as LOD level (can be null)</param>
        abstract addLODLevel: distance: float * mesh: Nullable<Mesh> -> Mesh
        /// <summary>Returns the LOD level mesh at the passed distance or null if not found.</summary>
        /// <param name="distance">The distance from the center of the object to show this level</param>
        abstract getLODLevelAtDistance: distance: float -> Nullable<Mesh>
        /// <summary>Remove a mesh from the LOD array</summary>
        /// <param name="mesh">defines the mesh to be removed</param>
        abstract removeLODLevel: mesh: Mesh -> Mesh
        /// <summary>Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.</summary>
        /// <param name="camera">defines the camera to use to compute distance</param>
        /// <param name="boundingSphere">defines a custom bounding sphere to use instead of the one from this mesh</param>
        abstract getLOD: camera: Camera * ?boundingSphere: BoundingSphere -> Nullable<AbstractMesh>
        /// Gets the mesh internal Geometry object
        abstract geometry: Nullable<Geometry>
        /// Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.
        abstract getTotalVertices: unit -> float
        /// <summary>Returns the content of an associated vertex buffer</summary>
        /// <param name="kind">defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind</param>
        /// <param name="copyWhenShared">defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one</param>
        /// <param name="forceCopy">defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is</param>
        abstract getVerticesData: kind: string * ?copyWhenShared: bool * ?forceCopy: bool -> Nullable<FloatArray>
        /// <summary>Returns the mesh VertexBuffer object from the requested `kind`</summary>
        /// <param name="kind">defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind</param>
        abstract getVertexBuffer: kind: string -> Nullable<VertexBuffer>
        /// <summary>Tests if a specific vertex buffer is associated with this mesh</summary>
        /// <param name="kind">defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind</param>
        abstract isVerticesDataPresent: kind: string -> bool
        /// <summary>Returns a boolean defining if the vertex data for the requested `kind` is updatable.</summary>
        /// <param name="kind">defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind</param>
        abstract isVertexBufferUpdatable: kind: string -> bool
        /// Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.
        abstract getVerticesDataKinds: unit -> ResizeArray<string>
        /// Returns a positive integer : the total number of indices in this mesh geometry.
        abstract getTotalIndices: unit -> float
        /// <summary>Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.</summary>
        /// <param name="copyWhenShared">If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.</param>
        /// <param name="forceCopy">defines a boolean indicating that the returned array must be cloned upon returning it</param>
        abstract getIndices: ?copyWhenShared: bool * ?forceCopy: bool -> Nullable<IndicesArray>
        abstract isBlocked: bool
        /// <summary>Determine if the current mesh is ready to be rendered</summary>
        /// <param name="completeCheck">defines if a complete check (including materials and lights) has to be done (false by default)</param>
        /// <param name="forceInstanceSupport">will check if the mesh will be ready when used with instances (false by default)</param>
        abstract isReady: ?completeCheck: bool * ?forceInstanceSupport: bool -> bool
        /// Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.
        abstract areNormalsFrozen: bool
        /// This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.
        abstract freezeNormals: unit -> Mesh
        /// This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen
        abstract unfreezeNormals: unit -> Mesh
        /// Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs
        abstract overridenInstanceCount: float with get, set
        abstract _preActivate: unit -> Mesh
        abstract _preActivateForIntermediateRendering: renderId: float -> Mesh
        abstract _registerInstanceForRenderId: instance: InstancedMesh * renderId: float -> Mesh
        /// This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
        /// This means the mesh underlying bounding box and sphere are recomputed.
        abstract refreshBoundingInfo: unit -> Mesh
        abstract _refreshBoundingInfo: applySkeleton: bool -> Mesh
        abstract _createGlobalSubMesh: force: bool -> Nullable<SubMesh>
        /// <summary>This function will subdivide the mesh into multiple submeshes</summary>
        /// <param name="count">defines the expected number of submeshes</param>
        abstract subdivide: count: float -> unit
        /// <summary>Copy a FloatArray into a specific associated vertex buffer</summary>
        /// <param name="kind">defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind</param>
        /// <param name="data">defines the data source</param>
        /// <param name="updatable">defines if the updated vertex buffer must be flagged as updatable</param>
        /// <param name="stride">defines the data stride size (can be null)</param>
        abstract setVerticesData: kind: string * data: FloatArray * ?updatable: bool * ?stride: float -> Mesh
        /// <summary>Flags an associated vertex buffer as updatable</summary>
        /// <param name="kind">defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind</param>
        /// <param name="updatable">defines if the updated vertex buffer must be flagged as updatable</param>
        abstract markVerticesDataAsUpdatable: kind: string * ?updatable: bool -> unit
        /// <summary>Sets the mesh global Vertex Buffer</summary>
        /// <param name="buffer">defines the buffer to use</param>
        abstract setVerticesBuffer: buffer: VertexBuffer -> Mesh
        /// <summary>Update a specific associated vertex buffer</summary>
        /// <param name="kind">defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind</param>
        /// <param name="data">defines the data source</param>
        /// <param name="updateExtends">defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind</param>
        /// <param name="makeItUnique">defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)</param>
        abstract updateVerticesData: kind: string * data: FloatArray * ?updateExtends: bool * ?makeItUnique: bool -> Mesh
        /// <summary>This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.</summary>
        /// <param name="positionFunction">is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything</param>
        /// <param name="computeNormals">is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update</param>
        abstract updateMeshPositions: positionFunction: (FloatArray -> unit) * ?computeNormals: bool -> Mesh
        /// Creates a un-shared specific occurence of the geometry for the mesh.
        abstract makeGeometryUnique: unit -> Mesh
        /// <summary>Set the index buffer of this mesh</summary>
        /// <param name="indices">defines the source data</param>
        /// <param name="totalVertices">defines the total number of vertices referenced by this index data (can be null)</param>
        /// <param name="updatable">defines if the updated index buffer must be flagged as updatable (default is false)</param>
        abstract setIndices: indices: IndicesArray * ?totalVertices: float * ?updatable: bool -> Mesh
        /// <summary>Update the current index buffer</summary>
        /// <param name="indices">defines the source data</param>
        /// <param name="offset">defines the offset in the index buffer where to store the new data (can be null)</param>
        abstract updateIndices: indices: IndicesArray * ?offset: float -> Mesh
        /// Invert the geometry to move from a right handed system to a left handed one.
        abstract toLeftHanded: unit -> Mesh
        abstract _bind: subMesh: SubMesh * effect: Effect * fillMode: float -> Mesh
        abstract _draw: subMesh: SubMesh * fillMode: float * ?instancesCount: float * ?alternate: bool -> Mesh
        /// <summary>Registers for this mesh a javascript function called just before the rendering process</summary>
        /// <param name="func">defines the function to call before rendering this mesh</param>
        abstract registerBeforeRender: func: (AbstractMesh -> unit) -> Mesh
        /// <summary>Disposes a previously registered javascript function called before the rendering</summary>
        /// <param name="func">defines the function to remove</param>
        abstract unregisterBeforeRender: func: (AbstractMesh -> unit) -> Mesh
        /// <summary>Registers for this mesh a javascript function called just after the rendering is complete</summary>
        /// <param name="func">defines the function to call after rendering this mesh</param>
        abstract registerAfterRender: func: (AbstractMesh -> unit) -> Mesh
        /// <summary>Disposes a previously registered javascript function called after the rendering.</summary>
        /// <param name="func">defines the function to remove</param>
        abstract unregisterAfterRender: func: (AbstractMesh -> unit) -> Mesh
        abstract _getInstancesRenderList: subMeshId: float -> _InstancesBatch
        abstract _renderWithInstances: subMesh: SubMesh * fillMode: float * batch: _InstancesBatch * effect: Effect * engine: Engine -> Mesh
        abstract _processRendering: subMesh: SubMesh * effect: Effect * fillMode: float * batch: _InstancesBatch * hardwareInstancedRendering: bool * onBeforeDraw: (bool -> Matrix -> Material -> unit) * ?effectiveMaterial: Material -> Mesh
        /// <summary>Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager</summary>
        /// <param name="subMesh">defines the subMesh to render</param>
        /// <param name="enableAlphaMode">defines if alpha mode can be changed</param>
        abstract render: subMesh: SubMesh * enableAlphaMode: bool -> Mesh
        /// Renormalize the mesh and patch it up if there are no weights
        /// Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.
        /// However in the case of zero weights then we set just a single influence to 1.
        /// We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.
        abstract cleanMatrixWeights: unit -> unit
        /// ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,
        /// or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let
        /// the user know there was an issue with importing the mesh
        abstract validateSkinning: unit -> MeshValidateSkinningReturn
        abstract _checkDelayState: unit -> Mesh
        /// <summary>Returns `true` if the mesh is within the frustum defined by the passed array of planes.
        /// A mesh is in the frustum if its bounding box intersects the frustum</summary>
        /// <param name="frustumPlanes">defines the frustum to test</param>
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// <summary>Sets the mesh material by the material or multiMaterial `id` property</summary>
        /// <param name="id">is a string identifying the material or the multiMaterial</param>
        abstract setMaterialByID: id: string -> Mesh
        /// Returns as a new array populated with the mesh material and/or skeleton, if any.
        abstract getAnimatables: unit -> ResizeArray<IAnimatable>
        /// <summary>Modifies the mesh geometry according to the passed transformation matrix.
        /// This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.
        /// The mesh normals are modified using the same transformation.
        /// Note that, under the hood, this method sets a new VertexBuffer each call.</summary>
        /// <param name="transform">defines the transform matrix to use</param>
        abstract bakeTransformIntoVertices: transform: Matrix -> Mesh
        /// Modifies the mesh geometry according to its own current World Matrix.
        /// The mesh World Matrix is then reset.
        /// This method returns nothing but really modifies the mesh even if it's originally not set as updatable.
        /// Note that, under the hood, this method sets a new VertexBuffer each call.
        abstract bakeCurrentTransformIntoVertices: unit -> Mesh
        abstract _positions: Nullable<ResizeArray<Vector3>>
        abstract _resetPointsArrayCache: unit -> Mesh
        abstract _generatePointsArray: unit -> bool
        /// <summary>Returns a new Mesh object generated from the current mesh properties.
        /// This method must not get confused with createInstance()</summary>
        /// <param name="name">is a string, the name given to the new mesh</param>
        /// <param name="newParent">can be any Node object (default `null`)</param>
        /// <param name="doNotCloneChildren">allows/denies the recursive cloning of the original mesh children if any (default `false`)</param>
        /// <param name="clonePhysicsImpostor">allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)</param>
        abstract clone: ?name: string * ?newParent: Node * ?doNotCloneChildren: bool * ?clonePhysicsImpostor: bool -> Mesh
        /// <summary>Releases resources associated with this mesh.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit
        /// <summary>Modifies the mesh geometry according to a displacement map.
        /// A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
        /// The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.</summary>
        /// <param name="url">is a string, the URL from the image file is to be downloaded.</param>
        /// <param name="minHeight">is the lower limit of the displacement.</param>
        /// <param name="maxHeight">is the upper limit of the displacement.</param>
        /// <param name="onSuccess">is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.</param>
        /// <param name="uvOffset">is an optional vector2 used to offset UV.</param>
        /// <param name="uvScale">is an optional vector2 used to scale UV.</param>
        /// <param name="forceUpdate">defines whether or not to force an update of the generated buffers. This is usefull to apply on a deserialized model for instance.</param>
        abstract applyDisplacementMap: url: string * minHeight: float * maxHeight: float * ?onSuccess: (Mesh -> unit) * ?uvOffset: Vector2 * ?uvScale: Vector2 * ?forceUpdate: bool -> Mesh
        /// <summary>Modifies the mesh geometry according to a displacementMap buffer.
        /// A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
        /// The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.</summary>
        /// <param name="buffer">is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.</param>
        /// <param name="heightMapWidth">is the width of the buffer image.</param>
        /// <param name="heightMapHeight">is the height of the buffer image.</param>
        /// <param name="minHeight">is the lower limit of the displacement.</param>
        /// <param name="maxHeight">is the upper limit of the displacement.</param>
        /// <param name="uvOffset">is an optional vector2 used to offset UV.</param>
        /// <param name="uvScale">is an optional vector2 used to scale UV.</param>
        /// <param name="forceUpdate">defines whether or not to force an update of the generated buffers. This is usefull to apply on a deserialized model for instance.</param>
        abstract applyDisplacementMapFromBuffer: buffer: Uint8Array * heightMapWidth: float * heightMapHeight: float * minHeight: float * maxHeight: float * ?uvOffset: Vector2 * ?uvScale: Vector2 * ?forceUpdate: bool -> Mesh
        /// Modify the mesh to get a flat shading rendering.
        /// This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.
        /// Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.
        abstract convertToFlatShadedMesh: unit -> Mesh
        /// This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.
        /// In other words, more vertices, no more indices and a single bigger VBO.
        /// The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.
        abstract convertToUnIndexedMesh: unit -> Mesh
        /// <summary>Inverses facet orientations.
        /// Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.</summary>
        /// <param name="flipNormals">will also inverts the normals</param>
        abstract flipFaces: ?flipNormals: bool -> Mesh
        /// <summary>Creates a new InstancedMesh object from the mesh model.
        /// Warning : this method is not supported for Line mesh and LineSystem</summary>
        /// <param name="name">defines the name of the new instance</param>
        abstract createInstance: name: string -> InstancedMesh
        /// Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.
        /// After this call, all the mesh instances have the same submeshes than the current mesh.
        abstract synchronizeInstances: unit -> Mesh
        /// <summary>Optimization of the mesh's indices, in case a mesh has duplicated vertices.
        /// The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.
        /// This should be used together with the simplification to avoid disappearing triangles.</summary>
        /// <param name="successCallback">an optional success callback to be called after the optimization finished.</param>
        abstract optimizeIndices: ?successCallback: (Mesh -> unit) -> Mesh
        /// <summary>Serialize current mesh</summary>
        /// <param name="serializationObject">defines the object which will receive the serialization data</param>
        abstract serialize: serializationObject: obj option -> unit
        abstract _syncGeometryWithMorphTargetManager: unit -> unit
        /// Prepare internal position array for software CPU skinning
        abstract setPositionsForCPUSkinning: unit -> Float32Array
        /// Prepare internal normal array for software CPU skinning
        abstract setNormalsForCPUSkinning: unit -> Float32Array
        /// <summary>Updates the vertex buffer by applying transformation from the bones</summary>
        /// <param name="skeleton">defines the skeleton to apply to current mesh</param>
        abstract applySkeleton: skeleton: Skeleton -> Mesh
        /// <summary>Simplify the mesh according to the given array of settings.
        /// Function will return immediately and will simplify async</summary>
        /// <param name="settings">a collection of simplification settings</param>
        /// <param name="parallelProcessing">should all levels calculate parallel or one after the other</param>
        /// <param name="simplificationType">the type of simplification to run</param>
        /// <param name="successCallback">optional success callback to be called after the simplification finished processing all settings</param>
        abstract simplify: settings: Array<ISimplificationSettings> * ?parallelProcessing: bool * ?simplificationType: SimplificationType * ?successCallback: (Mesh -> float -> unit) -> Mesh
        /// Returns an array populated with IParticleSystem objects whose the mesh is the emitter
        abstract getEmittedParticleSystems: unit -> ResizeArray<IParticleSystem>
        /// Returns an array populated with IParticleSystem objects whose the mesh or its children are the emitter
        abstract getHierarchyEmittedParticleSystems: unit -> ResizeArray<IParticleSystem>

    type [<AllowNullLiteral>] MeshValidateSkinningReturn =
        abstract skinned: bool with get, set
        abstract valid: bool with get, set
        abstract report: string with get, set

    /// Class used to represent renderable models
    type [<AllowNullLiteral>] MeshStatic =
        /// Mesh side orientation : usually the external or front surface
        abstract FRONTSIDE: float
        /// Mesh side orientation : usually the internal or back surface
        abstract BACKSIDE: float
        /// Mesh side orientation : both internal and external or front and back surfaces
        abstract DOUBLESIDE: float
        /// Mesh side orientation : by default, `FRONTSIDE`
        abstract DEFAULTSIDE: float
        /// Mesh cap setting : no cap
        abstract NO_CAP: float
        /// Mesh cap setting : one cap at the beginning of the mesh
        abstract CAP_START: float
        /// Mesh cap setting : one cap at the end of the mesh
        abstract CAP_END: float
        /// Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh
        abstract CAP_ALL: float
        /// <param name="name">The value used by scene.getMeshByName() to do a lookup.</param>
        /// <param name="scene">The scene to add this mesh to.</param>
        /// <param name="parent">The parent of this mesh, if it has one</param>
        /// <param name="source">An optional Mesh from which geometry is shared, cloned.</param>
        /// <param name="doNotCloneChildren">When cloning, skip cloning child meshes of source, default False.
        /// When false, achieved by calling a clone(), also passing False.
        /// This will make creation of children, recursive.</param>
        /// <param name="clonePhysicsImpostor">When cloning, include cloning mesh physics impostor, default True.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Scene * ?parent: Node * ?source: Mesh * ?doNotCloneChildren: bool * ?clonePhysicsImpostor: bool -> Mesh
        /// <summary>Returns a new Mesh object parsed from the source provided.</summary>
        /// <param name="parsedMesh">is the source</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="rootUrl">is the root URL to prefix the `delayLoadingFile` property with</param>
        abstract Parse: parsedMesh: obj option * scene: Scene * rootUrl: string -> Mesh
        /// <summary>Creates a ribbon mesh. Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="pathArray">is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry.</param>
        /// <param name="closeArray">creates a seam between the first and the last paths of the path array (default is false)</param>
        /// <param name="closePath">creates a seam between the first and the last points of each path of the path array</param>
        /// <param name="offset">is taken in account only if the `pathArray` is containing a single path</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        /// <param name="instance">defines an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter (http://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#ribbon)</param>
        abstract CreateRibbon: name: string * pathArray: ResizeArray<ResizeArray<Vector3>> * closeArray: bool option * closePath: bool * offset: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float * ?instance: Mesh -> Mesh
        /// <summary>Creates a plane polygonal mesh.  By default, this is a disc. Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="radius">sets the radius size (float) of the polygon (default 0.5)</param>
        /// <param name="tessellation">sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        abstract CreateDisc: name: string * radius: float * tessellation: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// <summary>Creates a box mesh. Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="size">sets the size (float) of each box side (default 1)</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        abstract CreateBox: name: string * size: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// <summary>Creates a sphere mesh. Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="segments">sets the sphere number of horizontal stripes (positive integer, default 32)</param>
        /// <param name="diameter">sets the diameter size (float) of the sphere (default 1)</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        abstract CreateSphere: name: string * segments: float * diameter: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// <summary>Creates a cylinder or a cone mesh. Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="height">sets the height size (float) of the cylinder/cone (float, default 2)</param>
        /// <param name="diameterTop">set the top cap diameter (floats, default 1)</param>
        /// <param name="diameterBottom">set the bottom cap diameter (floats, default 1). This value can't be zero</param>
        /// <param name="tessellation">sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance</param>
        /// <param name="subdivisions">sets the number of rings along the cylinder height (positive integer, default 1)</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        abstract CreateCylinder: name: string * height: float * diameterTop: float * diameterBottom: float * tessellation: float * subdivisions: obj option * ?scene: Scene * ?updatable: obj * ?sideOrientation: float -> Mesh
        /// <summary>Creates a torus mesh. Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="diameter">sets the diameter size (float) of the torus (default 1)</param>
        /// <param name="thickness">sets the diameter size of the tube of the torus (float, default 0.5)</param>
        /// <param name="tessellation">sets the number of torus sides (postive integer, default 16)</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        abstract CreateTorus: name: string * diameter: float * thickness: float * tessellation: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// <summary>Creates a torus knot mesh. Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="radius">sets the global radius size (float) of the torus knot (default 2)</param>
        /// <param name="tube">sets the diameter size of the tube of the torus (float, default 0.5)</param>
        /// <param name="radialSegments">sets the number of sides on each tube segments (positive integer, default 32)</param>
        /// <param name="tubularSegments">sets the number of tubes to decompose the knot into (positive integer, default 32)</param>
        /// <param name="p">the number of windings on X axis (positive integers, default 2)</param>
        /// <param name="q">the number of windings on Y axis (positive integers, default 3)</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        abstract CreateTorusKnot: name: string * radius: float * tube: float * radialSegments: float * tubularSegments: float * p: float * q: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// <summary>Creates a line mesh. Please consider using the same method from the MeshBuilder class instead.</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="points">is an array successive Vector3</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="instance">is an instance of an existing LineMesh object to be updated with the passed `points` parameter (http://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#lines-and-dashedlines).</param>
        abstract CreateLines: name: string * points: ResizeArray<Vector3> * ?scene: Scene * ?updatable: bool * ?instance: LinesMesh -> LinesMesh
        /// <summary>Creates a dashed line mesh. Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="points">is an array successive Vector3</param>
        /// <param name="dashSize">is the size of the dashes relatively the dash number (positive float, default 3)</param>
        /// <param name="gapSize">is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)</param>
        /// <param name="dashNb">is the intended total number of dashes (positive integer, default 200)</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="instance">is an instance of an existing LineMesh object to be updated with the passed `points` parameter (http://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#lines-and-dashedlines)</param>
        abstract CreateDashedLines: name: string * points: ResizeArray<Vector3> * dashSize: float * gapSize: float * dashNb: float * ?scene: Scene * ?updatable: bool * ?instance: LinesMesh -> LinesMesh
        /// <summary>Creates a polygon mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh.
        /// The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors.
        /// You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        /// Remember you can only change the shape positions, not their number when updating a polygon.
        /// Creates a polygon mesh.Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="shape">is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="holes">is a required array of arrays of successive Vector3 used to defines holes in the polygon</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        abstract CreatePolygon: name: string * shape: ResizeArray<Vector3> * scene: Scene * ?holes: ResizeArray<ResizeArray<Vector3>> * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// <summary>Creates an extruded polygon mesh, with depth in the Y direction. Please consider using the same method from the MeshBuilder class instead.</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="shape">is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors</param>
        /// <param name="depth">defines the height of extrusion</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="holes">is a required array of arrays of successive Vector3 used to defines holes in the polygon</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        abstract ExtrudePolygon: name: string * shape: ResizeArray<Vector3> * depth: float * scene: Scene * ?holes: ResizeArray<ResizeArray<Vector3>> * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// <summary>Creates an extruded shape mesh.
        /// The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters. Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="shape">is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis</param>
        /// <param name="path">is a required array of successive Vector3. This is the axis curve the shape is extruded along</param>
        /// <param name="scale">is the value to scale the shape</param>
        /// <param name="rotation">is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve</param>
        /// <param name="cap">sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        /// <param name="instance">is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters (http://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#extruded-shape)</param>
        abstract ExtrudeShape: name: string * shape: ResizeArray<Vector3> * path: ResizeArray<Vector3> * scale: float * rotation: float * cap: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float * ?instance: Mesh -> Mesh
        /// <summary>Creates an custom extruded shape mesh.
        /// The custom extrusion is a parametric shape.
        /// It has no predefined shape. Its final shape will depend on the input parameters.
        /// Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="shape">is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis</param>
        /// <param name="path">is a required array of successive Vector3. This is the axis curve the shape is extruded along</param>
        /// <param name="scaleFunction">is a custom Javascript function called on each path point</param>
        /// <param name="rotationFunction">is a custom Javascript function called on each path point</param>
        /// <param name="ribbonCloseArray">forces the extrusion underlying ribbon to close all the paths in its `pathArray`</param>
        /// <param name="ribbonClosePath">forces the extrusion underlying ribbon to close its `pathArray`</param>
        /// <param name="cap">sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        /// <param name="instance">is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters (http://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape)</param>
        abstract ExtrudeShapeCustom: name: string * shape: ResizeArray<Vector3> * path: ResizeArray<Vector3> * scaleFunction: Function * rotationFunction: Function * ribbonCloseArray: bool * ribbonClosePath: bool * cap: float * scene: Scene * ?updatable: bool * ?sideOrientation: float * ?instance: Mesh -> Mesh
        /// <summary>Creates lathe mesh.
        /// The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe.
        /// Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="shape">is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero</param>
        /// <param name="radius">is the radius value of the lathe</param>
        /// <param name="tessellation">is the side number of the lathe.</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        abstract CreateLathe: name: string * shape: ResizeArray<Vector3> * radius: float * tessellation: float * scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// <summary>Creates a plane mesh. Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="size">sets the size (float) of both sides of the plane at once (default 1)</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        abstract CreatePlane: name: string * size: float * scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// <summary>Creates a ground mesh.
        /// Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="width">set the width of the ground</param>
        /// <param name="height">set the height of the ground</param>
        /// <param name="subdivisions">sets the number of subdivisions per side</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        abstract CreateGround: name: string * width: float * height: float * subdivisions: float * ?scene: Scene * ?updatable: bool -> Mesh
        /// <summary>Creates a tiled ground mesh.
        /// Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="xmin">set the ground minimum X coordinate</param>
        /// <param name="zmin">set the ground minimum Y coordinate</param>
        /// <param name="xmax">set the ground maximum X coordinate</param>
        /// <param name="zmax">set the ground maximum Z coordinate</param>
        /// <param name="subdivisions">is an object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile</param>
        /// <param name="precision">is an object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        abstract CreateTiledGround: name: string * xmin: float * zmin: float * xmax: float * zmax: float * subdivisions: MeshStaticCreateTiledGroundSubdivisions * precision: MeshStaticCreateTiledGroundPrecision * scene: Scene * ?updatable: bool -> Mesh
        /// <summary>Creates a ground mesh from a height map.
        /// Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="url">sets the URL of the height map image resource</param>
        /// <param name="width">set the ground width size</param>
        /// <param name="height">set the ground height size</param>
        /// <param name="subdivisions">sets the number of subdivision per side</param>
        /// <param name="minHeight">is the minimum altitude on the ground</param>
        /// <param name="maxHeight">is the maximum altitude on the ground</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="onReady">is a callback function that will be called  once the mesh is built (the height map download can last some time)</param>
        /// <param name="alphaFilter">will filter any data where the alpha channel is below this value, defaults 0 (all data visible)</param>
        abstract CreateGroundFromHeightMap: name: string * url: string * width: float * height: float * subdivisions: float * minHeight: float * maxHeight: float * scene: Scene * ?updatable: bool * ?onReady: (GroundMesh -> unit) * ?alphaFilter: float -> GroundMesh
        /// <summary>Creates a tube mesh.
        /// The tube is a parametric shape.
        /// It has no predefined shape. Its final shape will depend on the input parameters.
        /// Please consider using the same method from the MeshBuilder class instead</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="path">is a required array of successive Vector3. It is the curve used as the axis of the tube</param>
        /// <param name="radius">sets the tube radius size</param>
        /// <param name="tessellation">is the number of sides on the tubular surface</param>
        /// <param name="radiusFunction">is a custom function. If it is not null, it overwrittes the parameter `radius`. This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path</param>
        /// <param name="cap">sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="updatable">defines if the mesh must be flagged as updatable</param>
        /// <param name="sideOrientation">defines the mesh side orientation (http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)</param>
        /// <param name="instance">is an instance of an existing Tube object to be updated with the passed `pathArray` parameter (http://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#tube)</param>
        abstract CreateTube: name: string * path: ResizeArray<Vector3> * radius: float * tessellation: float * radiusFunction: MeshStaticCreateTubeRadiusFunction * cap: float * scene: Scene * ?updatable: bool * ?sideOrientation: float * ?instance: Mesh -> Mesh
        /// <summary>Creates a polyhedron mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
        /// * The parameter `size` (positive float, default 1) sets the polygon size
        /// * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
        /// * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
        /// * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
        /// * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
        /// * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
        /// * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh to create</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreatePolyhedron: name: string * options: MeshStaticCreatePolyhedronOptions * scene: Scene -> Mesh
        /// <summary>Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
        /// * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
        /// * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`)
        /// * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
        /// * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateIcoSphere: name: string * options: MeshStaticCreateIcoSphereOptions * scene: Scene -> Mesh
        /// <summary>Creates a decal mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// A decal is a mesh usually applied as a model onto the surface of another mesh</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="sourceMesh">defines the mesh receiving the decal</param>
        /// <param name="position">sets the position of the decal in world coordinates</param>
        /// <param name="normal">sets the normal of the mesh where the decal is applied onto in world coordinates</param>
        /// <param name="size">sets the decal scaling</param>
        /// <param name="angle">sets the angle to rotate the decal</param>
        abstract CreateDecal: name: string * sourceMesh: AbstractMesh * position: Vector3 * normal: Vector3 * size: Vector3 * angle: float -> Mesh
        /// <summary>Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates</summary>
        /// <param name="meshes">defines the list of meshes to scan</param>
        abstract MinMax: meshes: ResizeArray<AbstractMesh> -> MeshStaticMinMaxReturn
        /// <summary>Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array</summary>
        /// <param name="meshesOrMinMaxVector">could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object</param>
        abstract Center: meshesOrMinMaxVector: U2<TypeLiteral_27, ResizeArray<AbstractMesh>> -> Vector3
        /// <summary>Merge the array of meshes into a single mesh for performance reasons.</summary>
        /// <param name="meshes">defines he vertices source.  They should all be of the same material.  Entries can empty</param>
        /// <param name="disposeSource">when true (default), dispose of the vertices from the source meshes</param>
        /// <param name="allow32BitsIndices">when the sum of the vertices > 64k, this must be set to true</param>
        /// <param name="meshSubclass">when set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.</param>
        /// <param name="subdivideWithSubMeshes">when true (false default), subdivide mesh to his subMesh array with meshes source.</param>
        abstract MergeMeshes: meshes: Array<Mesh> * ?disposeSource: bool * ?allow32BitsIndices: bool * ?meshSubclass: Mesh * ?subdivideWithSubMeshes: bool -> Nullable<Mesh>

    type [<AllowNullLiteral>] MeshStaticCreateTiledGroundSubdivisions =
        abstract w: float with get, set
        abstract h: float with get, set

    type [<AllowNullLiteral>] MeshStaticCreateTiledGroundPrecision =
        abstract w: float with get, set
        abstract h: float with get, set

    type [<AllowNullLiteral>] MeshStaticCreateTubeRadiusFunction =
        [<Emit "$0($1...)">] abstract Invoke: i: float * distance: float -> float

    type [<AllowNullLiteral>] MeshStaticCreatePolyhedronOptions =
        abstract ``type``: float option with get, set
        abstract size: float option with get, set
        abstract sizeX: float option with get, set
        abstract sizeY: float option with get, set
        abstract sizeZ: float option with get, set
        abstract custom: obj option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set

    type [<AllowNullLiteral>] MeshStaticCreateIcoSphereOptions =
        abstract radius: float option with get, set
        abstract flat: bool option with get, set
        abstract subdivisions: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshStaticMinMaxReturn =
        abstract min: Vector3 with get, set
        abstract max: Vector3 with get, set

    /// Define an interface for all classes that will get and set the data on vertices
    type [<AllowNullLiteral>] IGetSetVerticesData =
        /// <summary>Gets a boolean indicating if specific vertex data is present</summary>
        /// <param name="kind">defines the vertex data kind to use</param>
        abstract isVerticesDataPresent: kind: string -> bool
        /// <summary>Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        /// <param name="copyWhenShared">defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes</param>
        /// <param name="forceCopy">defines a boolean indicating that the returned array must be cloned upon returning it</param>
        abstract getVerticesData: kind: string * ?copyWhenShared: bool * ?forceCopy: bool -> Nullable<FloatArray>
        /// <summary>Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.</summary>
        /// <param name="copyWhenShared">If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.</param>
        /// <param name="forceCopy">defines a boolean indicating that the returned array must be cloned upon returning it</param>
        abstract getIndices: ?copyWhenShared: bool * ?forceCopy: bool -> Nullable<IndicesArray>
        /// <summary>Set specific vertex data</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        /// <param name="data">defines the vertex data to use</param>
        /// <param name="updatable">defines if the vertex must be flagged as updatable (false as default)</param>
        abstract setVerticesData: kind: string * data: FloatArray * updatable: bool -> unit
        /// <summary>Update a specific associated vertex buffer</summary>
        /// <param name="kind">defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind</param>
        /// <param name="data">defines the data source</param>
        /// <param name="updateExtends">defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind</param>
        /// <param name="makeItUnique">defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)</param>
        abstract updateVerticesData: kind: string * data: FloatArray * ?updateExtends: bool * ?makeItUnique: bool -> unit
        /// <summary>Creates a new index buffer</summary>
        /// <param name="indices">defines the indices to store in the index buffer</param>
        /// <param name="totalVertices">defines the total number of vertices (could be null)</param>
        /// <param name="updatable">defines if the index buffer must be flagged as updatable (false by default)</param>
        abstract setIndices: indices: IndicesArray * totalVertices: Nullable<float> * ?updatable: bool -> unit

    /// This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance
    type [<AllowNullLiteral>] VertexData =
        /// An array of the x, y, z position of each vertex  [...., x, y, z, .....]
        abstract positions: Nullable<FloatArray> with get, set
        /// An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]
        abstract normals: Nullable<FloatArray> with get, set
        /// An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]
        abstract tangents: Nullable<FloatArray> with get, set
        /// An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs: Nullable<FloatArray> with get, set
        /// A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs2: Nullable<FloatArray> with get, set
        /// A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs3: Nullable<FloatArray> with get, set
        /// A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs4: Nullable<FloatArray> with get, set
        /// A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs5: Nullable<FloatArray> with get, set
        /// A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs6: Nullable<FloatArray> with get, set
        /// An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]
        abstract colors: Nullable<FloatArray> with get, set
        /// An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).
        abstract matricesIndices: Nullable<FloatArray> with get, set
        /// An array containing the list of weights defining the weight of each indexed matrix in the final computation
        abstract matricesWeights: Nullable<FloatArray> with get, set
        /// An array extending the number of possible indices
        abstract matricesIndicesExtra: Nullable<FloatArray> with get, set
        /// An array extending the number of possible weights when the number of indices is extended
        abstract matricesWeightsExtra: Nullable<FloatArray> with get, set
        /// An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]
        abstract indices: Nullable<IndicesArray> with get, set
        /// <summary>Uses the passed data array to set the set the values for the specified kind of data</summary>
        /// <param name="data">a linear array of floating numbers</param>
        /// <param name="kind">the type of data that is being set, eg positions, colors etc</param>
        abstract set: data: FloatArray * kind: string -> unit
        /// <summary>Associates the vertexData to the passed Mesh.
        /// Sets it as updatable or not (default `false`)</summary>
        /// <param name="mesh">the mesh the vertexData is applied to</param>
        /// <param name="updatable">when used and having the value true allows new data to update the vertexData</param>
        abstract applyToMesh: mesh: Mesh * ?updatable: bool -> VertexData
        /// <summary>Associates the vertexData to the passed Geometry.
        /// Sets it as updatable or not (default `false`)</summary>
        /// <param name="geometry">the geometry the vertexData is applied to</param>
        /// <param name="updatable">when used and having the value true allows new data to update the vertexData</param>
        abstract applyToGeometry: geometry: Geometry * ?updatable: bool -> VertexData
        /// <summary>Updates the associated mesh</summary>
        /// <param name="mesh">the mesh to be updated</param>
        /// <param name="updateExtends">when true the mesh BoundingInfo will be renewed when and if position kind is updated, optional with default false</param>
        /// <param name="makeItUnique">when true, and when and if position kind is updated, a new global geometry will be  created from these positions and set to the mesh, optional with default false</param>
        abstract updateMesh: mesh: Mesh * ?updateExtends: bool * ?makeItUnique: bool -> VertexData
        /// <summary>Updates the associated geometry</summary>
        /// <param name="geometry">the geometry to be updated</param>
        /// <param name="updateExtends">when true BoundingInfo will be renewed when and if position kind is updated, optional with default false</param>
        /// <param name="makeItUnique">when true, and when and if position kind is updated, a new global geometry will be created from these positions and set to the mesh, optional with default false</param>
        abstract updateGeometry: geometry: Geometry * ?updateExtends: bool * ?makeItUnique: bool -> VertexData
        /// <summary>Transforms each position and each normal of the vertexData according to the passed Matrix</summary>
        /// <param name="matrix">the transforming matrix</param>
        abstract transform: matrix: Matrix -> VertexData
        /// <summary>Merges the passed VertexData into the current one</summary>
        /// <param name="other">the VertexData to be merged into the current one</param>
        /// <param name="use32BitsIndices">defines a boolean indicating if indices must be store in a 32 bits array</param>
        abstract merge: other: VertexData * ?use32BitsIndices: bool -> VertexData
        /// Serializes the VertexData
        abstract serialize: unit -> obj option

    /// This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance
    type [<AllowNullLiteral>] VertexDataStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> VertexData
        /// <summary>Extracts the vertexData from a mesh</summary>
        /// <param name="mesh">the mesh from which to extract the VertexData</param>
        /// <param name="copyWhenShared">defines if the VertexData must be cloned when shared between multiple meshes, optional, default false</param>
        /// <param name="forceCopy">indicating that the VertexData must be cloned, optional, default false</param>
        abstract ExtractFromMesh: mesh: Mesh * ?copyWhenShared: bool * ?forceCopy: bool -> VertexData
        /// <summary>Extracts the vertexData from the geometry</summary>
        /// <param name="geometry">the geometry from which to extract the VertexData</param>
        /// <param name="copyWhenShared">defines if the VertexData must be cloned when the geometrty is shared between multiple meshes, optional, default false</param>
        /// <param name="forceCopy">indicating that the VertexData must be cloned, optional, default false</param>
        abstract ExtractFromGeometry: geometry: Geometry * ?copyWhenShared: bool * ?forceCopy: bool -> VertexData
        /// <summary>Creates the VertexData for a Ribbon</summary>
        /// <param name="options">an object used to set the following optional parameters for the ribbon, required but can be empty
        /// * pathArray array of paths, each of which an array of successive Vector3
        /// * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false
        /// * closePath creates a seam between the first and the last points of each path of the path array, optional, default false
        /// * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
        /// * invertUV swaps in the U and V coordinates when applying a texture, optional, default false
        /// * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional
        /// * colors a linear array, of length 4 * number of vertices, of custom color values, optional</param>
        abstract CreateRibbon: options: VertexDataStaticCreateRibbonOptions -> VertexData
        /// <summary>Creates the VertexData for a box</summary>
        /// <param name="options">an object used to set the following optional parameters for the box, required but can be empty
        /// * size sets the width, height and depth of the box to the value of size, optional default 1
        /// * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size
        /// * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size
        /// * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size
        /// * faceUV an array of 6 Vector4 elements used to set different images to each box side
        /// * faceColors an array of 6 Color3 elements used to set different colors to each box side
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateBox: options: VertexDataStaticCreateBoxOptions -> VertexData
        /// <summary>Creates the VertexData for an ellipsoid, defaults to a sphere</summary>
        /// <param name="options">an object used to set the following optional parameters for the box, required but can be empty
        /// * segments sets the number of horizontal strips optional, default 32
        /// * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1
        /// * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter
        /// * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter
        /// * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter
        /// * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1
        /// * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateSphere: options: VertexDataStaticCreateSphereOptions -> VertexData
        /// <summary>Creates the VertexData for a cylinder, cone or prism</summary>
        /// <param name="options">an object used to set the following optional parameters for the box, required but can be empty
        /// * height sets the height (y direction) of the cylinder, optional, default 2
        /// * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter
        /// * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter
        /// * diameter sets the diameter of the top and bottom of the cone, optional default 1
        /// * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
        /// * subdivisions` the number of rings along the cylinder height, optional, default 1
        /// * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1
        /// * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
        /// * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
        /// * hasRings when true makes each subdivision independantly treated as a face for faceUV and faceColors, optional, default false
        /// * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateCylinder: options: VertexDataStaticCreateCylinderOptions -> VertexData
        /// <summary>Creates the VertexData for a torus</summary>
        /// <param name="options">an object used to set the following optional parameters for the box, required but can be empty
        /// * diameter the diameter of the torus, optional default 1
        /// * thickness the diameter of the tube forming the torus, optional default 0.5
        /// * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateTorus: options: VertexDataStaticCreateTorusOptions -> VertexData
        /// <summary>Creates the VertexData of the LineSystem</summary>
        /// <param name="options">an object used to set the following optional parameters for the LineSystem, required but can be empty
        /// - lines an array of lines, each line being an array of successive Vector3
        /// - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point</param>
        abstract CreateLineSystem: options: VertexDataStaticCreateLineSystemOptions -> VertexData
        /// <summary>Create the VertexData for a DashedLines</summary>
        /// <param name="options">an object used to set the following optional parameters for the DashedLines, required but can be empty
        /// - points an array successive Vector3
        /// - dashSize the size of the dashes relative to the dash number, optional, default 3
        /// - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1
        /// - dashNb the intended total number of dashes, optional, default 200</param>
        abstract CreateDashedLines: options: VertexDataStaticCreateDashedLinesOptions -> VertexData
        /// <summary>Creates the VertexData for a Ground</summary>
        /// <param name="options">an object used to set the following optional parameters for the Ground, required but can be empty
        /// - width the width (x direction) of the ground, optional, default 1
        /// - height the height (z direction) of the ground, optional, default 1
        /// - subdivisions the number of subdivisions per side, optional, default 1</param>
        abstract CreateGround: options: VertexDataStaticCreateGroundOptions -> VertexData
        /// <summary>Creates the VertexData for a TiledGround by subdividing the ground into tiles</summary>
        /// <param name="options">an object used to set the following optional parameters for the Ground, required but can be empty
        /// * xmin the ground minimum X coordinate, optional, default -1
        /// * zmin the ground minimum Z coordinate, optional, default -1
        /// * xmax the ground maximum X coordinate, optional, default 1
        /// * zmax the ground maximum Z coordinate, optional, default 1
        /// * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}
        /// * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}</param>
        abstract CreateTiledGround: options: VertexDataStaticCreateTiledGroundOptions -> VertexData
        /// <summary>Creates the VertexData of the Ground designed from a heightmap</summary>
        /// <param name="options">an object used to set the following parameters for the Ground, required and provided by MeshBuilder.CreateGroundFromHeightMap
        /// * width the width (x direction) of the ground
        /// * height the height (z direction) of the ground
        /// * subdivisions the number of subdivisions per side
        /// * minHeight the minimum altitude on the ground, optional, default 0
        /// * maxHeight the maximum altitude on the ground, optional default 1
        /// * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)
        /// * buffer the array holding the image color data
        /// * bufferWidth the width of image
        /// * bufferHeight the height of image
        /// * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)</param>
        abstract CreateGroundFromHeightMap: options: VertexDataStaticCreateGroundFromHeightMapOptions -> VertexData
        /// <summary>Creates the VertexData for a Plane</summary>
        /// <param name="options">an object used to set the following optional parameters for the plane, required but can be empty
        /// * size sets the width and height of the plane to the value of size, optional default 1
        /// * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size
        /// * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreatePlane: options: VertexDataStaticCreatePlaneOptions -> VertexData
        /// <summary>Creates the VertexData of the Disc or regular Polygon</summary>
        /// <param name="options">an object used to set the following optional parameters for the disc, required but can be empty
        /// * radius the radius of the disc, optional default 0.5
        /// * tessellation the number of polygon sides, optional, default 64
        /// * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateDisc: options: VertexDataStaticCreateDiscOptions -> VertexData
        /// <summary>Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()
        /// All parameters are provided by MeshBuilder.CreatePolygon as needed</summary>
        /// <param name="polygon">a mesh built from polygonTriangulation.build()</param>
        /// <param name="sideOrientation">takes the values BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE</param>
        /// <param name="fUV">an array of Vector4 elements used to set different images to the top, rings and bottom respectively</param>
        /// <param name="fColors">an array of Color3 elements used to set different colors to the top, rings and bottom respectively</param>
        /// <param name="frontUVs">only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)</param>
        /// <param name="backUVs">only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreatePolygon: polygon: Mesh * sideOrientation: float * ?fUV: ResizeArray<Vector4> * ?fColors: ResizeArray<Color4> * ?frontUVs: Vector4 * ?backUVs: Vector4 -> VertexData
        /// <summary>Creates the VertexData of the IcoSphere</summary>
        /// <param name="options">an object used to set the following optional parameters for the IcoSphere, required but can be empty
        /// * radius the radius of the IcoSphere, optional default 1
        /// * radiusX allows stretching in the x direction, optional, default radius
        /// * radiusY allows stretching in the y direction, optional, default radius
        /// * radiusZ allows stretching in the z direction, optional, default radius
        /// * flat when true creates a flat shaded mesh, optional, default true
        /// * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateIcoSphere: options: VertexDataStaticCreateIcoSphereOptions -> VertexData
        /// <summary>Creates the VertexData for a Polyhedron</summary>
        /// <param name="options">an object used to set the following optional parameters for the polyhedron, required but can be empty
        /// * type provided types are:
        /// * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)
        /// * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)
        /// * size the size of the IcoSphere, optional default 1
        /// * sizeX allows stretching in the x direction, optional, default size
        /// * sizeY allows stretching in the y direction, optional, default size
        /// * sizeZ allows stretching in the z direction, optional, default size
        /// * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor
        /// * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
        /// * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
        /// * flat when true creates a flat shaded mesh, optional, default true
        /// * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreatePolyhedron: options: VertexDataStaticCreatePolyhedronOptions -> VertexData
        /// <summary>Creates the VertexData for a TorusKnot</summary>
        /// <param name="options">an object used to set the following optional parameters for the TorusKnot, required but can be empty
        /// * radius the radius of the torus knot, optional, default 2
        /// * tube the thickness of the tube, optional, default 0.5
        /// * radialSegments the number of sides on each tube segments, optional, default 32
        /// * tubularSegments the number of tubes to decompose the knot into, optional, default 32
        /// * p the number of windings around the z axis, optional,  default 2
        /// * q the number of windings around the x axis, optional,  default 3
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateTorusKnot: options: VertexDataStaticCreateTorusKnotOptions -> VertexData
        /// <summary>Compute normals for given positions and indices</summary>
        /// <param name="positions">an array of vertex positions, [...., x, y, z, ......]</param>
        /// <param name="indices">an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]</param>
        /// <param name="normals">an array of vertex normals, [...., x, y, z, ......]</param>
        /// <param name="options">an object used to set the following optional parameters for the TorusKnot, optional
        /// * facetNormals : optional array of facet normals (vector3)
        /// * facetPositions : optional array of facet positions (vector3)
        /// * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation
        /// * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation
        /// * bInfo : optional bounding info, required for facetPartitioning computation
        /// * bbSize : optional bounding box size data, required for facetPartitioning computation
        /// * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation
        /// * useRightHandedSystem: optional boolean to for right handed system computation
        /// * depthSort : optional boolean to enable the facet depth sort computation
        /// * distanceTo : optional Vector3 to compute the facet depth from this location
        /// * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location</param>
        abstract ComputeNormals: positions: obj option * indices: obj option * normals: obj option * ?options: VertexDataStaticComputeNormalsOptions -> unit
        /// <summary>Applies VertexData created from the imported parameters to the geometry</summary>
        /// <param name="parsedVertexData">the parsed data from an imported file</param>
        /// <param name="geometry">the geometry to apply the VertexData to</param>
        abstract ImportVertexData: parsedVertexData: obj option * geometry: Geometry -> unit

    type [<AllowNullLiteral>] VertexDataStaticCreateRibbonOptions =
        abstract pathArray: ResizeArray<ResizeArray<Vector3>> with get, set
        abstract closeArray: bool option with get, set
        abstract closePath: bool option with get, set
        abstract offset: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract invertUV: bool option with get, set
        abstract uvs: ResizeArray<Vector2> option with get, set
        abstract colors: ResizeArray<Color4> option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateBoxOptions =
        abstract size: float option with get, set
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract depth: float option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateSphereOptions =
        abstract segments: float option with get, set
        abstract diameter: float option with get, set
        abstract diameterX: float option with get, set
        abstract diameterY: float option with get, set
        abstract diameterZ: float option with get, set
        abstract arc: float option with get, set
        abstract slice: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateCylinderOptions =
        abstract height: float option with get, set
        abstract diameterTop: float option with get, set
        abstract diameterBottom: float option with get, set
        abstract diameter: float option with get, set
        abstract tessellation: float option with get, set
        abstract subdivisions: float option with get, set
        abstract arc: float option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract hasRings: bool option with get, set
        abstract enclose: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateTorusOptions =
        abstract diameter: float option with get, set
        abstract thickness: float option with get, set
        abstract tessellation: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateLineSystemOptions =
        abstract lines: ResizeArray<ResizeArray<Vector3>> with get, set
        abstract colors: Nullable<ResizeArray<ResizeArray<Color4>>> option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateDashedLinesOptions =
        abstract points: ResizeArray<Vector3> with get, set
        abstract dashSize: float option with get, set
        abstract gapSize: float option with get, set
        abstract dashNb: float option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateGroundOptions =
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract subdivisions: float option with get, set
        abstract subdivisionsX: float option with get, set
        abstract subdivisionsY: float option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateTiledGroundOptions =
        abstract xmin: float with get, set
        abstract zmin: float with get, set
        abstract xmax: float with get, set
        abstract zmax: float with get, set
        abstract subdivisions: TypeLiteral_26 option with get, set
        abstract precision: TypeLiteral_26 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateGroundFromHeightMapOptions =
        abstract width: float with get, set
        abstract height: float with get, set
        abstract subdivisions: float with get, set
        abstract minHeight: float with get, set
        abstract maxHeight: float with get, set
        abstract colorFilter: Color3 with get, set
        abstract buffer: Uint8Array with get, set
        abstract bufferWidth: float with get, set
        abstract bufferHeight: float with get, set
        abstract alphaFilter: float with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreatePlaneOptions =
        abstract size: float option with get, set
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateDiscOptions =
        abstract radius: float option with get, set
        abstract tessellation: float option with get, set
        abstract arc: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateIcoSphereOptions =
        abstract radius: float option with get, set
        abstract radiusX: float option with get, set
        abstract radiusY: float option with get, set
        abstract radiusZ: float option with get, set
        abstract flat: bool option with get, set
        abstract subdivisions: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreatePolyhedronOptions =
        abstract ``type``: float option with get, set
        abstract size: float option with get, set
        abstract sizeX: float option with get, set
        abstract sizeY: float option with get, set
        abstract sizeZ: float option with get, set
        abstract custom: obj option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract flat: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateTorusKnotOptions =
        abstract radius: float option with get, set
        abstract tube: float option with get, set
        abstract radialSegments: float option with get, set
        abstract tubularSegments: float option with get, set
        abstract p: float option with get, set
        abstract q: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticComputeNormalsOptions =
        abstract facetNormals: obj option with get, set
        abstract facetPositions: obj option with get, set
        abstract facetPartitioning: obj option with get, set
        abstract ratio: float option with get, set
        abstract bInfo: obj option with get, set
        abstract bbSize: Vector3 option with get, set
        abstract subDiv: obj option with get, set
        abstract useRightHandedSystem: bool option with get, set
        abstract depthSort: bool option with get, set
        abstract distanceTo: Vector3 option with get, set
        abstract depthSortedFacets: obj option with get, set

    /// Class containing static functions to help procedurally build meshes
    type [<AllowNullLiteral>] MeshBuilder =
        interface end

    /// Class containing static functions to help procedurally build meshes
    type [<AllowNullLiteral>] MeshBuilderStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> MeshBuilder
        /// <summary>Creates a box mesh
        /// * The parameter `size` sets the size (float) of each box side (default 1)
        /// * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)
        /// * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
        /// * Please read this tutorial : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateBox: name: string * options: MeshBuilderStaticCreateBoxOptions * ?scene: Scene -> Mesh
        /// <summary>Creates a sphere mesh
        /// * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
        /// * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)
        /// * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
        /// * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
        /// * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateSphere: name: string * options: MeshBuilderStaticCreateSphereOptions * scene: obj option -> Mesh
        /// <summary>Creates a plane polygonal mesh.  By default, this is a disc
        /// * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
        /// * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
        /// * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateDisc: name: string * options: MeshBuilderStaticCreateDiscOptions * ?scene: Scene -> Mesh
        /// <summary>Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
        /// * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
        /// * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)
        /// * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
        /// * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateIcoSphere: name: string * options: MeshBuilderStaticCreateIcoSphereOptions * scene: Scene -> Mesh
        /// <summary>Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
        /// * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
        /// * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
        /// * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
        /// * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
        /// * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
        /// * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#ribbon
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
        /// * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
        /// * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
        /// * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
        /// * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateRibbon: name: string * options: MeshBuilderStaticCreateRibbonOptions * ?scene: Scene -> Mesh
        /// <summary>Creates a cylinder or a cone mesh
        /// * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
        /// * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
        /// * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
        /// * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
        /// * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
        /// * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
        /// * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
        /// * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
        /// * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
        /// * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
        /// * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
        /// * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
        /// * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
        /// * If `enclose` is false, a ring surface is one element.
        /// * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
        /// * Example how to set colors and textures on a sliced cylinder : http://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateCylinder: name: string * options: MeshBuilderStaticCreateCylinderOptions * scene: obj option -> Mesh
        /// <summary>Creates a torus mesh
        /// * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
        /// * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
        /// * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateTorus: name: string * options: MeshBuilderStaticCreateTorusOptions * scene: obj option -> Mesh
        /// <summary>Creates a torus knot mesh
        /// * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
        /// * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
        /// * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
        /// * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateTorusKnot: name: string * options: MeshBuilderStaticCreateTorusKnotOptions * scene: obj option -> Mesh
        /// <summary>Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
        /// * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
        /// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
        /// * The parameter `lines` is an array of lines, each line being an array of successive Vector3
        /// * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
        /// * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
        /// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
        /// * Updating a simple Line mesh, you just need to update every line in the `lines` array : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
        /// * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the new line system</param>
        /// <param name="options">defines the options used to create the line system</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateLineSystem: name: string * options: MeshBuilderStaticCreateLineSystemOptions * scene: Nullable<Scene> -> LinesMesh
        /// <summary>Creates a line mesh
        /// A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
        /// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
        /// * The parameter `points` is an array successive Vector3
        /// * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
        /// * The optional parameter `colors` is an array of successive Color4, one per line point
        /// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
        /// * When updating an instance, remember that only point positions can change, not the number of points
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the new line system</param>
        /// <param name="options">defines the options used to create the line system</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateLines: name: string * options: MeshBuilderStaticCreateLinesOptions * ?scene: Scene -> LinesMesh
        /// <summary>Creates a dashed line mesh
        /// * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
        /// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
        /// * The parameter `points` is an array successive Vector3
        /// * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
        /// * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
        /// * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
        /// * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
        /// * When updating an instance, remember that only point positions can change, not the number of points
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateDashedLines: name: string * options: MeshBuilderStaticCreateDashedLinesOptions * ?scene: Scene -> LinesMesh
        /// <summary>Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
        /// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
        /// * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
        /// * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
        /// * The parameter `scale` (float, default 1) is the value to scale the shape.
        /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
        /// * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract ExtrudeShape: name: string * options: MeshBuilderStaticExtrudeShapeOptions * ?scene: Scene -> Mesh
        /// <summary>Creates an custom extruded shape mesh.
        /// The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
        /// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
        /// * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
        /// * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
        /// * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
        /// * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
        /// * It must returns a float value that will be the scale value applied to the shape on each path point
        /// * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`
        /// * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`
        /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
        /// * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract ExtrudeShapeCustom: name: string * options: MeshBuilderStaticExtrudeShapeCustomOptions * scene: Scene -> Mesh
        /// <summary>Creates lathe mesh.
        /// The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe
        /// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
        /// * The parameter `radius` (positive float, default 1) is the radius value of the lathe
        /// * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
        /// * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides
        /// * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
        /// * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
        /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateLathe: name: string * options: MeshBuilderStaticCreateLatheOptions * scene: Scene -> Mesh
        /// <summary>Creates a plane mesh
        /// * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)
        /// * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)
        /// * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreatePlane: name: string * options: MeshBuilderStaticCreatePlaneOptions * scene: Scene -> Mesh
        /// <summary>Creates a ground mesh
        /// * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
        /// * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateGround: name: string * options: MeshBuilderStaticCreateGroundOptions * scene: obj option -> Mesh
        /// <summary>Creates a tiled ground mesh
        /// * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
        /// * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
        /// * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
        /// * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateTiledGround: name: string * options: MeshBuilderStaticCreateTiledGroundOptions * scene: Scene -> Mesh
        /// <summary>Creates a ground mesh from a height map
        /// * The parameter `url` sets the URL of the height map image resource.
        /// * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
        /// * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
        /// * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
        /// * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
        /// * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
        /// * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
        /// * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="url">defines the url to the height map</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateGroundFromHeightMap: name: string * url: string * options: MeshBuilderStaticCreateGroundFromHeightMapOptions * scene: Scene -> GroundMesh
        /// <summary>Creates a polygon mesh
        /// The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
        /// * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
        /// * You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
        /// * Remember you can only change the shape positions, not their number when updating a polygon</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreatePolygon: name: string * options: MeshBuilderStaticCreatePolygonOptions * scene: Scene -> Mesh
        /// <summary>Creates an extruded polygon mesh, with depth in the Y direction.
        /// * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract ExtrudePolygon: name: string * options: MeshBuilderStaticExtrudePolygonOptions * scene: Scene -> Mesh
        /// <summary>Creates a tube mesh.
        /// The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
        /// * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
        /// * The parameter `radius` (positive float, default 1) sets the tube radius size
        /// * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
        /// * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`
        /// * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
        /// * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
        /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#tube
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateTube: name: string * options: MeshBuilderStaticCreateTubeOptions * scene: Scene -> Mesh
        /// <summary>Creates a polyhedron mesh
        /// * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
        /// * The parameter `size` (positive float, default 1) sets the polygon size
        /// * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
        /// * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
        /// * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
        /// * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
        /// * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
        /// * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreatePolyhedron: name: string * options: MeshBuilderStaticCreatePolyhedronOptions * scene: Scene -> Mesh
        /// <summary>Creates a decal mesh.
        /// A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
        /// * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
        /// * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
        /// * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
        /// * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="sourceMesh">defines the mesh where the decal must be applied</param>
        /// <param name="options">defines the options used to create the mesh</param>
        abstract CreateDecal: name: string * sourceMesh: AbstractMesh * options: MeshBuilderStaticCreateDecalOptions -> Mesh

    type [<AllowNullLiteral>] MeshBuilderStaticCreateBoxOptions =
        abstract size: float option with get, set
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract depth: float option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateSphereOptions =
        abstract segments: float option with get, set
        abstract diameter: float option with get, set
        abstract diameterX: float option with get, set
        abstract diameterY: float option with get, set
        abstract diameterZ: float option with get, set
        abstract arc: float option with get, set
        abstract slice: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateDiscOptions =
        abstract radius: float option with get, set
        abstract tessellation: float option with get, set
        abstract arc: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateIcoSphereOptions =
        abstract radius: float option with get, set
        abstract radiusX: float option with get, set
        abstract radiusY: float option with get, set
        abstract radiusZ: float option with get, set
        abstract flat: bool option with get, set
        abstract subdivisions: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateRibbonOptions =
        abstract pathArray: ResizeArray<ResizeArray<Vector3>> with get, set
        abstract closeArray: bool option with get, set
        abstract closePath: bool option with get, set
        abstract offset: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract instance: Mesh option with get, set
        abstract invertUV: bool option with get, set
        abstract uvs: ResizeArray<Vector2> option with get, set
        abstract colors: ResizeArray<Color4> option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateCylinderOptions =
        abstract height: float option with get, set
        abstract diameterTop: float option with get, set
        abstract diameterBottom: float option with get, set
        abstract diameter: float option with get, set
        abstract tessellation: float option with get, set
        abstract subdivisions: float option with get, set
        abstract arc: float option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract updatable: bool option with get, set
        abstract hasRings: bool option with get, set
        abstract enclose: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateTorusOptions =
        abstract diameter: float option with get, set
        abstract thickness: float option with get, set
        abstract tessellation: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateTorusKnotOptions =
        abstract radius: float option with get, set
        abstract tube: float option with get, set
        abstract radialSegments: float option with get, set
        abstract tubularSegments: float option with get, set
        abstract p: float option with get, set
        abstract q: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateLineSystemOptions =
        abstract lines: ResizeArray<ResizeArray<Vector3>> with get, set
        abstract updatable: bool option with get, set
        abstract instance: Nullable<LinesMesh> option with get, set
        abstract colors: Nullable<ResizeArray<ResizeArray<Color4>>> option with get, set
        abstract useVertexAlpha: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateLinesOptions =
        abstract points: ResizeArray<Vector3> with get, set
        abstract updatable: bool option with get, set
        abstract instance: Nullable<LinesMesh> option with get, set
        abstract colors: ResizeArray<Color4> option with get, set
        abstract useVertexAlpha: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateDashedLinesOptions =
        abstract points: ResizeArray<Vector3> with get, set
        abstract dashSize: float option with get, set
        abstract gapSize: float option with get, set
        abstract dashNb: float option with get, set
        abstract updatable: bool option with get, set
        abstract instance: LinesMesh option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticExtrudeShapeOptions =
        abstract shape: ResizeArray<Vector3> with get, set
        abstract path: ResizeArray<Vector3> with get, set
        abstract scale: float option with get, set
        abstract rotation: float option with get, set
        abstract cap: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract instance: Mesh option with get, set
        abstract invertUV: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticExtrudeShapeCustomOptions =
        abstract shape: ResizeArray<Vector3> with get, set
        abstract path: ResizeArray<Vector3> with get, set
        abstract scaleFunction: obj option with get, set
        abstract rotationFunction: obj option with get, set
        abstract ribbonCloseArray: bool option with get, set
        abstract ribbonClosePath: bool option with get, set
        abstract cap: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract instance: Mesh option with get, set
        abstract invertUV: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateLatheOptions =
        abstract shape: ResizeArray<Vector3> with get, set
        abstract radius: float option with get, set
        abstract tessellation: float option with get, set
        abstract clip: float option with get, set
        abstract arc: float option with get, set
        abstract closed: bool option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract cap: float option with get, set
        abstract invertUV: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreatePlaneOptions =
        abstract size: float option with get, set
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract updatable: bool option with get, set
        abstract sourcePlane: Plane option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateGroundOptions =
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract subdivisions: float option with get, set
        abstract subdivisionsX: float option with get, set
        abstract subdivisionsY: float option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateTiledGroundOptions =
        abstract xmin: float with get, set
        abstract zmin: float with get, set
        abstract xmax: float with get, set
        abstract zmax: float with get, set
        abstract subdivisions: TypeLiteral_26 option with get, set
        abstract precision: TypeLiteral_26 option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateGroundFromHeightMapOptions =
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract subdivisions: float option with get, set
        abstract minHeight: float option with get, set
        abstract maxHeight: float option with get, set
        abstract colorFilter: Color3 option with get, set
        abstract alphaFilter: float option with get, set
        abstract updatable: bool option with get, set
        abstract onReady: (GroundMesh -> unit) option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreatePolygonOptions =
        abstract shape: ResizeArray<Vector3> with get, set
        abstract holes: ResizeArray<ResizeArray<Vector3>> option with get, set
        abstract depth: float option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticExtrudePolygonOptions =
        abstract shape: ResizeArray<Vector3> with get, set
        abstract holes: ResizeArray<ResizeArray<Vector3>> option with get, set
        abstract depth: float option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateTubeOptions =
        abstract path: ResizeArray<Vector3> with get, set
        abstract radius: float option with get, set
        abstract tessellation: float option with get, set
        abstract radiusFunction: TypeLiteral_28 option with get, set
        abstract cap: float option with get, set
        abstract arc: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract instance: Mesh option with get, set
        abstract invertUV: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreatePolyhedronOptions =
        abstract ``type``: float option with get, set
        abstract size: float option with get, set
        abstract sizeX: float option with get, set
        abstract sizeY: float option with get, set
        abstract sizeZ: float option with get, set
        abstract custom: obj option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract flat: bool option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateDecalOptions =
        abstract position: Vector3 option with get, set
        abstract normal: Vector3 option with get, set
        abstract size: Vector3 option with get, set
        abstract angle: float option with get, set

    /// Class used to represent a specific level of detail of a mesh
    type [<AllowNullLiteral>] MeshLODLevel =
        /// Defines the distance where this level should star being displayed 
        abstract distance: float with get, set
        /// Defines the mesh to use to render this level 
        abstract mesh: Nullable<Mesh> with get, set

    /// Class used to represent a specific level of detail of a mesh
    type [<AllowNullLiteral>] MeshLODLevelStatic =
        /// <summary>Creates a new LOD level</summary>
        /// <param name="distance">defines the distance where this level should star being displayed</param>
        /// <param name="mesh">defines the mesh to use to render this level</param>
        [<Emit "new $0($1...)">] abstract Create: distance: float * mesh: Nullable<Mesh> -> MeshLODLevel

    /// A simplifier interface for future simplification implementations
    type [<AllowNullLiteral>] ISimplifier =
        /// <summary>Simplification of a given mesh according to the given settings.
        /// Since this requires computation, it is assumed that the function runs async.</summary>
        /// <param name="settings">The settings of the simplification, including quality and distance</param>
        /// <param name="successCallback">A callback that will be called after the mesh was simplified.</param>
        /// <param name="errorCallback">in case of an error, this callback will be called. optional.</param>
        abstract simplify: settings: ISimplificationSettings * successCallback: (Mesh -> unit) * ?errorCallback: (unit -> unit) -> unit

    /// Expected simplification settings.
    /// Quality should be between 0 and 1 (1 being 100%, 0 being 0%)
    type [<AllowNullLiteral>] ISimplificationSettings =
        /// Gets or sets the expected quality
        abstract quality: float with get, set
        /// Gets or sets the distance when this optimized version should be used
        abstract distance: float with get, set
        /// Gets an already optimized mesh
        abstract optimizeMesh: bool option with get, set

    /// Class used to specify simplification options
    type [<AllowNullLiteral>] SimplificationSettings =
        inherit ISimplificationSettings
        /// expected quality 
        abstract quality: float with get, set
        /// distance when this optimized version should be used 
        abstract distance: float with get, set
        /// already optimized mesh  
        abstract optimizeMesh: bool option with get, set

    /// Class used to specify simplification options
    type [<AllowNullLiteral>] SimplificationSettingsStatic =
        /// <summary>Creates a SimplificationSettings</summary>
        /// <param name="quality">expected quality</param>
        /// <param name="distance">distance when this optimized version should be used</param>
        /// <param name="optimizeMesh">already optimized mesh</param>
        [<Emit "new $0($1...)">] abstract Create: quality: float * distance: float * ?optimizeMesh: bool -> SimplificationSettings

    /// Interface used to define a simplification task
    type [<AllowNullLiteral>] ISimplificationTask =
        /// Array of settings
        abstract settings: Array<ISimplificationSettings> with get, set
        /// Simplification type
        abstract simplificationType: SimplificationType with get, set
        /// Mesh to simplify
        abstract mesh: Mesh with get, set
        /// Callback called on success
        abstract successCallback: (unit -> unit) option with get, set
        /// Defines if parallel processing can be used
        abstract parallelProcessing: bool with get, set

    /// Queue used to order the simplification tasks
    type [<AllowNullLiteral>] SimplificationQueue =
        /// Gets a boolean indicating that the process is still running
        abstract running: bool with get, set
        /// <summary>Adds a new simplification task</summary>
        /// <param name="task">defines a task to add</param>
        abstract addTask: task: ISimplificationTask -> unit
        /// Execute next task
        abstract executeNext: unit -> unit
        /// <summary>Execute a simplification task</summary>
        /// <param name="task">defines the task to run</param>
        abstract runSimplification: task: ISimplificationTask -> unit

    /// Queue used to order the simplification tasks
    type [<AllowNullLiteral>] SimplificationQueueStatic =
        /// Creates a new queue
        [<Emit "new $0($1...)">] abstract Create: unit -> SimplificationQueue

    type [<RequireQualifiedAccess>] SimplificationType =
        | QUADRATIC = 0

    /// Defines the simplification queue scene component responsible to help scheduling the various simplification task
    /// created in a scene
    type [<AllowNullLiteral>] SimplicationQueueSceneComponent =
        inherit ISceneComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources
        abstract dispose: unit -> unit

    /// Defines the simplification queue scene component responsible to help scheduling the various simplification task
    /// created in a scene
    type [<AllowNullLiteral>] SimplicationQueueSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> SimplicationQueueSceneComponent

    /// Polygon
    type [<AllowNullLiteral>] Polygon =
        interface end

    /// Polygon
    type [<AllowNullLiteral>] PolygonStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Polygon
        /// <summary>Creates a rectangle</summary>
        /// <param name="xmin">bottom X coord</param>
        /// <param name="ymin">bottom Y coord</param>
        /// <param name="xmax">top X coord</param>
        /// <param name="ymax">top Y coord</param>
        abstract Rectangle: xmin: float * ymin: float * xmax: float * ymax: float -> ResizeArray<Vector2>
        /// <summary>Creates a circle</summary>
        /// <param name="radius">radius of circle</param>
        /// <param name="cx">scale in x</param>
        /// <param name="cy">scale in y</param>
        /// <param name="numberOfSides">number of sides that make up the circle</param>
        abstract Circle: radius: float * ?cx: float * ?cy: float * ?numberOfSides: float -> ResizeArray<Vector2>
        /// <summary>Creates a polygon from input string</summary>
        /// <param name="input">Input polygon data</param>
        abstract Parse: input: string -> ResizeArray<Vector2>
        /// <summary>Starts building a polygon from x and y coordinates</summary>
        /// <param name="x">x coordinate</param>
        /// <param name="y">y coordinate</param>
        abstract StartingAt: x: float * y: float -> Path2

    /// Builds a polygon
    type [<AllowNullLiteral>] PolygonMeshBuilder =
        /// <summary>Adds a whole within the polygon</summary>
        /// <param name="hole">Array of points defining the hole</param>
        abstract addHole: hole: ResizeArray<Vector2> -> PolygonMeshBuilder
        /// <summary>Creates the polygon</summary>
        /// <param name="updatable">If the mesh should be updatable</param>
        /// <param name="depth">The depth of the mesh created</param>
        abstract build: ?updatable: bool * ?depth: float -> Mesh

    /// Builds a polygon
    type [<AllowNullLiteral>] PolygonMeshBuilderStatic =
        /// <summary>Creates a PolygonMeshBuilder</summary>
        /// <param name="name">name of the builder</param>
        /// <param name="contours">Path of the polygon</param>
        /// <param name="scene">scene to add to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * contours: U3<Path2, ResizeArray<Vector2>, obj option> * scene: Scene -> PolygonMeshBuilder

    /// Base class for submeshes
    type [<AllowNullLiteral>] BaseSubMesh =
        abstract _materialDefines: Nullable<MaterialDefines> with get, set
        abstract _materialEffect: Nullable<Effect> with get, set
        /// Gets associated effect
        abstract effect: Nullable<Effect>
        /// <summary>Sets associated effect (effect used to render this submesh)</summary>
        /// <param name="effect">defines the effect to associate with</param>
        /// <param name="defines">defines the set of defines used to compile this effect</param>
        abstract setEffect: effect: Nullable<Effect> * ?defines: MaterialDefines -> unit

    /// Base class for submeshes
    type [<AllowNullLiteral>] BaseSubMeshStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> BaseSubMesh

    /// Defines a subdivision inside a mesh
    type [<AllowNullLiteral>] SubMesh =
        inherit BaseSubMesh
        inherit ICullable
        /// the material index to use 
        abstract materialIndex: float with get, set
        /// vertex index start 
        abstract verticesStart: float with get, set
        /// vertices count 
        abstract verticesCount: float with get, set
        /// index start 
        abstract indexStart: float with get, set
        /// indices count 
        abstract indexCount: float with get, set
        abstract _linesIndexCount: float with get, set
        abstract _lastColliderWorldVertices: Nullable<ResizeArray<Vector3>> with get, set
        abstract _trianglePlanes: ResizeArray<Plane> with get, set
        abstract _lastColliderTransformMatrix: Matrix with get, set
        abstract _renderId: float with get, set
        abstract _alphaIndex: float with get, set
        abstract _distanceToCamera: float with get, set
        abstract _id: float with get, set
        /// Returns true if this submesh covers the entire parent mesh
        abstract IsGlobal: bool
        /// Returns the submesh BoudingInfo object
        abstract getBoundingInfo: unit -> BoundingInfo
        /// <summary>Sets the submesh BoundingInfo</summary>
        /// <param name="boundingInfo">defines the new bounding info to use</param>
        abstract setBoundingInfo: boundingInfo: BoundingInfo -> SubMesh
        /// Returns the mesh of the current submesh
        abstract getMesh: unit -> AbstractMesh
        /// Returns the rendering mesh of the submesh
        abstract getRenderingMesh: unit -> Mesh
        /// Returns the submesh material
        abstract getMaterial: unit -> Nullable<Material>
        /// Sets a new updated BoundingInfo object to the submesh
        abstract refreshBoundingInfo: unit -> SubMesh
        abstract _checkCollision: collider: Collider -> bool
        /// <summary>Updates the submesh BoundingInfo</summary>
        /// <param name="world">defines the world matrix to use to update the bounding info</param>
        abstract updateBoundingInfo: world: Matrix -> SubMesh
        /// <summary>True is the submesh bounding box intersects the frustum defined by the passed array of planes.</summary>
        /// <param name="frustumPlanes">defines the frustum planes</param>
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// <summary>True is the submesh bounding box is completely inside the frustum defined by the passed array of planes</summary>
        /// <param name="frustumPlanes">defines the frustum planes</param>
        abstract isCompletelyInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// <summary>Renders the submesh</summary>
        /// <param name="enableAlphaMode">defines if alpha needs to be used</param>
        abstract render: enableAlphaMode: bool -> SubMesh
        abstract _getLinesIndexBuffer: indices: IndicesArray * engine: Engine -> WebGLBuffer
        /// <summary>Checks if the submesh intersects with a ray</summary>
        /// <param name="ray">defines the ray to test</param>
        abstract canIntersects: ray: Ray -> bool
        /// <summary>Intersects current submesh with a ray</summary>
        /// <param name="ray">defines the ray to test</param>
        /// <param name="positions">defines mesh's positions array</param>
        /// <param name="indices">defines mesh's indices array</param>
        /// <param name="fastCheck">defines if only bounding info should be used</param>
        abstract intersects: ray: Ray * positions: ResizeArray<Vector3> * indices: IndicesArray * ?fastCheck: bool -> Nullable<IntersectionInfo>
        abstract _rebuild: unit -> unit
        /// <summary>Creates a new submesh from the passed mesh</summary>
        /// <param name="newMesh">defines the new hosting mesh</param>
        /// <param name="newRenderingMesh">defines an optional rendering mesh</param>
        abstract clone: newMesh: AbstractMesh * ?newRenderingMesh: Mesh -> SubMesh
        /// Release associated resources
        abstract dispose: unit -> unit

    /// Defines a subdivision inside a mesh
    type [<AllowNullLiteral>] SubMeshStatic =
        /// <summary>Add a new submesh to a mesh</summary>
        /// <param name="materialIndex">defines the material index to use</param>
        /// <param name="verticesStart">defines vertex index start</param>
        /// <param name="verticesCount">defines vertices count</param>
        /// <param name="indexStart">defines index start</param>
        /// <param name="indexCount">defines indices count</param>
        /// <param name="mesh">defines the parent mesh</param>
        /// <param name="renderingMesh">defines an optional rendering mesh</param>
        /// <param name="createBoundingBox">defines if bounding box should be created for this submesh</param>
        abstract AddToMesh: materialIndex: float * verticesStart: float * verticesCount: float * indexStart: float * indexCount: float * mesh: AbstractMesh * ?renderingMesh: Mesh * ?createBoundingBox: bool -> SubMesh
        /// <summary>Creates a new submesh</summary>
        /// <param name="materialIndex">defines the material index to use</param>
        /// <param name="verticesStart">defines vertex index start</param>
        /// <param name="verticesCount">defines vertices count</param>
        /// <param name="indexStart">defines index start</param>
        /// <param name="indexCount">defines indices count</param>
        /// <param name="mesh">defines the parent mesh</param>
        /// <param name="renderingMesh">defines an optional rendering mesh</param>
        /// <param name="createBoundingBox">defines if bounding box should be created for this submesh</param>
        [<Emit "new $0($1...)">] abstract Create: materialIndex: float * verticesStart: float * verticesCount: float * indexStart: float * indexCount: float * mesh: AbstractMesh * ?renderingMesh: Mesh * ?createBoundingBox: bool -> SubMesh
        /// <summary>Creates a new submesh from indices data</summary>
        /// <param name="materialIndex">the index of the main mesh material</param>
        /// <param name="startIndex">the index where to start the copy in the mesh indices array</param>
        /// <param name="indexCount">the number of indices to copy then from the startIndex</param>
        /// <param name="mesh">the main mesh to create the submesh from</param>
        /// <param name="renderingMesh">the optional rendering mesh</param>
        abstract CreateFromIndices: materialIndex: float * startIndex: float * indexCount: float * mesh: AbstractMesh * ?renderingMesh: Mesh -> SubMesh

    /// A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.
    type [<AllowNullLiteral>] TransformNode =
        inherit Node
        abstract _scaling: Vector3 with get, set
        abstract _isDirty: bool with get, set
        /// Set the billboard mode. Default is 0.
        /// 
        /// | Value | Type | Description |
        /// | --- | --- | --- |
        /// | 0 | BILLBOARDMODE_NONE |  |
        /// | 1 | BILLBOARDMODE_X |  |
        /// | 2 | BILLBOARDMODE_Y |  |
        /// | 4 | BILLBOARDMODE_Z |  |
        /// | 7 | BILLBOARDMODE_ALL |  |
        abstract billboardMode: float with get, set
        /// Multiplication factor on scale x/y/z when computing the world matrix. Eg. for a 1x1x1 cube setting this to 2 will make it a 2x2x2 cube
        abstract scalingDeterminant: float with get, set
        /// Sets the distance of the object to max, often used by skybox
        abstract infiniteDistance: bool with get, set
        /// Gets or sets a boolean indicating that non uniform scaling (when at least one component is different from others) should be ignored.
        /// By default the system will update normals to compensate
        abstract ignoreNonUniformScaling: bool with get, set
        abstract _poseMatrix: Matrix with get, set
        abstract _isWorldMatrixFrozen: bool with get, set
        /// An event triggered after the world matrix is updated
        abstract onAfterWorldMatrixUpdateObservable: Observable<TransformNode> with get, set
        /// Gets a string identifying the name of the class
        abstract getClassName: unit -> string
        /// Gets or set the node position (default is (0.0, 0.0, 0.0))
        abstract position: Vector3 with get, set
        /// Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).
        /// If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion
        abstract rotation: Vector3 with get, set
        /// Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (0.0, 0.0, 0.0)).
        abstract scaling: Vector3 with get, set
        /// Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (null by default).
        /// If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)
        abstract rotationQuaternion: Nullable<Quaternion> with get, set
        /// The forward direction of that transform in world space.
        abstract forward: Vector3
        /// The up direction of that transform in world space.
        abstract up: Vector3
        /// The right direction of that transform in world space.
        abstract right: Vector3
        /// <summary>Copies the parameter passed Matrix into the mesh Pose matrix.</summary>
        /// <param name="matrix">the matrix to copy the pose from</param>
        abstract updatePoseMatrix: matrix: Matrix -> TransformNode
        /// Returns the mesh Pose matrix.
        abstract getPoseMatrix: unit -> Matrix
        abstract _isSynchronized: unit -> bool
        abstract _initCache: unit -> unit
        /// <summary>Flag the transform node as dirty (Forcing it to update everything)</summary>
        /// <param name="property">if set to "rotation" the objects rotationQuaternion will be set to null</param>
        abstract markAsDirty: property: string -> TransformNode
        /// Returns the current mesh absolute position.
        /// Returns a Vector3.
        abstract absolutePosition: Vector3
        /// <summary>Sets a new matrix to apply before all other transformation</summary>
        /// <param name="matrix">defines the transform matrix</param>
        abstract setPreTransformMatrix: matrix: Matrix -> TransformNode
        /// <summary>Sets a new pivot matrix to the current node</summary>
        /// <param name="matrix">defines the new pivot matrix to use</param>
        /// <param name="postMultiplyPivotMatrix">defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect</param>
        abstract setPivotMatrix: matrix: Matrix * ?postMultiplyPivotMatrix: bool -> TransformNode
        /// Returns the mesh pivot matrix.
        /// Default : Identity.
        abstract getPivotMatrix: unit -> Matrix
        /// Prevents the World matrix to be computed any longer.
        abstract freezeWorldMatrix: unit -> TransformNode
        /// Allows back the World matrix computation.
        abstract unfreezeWorldMatrix: unit -> TransformNode
        /// True if the World matrix has been frozen.
        abstract isWorldMatrixFrozen: bool
        /// Retuns the mesh absolute position in the World.
        abstract getAbsolutePosition: unit -> Vector3
        /// <summary>Sets the mesh absolute position in the World from a Vector3 or an Array(3).</summary>
        /// <param name="absolutePosition">the absolute position to set</param>
        abstract setAbsolutePosition: absolutePosition: Vector3 -> TransformNode
        /// <summary>Sets the mesh position in its local space.</summary>
        /// <param name="vector3">the position to set in localspace</param>
        abstract setPositionWithLocalVector: vector3: Vector3 -> TransformNode
        /// Returns the mesh position in the local space from the current World matrix values.
        abstract getPositionExpressedInLocalSpace: unit -> Vector3
        /// <summary>Translates the mesh along the passed Vector3 in its local space.</summary>
        /// <param name="vector3">the distance to translate in localspace</param>
        abstract locallyTranslate: vector3: Vector3 -> TransformNode
        /// <summary>Orients a mesh towards a target point. Mesh must be drawn facing user.</summary>
        /// <param name="targetPoint">the position (must be in same space as current mesh) to look at</param>
        /// <param name="yawCor">optional yaw (y-axis) correction in radians</param>
        /// <param name="pitchCor">optional pitch (x-axis) correction in radians</param>
        /// <param name="rollCor">optional roll (z-axis) correction in radians</param>
        /// <param name="space">the choosen space of the target</param>
        abstract lookAt: targetPoint: Vector3 * ?yawCor: float * ?pitchCor: float * ?rollCor: float * ?space: Space -> TransformNode
        /// <summary>Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
        /// This Vector3 is expressed in the World space.</summary>
        /// <param name="localAxis">axis to rotate</param>
        abstract getDirection: localAxis: Vector3 -> Vector3
        /// <summary>Sets the Vector3 "result" as the rotated Vector3 "localAxis" in the same rotation than the mesh.
        /// localAxis is expressed in the mesh local space.
        /// result is computed in the Wordl space from the mesh World matrix.</summary>
        /// <param name="localAxis">axis to rotate</param>
        /// <param name="result">the resulting transformnode</param>
        abstract getDirectionToRef: localAxis: Vector3 * result: Vector3 -> TransformNode
        /// <summary>Sets a new pivot point to the current node</summary>
        /// <param name="point">defines the new pivot point to use</param>
        /// <param name="space">defines if the point is in world or local space (local by default)</param>
        abstract setPivotPoint: point: Vector3 * ?space: Space -> TransformNode
        /// Returns a new Vector3 set with the mesh pivot point coordinates in the local space.
        abstract getPivotPoint: unit -> Vector3
        /// <summary>Sets the passed Vector3 "result" with the coordinates of the mesh pivot point in the local space.</summary>
        /// <param name="result">the vector3 to store the result</param>
        abstract getPivotPointToRef: result: Vector3 -> TransformNode
        /// Returns a new Vector3 set with the mesh pivot point World coordinates.
        abstract getAbsolutePivotPoint: unit -> Vector3
        /// <summary>Sets the Vector3 "result" coordinates with the mesh pivot point World coordinates.</summary>
        /// <param name="result">vector3 to store the result</param>
        abstract getAbsolutePivotPointToRef: result: Vector3 -> TransformNode
        /// <summary>Defines the passed node as the parent of the current node.
        /// The node will remain exactly where it is and its position / rotation will be updated accordingly</summary>
        /// <param name="node">the node ot set as the parent</param>
        abstract setParent: node: Nullable<Node> -> TransformNode
        /// True if the scaling property of this object is non uniform eg. (1,2,1)
        abstract nonUniformScaling: bool
        abstract _updateNonUniformScalingState: value: bool -> bool
        /// <summary>Attach the current TransformNode to another TransformNode associated with a bone</summary>
        /// <param name="bone">Bone affecting the TransformNode</param>
        /// <param name="affectedTransformNode">TransformNode associated with the bone</param>
        abstract attachToBone: bone: Bone * affectedTransformNode: TransformNode -> TransformNode
        /// Detach the transform node if its associated with a bone
        abstract detachFromBone: unit -> TransformNode
        /// <summary>Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.
        /// space (default LOCAL) can be either BABYLON.Space.LOCAL, either BABYLON.Space.WORLD.
        /// Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
        /// The passed axis is also normalized.</summary>
        /// <param name="axis">the axis to rotate around</param>
        /// <param name="amount">the amount to rotate in radians</param>
        /// <param name="space">Space to rotate in (Default: local)</param>
        abstract rotate: axis: Vector3 * amount: float * ?space: Space -> TransformNode
        /// <summary>Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.
        /// Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
        /// The passed axis is also normalized. .
        /// Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm</summary>
        /// <param name="point">the point to rotate around</param>
        /// <param name="axis">the axis to rotate around</param>
        /// <param name="amount">the amount to rotate in radians</param>
        abstract rotateAround: point: Vector3 * axis: Vector3 * amount: float -> TransformNode
        /// <summary>Translates the mesh along the axis vector for the passed distance in the given space.
        /// space (default LOCAL) can be either BABYLON.Space.LOCAL, either BABYLON.Space.WORLD.</summary>
        /// <param name="axis">the axis to translate in</param>
        /// <param name="distance">the distance to translate</param>
        /// <param name="space">Space to rotate in (Default: local)</param>
        abstract translate: axis: Vector3 * distance: float * ?space: Space -> TransformNode
        /// <summary>Adds a rotation step to the mesh current rotation.
        /// x, y, z are Euler angles expressed in radians.
        /// This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.
        /// This means this rotation is made in the mesh local space only.
        /// It's useful to set a custom rotation order different from the BJS standard one YXZ.
        /// Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.
        /// ```javascript
        /// mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);
        /// ```
        /// Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.
        /// Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.</summary>
        /// <param name="x">Rotation to add</param>
        /// <param name="y">Rotation to add</param>
        /// <param name="z">Rotation to add</param>
        abstract addRotation: x: float * y: float * z: float -> TransformNode
        /// <summary>Computes the world matrix of the node</summary>
        /// <param name="force">defines if the cache version should be invalidated forcing the world matrix to be created from scratch</param>
        abstract computeWorldMatrix: ?force: bool -> Matrix
        abstract _afterComputeWorldMatrix: unit -> unit
        /// <summary>If you'd like to be called back after the mesh position, rotation or scaling has been updated.</summary>
        /// <param name="func">callback function to add</param>
        abstract registerAfterWorldMatrixUpdate: func: (TransformNode -> unit) -> TransformNode
        /// <summary>Removes a registered callback function.</summary>
        /// <param name="func">callback function to remove</param>
        abstract unregisterAfterWorldMatrixUpdate: func: (TransformNode -> unit) -> TransformNode
        /// <summary>Clone the current transform node</summary>
        /// <param name="name">Name of the new clone</param>
        /// <param name="newParent">New parent for the clone</param>
        /// <param name="doNotCloneChildren">Do not clone children hierarchy</param>
        abstract clone: name: string * newParent: Node * ?doNotCloneChildren: bool -> Nullable<TransformNode>
        /// <summary>Serializes the objects information.</summary>
        /// <param name="currentSerializationObject">defines the object to serialize in</param>
        abstract serialize: ?currentSerializationObject: obj -> obj option
        /// <summary>Releases resources associated with this transform node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit

    /// A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.
    type [<AllowNullLiteral>] TransformNodeStatic =
        /// Object will not rotate to face the camera
        abstract BILLBOARDMODE_NONE: float with get, set
        /// Object will rotate to face the camera but only on the x axis
        abstract BILLBOARDMODE_X: float with get, set
        /// Object will rotate to face the camera but only on the y axis
        abstract BILLBOARDMODE_Y: float with get, set
        /// Object will rotate to face the camera but only on the z axis
        abstract BILLBOARDMODE_Z: float with get, set
        /// Object will rotate to face the camera
        abstract BILLBOARDMODE_ALL: float with get, set
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Scene * ?isPure: bool -> TransformNode
        /// <summary>Returns a new TransformNode object parsed from the source provided.</summary>
        /// <param name="parsedTransformNode">is the source.</param>
        /// <param name="scene">the scne the object belongs to</param>
        /// <param name="rootUrl">is a string, it's the root URL to prefix the `delayLoadingFile` property with</param>
        abstract Parse: parsedTransformNode: obj option * scene: Scene * rootUrl: string -> TransformNode

    /// Specialized buffer used to store vertex data
    type [<AllowNullLiteral>] VertexBuffer =
        abstract _buffer: Buffer with get, set
        /// Gets or sets the instance divisor when in instanced mode
        abstract instanceDivisor: float with get, set
        /// Gets the byte stride.
        abstract byteStride: float
        /// Gets the byte offset.
        abstract byteOffset: float
        /// Gets whether integer data values should be normalized into a certain range when being casted to a float.
        abstract normalized: bool
        /// Gets the data type of each component in the array.
        abstract ``type``: float
        abstract _rebuild: unit -> unit
        /// Returns the kind of the VertexBuffer (string)
        abstract getKind: unit -> string
        /// Gets a boolean indicating if the VertexBuffer is updatable?
        abstract isUpdatable: unit -> bool
        /// Gets current buffer's data
        abstract getData: unit -> Nullable<DataArray>
        /// Gets underlying native buffer
        abstract getBuffer: unit -> Nullable<WebGLBuffer>
        /// Gets the stride in float32 units (i.e. byte stride / 4).
        /// May not be an integer if the byte stride is not divisible by 4.
        /// DEPRECATED. Use byteStride instead.
        abstract getStrideSize: unit -> float
        /// Returns the offset as a multiple of the type byte length.
        /// DEPRECATED. Use byteOffset instead.
        abstract getOffset: unit -> float
        /// Returns the number of components per vertex attribute (integer)
        abstract getSize: unit -> float
        /// Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced
        abstract getIsInstanced: unit -> bool
        /// Returns the instancing divisor, zero for non-instanced (integer).
        abstract getInstanceDivisor: unit -> float
        /// <summary>Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property</summary>
        /// <param name="data">defines the data to store</param>
        abstract create: ?data: DataArray -> unit
        /// <summary>Updates the underlying buffer according to the passed numeric array or Float32Array.
        /// This function will create a new buffer if the current one is not updatable</summary>
        /// <param name="data">defines the data to store</param>
        abstract update: data: DataArray -> unit
        /// <summary>Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.
        /// Returns the directly updated WebGLBuffer.</summary>
        /// <param name="data">the new data</param>
        /// <param name="offset">the new offset</param>
        /// <param name="useBytes">set to true if the offset is in bytes</param>
        abstract updateDirectly: data: DataArray * offset: float * ?useBytes: bool -> unit
        /// Disposes the VertexBuffer and the underlying WebGLBuffer.
        abstract dispose: unit -> unit
        /// <summary>Enumerates each value of this vertex buffer as numbers.</summary>
        /// <param name="count">the number of values to enumerate</param>
        /// <param name="callback">the callback function called for each value</param>
        abstract forEach: count: float * callback: (float -> float -> unit) -> unit

    /// Specialized buffer used to store vertex data
    type [<AllowNullLiteral>] VertexBufferStatic =
        /// The byte type.
        abstract BYTE: float
        /// The unsigned byte type.
        abstract UNSIGNED_BYTE: float
        /// The short type.
        abstract SHORT: float
        /// The unsigned short type.
        abstract UNSIGNED_SHORT: float
        /// The integer type.
        abstract INT: float
        /// The unsigned integer type.
        abstract UNSIGNED_INT: float
        /// The float type.
        abstract FLOAT: float
        /// <summary>Constructor</summary>
        /// <param name="engine">the engine</param>
        /// <param name="data">the data to use for this vertex buffer</param>
        /// <param name="kind">the vertex buffer kind</param>
        /// <param name="updatable">whether the data is updatable</param>
        /// <param name="postponeInternalCreation">whether to postpone creating the internal WebGL buffer (optional)</param>
        /// <param name="stride">the stride (optional)</param>
        /// <param name="instanced">whether the buffer is instanced (optional)</param>
        /// <param name="offset">the offset of the data (optional)</param>
        /// <param name="size">the number of components (optional)</param>
        /// <param name="type">the type of the component (optional)</param>
        /// <param name="normalized">whether the data contains normalized data (optional)</param>
        /// <param name="useBytes">set to true if stride and offset are in bytes (optional)</param>
        [<Emit "new $0($1...)">] abstract Create: engine: obj option * data: U2<DataArray, Buffer> * kind: string * updatable: bool * ?postponeInternalCreation: bool * ?stride: float * ?instanced: bool * ?offset: float * ?size: float * ?``type``: float * ?normalized: bool * ?useBytes: bool -> VertexBuffer
        /// Positions
        abstract PositionKind: string
        /// Normals
        abstract NormalKind: string
        /// Tangents
        abstract TangentKind: string
        /// Texture coordinates
        abstract UVKind: string
        /// Texture coordinates 2
        abstract UV2Kind: string
        /// Texture coordinates 3
        abstract UV3Kind: string
        /// Texture coordinates 4
        abstract UV4Kind: string
        /// Texture coordinates 5
        abstract UV5Kind: string
        /// Texture coordinates 6
        abstract UV6Kind: string
        /// Colors
        abstract ColorKind: string
        /// Matrix indices (for bones)
        abstract MatricesIndicesKind: string
        /// Matrix weights (for bones)
        abstract MatricesWeightsKind: string
        /// Additional matrix indices (for bones)
        abstract MatricesIndicesExtraKind: string
        /// Additional matrix weights (for bones)
        abstract MatricesWeightsExtraKind: string
        /// <summary>Deduces the stride given a kind.</summary>
        /// <param name="kind">The kind string to deduce</param>
        abstract DeduceStride: kind: string -> float
        /// <summary>Gets the byte length of the given type.</summary>
        /// <param name="type">the type</param>
        abstract GetTypeByteLength: ``type``: float -> float
        /// <summary>Enumerates each value of the given parameters as numbers.</summary>
        /// <param name="data">the data to enumerate</param>
        /// <param name="byteOffset">the byte offset of the data</param>
        /// <param name="byteStride">the byte stride of the data</param>
        /// <param name="componentCount">the number of components per element</param>
        /// <param name="componentType">the type of the component</param>
        /// <param name="count">the total number of components</param>
        /// <param name="normalized">whether the data is normalized</param>
        /// <param name="callback">the callback function called for each value</param>
        abstract ForEach: data: DataArray * byteOffset: float * byteStride: float * componentCount: float * componentType: float * count: float * normalized: bool * callback: (float -> float -> unit) -> unit

    /// Defines a target to use with MorphTargetManager
    type [<AllowNullLiteral>] MorphTarget =
        inherit IAnimatable
        /// defines the name of the target 
        abstract name: string with get, set
        /// Gets or sets the list of animations
        abstract animations: ResizeArray<Animation> with get, set
        /// Observable raised when the influence changes
        abstract onInfluenceChanged: Observable<bool> with get, set
        abstract _onDataLayoutChanged: Observable<unit> with get, set
        /// Gets or sets the influence of this target (ie. its weight in the overall morphing)
        abstract influence: float with get, set
        /// Gets or sets the animation properties override
        abstract animationPropertiesOverride: Nullable<AnimationPropertiesOverride> with get, set
        /// Gets a boolean defining if the target contains position data
        abstract hasPositions: bool
        /// Gets a boolean defining if the target contains normal data
        abstract hasNormals: bool
        /// Gets a boolean defining if the target contains tangent data
        abstract hasTangents: bool
        /// <summary>Affects position data to this target</summary>
        /// <param name="data">defines the position data to use</param>
        abstract setPositions: data: Nullable<FloatArray> -> unit
        /// Gets the position data stored in this target
        abstract getPositions: unit -> Nullable<FloatArray>
        /// <summary>Affects normal data to this target</summary>
        /// <param name="data">defines the normal data to use</param>
        abstract setNormals: data: Nullable<FloatArray> -> unit
        /// Gets the normal data stored in this target
        abstract getNormals: unit -> Nullable<FloatArray>
        /// <summary>Affects tangent data to this target</summary>
        /// <param name="data">defines the tangent data to use</param>
        abstract setTangents: data: Nullable<FloatArray> -> unit
        /// Gets the tangent data stored in this target
        abstract getTangents: unit -> Nullable<FloatArray>
        /// Serializes the current target into a Serialization object
        abstract serialize: unit -> obj option

    /// Defines a target to use with MorphTargetManager
    type [<AllowNullLiteral>] MorphTargetStatic =
        /// <summary>Creates a new MorphTarget</summary>
        /// <param name="name">defines the name of the target</param>
        /// <param name="influence">defines the influence to use</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ?influence: float * ?scene: Scene -> MorphTarget
        /// <summary>Creates a new target from serialized data</summary>
        /// <param name="serializationObject">defines the serialized data to use</param>
        abstract Parse: serializationObject: obj option -> MorphTarget
        /// <summary>Creates a MorphTarget from mesh data</summary>
        /// <param name="mesh">defines the source mesh</param>
        /// <param name="name">defines the name to use for the new target</param>
        /// <param name="influence">defines the influence to attach to the target</param>
        abstract FromMesh: mesh: AbstractMesh * ?name: string * ?influence: float -> MorphTarget

    /// This class is used to deform meshes using morphing between different targets
    type [<AllowNullLiteral>] MorphTargetManager =
        /// Gets the unique ID of this manager
        abstract uniqueId: float
        /// Gets the number of vertices handled by this manager
        abstract vertexCount: float
        /// Gets a boolean indicating if this manager supports morphing of normals
        abstract supportsNormals: bool
        /// Gets a boolean indicating if this manager supports morphing of tangents
        abstract supportsTangents: bool
        /// Gets the number of targets stored in this manager
        abstract numTargets: float
        /// Gets the number of influencers (ie. the number of targets with influences > 0)
        abstract numInfluencers: float
        /// Gets the list of influences (one per target)
        abstract influences: Float32Array
        /// <summary>Gets the active target at specified index. An active target is a target with an influence > 0</summary>
        /// <param name="index">defines the index to check</param>
        abstract getActiveTarget: index: float -> MorphTarget
        /// <summary>Gets the target at specified index</summary>
        /// <param name="index">defines the index to check</param>
        abstract getTarget: index: float -> MorphTarget
        /// <summary>Add a new target to this manager</summary>
        /// <param name="target">defines the target to add</param>
        abstract addTarget: target: MorphTarget -> unit
        /// <summary>Removes a target from the manager</summary>
        /// <param name="target">defines the target to remove</param>
        abstract removeTarget: target: MorphTarget -> unit
        /// Serializes the current manager into a Serialization object
        abstract serialize: unit -> obj option
        /// Syncrhonize the targets with all the meshes using this morph target manager
        abstract synchronize: unit -> unit

    /// This class is used to deform meshes using morphing between different targets
    type [<AllowNullLiteral>] MorphTargetManagerStatic =
        /// <summary>Creates a new MorphTargetManager</summary>
        /// <param name="scene">defines the current scene</param>
        [<Emit "new $0($1...)">] abstract Create: ?scene: Scene -> MorphTargetManager
        /// <summary>Creates a new MorphTargetManager from serialized data</summary>
        /// <param name="serializationObject">defines the serialized data</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract Parse: serializationObject: obj option * scene: Scene -> MorphTargetManager

    /// This represents the base class for particle system in Babylon.
    /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
    /// Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
    type [<AllowNullLiteral>] BaseParticleSystem =
        /// List of animations used by the particle system.
        abstract animations: ResizeArray<Animation> with get, set
        /// The id of the Particle system.
        abstract id: string with get, set
        /// The friendly name of the Particle system.
        abstract name: string with get, set
        /// The rendering group used by the Particle system to chose when to render.
        abstract renderingGroupId: float with get, set
        /// The emitter represents the Mesh or position we are attaching the particle system to.
        abstract emitter: Nullable<U2<AbstractMesh, Vector3>> with get, set
        /// The maximum number of particles to emit per frame
        abstract emitRate: float with get, set
        /// If you want to launch only a few particles at once, that can be done, as well.
        abstract manualEmitCount: float with get, set
        /// The overall motion speed (0.01 is default update speed, faster updates = faster animation)
        abstract updateSpeed: float with get, set
        /// The amount of time the particle system is running (depends of the overall update speed).
        abstract targetStopDuration: float with get, set
        /// Specifies whether the particle system will be disposed once it reaches the end of the animation.
        abstract disposeOnStop: bool with get, set
        /// Minimum power of emitting particles.
        abstract minEmitPower: float with get, set
        /// Maximum power of emitting particles.
        abstract maxEmitPower: float with get, set
        /// Minimum life time of emitting particles.
        abstract minLifeTime: float with get, set
        /// Maximum life time of emitting particles.
        abstract maxLifeTime: float with get, set
        /// Minimum Size of emitting particles.
        abstract minSize: float with get, set
        /// Maximum Size of emitting particles.
        abstract maxSize: float with get, set
        /// Minimum scale of emitting particles on X axis.
        abstract minScaleX: float with get, set
        /// Maximum scale of emitting particles on X axis.
        abstract maxScaleX: float with get, set
        /// Minimum scale of emitting particles on Y axis.
        abstract minScaleY: float with get, set
        /// Maximum scale of emitting particles on Y axis.
        abstract maxScaleY: float with get, set
        /// Gets or sets the minimal initial rotation in radians.
        abstract minInitialRotation: float with get, set
        /// Gets or sets the maximal initial rotation in radians.
        abstract maxInitialRotation: float with get, set
        /// Minimum angular speed of emitting particles (Z-axis rotation for each particle).
        abstract minAngularSpeed: float with get, set
        /// Maximum angular speed of emitting particles (Z-axis rotation for each particle).
        abstract maxAngularSpeed: float with get, set
        /// The texture used to render each particle. (this can be a spritesheet)
        abstract particleTexture: Nullable<Texture> with get, set
        /// The layer mask we are rendering the particles through.
        abstract layerMask: float with get, set
        /// This can help using your own shader to render the particle system.
        /// The according effect will be created
        abstract customShader: obj option with get, set
        /// By default particle system starts as soon as they are created. This prevents the
        /// automatic start to happen and let you decide when to start emitting particles.
        abstract preventAutoStart: bool with get, set
        /// Gets or sets a texture used to add random noise to particle positions
        abstract noiseTexture: Nullable<ProceduralTexture> with get, set
        /// Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) 
        abstract noiseStrength: Vector3 with get, set
        /// Callback triggered when the particle animation is ending.
        abstract onAnimationEnd: Nullable<(unit -> unit)> with get, set
        /// Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
        abstract blendMode: float with get, set
        /// Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
        /// to override the particles.
        abstract forceDepthWrite: bool with get, set
        /// Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0 
        abstract preWarmCycles: float with get, set
        /// Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1) 
        abstract preWarmStepOffset: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)
        abstract spriteCellChangeSpeed: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display
        abstract startSpriteCellID: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display
        abstract endSpriteCellID: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use
        abstract spriteCellWidth: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use
        abstract spriteCellHeight: float with get, set
        /// This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID
        abstract spriteRandomStartCell: bool with get, set
        /// Gets or sets a Vector2 used to move the pivot (by default (0,0)) 
        abstract translationPivot: Vector2 with get, set
        abstract _isAnimationSheetEnabled: bool with get, set
        /// Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called
        abstract beginAnimationOnStart: bool with get, set
        /// Gets or sets the frame to start the animation from when beginAnimationOnStart is true
        abstract beginAnimationFrom: float with get, set
        /// Gets or sets the frame to end the animation on when beginAnimationOnStart is true
        abstract beginAnimationTo: float with get, set
        /// Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true
        abstract beginAnimationLoop: bool with get, set
        /// Gets or sets whether an animation sprite sheet is enabled or not on the particle system
        abstract isAnimationSheetEnabled: bool with get, set
        /// Get hosting scene
        abstract getScene: unit -> Scene
        /// You can use gravity if you want to give an orientation to your particles.
        abstract gravity: Vector3 with get, set
        abstract _colorGradients: Nullable<Array<ColorGradient>> with get, set
        abstract _sizeGradients: Nullable<Array<FactorGradient>> with get, set
        abstract _lifeTimeGradients: Nullable<Array<FactorGradient>> with get, set
        abstract _angularSpeedGradients: Nullable<Array<FactorGradient>> with get, set
        abstract _velocityGradients: Nullable<Array<FactorGradient>> with get, set
        abstract _limitVelocityGradients: Nullable<Array<FactorGradient>> with get, set
        abstract _dragGradients: Nullable<Array<FactorGradient>> with get, set
        abstract _emitRateGradients: Nullable<Array<FactorGradient>> with get, set
        abstract _startSizeGradients: Nullable<Array<FactorGradient>> with get, set
        abstract _rampGradients: Nullable<Array<Color3Gradient>> with get, set
        abstract _colorRemapGradients: Nullable<Array<FactorGradient>> with get, set
        abstract _alphaRemapGradients: Nullable<Array<FactorGradient>> with get, set
        abstract _hasTargetStopDurationDependantGradient: unit -> bool option
        /// Defines the delay in milliseconds before starting the system (0 by default)
        abstract startDelay: float with get, set
        /// Gets the current list of drag gradients.
        /// You must use addDragGradient and removeDragGradient to udpate this list
        abstract getDragGradients: unit -> Nullable<Array<FactorGradient>>
        /// Gets or sets a value indicating the damping to apply if the limit velocity factor is reached 
        abstract limitVelocityDamping: float with get, set
        /// Gets the current list of limit velocity gradients.
        /// You must use addLimitVelocityGradient and removeLimitVelocityGradient to udpate this list
        abstract getLimitVelocityGradients: unit -> Nullable<Array<FactorGradient>>
        /// Gets the current list of color gradients.
        /// You must use addColorGradient and removeColorGradient to udpate this list
        abstract getColorGradients: unit -> Nullable<Array<ColorGradient>>
        /// Gets the current list of size gradients.
        /// You must use addSizeGradient and removeSizeGradient to udpate this list
        abstract getSizeGradients: unit -> Nullable<Array<FactorGradient>>
        /// Gets the current list of color remap gradients.
        /// You must use addColorRemapGradient and removeColorRemapGradient to udpate this list
        abstract getColorRemapGradients: unit -> Nullable<Array<FactorGradient>>
        /// Gets the current list of alpha remap gradients.
        /// You must use addAlphaRemapGradient and removeAlphaRemapGradient to udpate this list
        abstract getAlphaRemapGradients: unit -> Nullable<Array<FactorGradient>>
        /// Gets the current list of life time gradients.
        /// You must use addLifeTimeGradient and removeLifeTimeGradient to udpate this list
        abstract getLifeTimeGradients: unit -> Nullable<Array<FactorGradient>>
        /// Gets the current list of angular speed gradients.
        /// You must use addAngularSpeedGradient and removeAngularSpeedGradient to udpate this list
        abstract getAngularSpeedGradients: unit -> Nullable<Array<FactorGradient>>
        /// Gets the current list of velocity gradients.
        /// You must use addVelocityGradient and removeVelocityGradient to udpate this list
        abstract getVelocityGradients: unit -> Nullable<Array<FactorGradient>>
        /// Gets the current list of start size gradients.
        /// You must use addStartSizeGradient and removeStartSizeGradient to udpate this list
        abstract getStartSizeGradients: unit -> Nullable<Array<FactorGradient>>
        /// Gets the current list of emit rate gradients.
        /// You must use addEmitRateGradient and removeEmitRateGradient to udpate this list
        abstract getEmitRateGradients: unit -> Nullable<Array<FactorGradient>>
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract direction1: Vector3 with get, set
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract direction2: Vector3 with get, set
        /// Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract minEmitBox: Vector3 with get, set
        /// Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract maxEmitBox: Vector3 with get, set
        /// Random color of each particle after it has been emitted, between color1 and color2 vectors
        abstract color1: Color4 with get, set
        /// Random color of each particle after it has been emitted, between color1 and color2 vectors
        abstract color2: Color4 with get, set
        /// Color the particle will have at the end of its lifetime
        abstract colorDead: Color4 with get, set
        /// An optional mask to filter some colors out of the texture, or filter a part of the alpha channel
        abstract textureMask: Color4 with get, set
        /// The particle emitter type defines the emitter used by the particle system.
        /// It can be for example box, sphere, or cone...
        abstract particleEmitterType: IParticleEmitterType with get, set
        abstract _isSubEmitter: bool with get, set
        /// Gets or sets the billboard mode to use when isBillboardBased = true.
        /// Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
        abstract billboardMode: float with get, set
        abstract _isBillboardBased: bool with get, set
        /// Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
        abstract isBillboardBased: bool with get, set
        /// The scene the particle system belongs to.
        abstract _scene: Scene with get, set
        /// Local cache of defines for image processing.
        abstract _imageProcessingConfigurationDefines: ImageProcessingConfigurationDefines with get, set
        /// Default configuration related to image processing available in the standard Material.
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Gets the image processing configuration used either in this material.
        /// Sets the Default image processing configuration used either in the this material.
        /// 
        /// If sets to null, the scene one is in use.
        abstract imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// <summary>Attaches a new image processing configuration to the Standard Material.</summary>
        /// <param name="configuration"></param>
        abstract _attachImageProcessingConfiguration: configuration: Nullable<ImageProcessingConfiguration> -> unit
        abstract _reset: unit -> unit
        abstract _removeGradientAndTexture: gradient: float * gradients: Nullable<ResizeArray<IValueGradient>> * texture: Nullable<RawTexture> -> BaseParticleSystem
        /// <summary>Creates a Point Emitter for the particle system (emits directly from the emitter position)</summary>
        /// <param name="direction1">Particles are emitted between the direction1 and direction2 from within the box</param>
        /// <param name="direction2">Particles are emitted between the direction1 and direction2 from within the box</param>
        abstract createPointEmitter: direction1: Vector3 * direction2: Vector3 -> PointParticleEmitter
        /// <summary>Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)</summary>
        /// <param name="radius">The radius of the hemisphere to emit from</param>
        /// <param name="radiusRange">The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius</param>
        abstract createHemisphericEmitter: ?radius: float * ?radiusRange: float -> HemisphericParticleEmitter
        /// <summary>Creates a Sphere Emitter for the particle system (emits along the sphere radius)</summary>
        /// <param name="radius">The radius of the sphere to emit from</param>
        /// <param name="radiusRange">The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius</param>
        abstract createSphereEmitter: ?radius: float * ?radiusRange: float -> SphereParticleEmitter
        /// <summary>Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)</summary>
        /// <param name="radius">The radius of the sphere to emit from</param>
        /// <param name="direction1">Particles are emitted between the direction1 and direction2 from within the sphere</param>
        /// <param name="direction2">Particles are emitted between the direction1 and direction2 from within the sphere</param>
        abstract createDirectedSphereEmitter: ?radius: float * ?direction1: Vector3 * ?direction2: Vector3 -> SphereDirectedParticleEmitter
        /// <summary>Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)</summary>
        /// <param name="radius">The radius of the emission cylinder</param>
        /// <param name="height">The height of the emission cylinder</param>
        /// <param name="radiusRange">The range of emission [0-1] 0 Surface only, 1 Entire Radius</param>
        /// <param name="directionRandomizer">How much to randomize the particle direction [0-1]</param>
        abstract createCylinderEmitter: ?radius: float * ?height: float * ?radiusRange: float * ?directionRandomizer: float -> CylinderParticleEmitter
        /// <summary>Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)</summary>
        /// <param name="radius">The radius of the cylinder to emit from</param>
        /// <param name="height">The height of the emission cylinder</param>
        /// <param name="radiusRange">the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)</param>
        /// <param name="direction1">Particles are emitted between the direction1 and direction2 from within the cylinder</param>
        /// <param name="direction2">Particles are emitted between the direction1 and direction2 from within the cylinder</param>
        abstract createDirectedCylinderEmitter: ?radius: float * ?height: float * ?radiusRange: float * ?direction1: Vector3 * ?direction2: Vector3 -> CylinderDirectedParticleEmitter
        /// <summary>Creates a Cone Emitter for the particle system (emits from the cone to the particle position)</summary>
        /// <param name="radius">The radius of the cone to emit from</param>
        /// <param name="angle">The base angle of the cone</param>
        abstract createConeEmitter: ?radius: float * ?angle: float -> ConeParticleEmitter
        /// <summary>Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)</summary>
        /// <param name="direction1">Particles are emitted between the direction1 and direction2 from within the box</param>
        /// <param name="direction2">Particles are emitted between the direction1 and direction2 from within the box</param>
        /// <param name="minEmitBox">Particles are emitted from the box between minEmitBox and maxEmitBox</param>
        /// <param name="maxEmitBox">Particles are emitted from the box between minEmitBox and maxEmitBox</param>
        abstract createBoxEmitter: direction1: Vector3 * direction2: Vector3 * minEmitBox: Vector3 * maxEmitBox: Vector3 -> BoxParticleEmitter

    /// This represents the base class for particle system in Babylon.
    /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
    /// Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
    type [<AllowNullLiteral>] BaseParticleSystemStatic =
        /// Source color is added to the destination color without alpha affecting the result
        abstract BLENDMODE_ONEONE: float with get, set
        /// Blend current color and particle color using particles alpha
        abstract BLENDMODE_STANDARD: float with get, set
        /// Add current color and particle color multiplied by particles alpha
        abstract BLENDMODE_ADD: float with get, set
        /// Multiply current color with particle color
        abstract BLENDMODE_MULTIPLY: float with get, set
        /// Multiply current color with particle color then add current color and particle color multiplied by particles alpha
        abstract BLENDMODE_MULTIPLYADD: float with get, set
        /// <summary>Instantiates a particle system.
        /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.</summary>
        /// <param name="name">The name of the particle system</param>
        [<Emit "new $0($1...)">] abstract Create: name: string -> BaseParticleSystem

    /// This represents a GPU particle system in Babylon
    /// This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data
    type [<AllowNullLiteral>] GPUParticleSystem =
        inherit BaseParticleSystem
        inherit IDisposable
        inherit IParticleSystem
        inherit IAnimatable
        /// The layer mask we are rendering the particles through.
        abstract layerMask: float with get, set
        /// An event triggered when the system is disposed.
        abstract onDisposeObservable: Observable<GPUParticleSystem> with get, set
        /// Gets the maximum number of particles active at the same time.
        abstract getCapacity: unit -> float
        /// Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
        /// to override the particles.
        abstract forceDepthWrite: bool with get, set
        /// Gets or set the number of active particles
        abstract activeParticleCount: float with get, set
        /// Is this system ready to be used/rendered
        abstract isReady: unit -> bool
        /// Gets if the system has been started. (Note: this will still be true after stop is called)
        abstract isStarted: unit -> bool
        /// <summary>Starts the particle system and begins to emit</summary>
        /// <param name="delay">defines the delay in milliseconds before starting the system (this.startDelay by default)</param>
        abstract start: ?delay: float -> unit
        /// Stops the particle system.
        abstract stop: unit -> unit
        /// Remove all active particles
        abstract reset: unit -> unit
        /// Returns the string "GPUParticleSystem"
        abstract getClassName: unit -> string
        abstract _removeGradientAndTexture: gradient: float * gradients: Nullable<ResizeArray<IValueGradient>> * texture: RawTexture -> BaseParticleSystem
        /// <summary>Adds a new color gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="color1">defines the color to affect to the specified gradient</param>
        /// <param name="color2">defines an additional color used to define a range ([color, color2]) with main color to pick the final color from</param>
        abstract addColorGradient: gradient: float * color1: Color4 * ?color2: Color4 -> GPUParticleSystem
        /// <summary>Remove a specific color gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeColorGradient: gradient: float -> GPUParticleSystem
        /// <summary>Adds a new size gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the size factor to affect to the specified gradient</param>
        abstract addSizeGradient: gradient: float * factor: float -> GPUParticleSystem
        /// <summary>Remove a specific size gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeSizeGradient: gradient: float -> GPUParticleSystem
        /// <summary>Adds a new angular speed gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the angular speed to affect to the specified gradient</param>
        abstract addAngularSpeedGradient: gradient: float * factor: float -> GPUParticleSystem
        /// <summary>Remove a specific angular speed gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeAngularSpeedGradient: gradient: float -> GPUParticleSystem
        /// <summary>Adds a new velocity gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the velocity to affect to the specified gradient</param>
        abstract addVelocityGradient: gradient: float * factor: float -> GPUParticleSystem
        /// <summary>Remove a specific velocity gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeVelocityGradient: gradient: float -> GPUParticleSystem
        /// <summary>Adds a new limit velocity gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the limit velocity value to affect to the specified gradient</param>
        abstract addLimitVelocityGradient: gradient: float * factor: float -> GPUParticleSystem
        /// <summary>Remove a specific limit velocity gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeLimitVelocityGradient: gradient: float -> GPUParticleSystem
        /// <summary>Adds a new drag gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the drag value to affect to the specified gradient</param>
        abstract addDragGradient: gradient: float * factor: float -> GPUParticleSystem
        /// <summary>Remove a specific drag gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeDragGradient: gradient: float -> GPUParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the emit rate value to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addEmitRateGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeEmitRateGradient: gradient: float -> IParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the start size value to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addStartSizeGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeStartSizeGradient: gradient: float -> IParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="min">defines the color remap minimal range</param>
        /// <param name="max">defines the color remap maximal range</param>
        abstract addColorRemapGradient: gradient: float * min: float * max: float -> IParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeColorRemapGradient: gradient: float -> IParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="min">defines the alpha remap minimal range</param>
        /// <param name="max">defines the alpha remap maximal range</param>
        abstract addAlphaRemapGradient: gradient: float * min: float * max: float -> IParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeAlphaRemapGradient: gradient: float -> IParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="color">defines the color to affect to the specified gradient</param>
        abstract addRampGradient: gradient: float * color: Color3 -> IParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeRampGradient: gradient: float -> IParticleSystem
        /// Not supported by GPUParticleSystem
        abstract getRampGradients: unit -> Nullable<Array<Color3Gradient>>
        /// Not supported by GPUParticleSystem
        /// Gets or sets a boolean indicating that ramp gradients must be used
        abstract useRampGradients: bool with get, set
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the life time factor to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addLifeTimeGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Not supported by GPUParticleSystem</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeLifeTimeGradient: gradient: float -> IParticleSystem
        abstract _reset: unit -> unit
        abstract _recreateUpdateEffect: unit -> unit
        abstract _recreateRenderEffect: unit -> unit
        /// <summary>Animates the particle system for the current frame by emitting new particles and or animating the living ones.</summary>
        /// <param name="preWarm">defines if we are in the pre-warmimg phase</param>
        abstract animate: ?preWarm: bool -> unit
        /// <summary>Renders the particle system in its current state</summary>
        /// <param name="preWarm">defines if the system should only update the particles but not render them</param>
        abstract render: ?preWarm: bool -> float
        /// Rebuilds the particle system
        abstract rebuild: unit -> unit
        /// <summary>Disposes the particle system and free the associated resources</summary>
        /// <param name="disposeTexture">defines if the particule texture must be disposed as well (true by default)</param>
        abstract dispose: ?disposeTexture: bool -> unit
        /// <summary>Clones the particle system.</summary>
        /// <param name="name">The name of the cloned object</param>
        /// <param name="newEmitter">The new emitter to use</param>
        abstract clone: name: string * newEmitter: obj option -> GPUParticleSystem
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option

    /// This represents a GPU particle system in Babylon
    /// This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data
    type [<AllowNullLiteral>] GPUParticleSystemStatic =
        /// Gets a boolean indicating if the GPU particles can be rendered on current browser
        abstract IsSupported: bool
        /// <summary>Instantiates a GPU particle system.
        /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.</summary>
        /// <param name="name">The name of the particle system</param>
        /// <param name="options">The options used to create the system</param>
        /// <param name="scene">The scene the particle system belongs to</param>
        /// <param name="isAnimationSheetEnabled">Must be true if using a spritesheet to animate the particles texture</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: obj * scene: Scene * ?isAnimationSheetEnabled: bool -> GPUParticleSystem
        /// <summary>Parses a JSON object to create a GPU particle system.</summary>
        /// <param name="parsedParticleSystem">The JSON object to parse</param>
        /// <param name="scene">The scene to create the particle system in</param>
        /// <param name="rootUrl">The root url to use to load external dependencies like texture</param>
        /// <param name="doNotStart">Ignore the preventAutoStart attribute and does not start</param>
        abstract Parse: parsedParticleSystem: obj option * scene: Scene * rootUrl: string * ?doNotStart: bool -> GPUParticleSystem

    /// Interface representing a particle system in Babylon.js.
    /// This groups the common functionalities that needs to be implemented in order to create a particle system.
    /// A particle system represents a way to manage particles from their emission to their animation and rendering.
    type [<AllowNullLiteral>] IParticleSystem =
        /// List of animations used by the particle system.
        abstract animations: ResizeArray<Animation> with get, set
        /// The id of the Particle system.
        abstract id: string with get, set
        /// The name of the Particle system.
        abstract name: string with get, set
        /// The emitter represents the Mesh or position we are attaching the particle system to.
        abstract emitter: Nullable<U2<AbstractMesh, Vector3>> with get, set
        /// Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
        abstract isBillboardBased: bool with get, set
        /// The rendering group used by the Particle system to chose when to render.
        abstract renderingGroupId: float with get, set
        /// The layer mask we are rendering the particles through.
        abstract layerMask: float with get, set
        /// The overall motion speed (0.01 is default update speed, faster updates = faster animation)
        abstract updateSpeed: float with get, set
        /// The amount of time the particle system is running (depends of the overall update speed).
        abstract targetStopDuration: float with get, set
        /// The texture used to render each particle. (this can be a spritesheet)
        abstract particleTexture: Nullable<Texture> with get, set
        /// Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE, ParticleSystem.BLENDMODE_STANDARD or ParticleSystem.BLENDMODE_ADD.
        abstract blendMode: float with get, set
        /// Minimum life time of emitting particles.
        abstract minLifeTime: float with get, set
        /// Maximum life time of emitting particles.
        abstract maxLifeTime: float with get, set
        /// Minimum Size of emitting particles.
        abstract minSize: float with get, set
        /// Maximum Size of emitting particles.
        abstract maxSize: float with get, set
        /// Minimum scale of emitting particles on X axis.
        abstract minScaleX: float with get, set
        /// Maximum scale of emitting particles on X axis.
        abstract maxScaleX: float with get, set
        /// Minimum scale of emitting particles on Y axis.
        abstract minScaleY: float with get, set
        /// Maximum scale of emitting particles on Y axis.
        abstract maxScaleY: float with get, set
        /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
        abstract color1: Color4 with get, set
        /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
        abstract color2: Color4 with get, set
        /// Color the particle will have at the end of its lifetime.
        abstract colorDead: Color4 with get, set
        /// The maximum number of particles to emit per frame until we reach the activeParticleCount value
        abstract emitRate: float with get, set
        /// You can use gravity if you want to give an orientation to your particles.
        abstract gravity: Vector3 with get, set
        /// Minimum power of emitting particles.
        abstract minEmitPower: float with get, set
        /// Maximum power of emitting particles.
        abstract maxEmitPower: float with get, set
        /// Minimum angular speed of emitting particles (Z-axis rotation for each particle).
        abstract minAngularSpeed: float with get, set
        /// Maximum angular speed of emitting particles (Z-axis rotation for each particle).
        abstract maxAngularSpeed: float with get, set
        /// Gets or sets the minimal initial rotation in radians.
        abstract minInitialRotation: float with get, set
        /// Gets or sets the maximal initial rotation in radians.
        abstract maxInitialRotation: float with get, set
        /// The particle emitter type defines the emitter used by the particle system.
        /// It can be for example box, sphere, or cone...
        abstract particleEmitterType: Nullable<IParticleEmitterType> with get, set
        /// Defines the delay in milliseconds before starting the system (0 by default)
        abstract startDelay: float with get, set
        /// Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0
        abstract preWarmCycles: float with get, set
        /// Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1)
        abstract preWarmStepOffset: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)
        abstract spriteCellChangeSpeed: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display
        abstract startSpriteCellID: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display
        abstract endSpriteCellID: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use
        abstract spriteCellWidth: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use
        abstract spriteCellHeight: float with get, set
        /// This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID
        abstract spriteRandomStartCell: bool with get, set
        /// Gets or sets a boolean indicating if a spritesheet is used to animate the particles texture
        abstract isAnimationSheetEnabled: bool with get, set
        /// Gets or sets a Vector2 used to move the pivot (by default (0,0)) 
        abstract translationPivot: Vector2 with get, set
        /// Gets or sets a texture used to add random noise to particle positions
        abstract noiseTexture: Nullable<BaseTexture> with get, set
        /// Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) 
        abstract noiseStrength: Vector3 with get, set
        /// Gets or sets the billboard mode to use when isBillboardBased = true.
        /// Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
        abstract billboardMode: float with get, set
        /// Gets or sets a value indicating the damping to apply if the limit velocity factor is reached 
        abstract limitVelocityDamping: float with get, set
        /// Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called
        abstract beginAnimationOnStart: bool with get, set
        /// Gets or sets the frame to start the animation from when beginAnimationOnStart is true
        abstract beginAnimationFrom: float with get, set
        /// Gets or sets the frame to end the animation on when beginAnimationOnStart is true
        abstract beginAnimationTo: float with get, set
        /// Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true
        abstract beginAnimationLoop: bool with get, set
        /// Specifies whether the particle system will be disposed once it reaches the end of the animation.
        abstract disposeOnStop: bool with get, set
        /// Gets the maximum number of particles active at the same time.
        abstract getCapacity: unit -> float
        /// Gets if the system has been started. (Note: this will still be true after stop is called)
        abstract isStarted: unit -> bool
        /// Animates the particle system for this frame.
        abstract animate: unit -> unit
        /// Renders the particle system in its current state.
        abstract render: unit -> float
        /// <summary>Dispose the particle system and frees its associated resources.</summary>
        /// <param name="disposeTexture">defines if the particule texture must be disposed as well (true by default)</param>
        abstract dispose: ?disposeTexture: bool -> unit
        /// <summary>Clones the particle system.</summary>
        /// <param name="name">The name of the cloned object</param>
        /// <param name="newEmitter">The new emitter to use</param>
        abstract clone: name: string * newEmitter: obj option -> Nullable<IParticleSystem>
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// Rebuild the particle system
        abstract rebuild: unit -> unit
        /// <summary>Starts the particle system and begins to emit</summary>
        /// <param name="delay">defines the delay in milliseconds before starting the system (0 by default)</param>
        abstract start: ?delay: float -> unit
        /// Stops the particle system.
        abstract stop: unit -> unit
        /// Remove all active particles
        abstract reset: unit -> unit
        /// Is this system ready to be used/rendered
        abstract isReady: unit -> bool
        /// <summary>Adds a new color gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="color1">defines the color to affect to the specified gradient</param>
        /// <param name="color2">defines an additional color used to define a range ([color, color2]) with main color to pick the final color from</param>
        abstract addColorGradient: gradient: float * color1: Color4 * ?color2: Color4 -> IParticleSystem
        /// <summary>Remove a specific color gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeColorGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new size gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the size factor to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addSizeGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific size gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeSizeGradient: gradient: float -> IParticleSystem
        /// Gets the current list of color gradients.
        /// You must use addColorGradient and removeColorGradient to udpate this list
        abstract getColorGradients: unit -> Nullable<Array<ColorGradient>>
        /// Gets the current list of size gradients.
        /// You must use addSizeGradient and removeSizeGradient to udpate this list
        abstract getSizeGradients: unit -> Nullable<Array<FactorGradient>>
        /// Gets the current list of angular speed gradients.
        /// You must use addAngularSpeedGradient and removeAngularSpeedGradient to udpate this list
        abstract getAngularSpeedGradients: unit -> Nullable<Array<FactorGradient>>
        /// <summary>Adds a new angular speed gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the angular speed to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addAngularSpeedGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific angular speed gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeAngularSpeedGradient: gradient: float -> IParticleSystem
        /// Gets the current list of velocity gradients.
        /// You must use addVelocityGradient and removeVelocityGradient to udpate this list
        abstract getVelocityGradients: unit -> Nullable<Array<FactorGradient>>
        /// <summary>Adds a new velocity gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the velocity to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addVelocityGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific velocity gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeVelocityGradient: gradient: float -> IParticleSystem
        /// Gets the current list of limit velocity gradients.
        /// You must use addLimitVelocityGradient and removeLimitVelocityGradient to udpate this list
        abstract getLimitVelocityGradients: unit -> Nullable<Array<FactorGradient>>
        /// <summary>Adds a new limit velocity gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the limit velocity to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addLimitVelocityGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific limit velocity gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeLimitVelocityGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new drag gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the drag to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addDragGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific drag gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeDragGradient: gradient: float -> IParticleSystem
        /// Gets the current list of drag gradients.
        /// You must use addDragGradient and removeDragGradient to udpate this list
        abstract getDragGradients: unit -> Nullable<Array<FactorGradient>>
        /// <summary>Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the emit rate to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addEmitRateGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific emit rate gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeEmitRateGradient: gradient: float -> IParticleSystem
        /// Gets the current list of emit rate gradients.
        /// You must use addEmitRateGradient and removeEmitRateGradient to udpate this list
        abstract getEmitRateGradients: unit -> Nullable<Array<FactorGradient>>
        /// <summary>Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the start size to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addStartSizeGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific start size gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeStartSizeGradient: gradient: float -> IParticleSystem
        /// Gets the current list of start size gradients.
        /// You must use addStartSizeGradient and removeStartSizeGradient to udpate this list
        abstract getStartSizeGradients: unit -> Nullable<Array<FactorGradient>>
        /// <summary>Adds a new life time gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the life time factor to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addLifeTimeGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific life time gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeLifeTimeGradient: gradient: float -> IParticleSystem
        /// Gets the current list of life time gradients.
        /// You must use addLifeTimeGradient and removeLifeTimeGradient to udpate this list
        abstract getLifeTimeGradients: unit -> Nullable<Array<FactorGradient>>
        /// <summary>Adds a new ramp gradient used to remap particle colors</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="color">defines the color to affect to the specified gradient</param>
        abstract addRampGradient: gradient: float * color: Color3 -> IParticleSystem
        /// Gets the current list of ramp gradients.
        /// You must use addRampGradient and removeRampGradient to udpate this list
        abstract getRampGradients: unit -> Nullable<Array<Color3Gradient>>
        /// Gets or sets a boolean indicating that ramp gradients must be used
        abstract useRampGradients: bool with get, set
        /// <summary>Adds a new color remap gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="min">defines the color remap minimal range</param>
        /// <param name="max">defines the color remap maximal range</param>
        abstract addColorRemapGradient: gradient: float * min: float * max: float -> IParticleSystem
        /// Gets the current list of color remap gradients.
        /// You must use addColorRemapGradient and removeColorRemapGradient to udpate this list
        abstract getColorRemapGradients: unit -> Nullable<Array<FactorGradient>>
        /// <summary>Adds a new alpha remap gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="min">defines the alpha remap minimal range</param>
        /// <param name="max">defines the alpha remap maximal range</param>
        abstract addAlphaRemapGradient: gradient: float * min: float * max: float -> IParticleSystem
        /// Gets the current list of alpha remap gradients.
        /// You must use addAlphaRemapGradient and removeAlphaRemapGradient to udpate this list
        abstract getAlphaRemapGradients: unit -> Nullable<Array<FactorGradient>>
        /// <summary>Creates a Point Emitter for the particle system (emits directly from the emitter position)</summary>
        /// <param name="direction1">Particles are emitted between the direction1 and direction2 from within the box</param>
        /// <param name="direction2">Particles are emitted between the direction1 and direction2 from within the box</param>
        abstract createPointEmitter: direction1: Vector3 * direction2: Vector3 -> PointParticleEmitter
        /// <summary>Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)</summary>
        /// <param name="radius">The radius of the hemisphere to emit from</param>
        /// <param name="radiusRange">The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius</param>
        abstract createHemisphericEmitter: radius: float * radiusRange: float -> HemisphericParticleEmitter
        /// <summary>Creates a Sphere Emitter for the particle system (emits along the sphere radius)</summary>
        /// <param name="radius">The radius of the sphere to emit from</param>
        /// <param name="radiusRange">The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius</param>
        abstract createSphereEmitter: radius: float * radiusRange: float -> SphereParticleEmitter
        /// <summary>Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)</summary>
        /// <param name="radius">The radius of the sphere to emit from</param>
        /// <param name="direction1">Particles are emitted between the direction1 and direction2 from within the sphere</param>
        /// <param name="direction2">Particles are emitted between the direction1 and direction2 from within the sphere</param>
        abstract createDirectedSphereEmitter: radius: float * direction1: Vector3 * direction2: Vector3 -> SphereDirectedParticleEmitter
        /// <summary>Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)</summary>
        /// <param name="radius">The radius of the emission cylinder</param>
        /// <param name="height">The height of the emission cylinder</param>
        /// <param name="radiusRange">The range of emission [0-1] 0 Surface only, 1 Entire Radius</param>
        /// <param name="directionRandomizer">How much to randomize the particle direction [0-1]</param>
        abstract createCylinderEmitter: radius: float * height: float * radiusRange: float * directionRandomizer: float -> CylinderParticleEmitter
        /// <summary>Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)</summary>
        /// <param name="radius">The radius of the cylinder to emit from</param>
        /// <param name="height">The height of the emission cylinder</param>
        /// <param name="radiusRange">the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)</param>
        /// <param name="direction1">Particles are emitted between the direction1 and direction2 from within the cylinder</param>
        /// <param name="direction2">Particles are emitted between the direction1 and direction2 from within the cylinder</param>
        abstract createDirectedCylinderEmitter: radius: float * height: float * radiusRange: float * direction1: Vector3 * direction2: Vector3 -> SphereDirectedParticleEmitter
        /// <summary>Creates a Cone Emitter for the particle system (emits from the cone to the particle position)</summary>
        /// <param name="radius">The radius of the cone to emit from</param>
        /// <param name="angle">The base angle of the cone</param>
        abstract createConeEmitter: radius: float * angle: float -> ConeParticleEmitter
        /// <summary>Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)</summary>
        /// <param name="direction1">Particles are emitted between the direction1 and direction2 from within the box</param>
        /// <param name="direction2">Particles are emitted between the direction1 and direction2 from within the box</param>
        /// <param name="minEmitBox">Particles are emitted from the box between minEmitBox and maxEmitBox</param>
        /// <param name="maxEmitBox">Particles are emitted from the box between minEmitBox and maxEmitBox</param>
        abstract createBoxEmitter: direction1: Vector3 * direction2: Vector3 * minEmitBox: Vector3 * maxEmitBox: Vector3 -> BoxParticleEmitter
        /// Get hosting scene
        abstract getScene: unit -> Scene

    /// A particle represents one of the element emitted by a particle system.
    /// This is mainly define by its coordinates, direction, velocity and age.
    type [<AllowNullLiteral>] Particle =
        /// The particle system the particle belongs to.
        abstract particleSystem: ParticleSystem with get, set
        /// Unique ID of the particle
        abstract id: float with get, set
        /// The world position of the particle in the scene.
        abstract position: Vector3 with get, set
        /// The world direction of the particle in the scene.
        abstract direction: Vector3 with get, set
        /// The color of the particle.
        abstract color: Color4 with get, set
        /// The color change of the particle per step.
        abstract colorStep: Color4 with get, set
        /// Defines how long will the life of the particle be.
        abstract lifeTime: float with get, set
        /// The current age of the particle.
        abstract age: float with get, set
        /// The current size of the particle.
        abstract size: float with get, set
        /// The current scale of the particle.
        abstract scale: Vector2 with get, set
        /// The current angle of the particle.
        abstract angle: float with get, set
        /// Defines how fast is the angle changing.
        abstract angularSpeed: float with get, set
        /// Defines the cell index used by the particle to be rendered from a sprite.
        abstract cellIndex: float with get, set
        /// The information required to support color remapping
        abstract remapData: Vector4 with get, set
        abstract _randomCellOffset: float option with get, set
        abstract _initialDirection: Nullable<Vector3> with get, set
        abstract _attachedSubEmitters: Nullable<Array<SubEmitter>> with get, set
        abstract _initialStartSpriteCellID: float with get, set
        abstract _initialEndSpriteCellID: float with get, set
        abstract _currentColorGradient: Nullable<ColorGradient> with get, set
        abstract _currentColor1: Color4 with get, set
        abstract _currentColor2: Color4 with get, set
        abstract _currentSizeGradient: Nullable<FactorGradient> with get, set
        abstract _currentSize1: float with get, set
        abstract _currentSize2: float with get, set
        abstract _currentAngularSpeedGradient: Nullable<FactorGradient> with get, set
        abstract _currentAngularSpeed1: float with get, set
        abstract _currentAngularSpeed2: float with get, set
        abstract _currentVelocityGradient: Nullable<FactorGradient> with get, set
        abstract _currentVelocity1: float with get, set
        abstract _currentVelocity2: float with get, set
        abstract _currentLimitVelocityGradient: Nullable<FactorGradient> with get, set
        abstract _currentLimitVelocity1: float with get, set
        abstract _currentLimitVelocity2: float with get, set
        abstract _currentDragGradient: Nullable<FactorGradient> with get, set
        abstract _currentDrag1: float with get, set
        abstract _currentDrag2: float with get, set
        abstract _randomNoiseCoordinates1: Vector3 with get, set
        abstract _randomNoiseCoordinates2: Vector3 with get, set
        /// Defines how the sprite cell index is updated for the particle
        abstract updateCellIndex: unit -> unit
        abstract _inheritParticleInfoToSubEmitter: subEmitter: SubEmitter -> unit
        abstract _inheritParticleInfoToSubEmitters: unit -> unit
        abstract _reset: unit -> unit
        /// <summary>Copy the properties of particle to another one.</summary>
        /// <param name="other">the particle to copy the information to.</param>
        abstract copyTo: other: Particle -> unit

    /// A particle represents one of the element emitted by a particle system.
    /// This is mainly define by its coordinates, direction, velocity and age.
    type [<AllowNullLiteral>] ParticleStatic =
        /// <summary>Creates a new instance Particle</summary>
        /// <param name="particleSystem">the particle system the particle belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: particleSystem: ParticleSystem -> Particle

    /// This class is made for on one-liner static method to help creating particle system set.
    type [<AllowNullLiteral>] ParticleHelper =
        interface end

    /// This class is made for on one-liner static method to help creating particle system set.
    type [<AllowNullLiteral>] ParticleHelperStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ParticleHelper
        /// Gets or sets base Assets URL
        abstract BaseAssetsUrl: string with get, set
        /// <summary>Create a default particle system that you can tweak</summary>
        /// <param name="emitter">defines the emitter to use</param>
        /// <param name="capacity">defines the system capacity (default is 500 particles)</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="useGPU">defines if a GPUParticleSystem must be created (default is false)</param>
        abstract CreateDefault: emitter: Nullable<U2<AbstractMesh, Vector3>> * ?capacity: float * ?scene: Scene * ?useGPU: bool -> IParticleSystem
        /// <summary>This is the main static method (one-liner) of this helper to create different particle systems</summary>
        /// <param name="type">This string represents the type to the particle system to create</param>
        /// <param name="scene">The scene where the particle system should live</param>
        /// <param name="gpu">If the system will use gpu</param>
        abstract CreateAsync: ``type``: string * scene: Nullable<Scene> * ?gpu: bool -> Promise<ParticleSystemSet>
        /// <summary>Static function used to export a particle system to a ParticleSystemSet variable.
        /// Please note that the emitter shape is not exported</summary>
        /// <param name="systems">defines the particle systems to export</param>
        abstract ExportSet: systems: ResizeArray<IParticleSystem> -> ParticleSystemSet

    /// This represents a particle system in Babylon.
    /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
    /// Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
    type [<AllowNullLiteral>] ParticleSystem =
        inherit BaseParticleSystem
        inherit IDisposable
        inherit IAnimatable
        inherit IParticleSystem
        /// This function can be defined to provide custom update for active particles.
        /// This function will be called instead of regular update (age, position, color, etc.).
        /// Do not forget that this function will be called on every frame so try to keep it simple and fast :)
        abstract updateFunction: (ResizeArray<Particle> -> unit) with get, set
        /// This function can be defined to specify initial direction for every new particle.
        /// It by default use the emitterType defined function
        abstract startDirectionFunction: (Matrix -> Vector3 -> Particle -> unit) with get, set
        /// This function can be defined to specify initial position for every new particle.
        /// It by default use the emitterType defined function
        abstract startPositionFunction: (Matrix -> Vector3 -> Particle -> unit) with get, set
        abstract _inheritedVelocityOffset: Vector3 with get, set
        /// An event triggered when the system is disposed
        abstract onDisposeObservable: Observable<ParticleSystem> with get, set
        /// Sets a callback that will be triggered when the system is disposed
        abstract onDispose: (unit -> unit) with get, set
        abstract _currentEmitRateGradient: Nullable<FactorGradient> with get, set
        abstract _currentEmitRate1: float with get, set
        abstract _currentEmitRate2: float with get, set
        abstract _currentStartSizeGradient: Nullable<FactorGradient> with get, set
        abstract _currentStartSize1: float with get, set
        abstract _currentStartSize2: float with get, set
        /// Gets or sets a boolean indicating that ramp gradients must be used
        abstract useRampGradients: bool with get, set
        /// The Sub-emitters templates that will be used to generate the sub particle system to be associated with the system, this property is used by the root particle system only.
        /// When a particle is spawned, an array will be chosen at random and all the emitters in that array will be attached to the particle.  (Default: [])
        abstract subEmitters: Array<U3<ParticleSystem, SubEmitter, Array<SubEmitter>>> with get, set
        abstract _disposeEmitterOnDispose: bool with get, set
        /// The current active Sub-systems, this property is used by the root particle system only.
        abstract activeSubSystems: Array<ParticleSystem> with get, set
        /// Gets the current list of active particles
        abstract particles: ResizeArray<Particle>
        /// Returns the string "ParticleSystem"
        abstract getClassName: unit -> string
        /// <summary>Adds a new life time gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the life time factor to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addLifeTimeGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific life time gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeLifeTimeGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new size gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the size factor to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addSizeGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific size gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeSizeGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new color remap gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="min">defines the color remap minimal range</param>
        /// <param name="max">defines the color remap maximal range</param>
        abstract addColorRemapGradient: gradient: float * min: float * max: float -> IParticleSystem
        /// <summary>Remove a specific color remap gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeColorRemapGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new alpha remap gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="min">defines the alpha remap minimal range</param>
        /// <param name="max">defines the alpha remap maximal range</param>
        abstract addAlphaRemapGradient: gradient: float * min: float * max: float -> IParticleSystem
        /// <summary>Remove a specific alpha remap gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeAlphaRemapGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new angular speed gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the angular speed  to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addAngularSpeedGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific angular speed gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeAngularSpeedGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new velocity gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the velocity to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addVelocityGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific velocity gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeVelocityGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new limit velocity gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the limit velocity value to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addLimitVelocityGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific limit velocity gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeLimitVelocityGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new drag gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the drag value to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addDragGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific drag gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeDragGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the emit rate value to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addEmitRateGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific emit rate gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeEmitRateGradient: gradient: float -> IParticleSystem
        /// <summary>Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="factor">defines the start size value to affect to the specified gradient</param>
        /// <param name="factor2">defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from</param>
        abstract addStartSizeGradient: gradient: float * factor: float * ?factor2: float -> IParticleSystem
        /// <summary>Remove a specific start size gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeStartSizeGradient: gradient: float -> IParticleSystem
        /// Gets the current list of ramp gradients.
        /// You must use addRampGradient and removeRampGradient to udpate this list
        abstract getRampGradients: unit -> Nullable<Array<Color3Gradient>>
        /// <summary>Adds a new ramp gradient used to remap particle colors</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="color">defines the color to affect to the specified gradient</param>
        abstract addRampGradient: gradient: float * color: Color3 -> ParticleSystem
        /// <summary>Remove a specific ramp gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeRampGradient: gradient: float -> ParticleSystem
        /// <summary>Adds a new color gradient</summary>
        /// <param name="gradient">defines the gradient to use (between 0 and 1)</param>
        /// <param name="color1">defines the color to affect to the specified gradient</param>
        /// <param name="color2">defines an additional color used to define a range ([color, color2]) with main color to pick the final color from</param>
        abstract addColorGradient: gradient: float * color1: Color4 * ?color2: Color4 -> IParticleSystem
        /// <summary>Remove a specific color gradient</summary>
        /// <param name="gradient">defines the gradient to remove</param>
        abstract removeColorGradient: gradient: float -> IParticleSystem
        abstract _reset: unit -> unit
        /// Gets the maximum number of particles active at the same time.
        abstract getCapacity: unit -> float
        /// Gets whether there are still active particles in the system.
        abstract isAlive: unit -> bool
        /// Gets if the system has been started. (Note: this will still be true after stop is called)
        abstract isStarted: unit -> bool
        /// <summary>Starts the particle system and begins to emit</summary>
        /// <param name="delay">defines the delay in milliseconds before starting the system (this.startDelay by default)</param>
        abstract start: ?delay: float -> unit
        /// <summary>Stops the particle system.</summary>
        /// <param name="stopSubEmitters">if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.</param>
        abstract stop: ?stopSubEmitters: bool -> unit
        /// Remove all active particles
        abstract reset: unit -> unit
        abstract _appendParticleVertex: index: float * particle: Particle * offsetX: float * offsetY: float -> unit
        /// "Recycles" one of the particle by copying it back to the "stock" of particles and removing it from the active list.
        /// Its lifetime will start back at 0.
        abstract recycleParticle: (Particle -> unit) with get, set
        /// <summary>Animates the particle system for the current frame by emitting new particles and or animating the living ones.</summary>
        /// <param name="preWarmOnly">will prevent the system from updating the vertex buffer (default is false)</param>
        abstract animate: ?preWarmOnly: bool -> unit
        /// Rebuilds the particle system.
        abstract rebuild: unit -> unit
        /// Is this system ready to be used/rendered
        abstract isReady: unit -> bool
        /// Renders the particle system in its current state.
        abstract render: unit -> float
        /// <summary>Disposes the particle system and free the associated resources</summary>
        /// <param name="disposeTexture">defines if the particule texture must be disposed as well (true by default)</param>
        abstract dispose: ?disposeTexture: bool -> unit
        /// <summary>Clones the particle system.</summary>
        /// <param name="name">The name of the cloned object</param>
        /// <param name="newEmitter">The new emitter to use</param>
        abstract clone: name: string * newEmitter: obj option -> ParticleSystem
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option

    /// This represents a particle system in Babylon.
    /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
    /// Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
    type [<AllowNullLiteral>] ParticleSystemStatic =
        /// Billboard mode will only apply to Y axis
        abstract BILLBOARDMODE_Y: float
        /// Billboard mode will apply to all axes
        abstract BILLBOARDMODE_ALL: float
        /// Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction
        abstract BILLBOARDMODE_STRETCHED: float
        /// <summary>Instantiates a particle system.
        /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.</summary>
        /// <param name="name">The name of the particle system</param>
        /// <param name="capacity">The max number of particles alive at the same time</param>
        /// <param name="scene">The scene the particle system belongs to</param>
        /// <param name="customEffect">a custom effect used to change the way particles are rendered by default</param>
        /// <param name="isAnimationSheetEnabled">Must be true if using a spritesheet to animate the particles texture</param>
        /// <param name="epsilon">Offset used to render the particles</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * capacity: float * scene: Scene * ?customEffect: Effect * ?isAnimationSheetEnabled: bool * ?epsilon: float -> ParticleSystem
        abstract _GetAttributeNamesOrOptions: ?isAnimationSheetEnabled: bool * ?isBillboardBased: bool * ?useRampGradients: bool -> ResizeArray<string>
        abstract _GetEffectCreationOptions: ?isAnimationSheetEnabled: bool -> ResizeArray<string>
        abstract _Serialize: serializationObject: obj option * particleSystem: IParticleSystem -> unit
        abstract _Parse: parsedParticleSystem: obj option * particleSystem: IParticleSystem * scene: Scene * rootUrl: string -> unit
        /// <summary>Parses a JSON object to create a particle system.</summary>
        /// <param name="parsedParticleSystem">The JSON object to parse</param>
        /// <param name="scene">The scene to create the particle system in</param>
        /// <param name="rootUrl">The root url to use to load external dependencies like texture</param>
        /// <param name="doNotStart">Ignore the preventAutoStart attribute and does not start</param>
        abstract Parse: parsedParticleSystem: obj option * scene: Scene * rootUrl: string * ?doNotStart: bool -> ParticleSystem

    /// Represents a set of particle systems working together to create a specific effect
    type [<AllowNullLiteral>] ParticleSystemSet =
        inherit IDisposable
        /// Gets the particle system list
        abstract systems: ResizeArray<IParticleSystem> with get, set
        /// Gets the emitter node used with this set
        abstract emitterNode: Nullable<TransformNode>
        /// <summary>Creates a new emitter mesh as a sphere</summary>
        /// <param name="options">defines the options used to create the sphere</param>
        /// <param name="renderingGroupId">defines the renderingGroupId to use for the sphere</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract setEmitterAsSphere: options: ParticleSystemSetSetEmitterAsSphereOptions * renderingGroupId: float * scene: Scene -> unit
        /// <summary>Starts all particle systems of the set</summary>
        /// <param name="emitter">defines an optional mesh to use as emitter for the particle systems</param>
        abstract start: ?emitter: AbstractMesh -> unit
        /// Release all associated resources
        abstract dispose: unit -> unit
        /// Serialize the set into a JSON compatible object
        abstract serialize: unit -> obj option

    type [<AllowNullLiteral>] ParticleSystemSetSetEmitterAsSphereOptions =
        abstract diameter: float with get, set
        abstract segments: float with get, set
        abstract color: Color3 with get, set

    /// Represents a set of particle systems working together to create a specific effect
    type [<AllowNullLiteral>] ParticleSystemSetStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ParticleSystemSet
        /// <summary>Parse a new ParticleSystemSet from a serialized source</summary>
        /// <param name="data">defines a JSON compatible representation of the set</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="gpu">defines if we want GPU particles or CPU particles</param>
        abstract Parse: data: obj option * scene: Scene * ?gpu: bool -> ParticleSystemSet

    /// Represents one particle of a solid particle system.
    type [<AllowNullLiteral>] SolidParticle =
        /// particle global index
        abstract idx: float with get, set
        /// The color of the particle
        abstract color: Nullable<Color4> with get, set
        /// The world space position of the particle.
        abstract position: Vector3 with get, set
        /// The world space rotation of the particle. (Not use if rotationQuaternion is set)
        abstract rotation: Vector3 with get, set
        /// The world space rotation quaternion of the particle.
        abstract rotationQuaternion: Nullable<Quaternion> with get, set
        /// The scaling of the particle.
        abstract scaling: Vector3 with get, set
        /// The uvs of the particle.
        abstract uvs: Vector4 with get, set
        /// The current speed of the particle.
        abstract velocity: Vector3 with get, set
        /// The pivot point in the particle local space.
        abstract pivot: Vector3 with get, set
        /// Must the particle be translated from its pivot point in its local space ?
        /// In this case, the pivot point is set at the origin of the particle local space and the particle is translated.
        /// Default : false
        abstract translateFromPivot: bool with get, set
        /// Is the particle active or not ?
        abstract alive: bool with get, set
        /// Is the particle visible or not ?
        abstract isVisible: bool with get, set
        /// Index of this particle in the global "positions" array (Internal use)
        abstract _pos: float with get, set
        abstract _ind: float with get, set
        abstract _model: ModelShape with get, set
        /// ModelShape id of this particle
        abstract shapeId: float with get, set
        /// Index of the particle in its shape id (Internal use)
        abstract idxInShape: float with get, set
        abstract _modelBoundingInfo: BoundingInfo with get, set
        abstract _boundingInfo: BoundingInfo with get, set
        abstract _sps: SolidParticleSystem with get, set
        abstract _stillInvisible: bool with get, set
        abstract _rotationMatrix: ResizeArray<float> with get, set
        /// Parent particle Id, if any.
        /// Default null.
        abstract parentId: Nullable<float> with get, set
        abstract _globalPosition: Vector3 with get, set
        /// Legacy support, changed scale to scaling
        /// Legacy support, changed scale to scaling
        abstract scale: Vector3 with get, set
        /// Legacy support, changed quaternion to rotationQuaternion
        /// Legacy support, changed quaternion to rotationQuaternion
        abstract quaternion: Nullable<Quaternion> with get, set
        /// <summary>Returns a boolean. True if the particle intersects another particle or another mesh, else false.
        /// The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)</summary>
        /// <param name="target">is the object (solid particle or mesh) what the intersection is computed against.</param>
        abstract intersectsMesh: target: U2<Mesh, SolidParticle> -> bool

    /// Represents one particle of a solid particle system.
    type [<AllowNullLiteral>] SolidParticleStatic =
        /// <summary>Creates a Solid Particle object.
        /// Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()</summary>
        /// <param name="particleIndex">(integer) is the particle index in the Solid Particle System pool. It's also the particle identifier.</param>
        /// <param name="positionIndex">(integer) is the starting index of the particle vertices in the SPS "positions" array.</param>
        /// <param name="indiceIndex">(integer) is the starting index of the particle indices in the SPS "indices" array.</param>
        /// <param name="model">(ModelShape) is a reference to the model shape on what the particle is designed.</param>
        /// <param name="shapeId">(integer) is the model shape identifier in the SPS.</param>
        /// <param name="idxInShape">(integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))</param>
        /// <param name="modelBoundingInfo">is the reference to the model BoundingInfo used for intersection computations.</param>
        [<Emit "new $0($1...)">] abstract Create: particleIndex: float * positionIndex: float * indiceIndex: float * model: Nullable<ModelShape> * shapeId: float * idxInShape: float * sps: SolidParticleSystem * ?modelBoundingInfo: BoundingInfo -> SolidParticle

    /// Represents the shape of the model used by one particle of a solid particle system.
    /// SPS internal tool, don't use it manually.
    type [<AllowNullLiteral>] ModelShape =
        /// The shape id
        abstract shapeID: float with get, set
        /// flat array of model positions (internal use)
        abstract _shape: ResizeArray<Vector3> with get, set
        /// flat array of model UVs (internal use)
        abstract _shapeUV: ResizeArray<float> with get, set
        /// length of the shape in the model indices array (internal use)
        abstract _indicesLength: float with get, set
        /// Custom position function (internal use)
        abstract _positionFunction: Nullable<(SolidParticle -> float -> float -> unit)> with get, set
        /// Custom vertex function (internal use)
        abstract _vertexFunction: Nullable<(SolidParticle -> Vector3 -> float -> unit)> with get, set

    /// Represents the shape of the model used by one particle of a solid particle system.
    /// SPS internal tool, don't use it manually.
    type [<AllowNullLiteral>] ModelShapeStatic =
        /// Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.
        /// SPS internal tool, don't use it manually.
        [<Emit "new $0($1...)">] abstract Create: id: float * shape: ResizeArray<Vector3> * indicesLength: float * shapeUV: ResizeArray<float> * posFunction: Nullable<(SolidParticle -> float -> float -> unit)> * vtxFunction: Nullable<(SolidParticle -> Vector3 -> float -> unit)> -> ModelShape

    /// Represents a Depth Sorted Particle in the solid particle system.
    type [<AllowNullLiteral>] DepthSortedParticle =
        /// Index of the particle in the "indices" array
        abstract ind: float with get, set
        /// Length of the particle shape in the "indices" array
        abstract indicesLength: float with get, set
        /// Squared distance from the particle to the camera
        abstract sqDistance: float with get, set

    /// Represents a Depth Sorted Particle in the solid particle system.
    type [<AllowNullLiteral>] DepthSortedParticleStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> DepthSortedParticle

    /// The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.
    /// As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
    /// 
    /// The SPS is also a particle system. It provides some methods to manage the particles.
    /// However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
    /// 
    /// Full documentation here : http://doc.babylonjs.com/overviews/Solid_Particle_System
    type [<AllowNullLiteral>] SolidParticleSystem =
        inherit IDisposable
        /// The SPS array of Solid Particle objects. Just access each particle as with any classic array.
        /// Example : var p = SPS.particles[i];
        abstract particles: ResizeArray<SolidParticle> with get, set
        /// The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.
        abstract nbParticles: float with get, set
        /// If the particles must ever face the camera (default false). Useful for planar particles.
        abstract billboard: bool with get, set
        /// Recompute normals when adding a shape
        abstract recomputeNormals: bool with get, set
        /// This a counter ofr your own usage. It's not set by any SPS functions.
        abstract counter: float with get, set
        /// The SPS name. This name is also given to the underlying mesh.
        abstract name: string with get, set
        /// The SPS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.
        abstract mesh: Mesh with get, set
        /// This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.
        /// Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#garbage-collector-concerns
        abstract vars: obj option with get, set
        /// This array is populated when the SPS is set as 'pickable'.
        /// Each key of this array is a `faceId` value that you can get from a pickResult object.
        /// Each element of this array is an object `{idx: int, faceId: int}`.
        /// `idx` is the picked particle index in the `SPS.particles` array
        /// `faceId` is the picked face index counted within this particle.
        /// Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#pickable-particles
        abstract pickedParticles: ResizeArray<TypeLiteral_29> with get, set
        /// This array is populated when `enableDepthSort` is set to true.
        /// Each element of this array is an instance of the class DepthSortedParticle.
        abstract depthSortedParticles: ResizeArray<DepthSortedParticle> with get, set
        /// If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)
        abstract _bSphereOnly: bool with get, set
        /// A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)
        abstract _bSphereRadiusFactor: float with get, set
        /// Builds the SPS underlying mesh. Returns a standard Mesh.
        /// If no model shape was added to the SPS, the returned mesh is just a single triangular plane.
        abstract buildMesh: unit -> Mesh
        /// <summary>Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.
        /// These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.
        /// Thus the particles generated from `digest()` have their property `position` set yet.</summary>
        /// <param name="mesh">( Mesh ) is the mesh to be digested</param>
        /// <param name="options">(optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any
        /// {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets
        /// {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets</param>
        abstract digest: mesh: Mesh * ?options: SolidParticleSystemDigestOptions -> SolidParticleSystem
        /// <summary>Adds some particles to the SPS from the model shape. Returns the shape id.
        /// Please read the doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#create-an-immutable-sps</summary>
        /// <param name="mesh">is any Mesh object that will be used as a model for the solid particles.</param>
        /// <param name="nb">(positive integer) the number of particles to be created from this model</param>
        /// <param name="options">is an optional javascript function to called for each particle on SPS creation.
        /// {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation</param>
        abstract addShape: mesh: Mesh * nb: float * ?options: SolidParticleSystemAddShapeOptions -> float
        /// Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.
        abstract rebuildMesh: unit -> SolidParticleSystem
        /// <summary>Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.
        /// This method calls `updateParticle()` for each particle of the SPS.
        /// For an animated SPS, it is usually called within the render loop.</summary>
        /// <param name="start">The particle index in the particle array where to start to compute the particle property values _(default 0)_</param>
        /// <param name="end">The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_</param>
        /// <param name="update">If the mesh must be finally updated on this call after all the particle computations _(default true)_</param>
        abstract setParticles: ?start: float * ?``end``: float * ?update: bool -> SolidParticleSystem
        /// Disposes the SPS.
        abstract dispose: unit -> unit
        /// Visibilty helper : Recomputes the visible size according to the mesh bounding box
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
        abstract refreshVisibleSize: unit -> SolidParticleSystem
        /// <summary>Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.</summary>
        /// <param name="size">the size (float) of the visibility box
        /// note : this doesn't lock the SPS mesh bounding box.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility</param>
        abstract setVisibilityBox: size: float -> unit
        /// Gets whether the SPS as always visible or not
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
        /// Sets the SPS as always visible or not
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
        abstract isAlwaysVisible: bool with get, set
        /// Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
        /// Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
        abstract isVisibilityBoxLocked: bool with get, set
        /// Tells to `setParticles()` to compute the particle rotations or not.
        /// Default value : true. The SPS is faster when it's set to false.
        /// Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
        /// Gets if `setParticles()` computes the particle rotations or not.
        /// Default value : true. The SPS is faster when it's set to false.
        /// Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
        abstract computeParticleRotation: bool with get, set
        /// Tells to `setParticles()` to compute the particle colors or not.
        /// Default value : true. The SPS is faster when it's set to false.
        /// Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
        /// Gets if `setParticles()` computes the particle colors or not.
        /// Default value : true. The SPS is faster when it's set to false.
        /// Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
        abstract computeParticleColor: bool with get, set
        /// Gets if `setParticles()` computes the particle textures or not.
        /// Default value : true. The SPS is faster when it's set to false.
        /// Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.
        abstract computeParticleTexture: bool with get, set
        /// Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.
        /// Default value : false. The SPS is faster when it's set to false.
        /// Note : the particle custom vertex positions aren't stored values.
        /// Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.
        /// Default value : false. The SPS is faster when it's set to false.
        /// Note : the particle custom vertex positions aren't stored values.
        abstract computeParticleVertex: bool with get, set
        /// Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.
        /// Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.
        abstract computeBoundingBox: bool with get, set
        /// Tells to `setParticles()` to sort or not the distance between each particle and the camera.
        /// Skipped when `enableDepthSort` is set to `false` (default) at construction time.
        /// Default : `true`
        /// Gets if `setParticles()` sorts or not the distance between each particle and the camera.
        /// Skipped when `enableDepthSort` is set to `false` (default) at construction time.
        /// Default : `true`
        abstract depthSortParticles: bool with get, set
        /// This function does nothing. It may be overwritten to set all the particle first values.
        /// The SPS doesn't call this function, you may have to call it by your own.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
        abstract initParticles: unit -> unit
        /// <summary>This function does nothing. It may be overwritten to recycle a particle.
        /// The SPS doesn't call this function, you may have to call it by your own.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management</summary>
        /// <param name="particle">The particle to recycle</param>
        abstract recycleParticle: particle: SolidParticle -> SolidParticle
        /// <summary>Updates a particle : this function should  be overwritten by the user.
        /// It is called on each particle by `setParticles()`. This is the place to code each particle behavior.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management</summary>
        /// <param name="particle">The particle to update</param>
        abstract updateParticle: particle: SolidParticle -> SolidParticle
        /// <summary>Updates a vertex of a particle : it can be overwritten by the user.
        /// This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.</summary>
        /// <param name="particle">the current particle</param>
        /// <param name="vertex">the current index of the current particle</param>
        /// <param name="pt">the index of the current vertex in the particle shape
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#update-each-particle-shape</param>
        abstract updateParticleVertex: particle: SolidParticle * vertex: Vector3 * pt: float -> Vector3
        /// <summary>This will be called before any other treatment by `setParticles()` and will be passed three parameters.
        /// This does nothing and may be overwritten by the user.</summary>
        /// <param name="start">the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()</param>
        /// <param name="stop">the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()</param>
        /// <param name="update">the boolean update value actually passed to setParticles()</param>
        abstract beforeUpdateParticles: ?start: float * ?stop: float * ?update: bool -> unit
        /// <summary>This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.
        /// This will be passed three parameters.
        /// This does nothing and may be overwritten by the user.</summary>
        /// <param name="start">the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()</param>
        /// <param name="stop">the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()</param>
        /// <param name="update">the boolean update value actually passed to setParticles()</param>
        abstract afterUpdateParticles: ?start: float * ?stop: float * ?update: bool -> unit

    type [<AllowNullLiteral>] SolidParticleSystemDigestOptions =
        abstract facetNb: float option with get, set
        abstract number: float option with get, set
        abstract delta: float option with get, set

    type [<AllowNullLiteral>] SolidParticleSystemAddShapeOptions =
        abstract positionFunction: obj option with get, set
        abstract vertexFunction: obj option with get, set

    /// The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.
    /// As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
    /// 
    /// The SPS is also a particle system. It provides some methods to manage the particles.
    /// However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
    /// 
    /// Full documentation here : http://doc.babylonjs.com/overviews/Solid_Particle_System
    type [<AllowNullLiteral>] SolidParticleSystemStatic =
        /// <summary>Creates a SPS (Solid Particle System) object.</summary>
        /// <param name="name">(String) is the SPS name, this will be the underlying mesh name.</param>
        /// <param name="scene">(Scene) is the scene in which the SPS is added.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ?options: SolidParticleSystemStaticOptions -> SolidParticleSystem

    type [<AllowNullLiteral>] SolidParticleSystemStaticOptions =
        abstract updatable: bool option with get, set
        abstract isPickable: bool option with get, set
        abstract enableDepthSort: bool option with get, set
        abstract particleIntersection: bool option with get, set
        abstract boundingSphereOnly: bool option with get, set
        abstract bSphereRadiusFactor: float option with get, set

    type [<RequireQualifiedAccess>] SubEmitterType =
        | ATTACHED = 0
        | END = 1

    /// Sub emitter class used to emit particles from an existing particle
    type [<AllowNullLiteral>] SubEmitter =
        /// the particle system to be used by the sub emitter
        abstract particleSystem: ParticleSystem with get, set
        /// Type of the submitter (Default: END)
        abstract ``type``: SubEmitterType with get, set
        /// If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)
        /// Note: This only is supported when using an emitter of type Mesh
        abstract inheritDirection: bool with get, set
        /// How much of the attached particles speed should be added to the sub emitted particle (default: 0)
        abstract inheritedVelocityAmount: float with get, set
        /// Clones the sub emitter
        abstract clone: unit -> SubEmitter
        /// Serialize current object to a JSON object
        abstract serialize: unit -> obj option
        /// Release associated resources 
        abstract dispose: unit -> unit

    /// Sub emitter class used to emit particles from an existing particle
    type [<AllowNullLiteral>] SubEmitterStatic =
        /// <summary>Creates a sub emitter</summary>
        /// <param name="particleSystem">the particle system to be used by the sub emitter</param>
        [<Emit "new $0($1...)">] abstract Create: particleSystem: ParticleSystem -> SubEmitter
        /// <summary>Creates a new SubEmitter from a serialized JSON version</summary>
        /// <param name="serializationObject">defines the JSON object to read from</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="rootUrl">defines the rootUrl for data loading</param>
        abstract Parse: serializationObject: obj option * scene: Scene * rootUrl: string -> SubEmitter

    /// Interface used to describe a physics joint
    type [<AllowNullLiteral>] PhysicsImpostorJoint =
        /// Defines the main impostor to which the joint is linked 
        abstract mainImpostor: PhysicsImpostor with get, set
        /// Defines the impostor that is connected to the main impostor using this joint 
        abstract connectedImpostor: PhysicsImpostor with get, set
        /// Defines the joint itself 
        abstract joint: PhysicsJoint with get, set

    type [<AllowNullLiteral>] IPhysicsEnginePlugin =
        abstract world: obj option with get, set
        abstract name: string with get, set
        abstract setGravity: gravity: Vector3 -> unit
        abstract setTimeStep: timeStep: float -> unit
        abstract getTimeStep: unit -> float
        abstract executeStep: delta: float * impostors: Array<PhysicsImpostor> -> unit
        abstract applyImpulse: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract applyForce: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract generatePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract removePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract generateJoint: joint: PhysicsImpostorJoint -> unit
        abstract removeJoint: joint: PhysicsImpostorJoint -> unit
        abstract isSupported: unit -> bool
        abstract setTransformationFromPhysicsBody: impostor: PhysicsImpostor -> unit
        abstract setPhysicsBodyTransformation: impostor: PhysicsImpostor * newPosition: Vector3 * newRotation: Quaternion -> unit
        abstract setLinearVelocity: impostor: PhysicsImpostor * velocity: Nullable<Vector3> -> unit
        abstract setAngularVelocity: impostor: PhysicsImpostor * velocity: Nullable<Vector3> -> unit
        abstract getLinearVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract getAngularVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract setBodyMass: impostor: PhysicsImpostor * mass: float -> unit
        abstract getBodyMass: impostor: PhysicsImpostor -> float
        abstract getBodyFriction: impostor: PhysicsImpostor -> float
        abstract setBodyFriction: impostor: PhysicsImpostor * friction: float -> unit
        abstract getBodyRestitution: impostor: PhysicsImpostor -> float
        abstract setBodyRestitution: impostor: PhysicsImpostor * restitution: float -> unit
        abstract sleepBody: impostor: PhysicsImpostor -> unit
        abstract wakeUpBody: impostor: PhysicsImpostor -> unit
        abstract updateDistanceJoint: joint: PhysicsJoint * maxDistance: float * ?minDistance: float -> unit
        abstract setMotor: joint: IMotorEnabledJoint * speed: float * ?maxForce: float * ?motorIndex: float -> unit
        abstract setLimit: joint: IMotorEnabledJoint * upperLimit: float * ?lowerLimit: float * ?motorIndex: float -> unit
        abstract getRadius: impostor: PhysicsImpostor -> float
        abstract getBoxSizeToRef: impostor: PhysicsImpostor * result: Vector3 -> unit
        abstract syncMeshWithImpostor: mesh: AbstractMesh * impostor: PhysicsImpostor -> unit
        abstract dispose: unit -> unit

    /// Interface used to define a physics engine
    type [<AllowNullLiteral>] IPhysicsEngine =
        /// Gets the gravity vector used by the simulation
        abstract gravity: Vector3 with get, set
        /// <summary>Sets the gravity vector used by the simulation</summary>
        /// <param name="gravity">defines the gravity vector to use</param>
        abstract setGravity: gravity: Vector3 -> unit
        /// <summary>Set the time step of the physics engine.
        /// Default is 1/60.
        /// To slow it down, enter 1/600 for example.
        /// To speed it up, 1/30</summary>
        /// <param name="newTimeStep">the new timestep to apply to this world.</param>
        abstract setTimeStep: newTimeStep: float -> unit
        /// Get the time step of the physics engine.
        abstract getTimeStep: unit -> float
        /// Release all resources
        abstract dispose: unit -> unit
        /// Gets the name of the current physics plugin
        abstract getPhysicsPluginName: unit -> string
        /// <summary>Adding a new impostor for the impostor tracking.
        /// This will be done by the impostor itself.</summary>
        /// <param name="impostor">the impostor to add</param>
        abstract addImpostor: impostor: PhysicsImpostor -> unit
        /// <summary>Remove an impostor from the engine.
        /// This impostor and its mesh will not longer be updated by the physics engine.</summary>
        /// <param name="impostor">the impostor to remove</param>
        abstract removeImpostor: impostor: PhysicsImpostor -> unit
        /// <summary>Add a joint to the physics engine</summary>
        /// <param name="mainImpostor">defines the main impostor to which the joint is added.</param>
        /// <param name="connectedImpostor">defines the impostor that is connected to the main impostor using this joint</param>
        /// <param name="joint">defines the joint that will connect both impostors.</param>
        abstract addJoint: mainImpostor: PhysicsImpostor * connectedImpostor: PhysicsImpostor * joint: PhysicsJoint -> unit
        /// <summary>Removes a joint from the simulation</summary>
        /// <param name="mainImpostor">defines the impostor used with the joint</param>
        /// <param name="connectedImpostor">defines the other impostor connected to the main one by the joint</param>
        /// <param name="joint">defines the joint to remove</param>
        abstract removeJoint: mainImpostor: PhysicsImpostor * connectedImpostor: PhysicsImpostor * joint: PhysicsJoint -> unit
        /// Gets the current plugin used to run the simulation
        abstract getPhysicsPlugin: unit -> IPhysicsEnginePlugin
        /// Gets the list of physic impostors
        abstract getImpostors: unit -> Array<PhysicsImpostor>
        /// <summary>Gets the impostor for a physics enabled object</summary>
        /// <param name="object">defines the object impersonated by the impostor</param>
        abstract getImpostorForPhysicsObject: ``object``: IPhysicsEnabledObject -> Nullable<PhysicsImpostor>
        /// <summary>Gets the impostor for a physics body object</summary>
        /// <param name="body">defines physics body used by the impostor</param>
        abstract getImpostorWithPhysicsBody: body: obj option -> Nullable<PhysicsImpostor>
        /// <summary>Called by the scene. No need to call it.</summary>
        /// <param name="delta">defines the timespam between frames</param>
        abstract _step: delta: float -> unit

    /// Class used to control physics engine
    type [<AllowNullLiteral>] PhysicsEngine =
        inherit IPhysicsEngine
        /// Gets the gravity vector used by the simulation
        abstract gravity: Vector3 with get, set
        /// <summary>Sets the gravity vector used by the simulation</summary>
        /// <param name="gravity">defines the gravity vector to use</param>
        abstract setGravity: gravity: Vector3 -> unit
        /// <summary>Set the time step of the physics engine.
        /// Default is 1/60.
        /// To slow it down, enter 1/600 for example.
        /// To speed it up, 1/30</summary>
        /// <param name="newTimeStep">defines the new timestep to apply to this world.</param>
        abstract setTimeStep: ?newTimeStep: float -> unit
        /// Get the time step of the physics engine.
        abstract getTimeStep: unit -> float
        /// Release all resources
        abstract dispose: unit -> unit
        /// Gets the name of the current physics plugin
        abstract getPhysicsPluginName: unit -> string
        /// <summary>Adding a new impostor for the impostor tracking.
        /// This will be done by the impostor itself.</summary>
        /// <param name="impostor">the impostor to add</param>
        abstract addImpostor: impostor: PhysicsImpostor -> unit
        /// <summary>Remove an impostor from the engine.
        /// This impostor and its mesh will not longer be updated by the physics engine.</summary>
        /// <param name="impostor">the impostor to remove</param>
        abstract removeImpostor: impostor: PhysicsImpostor -> unit
        /// <summary>Add a joint to the physics engine</summary>
        /// <param name="mainImpostor">defines the main impostor to which the joint is added.</param>
        /// <param name="connectedImpostor">defines the impostor that is connected to the main impostor using this joint</param>
        /// <param name="joint">defines the joint that will connect both impostors.</param>
        abstract addJoint: mainImpostor: PhysicsImpostor * connectedImpostor: PhysicsImpostor * joint: PhysicsJoint -> unit
        /// <summary>Removes a joint from the simulation</summary>
        /// <param name="mainImpostor">defines the impostor used with the joint</param>
        /// <param name="connectedImpostor">defines the other impostor connected to the main one by the joint</param>
        /// <param name="joint">defines the joint to remove</param>
        abstract removeJoint: mainImpostor: PhysicsImpostor * connectedImpostor: PhysicsImpostor * joint: PhysicsJoint -> unit
        /// <summary>Called by the scene. No need to call it.</summary>
        /// <param name="delta">defines the timespam between frames</param>
        abstract _step: delta: float -> unit
        /// Gets the current plugin used to run the simulation
        abstract getPhysicsPlugin: unit -> IPhysicsEnginePlugin
        /// Gets the list of physic impostors
        abstract getImpostors: unit -> Array<PhysicsImpostor>
        /// <summary>Gets the impostor for a physics enabled object</summary>
        /// <param name="object">defines the object impersonated by the impostor</param>
        abstract getImpostorForPhysicsObject: ``object``: IPhysicsEnabledObject -> Nullable<PhysicsImpostor>
        /// <summary>Gets the impostor for a physics body object</summary>
        /// <param name="body">defines physics body used by the impostor</param>
        abstract getImpostorWithPhysicsBody: body: obj option -> Nullable<PhysicsImpostor>

    /// Class used to control physics engine
    type [<AllowNullLiteral>] PhysicsEngineStatic =
        /// Global value used to control the smallest number supported by the simulation
        abstract Epsilon: float with get, set
        /// <summary>Creates a new Physics Engine</summary>
        /// <param name="gravity">defines the gravity vector used by the simulation</param>
        /// <param name="_physicsPlugin">defines the plugin to use (CannonJS by default)</param>
        [<Emit "new $0($1...)">] abstract Create: gravity: Nullable<Vector3> * ?_physicsPlugin: IPhysicsEnginePlugin -> PhysicsEngine

    /// Defines the physics engine scene component responsible to manage a physics engine
    type [<AllowNullLiteral>] PhysicsEngineSceneComponent =
        inherit ISceneComponent
        /// The component name helpful to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources
        abstract dispose: unit -> unit

    /// Defines the physics engine scene component responsible to manage a physics engine
    type [<AllowNullLiteral>] PhysicsEngineSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> PhysicsEngineSceneComponent

    /// A helper for physics simulations
    type [<AllowNullLiteral>] PhysicsHelper =
        /// <summary>Applies a radial explosion impulse</summary>
        /// <param name="origin">the origin of the explosion</param>
        /// <param name="radius">the explosion radius</param>
        /// <param name="strength">the explosion strength</param>
        /// <param name="falloff">possible options: Constant & Linear. Defaults to Constant</param>
        abstract applyRadialExplosionImpulse: origin: Vector3 * radius: float * strength: float * ?falloff: PhysicsRadialImpulseFalloff -> Nullable<PhysicsRadialExplosionEvent>
        /// <summary>Applies a radial explosion force</summary>
        /// <param name="origin">the origin of the explosion</param>
        /// <param name="radius">the explosion radius</param>
        /// <param name="strength">the explosion strength</param>
        /// <param name="falloff">possible options: Constant & Linear. Defaults to Constant</param>
        abstract applyRadialExplosionForce: origin: Vector3 * radius: float * strength: float * ?falloff: PhysicsRadialImpulseFalloff -> Nullable<PhysicsRadialExplosionEvent>
        /// <summary>Creates a gravitational field</summary>
        /// <param name="origin">the origin of the explosion</param>
        /// <param name="radius">the explosion radius</param>
        /// <param name="strength">the explosion strength</param>
        /// <param name="falloff">possible options: Constant & Linear. Defaults to Constant</param>
        abstract gravitationalField: origin: Vector3 * radius: float * strength: float * ?falloff: PhysicsRadialImpulseFalloff -> Nullable<PhysicsGravitationalFieldEvent>
        /// <summary>Creates a physics updraft event</summary>
        /// <param name="origin">the origin of the updraft</param>
        /// <param name="radius">the radius of the updraft</param>
        /// <param name="strength">the strength of the updraft</param>
        /// <param name="height">the height of the updraft</param>
        /// <param name="updraftMode">possible options: Center & Perpendicular. Defaults to Center</param>
        abstract updraft: origin: Vector3 * radius: float * strength: float * height: float * ?updraftMode: PhysicsUpdraftMode -> Nullable<PhysicsUpdraftEvent>
        /// <summary>Creates a physics vortex event</summary>
        /// <param name="origin">the of the vortex</param>
        /// <param name="radius">the radius of the vortex</param>
        /// <param name="strength">the strength of the vortex</param>
        /// <param name="height">the height of the vortex</param>
        abstract vortex: origin: Vector3 * radius: float * strength: float * height: float -> Nullable<PhysicsVortexEvent>

    /// A helper for physics simulations
    type [<AllowNullLiteral>] PhysicsHelperStatic =
        /// <summary>Initializes the Physics helper</summary>
        /// <param name="scene">Babylon.js scene</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> PhysicsHelper

    /// Represents a physics radial explosion event
    type [<AllowNullLiteral>] PhysicsRadialExplosionEvent =
        /// Returns the data related to the radial explosion event (sphere & rays).
        abstract getData: unit -> PhysicsRadialExplosionEventData
        /// <summary>Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.</summary>
        /// <param name="impostor">A physics imposter</param>
        /// <param name="origin">the origin of the explosion</param>
        /// <param name="radius">the explosion radius</param>
        /// <param name="strength">the explosion strength</param>
        /// <param name="falloff">possible options: Constant & Linear</param>
        abstract getImpostorForceAndContactPoint: impostor: PhysicsImpostor * origin: Vector3 * radius: float * strength: float * falloff: PhysicsRadialImpulseFalloff -> Nullable<PhysicsForceAndContactPoint>
        /// <summary>Disposes the sphere.</summary>
        /// <param name="force">Specifies if the sphere should be disposed by force</param>
        abstract dispose: ?force: bool -> unit

    /// Represents a physics radial explosion event
    type [<AllowNullLiteral>] PhysicsRadialExplosionEventStatic =
        /// <summary>Initializes a radial explosioin event</summary>
        /// <param name="scene">BabylonJS scene</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> PhysicsRadialExplosionEvent

    /// Represents a gravitational field event
    type [<AllowNullLiteral>] PhysicsGravitationalFieldEvent =
        /// Returns the data related to the gravitational field event (sphere).
        abstract getData: unit -> PhysicsGravitationalFieldEventData
        /// Enables the gravitational field.
        abstract enable: unit -> unit
        /// Disables the gravitational field.
        abstract disable: unit -> unit
        /// <summary>Disposes the sphere.</summary>
        /// <param name="force">The force to dispose from the gravitational field event</param>
        abstract dispose: ?force: bool -> unit

    /// Represents a gravitational field event
    type [<AllowNullLiteral>] PhysicsGravitationalFieldEventStatic =
        /// <summary>Initializes the physics gravitational field event</summary>
        /// <param name="physicsHelper">A physics helper</param>
        /// <param name="scene">BabylonJS scene</param>
        /// <param name="origin">The origin position of the gravitational field event</param>
        /// <param name="radius">The radius of the gravitational field event</param>
        /// <param name="strength">The strength of the gravitational field event</param>
        /// <param name="falloff">The falloff for the gravitational field event</param>
        [<Emit "new $0($1...)">] abstract Create: physicsHelper: PhysicsHelper * scene: Scene * origin: Vector3 * radius: float * strength: float * ?falloff: PhysicsRadialImpulseFalloff -> PhysicsGravitationalFieldEvent

    /// Represents a physics updraft event
    type [<AllowNullLiteral>] PhysicsUpdraftEvent =
        /// Returns the data related to the updraft event (cylinder).
        abstract getData: unit -> PhysicsUpdraftEventData
        /// Enables the updraft.
        abstract enable: unit -> unit
        /// Disables the cortex.
        abstract disable: unit -> unit
        /// <summary>Disposes the sphere.</summary>
        /// <param name="force">Specifies if the updraft should be disposed by force</param>
        abstract dispose: ?force: bool -> unit

    /// Represents a physics updraft event
    type [<AllowNullLiteral>] PhysicsUpdraftEventStatic =
        /// <summary>Initializes the physics updraft event</summary>
        /// <param name="_scene">BabylonJS scene</param>
        /// <param name="_origin">The origin position of the updraft</param>
        /// <param name="_radius">The radius of the updraft</param>
        /// <param name="_strength">The strength of the updraft</param>
        /// <param name="_height">The height of the updraft</param>
        /// <param name="_updraftMode">The mode of the updraft</param>
        [<Emit "new $0($1...)">] abstract Create: _scene: Scene * _origin: Vector3 * _radius: float * _strength: float * _height: float * _updraftMode: PhysicsUpdraftMode -> PhysicsUpdraftEvent

    /// Represents a physics vortex event
    type [<AllowNullLiteral>] PhysicsVortexEvent =
        /// Returns the data related to the vortex event (cylinder).
        abstract getData: unit -> PhysicsVortexEventData
        /// Enables the vortex.
        abstract enable: unit -> unit
        /// Disables the cortex.
        abstract disable: unit -> unit
        /// <summary>Disposes the sphere.</summary>
        /// <param name="force"></param>
        abstract dispose: ?force: bool -> unit

    /// Represents a physics vortex event
    type [<AllowNullLiteral>] PhysicsVortexEventStatic =
        /// <summary>Initializes the physics vortex event</summary>
        /// <param name="_scene">The BabylonJS scene</param>
        /// <param name="_origin">The origin position of the vortex</param>
        /// <param name="_radius">The radius of the vortex</param>
        /// <param name="_strength">The strength of the vortex</param>
        /// <param name="_height">The height of the vortex</param>
        [<Emit "new $0($1...)">] abstract Create: _scene: Scene * _origin: Vector3 * _radius: float * _strength: float * _height: float -> PhysicsVortexEvent

    type [<RequireQualifiedAccess>] PhysicsRadialImpulseFalloff =
        | Constant = 0
        | Linear = 1

    type [<RequireQualifiedAccess>] PhysicsUpdraftMode =
        | Center = 0
        | Perpendicular = 1

    /// Interface for a physics force and contact point
    type [<AllowNullLiteral>] PhysicsForceAndContactPoint =
        /// The force applied at the contact point
        abstract force: Vector3 with get, set
        /// The contact point
        abstract contactPoint: Vector3 with get, set

    /// Interface for radial explosion event data
    type [<AllowNullLiteral>] PhysicsRadialExplosionEventData =
        /// A sphere used for the radial explosion event
        abstract sphere: Mesh with get, set
        /// An array of rays for the radial explosion event
        abstract rays: Array<Ray> with get, set

    /// Interface for gravitational field event data
    type [<AllowNullLiteral>] PhysicsGravitationalFieldEventData =
        /// A sphere mesh used for the gravitational field event
        abstract sphere: Mesh with get, set

    /// Interface for updraft event data
    type [<AllowNullLiteral>] PhysicsUpdraftEventData =
        /// A cylinder used for the updraft event
        abstract cylinder: Mesh with get, set

    /// Interface for vortex event data
    type [<AllowNullLiteral>] PhysicsVortexEventData =
        /// A cylinder used for the vortex event
        abstract cylinder: Mesh with get, set

    /// The interface for the physics imposter parameters
    type [<AllowNullLiteral>] PhysicsImpostorParameters =
        /// The mass of the physics imposter
        abstract mass: float with get, set
        /// The friction of the physics imposter
        abstract friction: float option with get, set
        /// The coefficient of restitution of the physics imposter
        abstract restitution: float option with get, set
        /// The native options of the physics imposter
        abstract nativeOptions: obj option with get, set
        /// Specifies if the parent should be ignored
        abstract ignoreParent: bool option with get, set
        /// Specifies if bi-directional transformations should be disabled
        abstract disableBidirectionalTransformation: bool option with get, set

    /// Interface for a physics-enabled object
    type [<AllowNullLiteral>] IPhysicsEnabledObject =
        /// The position of the physics-enabled object
        abstract position: Vector3 with get, set
        /// The rotation of the physics-enabled object
        abstract rotationQuaternion: Nullable<Quaternion> with get, set
        /// The scale of the physics-enabled object
        abstract scaling: Vector3 with get, set
        /// The rotation of the physics-enabled object
        abstract rotation: Vector3 option with get, set
        /// The parent of the physics-enabled object
        abstract parent: obj option with get, set
        /// The bounding info of the physics-enabled object
        abstract getBoundingInfo: unit -> BoundingInfo
        /// <summary>Computes the world matrix</summary>
        /// <param name="force">Specifies if the world matrix should be computed by force</param>
        abstract computeWorldMatrix: force: bool -> Matrix
        /// Gets the world matrix
        abstract getWorldMatrix: unit -> Matrix
        /// <summary>Gets the child meshes</summary>
        /// <param name="directDescendantsOnly">Specifies if only direct-descendants should be obtained</param>
        abstract getChildMeshes: ?directDescendantsOnly: bool -> Array<AbstractMesh>
        /// <summary>Gets the vertex data</summary>
        /// <param name="kind">The type of vertex data</param>
        abstract getVerticesData: kind: string -> Nullable<U2<Array<float>, Float32Array>>
        /// Gets the indices from the mesh
        abstract getIndices: unit -> Nullable<IndicesArray>
        /// Gets the scene from the mesh
        abstract getScene: unit -> Scene
        /// Gets the absolute position from the mesh
        abstract getAbsolutePosition: unit -> Vector3
        /// Gets the absolute pivot point from the mesh
        abstract getAbsolutePivotPoint: unit -> Vector3
        /// <summary>Rotates the mesh</summary>
        /// <param name="axis">The axis of rotation</param>
        /// <param name="amount">The amount of rotation</param>
        /// <param name="space">The space of the rotation</param>
        abstract rotate: axis: Vector3 * amount: float * ?space: Space -> TransformNode
        /// <summary>Translates the mesh</summary>
        /// <param name="axis">The axis of translation</param>
        /// <param name="distance">The distance of translation</param>
        /// <param name="space">The space of the translation</param>
        abstract translate: axis: Vector3 * distance: float * ?space: Space -> TransformNode
        /// <summary>Sets the absolute position of the mesh</summary>
        /// <param name="absolutePosition">The absolute position of the mesh</param>
        abstract setAbsolutePosition: absolutePosition: Vector3 -> TransformNode
        /// Gets the class name of the mesh
        abstract getClassName: unit -> string

    /// Represents a physics imposter
    type [<AllowNullLiteral>] PhysicsImpostor =
        /// The physics-enabled object used as the physics imposter
        abstract ``object``: IPhysicsEnabledObject with get, set
        /// The type of the physics imposter
        abstract ``type``: float with get, set
        /// Specifies if the physics imposter is disposed
        abstract isDisposed: bool
        /// Gets the mass of the physics imposter
        abstract mass: float with get, set
        /// Gets the coefficient of friction
        /// Sets the coefficient of friction
        abstract friction: float with get, set
        /// Gets the coefficient of restitution
        /// Sets the coefficient of restitution
        abstract restitution: float with get, set
        /// The unique id of the physics imposter
        /// set by the physics engine when adding this impostor to the array
        abstract uniqueId: float with get, set
        /// This function will completly initialize this impostor.
        /// It will create a new body - but only if this mesh has no parent.
        /// If it has, this impostor will not be used other than to define the impostor
        /// of the child mesh.
        abstract _init: unit -> unit
        /// Should a new body be generated.
        abstract isBodyInitRequired: unit -> bool
        /// <summary>Sets the updated scaling</summary>
        /// <param name="updated">Specifies if the scaling is updated</param>
        abstract setScalingUpdated: updated: bool -> unit
        /// Force a regeneration of this or the parent's impostor's body.
        /// Use under cautious - This will remove all joints already implemented.
        abstract forceUpdate: unit -> unit
        /// Gets the body that holds this impostor. Either its own, or its parent.
        /// Set the physics body. Used mainly by the physics engine/plugin
        abstract physicsBody: obj option with get, set
        /// Get the parent of the physics imposter
        /// Sets the parent of the physics imposter
        abstract parent: Nullable<PhysicsImpostor> with get, set
        /// Resets the update flags
        abstract resetUpdateFlags: unit -> unit
        /// Gets the object extend size
        abstract getObjectExtendSize: unit -> Vector3
        /// Gets the object center
        abstract getObjectCenter: unit -> Vector3
        /// <summary>Get a specific parametes from the options parameter</summary>
        /// <param name="paramName">The object parameter name</param>
        abstract getParam: paramName: string -> obj option
        /// <summary>Sets a specific parameter in the options given to the physics plugin</summary>
        /// <param name="paramName">The parameter name</param>
        /// <param name="value">The value of the parameter</param>
        abstract setParam: paramName: string * value: float -> unit
        /// <summary>Specifically change the body's mass option. Won't recreate the physics body object</summary>
        /// <param name="mass">The mass of the physics imposter</param>
        abstract setMass: mass: float -> unit
        /// Gets the linear velocity
        abstract getLinearVelocity: unit -> Nullable<Vector3>
        /// <summary>Sets the linear velocity</summary>
        /// <param name="velocity">linear velocity or null</param>
        abstract setLinearVelocity: velocity: Nullable<Vector3> -> unit
        /// Gets the angular velocity
        abstract getAngularVelocity: unit -> Nullable<Vector3>
        /// <summary>Sets the angular velocity</summary>
        /// <param name="velocity">The velocity or null</param>
        abstract setAngularVelocity: velocity: Nullable<Vector3> -> unit
        /// <summary>Execute a function with the physics plugin native code
        /// Provide a function the will have two variables - the world object and the physics body object</summary>
        /// <param name="func">The function to execute with the physics plugin native code</param>
        abstract executeNativeFunction: func: (obj option -> obj option -> unit) -> unit
        /// <summary>Register a function that will be executed before the physics world is stepping forward</summary>
        /// <param name="func">The function to execute before the physics world is stepped forward</param>
        abstract registerBeforePhysicsStep: func: (PhysicsImpostor -> unit) -> unit
        /// <summary>Unregister a function that will be executed before the physics world is stepping forward</summary>
        /// <param name="func">The function to execute before the physics world is stepped forward</param>
        abstract unregisterBeforePhysicsStep: func: (PhysicsImpostor -> unit) -> unit
        /// <summary>Register a function that will be executed after the physics step</summary>
        /// <param name="func">The function to execute after physics step</param>
        abstract registerAfterPhysicsStep: func: (PhysicsImpostor -> unit) -> unit
        /// <summary>Unregisters a function that will be executed after the physics step</summary>
        /// <param name="func">The function to execute after physics step</param>
        abstract unregisterAfterPhysicsStep: func: (PhysicsImpostor -> unit) -> unit
        /// <summary>register a function that will be executed when this impostor collides against a different body</summary>
        /// <param name="collideAgainst">Physics imposter, or array of physics imposters to collide against</param>
        /// <param name="func">Callback that is executed on collision</param>
        abstract registerOnPhysicsCollide: collideAgainst: U2<PhysicsImpostor, Array<PhysicsImpostor>> * func: (PhysicsImpostor -> PhysicsImpostor -> unit) -> unit
        /// <summary>Unregisters the physics imposter on contact</summary>
        /// <param name="collideAgainst">The physics object to collide against</param>
        /// <param name="func">Callback to execute on collision</param>
        abstract unregisterOnPhysicsCollide: collideAgainst: U2<PhysicsImpostor, Array<PhysicsImpostor>> * func: (PhysicsImpostor -> U2<PhysicsImpostor, Array<PhysicsImpostor>> -> unit) -> unit
        /// Get the parent rotation
        abstract getParentsRotation: unit -> Quaternion
        /// this function is executed by the physics engine.
        abstract beforeStep: (unit -> unit) with get, set
        /// this function is executed by the physics engine
        abstract afterStep: (unit -> unit) with get, set
        /// Legacy collision detection event support
        abstract onCollideEvent: Nullable<(PhysicsImpostor -> PhysicsImpostor -> unit)> with get, set
        /// event and body object due to cannon's event-based architecture.
        abstract onCollide: (TypeLiteral_30 -> unit) with get, set
        /// <summary>Apply a force</summary>
        /// <param name="force">The force to apply</param>
        /// <param name="contactPoint">The contact point for the force</param>
        abstract applyForce: force: Vector3 * contactPoint: Vector3 -> PhysicsImpostor
        /// <summary>Apply an impulse</summary>
        /// <param name="force">The impulse force</param>
        /// <param name="contactPoint">The contact point for the impulse force</param>
        abstract applyImpulse: force: Vector3 * contactPoint: Vector3 -> PhysicsImpostor
        /// <summary>A help function to create a joint</summary>
        /// <param name="otherImpostor">A physics imposter used to create a joint</param>
        /// <param name="jointType">The type of joint</param>
        /// <param name="jointData">The data for the joint</param>
        abstract createJoint: otherImpostor: PhysicsImpostor * jointType: float * jointData: PhysicsJointData -> PhysicsImpostor
        /// <summary>Add a joint to this impostor with a different impostor</summary>
        /// <param name="otherImpostor">A physics imposter used to add a joint</param>
        /// <param name="joint">The joint to add</param>
        abstract addJoint: otherImpostor: PhysicsImpostor * joint: PhysicsJoint -> PhysicsImpostor
        /// Will keep this body still, in a sleep mode.
        abstract sleep: unit -> PhysicsImpostor
        /// Wake the body up.
        abstract wakeUp: unit -> PhysicsImpostor
        /// <summary>Clones the physics imposter</summary>
        /// <param name="newObject">The physics imposter clones to this physics-enabled object</param>
        abstract clone: newObject: IPhysicsEnabledObject -> Nullable<PhysicsImpostor>
        /// Disposes the physics imposter
        abstract dispose: unit -> unit
        /// <summary>Sets the delta position</summary>
        /// <param name="position">The delta position amount</param>
        abstract setDeltaPosition: position: Vector3 -> unit
        /// <summary>Sets the delta rotation</summary>
        /// <param name="rotation">The delta rotation amount</param>
        abstract setDeltaRotation: rotation: Quaternion -> unit
        /// <summary>Gets the box size of the physics imposter and stores the result in the input parameter</summary>
        /// <param name="result">Stores the box size</param>
        abstract getBoxSizeToRef: result: Vector3 -> PhysicsImpostor
        /// Gets the radius of the physics imposter
        abstract getRadius: unit -> float
        /// <summary>Sync a bone with this impostor</summary>
        /// <param name="bone">The bone to sync to the impostor.</param>
        /// <param name="boneMesh">The mesh that the bone is influencing.</param>
        /// <param name="jointPivot">The pivot of the joint / bone in local space.</param>
        /// <param name="distToJoint">Optional distance from the impostor to the joint.</param>
        /// <param name="adjustRotation">Optional quaternion for adjusting the local rotation of the bone.</param>
        abstract syncBoneWithImpostor: bone: Bone * boneMesh: AbstractMesh * jointPivot: Vector3 * ?distToJoint: float * ?adjustRotation: Quaternion -> unit
        /// <summary>Sync impostor to a bone</summary>
        /// <param name="bone">The bone that the impostor will be synced to.</param>
        /// <param name="boneMesh">The mesh that the bone is influencing.</param>
        /// <param name="jointPivot">The pivot of the joint / bone in local space.</param>
        /// <param name="distToJoint">Optional distance from the impostor to the joint.</param>
        /// <param name="adjustRotation">Optional quaternion for adjusting the local rotation of the bone.</param>
        /// <param name="boneAxis">Optional vector3 axis the bone is aligned with</param>
        abstract syncImpostorWithBone: bone: Bone * boneMesh: AbstractMesh * jointPivot: Vector3 * ?distToJoint: float * ?adjustRotation: Quaternion * ?boneAxis: Vector3 -> unit

    /// Represents a physics imposter
    type [<AllowNullLiteral>] PhysicsImpostorStatic =
        /// The default object size of the imposter
        abstract DEFAULT_OBJECT_SIZE: Vector3 with get, set
        /// The identity quaternion of the imposter
        abstract IDENTITY_QUATERNION: Quaternion with get, set
        /// <summary>Initializes the physics imposter</summary>
        /// <param name="object">The physics-enabled object used as the physics imposter</param>
        /// <param name="type">The type of the physics imposter</param>
        /// <param name="_options">The options for the physics imposter</param>
        /// <param name="_scene">The Babylon scene</param>
        [<Emit "new $0($1...)">] abstract Create: ``object``: IPhysicsEnabledObject * ``type``: float * ?_options: PhysicsImpostorParameters * ?_scene: Scene -> PhysicsImpostor
        /// No-Imposter type
        abstract NoImpostor: float with get, set
        /// Sphere-Imposter type
        abstract SphereImpostor: float with get, set
        /// Box-Imposter type
        abstract BoxImpostor: float with get, set
        /// Plane-Imposter type
        abstract PlaneImpostor: float with get, set
        /// Mesh-imposter type
        abstract MeshImpostor: float with get, set
        /// Cylinder-Imposter type
        abstract CylinderImpostor: float with get, set
        /// Particle-Imposter type
        abstract ParticleImpostor: float with get, set
        /// Heightmap-Imposter type
        abstract HeightmapImpostor: float with get, set

    /// Interface for Physics-Joint data
    type [<AllowNullLiteral>] PhysicsJointData =
        /// The main pivot of the joint
        abstract mainPivot: Vector3 option with get, set
        /// The connected pivot of the joint
        abstract connectedPivot: Vector3 option with get, set
        /// The main axis of the joint
        abstract mainAxis: Vector3 option with get, set
        /// The connected axis of the joint
        abstract connectedAxis: Vector3 option with get, set
        /// The collision of the joint
        abstract collision: bool option with get, set
        /// Native Oimo/Cannon/Energy data
        abstract nativeParams: obj option with get, set

    /// This is a holder class for the physics joint created by the physics plugin
    /// It holds a set of functions to control the underlying joint
    type [<AllowNullLiteral>] PhysicsJoint =
        /// The type of the physics joint
        abstract ``type``: float with get, set
        /// The data for the physics joint
        abstract jointData: PhysicsJointData with get, set
        abstract _physicsPlugin: IPhysicsEnginePlugin with get, set
        /// Gets the physics joint
        /// Sets the physics joint
        abstract physicsJoint: obj option with get, set
        /// Sets the physics plugin
        abstract physicsPlugin: IPhysicsEnginePlugin with get, set
        /// <summary>Execute a function that is physics-plugin specific.</summary>
        /// <param name="func">the function that will be executed.
        /// It accepts two parameters: the physics world and the physics joint</param>
        abstract executeNativeFunction: func: (obj option -> obj option -> unit) -> unit

    /// This is a holder class for the physics joint created by the physics plugin
    /// It holds a set of functions to control the underlying joint
    type [<AllowNullLiteral>] PhysicsJointStatic =
        /// <summary>Initializes the physics joint</summary>
        /// <param name="type">The type of the physics joint</param>
        /// <param name="jointData">The data for the physics joint</param>
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * jointData: PhysicsJointData -> PhysicsJoint
        /// Distance-Joint type
        abstract DistanceJoint: float with get, set
        /// Hinge-Joint type
        abstract HingeJoint: float with get, set
        /// Ball-and-Socket joint type
        abstract BallAndSocketJoint: float with get, set
        /// Wheel-Joint type
        abstract WheelJoint: float with get, set
        /// Slider-Joint type
        abstract SliderJoint: float with get, set
        /// Prismatic-Joint type
        abstract PrismaticJoint: float with get, set
        /// Universal-Joint type
        /// ENERGY FTW! (compare with this - @see http://ode-wiki.org/wiki/index.php?title=Manual:_Joint_Types_and_Functions)
        abstract UniversalJoint: float with get, set
        /// Hinge-Joint 2 type
        abstract Hinge2Joint: float with get, set
        /// Point to Point Joint type.  Similar to a Ball-Joint.  Different in parameters
        abstract PointToPointJoint: float with get, set
        /// Spring-Joint type
        abstract SpringJoint: float with get, set
        /// Lock-Joint type
        abstract LockJoint: float with get, set

    /// A class representing a physics distance joint
    type [<AllowNullLiteral>] DistanceJoint =
        inherit PhysicsJoint
        /// <summary>Update the predefined distance.</summary>
        /// <param name="maxDistance">The maximum preferred distance</param>
        /// <param name="minDistance">The minimum preferred distance</param>
        abstract updateDistance: maxDistance: float * ?minDistance: float -> unit

    /// A class representing a physics distance joint
    type [<AllowNullLiteral>] DistanceJointStatic =
        /// <param name="jointData">The data for the Distance-Joint</param>
        [<Emit "new $0($1...)">] abstract Create: jointData: DistanceJointData -> DistanceJoint

    /// Represents a Motor-Enabled Joint
    type [<AllowNullLiteral>] MotorEnabledJoint =
        inherit PhysicsJoint
        inherit IMotorEnabledJoint
        /// <summary>Set the motor values.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.</summary>
        /// <param name="force">the force to apply</param>
        /// <param name="maxForce">max force for this motor.</param>
        abstract setMotor: ?force: float * ?maxForce: float -> unit
        /// <summary>Set the motor's limits.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.</summary>
        /// <param name="upperLimit">The upper limit of the motor</param>
        /// <param name="lowerLimit">The lower limit of the motor</param>
        abstract setLimit: upperLimit: float * ?lowerLimit: float -> unit

    /// Represents a Motor-Enabled Joint
    type [<AllowNullLiteral>] MotorEnabledJointStatic =
        /// <summary>Initializes the Motor-Enabled Joint</summary>
        /// <param name="type">The type of the joint</param>
        /// <param name="jointData">The physica joint data for the joint</param>
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * jointData: PhysicsJointData -> MotorEnabledJoint

    /// This class represents a single physics Hinge-Joint
    type [<AllowNullLiteral>] HingeJoint =
        inherit MotorEnabledJoint
        /// <summary>Set the motor values.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.</summary>
        /// <param name="force">the force to apply</param>
        /// <param name="maxForce">max force for this motor.</param>
        abstract setMotor: ?force: float * ?maxForce: float -> unit
        /// <summary>Set the motor's limits.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.</summary>
        /// <param name="upperLimit">The upper limit of the motor</param>
        /// <param name="lowerLimit">The lower limit of the motor</param>
        abstract setLimit: upperLimit: float * ?lowerLimit: float -> unit

    /// This class represents a single physics Hinge-Joint
    type [<AllowNullLiteral>] HingeJointStatic =
        /// <summary>Initializes the Hinge-Joint</summary>
        /// <param name="jointData">The joint data for the Hinge-Joint</param>
        [<Emit "new $0($1...)">] abstract Create: jointData: PhysicsJointData -> HingeJoint

    /// This class represents a dual hinge physics joint (same as wheel joint)
    type [<AllowNullLiteral>] Hinge2Joint =
        inherit MotorEnabledJoint
        /// <summary>Set the motor values.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.</summary>
        /// <param name="force">the force to apply</param>
        /// <param name="maxForce">max force for this motor.</param>
        abstract setMotor: ?force: float * ?maxForce: float * ?motorIndex: float -> unit
        /// <summary>Set the motor limits.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.</summary>
        /// <param name="upperLimit">the upper limit</param>
        /// <param name="lowerLimit">lower limit</param>
        abstract setLimit: upperLimit: float * ?lowerLimit: float * ?motorIndex: float -> unit

    /// This class represents a dual hinge physics joint (same as wheel joint)
    type [<AllowNullLiteral>] Hinge2JointStatic =
        /// <summary>Initializes the Hinge2-Joint</summary>
        /// <param name="jointData">The joint data for the Hinge2-Joint</param>
        [<Emit "new $0($1...)">] abstract Create: jointData: PhysicsJointData -> Hinge2Joint

    /// Interface for a motor enabled joint
    type [<AllowNullLiteral>] IMotorEnabledJoint =
        /// Physics joint
        abstract physicsJoint: obj option with get, set
        /// <summary>Sets the motor of the motor-enabled joint</summary>
        /// <param name="force">The force of the motor</param>
        /// <param name="maxForce">The maximum force of the motor</param>
        /// <param name="motorIndex">The index of the motor</param>
        abstract setMotor: ?force: float * ?maxForce: float * ?motorIndex: float -> unit
        /// <summary>Sets the limit of the motor</summary>
        /// <param name="upperLimit">The upper limit of the motor</param>
        /// <param name="lowerLimit">The lower limit of the motor</param>
        /// <param name="motorIndex">The index of the motor</param>
        abstract setLimit: upperLimit: float * ?lowerLimit: float * ?motorIndex: float -> unit

    /// Joint data for a Distance-Joint
    type [<AllowNullLiteral>] DistanceJointData =
        inherit PhysicsJointData
        /// Max distance the 2 joint objects can be apart
        abstract maxDistance: float with get, set

    /// Joint data from a spring joint
    type [<AllowNullLiteral>] SpringJointData =
        inherit PhysicsJointData
        /// Length of the spring
        abstract length: float with get, set
        /// Stiffness of the spring
        abstract stiffness: float with get, set
        /// Damping of the spring
        abstract damping: float with get, set
        /// this callback will be called when applying the force to the impostors. 
        abstract forceApplicationCallback: (unit -> unit) with get, set

    /// Class used to generate realtime reflection / refraction cube textures
    type [<AllowNullLiteral>] ReflectionProbe =
        /// defines the name of the probe 
        abstract name: string with get, set
        /// Gets or sets probe position (center of the cube map) 
        abstract position: Vector3 with get, set
        /// Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 
        abstract samples: float with get, set
        /// Gets or sets the refresh rate to use (on every frame by default) 
        abstract refreshRate: float with get, set
        /// Gets the hosting scene
        abstract getScene: unit -> Scene
        /// Gets the internal CubeTexture used to render to 
        abstract cubeTexture: RenderTargetTexture
        /// Gets the list of meshes to render 
        abstract renderList: Nullable<ResizeArray<AbstractMesh>>
        /// <summary>Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)</summary>
        /// <param name="mesh">defines the mesh to attach to</param>
        abstract attachToMesh: mesh: AbstractMesh -> unit
        /// <summary>Specifies whether or not the stencil and depth buffer are cleared between two rendering groups</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="autoClearDepthStencil">Automatically clears depth and stencil between groups if true.</param>
        abstract setRenderingAutoClearDepthStencil: renderingGroupId: float * autoClearDepthStencil: bool -> unit
        /// Clean all associated resources
        abstract dispose: unit -> unit

    /// Class used to generate realtime reflection / refraction cube textures
    type [<AllowNullLiteral>] ReflectionProbeStatic =
        /// <summary>Creates a new reflection probe</summary>
        /// <param name="name">defines the name of the probe</param>
        /// <param name="size">defines the texture resolution (for each face)</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="generateMipMaps">defines if mip maps should be generated automatically (true by default)</param>
        /// <param name="useFloat">defines if HDR data (flaot data) should be used to store colors (false by default)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * size: float * scene: Scene * ?generateMipMaps: bool * ?useFloat: bool -> ReflectionProbe

    /// Component responsible of rendering the bounding box of the meshes in a scene.
    /// This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties
    type [<AllowNullLiteral>] BoundingBoxRenderer =
        inherit ISceneComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Color of the bounding box lines placed in front of an object
        abstract frontColor: Color3 with get, set
        /// Color of the bounding box lines placed behind an object
        abstract backColor: Color3 with get, set
        /// Defines if the renderer should show the back lines or not
        abstract showBackLines: bool with get, set
        abstract renderList: SmartArray<BoundingBox> with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        abstract reset: unit -> unit
        /// <summary>Render the bounding boxes of a specific rendering group</summary>
        /// <param name="renderingGroupId">defines the rendering group to render</param>
        abstract render: renderingGroupId: float -> unit
        /// <summary>In case of occlusion queries, we can render the occlusion bounding box through this method</summary>
        /// <param name="mesh">Define the mesh to render the occlusion bounding box for</param>
        abstract renderOcclusionBoundingBox: mesh: AbstractMesh -> unit
        /// Dispose and release the resources attached to this renderer.
        abstract dispose: unit -> unit

    /// Component responsible of rendering the bounding box of the meshes in a scene.
    /// This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties
    type [<AllowNullLiteral>] BoundingBoxRendererStatic =
        /// <summary>Instantiates a new bounding box renderer in a scene.</summary>
        /// <param name="scene">the scene the  renderer renders in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> BoundingBoxRenderer

    /// This represents a depth renderer in Babylon.
    /// A depth renderer will render to it's depth map every frame which can be displayed or used in post processing
    type [<AllowNullLiteral>] DepthRenderer =
        /// Specifiess that the depth renderer will only be used within
        /// the camera it is created for.
        /// This can help forcing its rendering during the camera processing.
        abstract useOnlyInActiveCamera: bool with get, set
        /// <summary>Creates the depth rendering effect and checks if the effect is ready.</summary>
        /// <param name="subMesh">The submesh to be used to render the depth map of</param>
        /// <param name="useInstances">If multiple world instances should be used</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// Gets the texture which the depth map will be written to.
        abstract getDepthMap: unit -> RenderTargetTexture
        /// Disposes of the depth renderer.
        abstract dispose: unit -> unit

    /// This represents a depth renderer in Babylon.
    /// A depth renderer will render to it's depth map every frame which can be displayed or used in post processing
    type [<AllowNullLiteral>] DepthRendererStatic =
        /// <summary>Instantiates a depth renderer</summary>
        /// <param name="scene">The scene the renderer belongs to</param>
        /// <param name="type">The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)</param>
        /// <param name="camera">The camera to be used to render the depth map (default: scene's active camera)</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?``type``: float * ?camera: Camera -> DepthRenderer

    /// Defines the Depth Renderer scene component responsible to manage a depth buffer usefull
    /// in several rendering techniques.
    type [<AllowNullLiteral>] DepthRendererSceneComponent =
        inherit ISceneComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources
        abstract dispose: unit -> unit

    /// Defines the Depth Renderer scene component responsible to manage a depth buffer usefull
    /// in several rendering techniques.
    type [<AllowNullLiteral>] DepthRendererSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> DepthRendererSceneComponent

    /// Defines the minimum contract an Edges renderer should follow.
    type [<AllowNullLiteral>] IEdgesRenderer =
        inherit IDisposable
        /// Gets or sets a boolean indicating if the edgesRenderer is active
        abstract isEnabled: bool with get, set
        /// Renders the edges of the attached mesh,
        abstract render: unit -> unit
        /// Checks wether or not the edges renderer is ready to render.
        abstract isReady: unit -> bool

    /// This class is used to generate edges of the mesh that could then easily be rendered in a scene.
    type [<AllowNullLiteral>] EdgesRenderer =
        inherit IEdgesRenderer
        /// Define the size of the edges with an orthographic camera
        abstract edgesWidthScalerForOrthographic: float with get, set
        /// Define the size of the edges with a perspective camera
        abstract edgesWidthScalerForPerspective: float with get, set
        abstract _source: AbstractMesh with get, set
        abstract _linesPositions: ResizeArray<float> with get, set
        abstract _linesNormals: ResizeArray<float> with get, set
        abstract _linesIndices: ResizeArray<float> with get, set
        abstract _epsilon: float with get, set
        abstract _indicesCount: float with get, set
        abstract _lineShader: ShaderMaterial with get, set
        abstract _ib: WebGLBuffer with get, set
        abstract _buffers: TypeLiteral_31 with get, set
        abstract _checkVerticesInsteadOfIndices: bool with get, set
        /// Gets or sets a boolean indicating if the edgesRenderer is active 
        abstract isEnabled: bool with get, set
        abstract _prepareRessources: unit -> unit
        abstract _rebuild: unit -> unit
        /// Releases the required resources for the edges renderer
        abstract dispose: unit -> unit
        abstract _processEdgeForAdjacencies: pa: float * pb: float * p0: float * p1: float * p2: float -> float
        abstract _processEdgeForAdjacenciesWithVertices: pa: Vector3 * pb: Vector3 * p0: Vector3 * p1: Vector3 * p2: Vector3 -> float
        /// <summary>Checks if the pair of p0 and p1 is en edge</summary>
        /// <param name="faceIndex"></param>
        /// <param name="edge"></param>
        /// <param name="faceNormals"></param>
        /// <param name="p0"></param>
        /// <param name="p1"></param>
        abstract _checkEdge: faceIndex: float * edge: float * faceNormals: Array<Vector3> * p0: Vector3 * p1: Vector3 -> unit
        /// Generates lines edges from adjacencjes
        abstract _generateEdgesLines: unit -> unit
        /// Checks wether or not the edges renderer is ready to render.
        abstract isReady: unit -> bool
        /// Renders the edges of the attached mesh,
        abstract render: unit -> unit

    /// This class is used to generate edges of the mesh that could then easily be rendered in a scene.
    type [<AllowNullLiteral>] EdgesRendererStatic =
        /// <summary>Creates an instance of the EdgesRenderer. It is primarily use to display edges of a mesh.
        /// Beware when you use this class with complex objects as the adjacencies computation can be really long</summary>
        /// <param name="source">Mesh used to create edges</param>
        /// <param name="epsilon">sum of angles in adjacency to check for edge</param>
        /// <param name="checkVerticesInsteadOfIndices"></param>
        /// <param name="generateEdgesLines">- should generate Lines or only prepare resources.</param>
        [<Emit "new $0($1...)">] abstract Create: source: AbstractMesh * ?epsilon: float * ?checkVerticesInsteadOfIndices: bool * ?generateEdgesLines: bool -> EdgesRenderer

    /// This renderer is helpfull to fill one of the render target with a geometry buffer.
    type [<AllowNullLiteral>] GeometryBufferRenderer =
        abstract _effect: Effect with get, set
        abstract _cachedDefines: string with get, set
        /// Set the render list (meshes to be rendered) used in the G buffer.
        abstract renderList: ResizeArray<Mesh> with get, set
        /// Gets wether or not G buffer are supported by the running hardware.
        /// This requires draw buffer supports
        abstract isSupported: bool
        /// Gets wether or not position are enabled for the G buffer.
        /// Sets wether or not position are enabled for the G buffer.
        abstract enablePosition: bool with get, set
        /// Gets the scene associated with the buffer.
        abstract scene: Scene
        /// Gets the ratio used by the buffer during its creation.
        /// How big is the buffer related to the main canvas.
        abstract ratio: float
        /// <summary>Checks wether everything is ready to render a submesh to the G buffer.</summary>
        /// <param name="subMesh">the submesh to check readiness for</param>
        /// <param name="useInstances">is the mesh drawn using instance or not</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// Gets the current underlying G Buffer.
        abstract getGBuffer: unit -> MultiRenderTarget
        /// Gets the number of samples used to render the buffer (anti aliasing).
        /// Sets the number of samples used to render the buffer (anti aliasing).
        abstract samples: float with get, set
        /// Disposes the renderer and frees up associated resources.
        abstract dispose: unit -> unit
        abstract _createRenderTargets: unit -> unit

    /// This renderer is helpfull to fill one of the render target with a geometry buffer.
    type [<AllowNullLiteral>] GeometryBufferRendererStatic =
        /// <summary>Creates a new G Buffer for the scene</summary>
        /// <param name="scene">The scene the buffer belongs to</param>
        /// <param name="ratio">How big is the buffer related to the main canvas.</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?ratio: float -> GeometryBufferRenderer

    /// Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful
    /// in several rendering techniques.
    type [<AllowNullLiteral>] GeometryBufferRendererSceneComponent =
        inherit ISceneComponent
        /// The component name helpful to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources
        abstract dispose: unit -> unit

    /// Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful
    /// in several rendering techniques.
    type [<AllowNullLiteral>] GeometryBufferRendererSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> GeometryBufferRendererSceneComponent

    /// LineEdgesRenderer for LineMeshes to remove unnecessary triangulation
    type [<AllowNullLiteral>] LineEdgesRenderer =
        inherit EdgesRenderer
        /// <summary>Always create the edge since its a line so only important things are p0 and p1</summary>
        /// <param name="faceIndex">not important for LineMesh</param>
        /// <param name="edge">not important for LineMesh</param>
        /// <param name="faceNormals">not important for LineMesh</param>
        /// <param name="p0">beginnig of line</param>
        /// <param name="p1">end of line</param>
        abstract _checkEdge: faceIndex: float * edge: float * faceNormals: Array<Vector3> * p0: Vector3 * p1: Vector3 -> unit
        /// Generate edges for each line in LinesMesh. Every Line should be rendered as edge.
        abstract _generateEdgesLines: unit -> unit

    /// LineEdgesRenderer for LineMeshes to remove unnecessary triangulation
    type [<AllowNullLiteral>] LineEdgesRendererStatic =
        /// <summary>This constructor turns off auto generating edges line in Edges Renderer to make it here.</summary>
        /// <param name="source">LineMesh used to generate edges</param>
        /// <param name="epsilon">not important (specified angle for edge detection)</param>
        /// <param name="checkVerticesInsteadOfIndices">not important for LineMesh</param>
        [<Emit "new $0($1...)">] abstract Create: source: AbstractMesh * ?epsilon: float * ?checkVerticesInsteadOfIndices: bool -> LineEdgesRenderer

    /// This class is responsible to draw bothe outline/overlay of meshes.
    /// It should not be used directly but through the available method on mesh.
    type [<AllowNullLiteral>] OutlineRenderer =
        inherit ISceneComponent
        /// The name of the component. Each component must have a unique name.
        abstract name: string with get, set
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Defines a zOffset to prevent zFighting between the overlay and the mesh.
        abstract zOffset: float with get, set
        /// Register the component to one instance of a scene.
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources.
        abstract dispose: unit -> unit
        /// <summary>Renders the outline in the canvas.</summary>
        /// <param name="subMesh">Defines the sumesh to render</param>
        /// <param name="batch">Defines the batch of meshes in case of instances</param>
        /// <param name="useOverlay">Defines if the rendering is for the overlay or the outline</param>
        abstract render: subMesh: SubMesh * batch: _InstancesBatch * ?useOverlay: bool -> unit
        /// <summary>Returns whether or not the outline renderer is ready for a given submesh.
        /// All the dependencies e.g. submeshes, texture, effect... mus be ready</summary>
        /// <param name="subMesh">Defines the submesh to check readyness for</param>
        /// <param name="useInstances">Defines wheter wee are trying to render instances or not</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool

    /// This class is responsible to draw bothe outline/overlay of meshes.
    /// It should not be used directly but through the available method on mesh.
    type [<AllowNullLiteral>] OutlineRendererStatic =
        /// <summary>Instantiates a new outline renderer. (There could be only one per scene).</summary>
        /// <param name="scene">Defines the scene it belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> OutlineRenderer

    /// This represents the object necessary to create a rendering group.
    /// This is exclusively used and created by the rendering manager.
    /// To modify the behavior, you use the available helpers in your scene or meshes.
    type [<AllowNullLiteral>] RenderingGroup =
        abstract index: float with get, set
        abstract onBeforeTransparentRendering: (unit -> unit) with get, set
        /// Set the opaque sort comparison function.
        /// If null the sub meshes will be render in the order they were created
        abstract opaqueSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> with get, set
        /// Set the alpha test sort comparison function.
        /// If null the sub meshes will be render in the order they were created
        abstract alphaTestSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> with get, set
        /// Set the transparent sort comparison function.
        /// If null the sub meshes will be render in the order they were created
        abstract transparentSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> with get, set
        /// <summary>Render all the sub meshes contained in the group.</summary>
        /// <param name="customRenderFunction">Used to override the default render behaviour of the group.</param>
        abstract render: customRenderFunction: Nullable<(SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> unit)> * renderSprites: bool * renderParticles: bool * activeMeshes: Nullable<ResizeArray<AbstractMesh>> -> unit
        /// Resets the different lists of submeshes to prepare a new frame.
        abstract prepare: unit -> unit
        abstract dispose: unit -> unit
        /// <summary>Inserts the submesh in its correct queue depending on its material.</summary>
        /// <param name="subMesh">The submesh to dispatch</param>
        /// <param name="mesh">Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.</param>
        /// <param name="material">Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.</param>
        abstract dispatch: subMesh: SubMesh * ?mesh: AbstractMesh * ?material: Material -> unit
        abstract dispatchSprites: spriteManager: ISpriteManager -> unit
        abstract dispatchParticles: particleSystem: IParticleSystem -> unit

    /// This represents the object necessary to create a rendering group.
    /// This is exclusively used and created by the rendering manager.
    /// To modify the behavior, you use the available helpers in your scene or meshes.
    type [<AllowNullLiteral>] RenderingGroupStatic =
        /// <summary>Creates a new rendering group.</summary>
        /// <param name="index">The rendering group index</param>
        /// <param name="opaqueSortCompareFn">The opaque sort comparison function. If null no order is applied</param>
        /// <param name="alphaTestSortCompareFn">The alpha test sort comparison function. If null no order is applied</param>
        /// <param name="transparentSortCompareFn">The transparent sort comparison function. If null back to front + alpha index sort is applied</param>
        [<Emit "new $0($1...)">] abstract Create: index: float * scene: Scene * ?opaqueSortCompareFn: (SubMesh -> SubMesh -> float) * ?alphaTestSortCompareFn: (SubMesh -> SubMesh -> float) * ?transparentSortCompareFn: (SubMesh -> SubMesh -> float) -> RenderingGroup
        /// <summary>Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
        /// are rendered back to front if in the same alpha index.</summary>
        /// <param name="a">The first submesh</param>
        /// <param name="b">The second submesh</param>
        abstract defaultTransparentSortCompare: a: SubMesh * b: SubMesh -> float
        /// <summary>Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
        /// are rendered back to front.</summary>
        /// <param name="a">The first submesh</param>
        /// <param name="b">The second submesh</param>
        abstract backToFrontSortCompare: a: SubMesh * b: SubMesh -> float
        /// <summary>Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
        /// are rendered front to back (prevent overdraw).</summary>
        /// <param name="a">The first submesh</param>
        /// <param name="b">The second submesh</param>
        abstract frontToBackSortCompare: a: SubMesh * b: SubMesh -> float

    /// Interface describing the different options available in the rendering manager
    /// regarding Auto Clear between groups.
    type [<AllowNullLiteral>] IRenderingManagerAutoClearSetup =
        /// Defines whether or not autoclear is enable.
        abstract autoClear: bool with get, set
        /// Defines whether or not to autoclear the depth buffer.
        abstract depth: bool with get, set
        /// Defines whether or not to autoclear the stencil buffer.
        abstract stencil: bool with get, set

    /// This is the manager responsible of all the rendering for meshes sprites and particles.
    /// It is enable to manage the different groups as well as the different necessary sort functions.
    /// This should not be used directly aside of the few static configurations
    type [<AllowNullLiteral>] RenderingManager =
        abstract _useSceneAutoClearSetup: bool with get, set
        /// Renders the entire managed groups. This is used by the scene or the different rennder targets.
        abstract render: customRenderFunction: Nullable<(SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> unit)> * activeMeshes: Nullable<ResizeArray<AbstractMesh>> * renderParticles: bool * renderSprites: bool -> unit
        /// Resets the different information of the group to prepare a new frame
        abstract reset: unit -> unit
        /// Dispose and release the group and its associated resources.
        abstract dispose: unit -> unit
        /// Clear the info related to rendering groups preventing retention points during dispose.
        abstract freeRenderingGroups: unit -> unit
        /// <summary>Add a sprite manager to the rendering manager in order to render it this frame.</summary>
        /// <param name="spriteManager">Define the sprite manager to render</param>
        abstract dispatchSprites: spriteManager: ISpriteManager -> unit
        /// <summary>Add a particle system to the rendering manager in order to render it this frame.</summary>
        /// <param name="particleSystem">Define the particle system to render</param>
        abstract dispatchParticles: particleSystem: IParticleSystem -> unit
        /// <summary>Add a submesh to the manager in order to render it this frame</summary>
        /// <param name="subMesh">The submesh to dispatch</param>
        /// <param name="mesh">Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.</param>
        /// <param name="material">Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.</param>
        abstract dispatch: subMesh: SubMesh * ?mesh: AbstractMesh * ?material: Material -> unit
        /// <summary>Overrides the default sort function applied in the renderging group to prepare the meshes.
        /// This allowed control for front to back rendering or reversly depending of the special needs.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="opaqueSortCompareFn">The opaque queue comparison function use to sort.</param>
        /// <param name="alphaTestSortCompareFn">The alpha test queue comparison function use to sort.</param>
        /// <param name="transparentSortCompareFn">The transparent queue comparison function use to sort.</param>
        abstract setRenderingOrder: renderingGroupId: float * ?opaqueSortCompareFn: (SubMesh -> SubMesh -> float) * ?alphaTestSortCompareFn: (SubMesh -> SubMesh -> float) * ?transparentSortCompareFn: (SubMesh -> SubMesh -> float) -> unit
        /// <summary>Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="autoClearDepthStencil">Automatically clears depth and stencil between groups if true.</param>
        /// <param name="depth">Automatically clears depth between groups if true and autoClear is true.</param>
        /// <param name="stencil">Automatically clears stencil between groups if true and autoClear is true.</param>
        abstract setRenderingAutoClearDepthStencil: renderingGroupId: float * autoClearDepthStencil: bool * ?depth: bool * ?stencil: bool -> unit
        /// <summary>Gets the current auto clear configuration for one rendering group of the rendering
        /// manager.</summary>
        /// <param name="index">the rendering group index to get the information for</param>
        abstract getAutoClearDepthStencilSetup: index: float -> IRenderingManagerAutoClearSetup

    /// This is the manager responsible of all the rendering for meshes sprites and particles.
    /// It is enable to manage the different groups as well as the different necessary sort functions.
    /// This should not be used directly aside of the few static configurations
    type [<AllowNullLiteral>] RenderingManagerStatic =
        /// The max id used for rendering groups (not included)
        abstract MAX_RENDERINGGROUPS: float with get, set
        /// The min id used for rendering groups (included)
        abstract MIN_RENDERINGGROUPS: float with get, set
        /// Used to globally prevent autoclearing scenes.
        abstract AUTOCLEAR: bool with get, set
        /// <summary>Instantiates a new rendering group for a particular scene</summary>
        /// <param name="scene">Defines the scene the groups belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> RenderingManager

    /// Renders a layer on top of an existing scene
    type [<AllowNullLiteral>] UtilityLayerRenderer =
        inherit IDisposable
        /// the original scene that will be rendered on top of 
        abstract originalScene: Scene with get, set
        /// The scene that is rendered on top of the original scene
        abstract utilityLayerScene: Scene with get, set
        /// If the utility layer should automatically be rendered on top of existing scene
        abstract shouldRender: bool with get, set
        /// If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene
        abstract onlyCheckPointerDownEvents: bool with get, set
        /// If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)
        abstract processAllEvents: bool with get, set
        /// Observable raised when the pointer move from the utility layer scene to the main scene
        abstract onPointerOutObservable: Observable<float> with get, set
        /// Gets or sets a predicate that will be used to indicate utility meshes present in the main scene 
        abstract mainSceneTrackerPredicate: (Nullable<AbstractMesh> -> bool) with get, set
        /// Renders the utility layers scene on top of the original scene
        abstract render: unit -> unit
        /// Disposes of the renderer
        abstract dispose: unit -> unit

    /// Renders a layer on top of an existing scene
    type [<AllowNullLiteral>] UtilityLayerRendererStatic =
        /// A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)
        abstract DefaultUtilityLayer: UtilityLayerRenderer
        /// A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)
        abstract DefaultKeepDepthUtilityLayer: UtilityLayerRenderer
        /// <summary>Instantiates a UtilityLayerRenderer</summary>
        /// <param name="originalScene">the original scene that will be rendered on top of</param>
        [<Emit "new $0($1...)">] abstract Create: originalScene: Scene -> UtilityLayerRenderer

    /// Postprocess used to generate anaglyphic rendering
    type [<AllowNullLiteral>] AnaglyphPostProcess =
        inherit PostProcess

    /// Postprocess used to generate anaglyphic rendering
    type [<AllowNullLiteral>] AnaglyphPostProcessStatic =
        /// <summary>Creates a new AnaglyphPostProcess</summary>
        /// <param name="name">defines postprocess name</param>
        /// <param name="options">defines creation options or target ratio scale</param>
        /// <param name="rigCameras">defines cameras using this postprocess</param>
        /// <param name="samplingMode">defines required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)</param>
        /// <param name="engine">defines hosting engine</param>
        /// <param name="reusable">defines if the postprocess will be reused multiple times per frame</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * rigCameras: ResizeArray<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> AnaglyphPostProcess

    /// Post process used to render in black and white
    type [<AllowNullLiteral>] BlackAndWhitePostProcess =
        inherit PostProcess
        /// Linear about to convert he result to black and white (default: 1)
        abstract degree: float with get, set

    /// Post process used to render in black and white
    type [<AllowNullLiteral>] BlackAndWhitePostProcessStatic =
        /// <summary>Creates a black and white post process</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Camera * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> BlackAndWhitePostProcess

    /// The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras
    type [<AllowNullLiteral>] BloomEffect =
        inherit PostProcessRenderEffect
        abstract _effects: Array<PostProcess> with get, set
        abstract _downscale: ExtractHighlightsPostProcess with get, set
        /// The luminance threshold to find bright areas of the image to bloom.
        abstract threshold: float with get, set
        /// The strength of the bloom.
        abstract weight: float with get, set
        /// Specifies the size of the bloom blur kernel, relative to the final output size
        abstract kernel: float with get, set
        /// <summary>Disposes each of the internal effects for a given camera.</summary>
        /// <param name="camera">The camera to dispose the effect on.</param>
        abstract disposeEffects: camera: Camera -> unit
        abstract _updateEffects: unit -> unit
        /// Internal
        abstract _isReady: unit -> bool

    /// The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras
    type [<AllowNullLiteral>] BloomEffectStatic =
        /// <summary>Creates a new instance of @see BloomEffect</summary>
        /// <param name="scene">The scene the effect belongs to.</param>
        /// <param name="bloomScale">The ratio of the blur texture to the input texture that should be used to compute the bloom.</param>
        /// <param name="bloomWeight">The the strength of bloom.</param>
        /// <param name="bloomKernel">The size of the kernel to be used when applying the blur.</param>
        /// <param name="pipelineTextureType">The type of texture to be used when performing the post processing.</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * bloomScale: float * bloomWeight: float * bloomKernel: float * ?pipelineTextureType: float * ?blockCompilation: bool -> BloomEffect

    /// The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
    type [<AllowNullLiteral>] BloomMergePostProcess =
        inherit PostProcess
        /// Weight of the bloom to be added to the original input. 
        abstract weight: float with get, set

    /// The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
    type [<AllowNullLiteral>] BloomMergePostProcessStatic =
        /// <summary>Creates a new instance of @see BloomMergePostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="originalFromInput">Post process which's input will be used for the merge.</param>
        /// <param name="blurred">Blurred highlights post process which's output will be used.</param>
        /// <param name="weight">Weight of the bloom to be added to the original input.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * originalFromInput: PostProcess * blurred: PostProcess * weight: float * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> BloomMergePostProcess

    /// The Blur Post Process which blurs an image based on a kernel and direction.
    /// Can be used twice in x and y directions to perform a guassian blur in two passes.
    type [<AllowNullLiteral>] BlurPostProcess =
        inherit PostProcess
        /// The direction in which to blur the image. 
        abstract direction: Vector2 with get, set
        abstract _kernel: float with get, set
        abstract _idealKernel: float with get, set
        abstract _packedFloat: bool with get, set
        /// Sets the length in pixels of the blur sample region
        /// Gets the length in pixels of the blur sample region
        abstract kernel: float with get, set
        /// Sets wether or not the blur needs to unpack/repack floats
        /// Gets wether or not the blur is unpacking/repacking floats
        abstract packedFloat: bool with get, set
        /// <summary>Updates the effect with the current post process compile time values and recompiles the shader.</summary>
        /// <param name="defines">Define statements that should be added at the beginning of the shader. (default: null)</param>
        /// <param name="uniforms">Set of uniform variables that will be passed to the shader. (default: null)</param>
        /// <param name="samplers">Set of Texture2D variables that will be passed to the shader. (default: null)</param>
        /// <param name="indexParameters">The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx</param>
        /// <param name="onCompiled">Called when the shader has been compiled.</param>
        /// <param name="onError">Called if there is an error when compiling a shader.</param>
        abstract updateEffect: ?defines: string * ?uniforms: ResizeArray<string> * ?samplers: ResizeArray<string> * ?indexParameters: obj * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) -> unit
        abstract _updateParameters: ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) -> unit
        /// <summary>Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.
        /// Other odd kernels optimize correctly but require proportionally more samples, even kernels are
        /// possible but will produce minor visual artifacts. Since each new kernel requires a new shader we
        /// want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.
        /// The gaps between physical kernels are compensated for in the weighting of the samples</summary>
        /// <param name="idealKernel">Ideal blur kernel.</param>
        abstract _nearestBestKernel: idealKernel: float -> float
        /// <summary>Calculates the value of a Gaussian distribution with sigma 3 at a given point.</summary>
        /// <param name="x">The point on the Gaussian distribution to sample.</param>
        abstract _gaussianWeight: x: float -> float
        /// <summary>Generates a string that can be used as a floating point number in GLSL.</summary>
        /// <param name="x">Value to print.</param>
        /// <param name="decimalFigures">Number of decimal places to print the number to (excluding trailing 0s).</param>
        abstract _glslFloat: x: float * ?decimalFigures: float -> string

    /// The Blur Post Process which blurs an image based on a kernel and direction.
    /// Can be used twice in x and y directions to perform a guassian blur in two passes.
    type [<AllowNullLiteral>] BlurPostProcessStatic =
        /// <summary>Creates a new instance BlurPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="direction">The direction in which to blur the image.</param>
        /// <param name="kernel">The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * direction: Vector2 * kernel: float * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?defines: string * ?blockCompilation: bool -> BlurPostProcess

    /// The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen
    type [<AllowNullLiteral>] ChromaticAberrationPostProcess =
        inherit PostProcess
        /// The amount of seperation of rgb channels (default: 30)
        abstract aberrationAmount: float with get, set
        /// The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)
        abstract radialIntensity: float with get, set
        /// The normilized direction in which the rgb channels should be seperated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))
        abstract direction: Vector2 with get, set
        /// The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corder] (default: Vector2(0.5 ,0.5))
        abstract centerPosition: Vector2 with get, set

    /// The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen
    type [<AllowNullLiteral>] ChromaticAberrationPostProcessStatic =
        /// <summary>Creates a new instance ChromaticAberrationPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="screenWidth">The width of the screen to apply the effect on.</param>
        /// <param name="screenHeight">The height of the screen to apply the effect on.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * screenWidth: float * screenHeight: float * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> ChromaticAberrationPostProcess

    /// The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion
    type [<AllowNullLiteral>] CircleOfConfusionPostProcess =
        inherit PostProcess
        /// Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
        abstract lensSize: float with get, set
        /// F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
        abstract fStop: float with get, set
        /// Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
        abstract focusDistance: float with get, set
        /// Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)
        abstract focalLength: float with get, set
        /// Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
        abstract depthTexture: RenderTargetTexture with get, set

    /// The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion
    type [<AllowNullLiteral>] CircleOfConfusionPostProcessStatic =
        /// <summary>Creates a new instance CircleOfConfusionPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="depthTexture">The depth texture of the scene to compute the circle of confusion. This must be set in order for this to function but may be set after initialization if needed.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * depthTexture: Nullable<RenderTargetTexture> * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> CircleOfConfusionPostProcess

    /// This post-process allows the modification of rendered colors by using
    /// a 'look-up table' (LUT). This effect is also called Color Grading.
    /// 
    /// The object needs to be provided an url to a texture containing the color
    /// look-up table: the texture must be 256 pixels wide and 16 pixels high.
    /// Use an image editing software to tweak the LUT to match your needs.
    /// 
    /// For an example of a color LUT, see here:
    type [<AllowNullLiteral>] ColorCorrectionPostProcess =
        inherit PostProcess

    /// This post-process allows the modification of rendered colors by using
    /// a 'look-up table' (LUT). This effect is also called Color Grading.
    /// 
    /// The object needs to be provided an url to a texture containing the color
    /// look-up table: the texture must be 256 pixels wide and 16 pixels high.
    /// Use an image editing software to tweak the LUT to match your needs.
    /// 
    /// For an example of a color LUT, see here:
    type [<AllowNullLiteral>] ColorCorrectionPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * colorTableUrl: string * options: U2<float, PostProcessOptions> * camera: Camera * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> ColorCorrectionPostProcess

    /// The ConvolutionPostProcess applies a 3x3 kernel to every pixel of the
    /// input texture to perform effects such as edge detection or sharpening
    /// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
    type [<AllowNullLiteral>] ConvolutionPostProcess =
        inherit PostProcess
        /// Array of 9 values corrisponding to the 3x3 kernel to be applied 
        abstract kernel: ResizeArray<float> with get, set

    /// The ConvolutionPostProcess applies a 3x3 kernel to every pixel of the
    /// input texture to perform effects such as edge detection or sharpening
    /// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
    type [<AllowNullLiteral>] ConvolutionPostProcessStatic =
        /// <summary>Creates a new instance ConvolutionPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="kernel">Array of 9 values corrisponding to the 3x3 kernel to be applied</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * kernel: ResizeArray<float> * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float -> ConvolutionPostProcess
        /// Edge detection 0 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract EdgeDetect0Kernel: ResizeArray<float> with get, set
        /// Edge detection 1 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract EdgeDetect1Kernel: ResizeArray<float> with get, set
        /// Edge detection 2 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract EdgeDetect2Kernel: ResizeArray<float> with get, set
        /// Kernel to sharpen an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract SharpenKernel: ResizeArray<float> with get, set
        /// Kernel to emboss an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract EmbossKernel: ResizeArray<float> with get, set
        /// Kernel to blur an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract GaussianKernel: ResizeArray<float> with get, set

    /// The DepthOfFieldBlurPostProcess applied a blur in a give direction.
    /// This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels
    /// based on samples that have a large difference in distance than the center pixel.
    /// See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
    type [<AllowNullLiteral>] DepthOfFieldBlurPostProcess =
        inherit BlurPostProcess
        abstract direction: Vector2 with get, set

    /// The DepthOfFieldBlurPostProcess applied a blur in a give direction.
    /// This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels
    /// based on samples that have a large difference in distance than the center pixel.
    /// See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
    type [<AllowNullLiteral>] DepthOfFieldBlurPostProcessStatic =
        /// <summary>Creates a new instance CircleOfConfusionPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="scene">The scene the effect belongs to.</param>
        /// <param name="direction">The direction the blur should be applied.</param>
        /// <param name="kernel">The size of the kernel used to blur.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="circleOfConfusion">The circle of confusion + depth map to be used to avoid blurring accross edges</param>
        /// <param name="imageToBlur">The image to apply the blur to (default: Current rendered frame)</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * direction: Vector2 * kernel: float * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * circleOfConfusion: PostProcess * ?imageToBlur: PostProcess * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> DepthOfFieldBlurPostProcess

    type [<RequireQualifiedAccess>] DepthOfFieldEffectBlurLevel =
        | Low = 0
        | Medium = 1
        | High = 2

    /// The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.
    type [<AllowNullLiteral>] DepthOfFieldEffect =
        inherit PostProcessRenderEffect
        abstract _depthOfFieldBlurX: Array<DepthOfFieldBlurPostProcess> with get, set
        abstract _effects: Array<PostProcess> with get, set
        /// The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)
        abstract focalLength: float with get, set
        /// F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
        abstract fStop: float with get, set
        /// Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
        abstract focusDistance: float with get, set
        /// Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
        abstract lensSize: float with get, set
        /// Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
        abstract depthTexture: RenderTargetTexture with get, set
        /// <summary>Disposes each of the internal effects for a given camera.</summary>
        /// <param name="camera">The camera to dispose the effect on.</param>
        abstract disposeEffects: camera: Camera -> unit
        abstract _updateEffects: unit -> unit
        /// Internal
        abstract _isReady: unit -> bool

    /// The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.
    type [<AllowNullLiteral>] DepthOfFieldEffectStatic =
        /// <summary>Creates a new instance DepthOfFieldEffect</summary>
        /// <param name="scene">The scene the effect belongs to.</param>
        /// <param name="depthTexture">The depth texture of the scene to compute the circle of confusion.This must be set in order for this to function but may be set after initialization if needed.</param>
        /// <param name="pipelineTextureType">The type of texture to be used when performing the post processing.</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * depthTexture: Nullable<RenderTargetTexture> * ?blurLevel: DepthOfFieldEffectBlurLevel * ?pipelineTextureType: float * ?blockCompilation: bool -> DepthOfFieldEffect

    /// Options to be set when merging outputs from the default pipeline.
    type [<AllowNullLiteral>] DepthOfFieldMergePostProcessOptions =
        /// The original image to merge on top of
        abstract originalFromInput: PostProcess with get, set
        /// Parameters to perform the merge of the depth of field effect
        abstract depthOfField: TypeLiteral_32 option with get, set
        /// Parameters to perform the merge of bloom effect
        abstract bloom: TypeLiteral_33 option with get, set

    /// Options to be set when merging outputs from the default pipeline.
    type [<AllowNullLiteral>] DepthOfFieldMergePostProcessOptionsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> DepthOfFieldMergePostProcessOptions

    /// The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
    type [<AllowNullLiteral>] DepthOfFieldMergePostProcess =
        inherit PostProcess
        /// <summary>Updates the effect with the current post process compile time values and recompiles the shader.</summary>
        /// <param name="defines">Define statements that should be added at the beginning of the shader. (default: null)</param>
        /// <param name="uniforms">Set of uniform variables that will be passed to the shader. (default: null)</param>
        /// <param name="samplers">Set of Texture2D variables that will be passed to the shader. (default: null)</param>
        /// <param name="indexParameters">The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx</param>
        /// <param name="onCompiled">Called when the shader has been compiled.</param>
        /// <param name="onError">Called if there is an error when compiling a shader.</param>
        abstract updateEffect: ?defines: string * ?uniforms: ResizeArray<string> * ?samplers: ResizeArray<string> * ?indexParameters: obj * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) -> unit

    /// The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
    type [<AllowNullLiteral>] DepthOfFieldMergePostProcessStatic =
        /// <summary>Creates a new instance of DepthOfFieldMergePostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="originalFromInput">Post process which's input will be used for the merge.</param>
        /// <param name="circleOfConfusion">Circle of confusion post process which's output will be used to blur each pixel.</param>
        /// <param name="blurSteps">Blur post processes from low to high which will be mixed with the original image.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * originalFromInput: PostProcess * circleOfConfusion: PostProcess * blurSteps: Array<PostProcess> * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> DepthOfFieldMergePostProcess

    /// DisplayPassPostProcess which produces an output the same as it's input
    type [<AllowNullLiteral>] DisplayPassPostProcess =
        inherit PostProcess

    /// DisplayPassPostProcess which produces an output the same as it's input
    type [<AllowNullLiteral>] DisplayPassPostProcessStatic =
        /// <summary>Creates the DisplayPassPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> DisplayPassPostProcess

    /// The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.
    type [<AllowNullLiteral>] ExtractHighlightsPostProcess =
        inherit PostProcess
        /// The luminance threshold, pixels below this value will be set to black.
        abstract threshold: float with get, set
        abstract _exposure: float with get, set
        /// Post process which has the input texture to be used when performing highlight extraction
        abstract _inputPostProcess: Nullable<PostProcess> with get, set

    /// The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.
    type [<AllowNullLiteral>] ExtractHighlightsPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> ExtractHighlightsPostProcess

    /// Applies a kernel filter to the image
    type [<AllowNullLiteral>] FilterPostProcess =
        inherit PostProcess
        /// The matrix to be applied to the image 
        abstract kernelMatrix: Matrix with get, set

    /// Applies a kernel filter to the image
    type [<AllowNullLiteral>] FilterPostProcessStatic =
        /// <param name="name">The name of the effect.</param>
        /// <param name="kernelMatrix">The matrix to be applied to the image</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * kernelMatrix: Matrix * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> FilterPostProcess

    /// Fxaa post process
    type [<AllowNullLiteral>] FxaaPostProcess =
        inherit PostProcess
        abstract texelWidth: float with get, set
        abstract texelHeight: float with get, set

    /// Fxaa post process
    type [<AllowNullLiteral>] FxaaPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * ?camera: Camera * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float -> FxaaPostProcess

    /// The GrainPostProcess adds noise to the image at mid luminance levels
    type [<AllowNullLiteral>] GrainPostProcess =
        inherit PostProcess
        /// The intensity of the grain added (default: 30)
        abstract intensity: float with get, set
        /// If the grain should be randomized on every frame
        abstract animated: bool with get, set

    /// The GrainPostProcess adds noise to the image at mid luminance levels
    type [<AllowNullLiteral>] GrainPostProcessStatic =
        /// <summary>Creates a new instance of @see GrainPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> GrainPostProcess

    /// Extracts highlights from the image
    type [<AllowNullLiteral>] HighlightsPostProcess =
        inherit PostProcess

    /// Extracts highlights from the image
    type [<AllowNullLiteral>] HighlightsPostProcessStatic =
        /// <summary>Extracts highlights from the image</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of texture for the post process (default: Engine.TEXTURETYPE_UNSIGNED_INT)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float -> HighlightsPostProcess

    /// ImageProcessingPostProcess
    type [<AllowNullLiteral>] ImageProcessingPostProcess =
        inherit PostProcess
        /// Default configuration related to image processing available in the PBR Material.
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Gets the image processing configuration used either in this material.
        /// Sets the Default image processing configuration used either in the this material.
        /// 
        /// If sets to null, the scene one is in use.
        abstract imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// <summary>Attaches a new image processing configuration to the PBR Material.</summary>
        /// <param name="configuration"></param>
        abstract _attachImageProcessingConfiguration: configuration: Nullable<ImageProcessingConfiguration> * ?doNotBuild: bool -> unit
        /// Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .
        /// Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .
        abstract colorCurves: Nullable<ColorCurves> with get, set
        /// Gets wether the color curves effect is enabled.
        /// Sets wether the color curves effect is enabled.
        abstract colorCurvesEnabled: bool with get, set
        /// Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
        /// Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
        abstract colorGradingTexture: Nullable<BaseTexture> with get, set
        /// Gets wether the color grading effect is enabled.
        /// Gets wether the color grading effect is enabled.
        abstract colorGradingEnabled: bool with get, set
        /// Gets exposure used in the effect.
        /// Sets exposure used in the effect.
        abstract exposure: float with get, set
        /// Gets wether tonemapping is enabled or not.
        /// Sets wether tonemapping is enabled or not
        abstract toneMappingEnabled: bool with get, set
        /// Gets contrast used in the effect.
        /// Sets contrast used in the effect.
        abstract contrast: float with get, set
        /// Gets Vignette stretch size.
        /// Sets Vignette stretch size.
        abstract vignetteStretch: float with get, set
        /// Gets Vignette centre X Offset.
        /// Sets Vignette centre X Offset.
        abstract vignetteCentreX: float with get, set
        /// Gets Vignette centre Y Offset.
        /// Sets Vignette centre Y Offset.
        abstract vignetteCentreY: float with get, set
        /// Gets Vignette weight or intensity of the vignette effect.
        /// Sets Vignette weight or intensity of the vignette effect.
        abstract vignetteWeight: float with get, set
        /// Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
        /// if vignetteEnabled is set to true.
        /// Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
        /// if vignetteEnabled is set to true.
        abstract vignetteColor: Color4 with get, set
        /// Gets Camera field of view used by the Vignette effect.
        /// Sets Camera field of view used by the Vignette effect.
        abstract vignetteCameraFov: float with get, set
        /// Gets the vignette blend mode allowing different kind of effect.
        /// Sets the vignette blend mode allowing different kind of effect.
        abstract vignetteBlendMode: float with get, set
        /// Gets wether the vignette effect is enabled.
        /// Sets wether the vignette effect is enabled.
        abstract vignetteEnabled: bool with get, set
        /// Gets wether the input of the processing is in Gamma or Linear Space.
        /// Sets wether the input of the processing is in Gamma or Linear Space.
        abstract fromLinearSpace: bool with get, set
        /// "ImageProcessingPostProcess"
        abstract getClassName: unit -> string
        abstract _updateParameters: unit -> unit
        abstract dispose: ?camera: Camera -> unit

    /// ImageProcessingPostProcess
    type [<AllowNullLiteral>] ImageProcessingPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * ?camera: Camera * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?imageProcessingConfiguration: ImageProcessingConfiguration -> ImageProcessingPostProcess

    /// PassPostProcess which produces an output the same as it's input
    type [<AllowNullLiteral>] PassPostProcess =
        inherit PostProcess

    /// PassPostProcess which produces an output the same as it's input
    type [<AllowNullLiteral>] PassPostProcessStatic =
        /// <summary>Creates the PassPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">The type of texture to be used when performing the post processing.</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * ?camera: Camera * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> PassPostProcess

    type [<AllowNullLiteral>] PostProcessOptions =
        abstract width: float with get, set
        abstract height: float with get, set

    /// PostProcess can be used to apply a shader to a texture after it has been rendered
    /// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
    type [<AllowNullLiteral>] PostProcess =
        /// Name of the PostProcess. 
        abstract name: string with get, set
        /// Width of the texture to apply the post process on
        abstract width: float with get, set
        /// Height of the texture to apply the post process on
        abstract height: float with get, set
        /// Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)
        abstract _outputTexture: Nullable<InternalTexture> with get, set
        /// Sampling mode used by the shader
        /// See https://doc.babylonjs.com/classes/3.1/texture
        abstract renderTargetSamplingMode: float with get, set
        /// Clear color to use when screen clearing
        abstract clearColor: Color4 with get, set
        /// If the buffer needs to be cleared before applying the post process. (default: true)
        /// Should be set to false if shader will overwrite all previous pixels.
        abstract autoClear: bool with get, set
        /// Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)
        abstract alphaMode: float with get, set
        /// Sets the setAlphaBlendConstants of the babylon engine
        abstract alphaConstants: Color4 with get, set
        /// Animations to be used for the post processing
        abstract animations: ResizeArray<Animation> with get, set
        /// Enable Pixel Perfect mode where texture is not scaled to be power of 2.
        /// Can only be used on a single postprocess or on the last one of a chain. (default: false)
        abstract enablePixelPerfectMode: bool with get, set
        /// Force the postprocess to be applied without taking in account viewport
        abstract forceFullscreenViewport: bool with get, set
        /// Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)
        /// 
        /// | Value | Type                                | Description |
        /// | ----- | ----------------------------------- | ----------- |
        /// | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](http://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |
        /// | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](http://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |
        /// | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](http://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |
        abstract scaleMode: float with get, set
        /// Force textures to be a power of two (default: false)
        abstract alwaysForcePOT: bool with get, set
        /// Number of sample textures (default: 1)
        abstract samples: float with get, set
        /// Modify the scale of the post process to be the same as the viewport (default: false)
        abstract adaptScaleToCurrentViewport: bool with get, set
        /// Smart array of input and output textures for the post process.
        abstract _textures: SmartArray<InternalTexture> with get, set
        /// The index in _textures that corresponds to the output texture.
        abstract _currentRenderTextureInd: float with get, set
        abstract _indexParameters: obj option with get, set
        /// An event triggered when the postprocess is activated.
        abstract onActivateObservable: Observable<Camera> with get, set
        /// A function that is added to the onActivateObservable
        abstract onActivate: Nullable<(Camera -> unit)> with get, set
        /// An event triggered when the postprocess changes its size.
        abstract onSizeChangedObservable: Observable<PostProcess> with get, set
        /// A function that is added to the onSizeChangedObservable
        abstract onSizeChanged: (PostProcess -> unit) with get, set
        /// An event triggered when the postprocess applies its effect.
        abstract onApplyObservable: Observable<Effect> with get, set
        /// A function that is added to the onApplyObservable
        abstract onApply: (Effect -> unit) with get, set
        /// An event triggered before rendering the postprocess
        abstract onBeforeRenderObservable: Observable<Effect> with get, set
        /// A function that is added to the onBeforeRenderObservable
        abstract onBeforeRender: (Effect -> unit) with get, set
        /// An event triggered after rendering the postprocess
        abstract onAfterRenderObservable: Observable<Effect> with get, set
        /// A function that is added to the onAfterRenderObservable
        abstract onAfterRender: (Effect -> unit) with get, set
        /// The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will
        /// render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.
        abstract inputTexture: InternalTexture with get, set
        /// Gets the camera which post process is applied to.
        abstract getCamera: unit -> Camera
        /// Gets the texel size of the postprocess.
        /// See https://en.wikipedia.org/wiki/Texel_(graphics)
        abstract texelSize: Vector2
        /// Gets the engine which this post process belongs to.
        abstract getEngine: unit -> Engine
        /// The effect that is created when initializing the post process.
        abstract getEffect: unit -> Effect
        /// <summary>To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.</summary>
        /// <param name="postProcess">The post process to share the output with.</param>
        abstract shareOutputWith: postProcess: PostProcess -> PostProcess
        /// Reverses the effect of calling shareOutputWith and returns the post process back to its original state.
        /// This should be called if the post process that shares output with this post process is disabled/disposed.
        abstract useOwnOutput: unit -> unit
        /// <summary>Updates the effect with the current post process compile time values and recompiles the shader.</summary>
        /// <param name="defines">Define statements that should be added at the beginning of the shader. (default: null)</param>
        /// <param name="uniforms">Set of uniform variables that will be passed to the shader. (default: null)</param>
        /// <param name="samplers">Set of Texture2D variables that will be passed to the shader. (default: null)</param>
        /// <param name="indexParameters">The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx</param>
        /// <param name="onCompiled">Called when the shader has been compiled.</param>
        /// <param name="onError">Called if there is an error when compiling a shader.</param>
        abstract updateEffect: ?defines: string * ?uniforms: ResizeArray<string> * ?samplers: ResizeArray<string> * ?indexParameters: obj * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) -> unit
        /// The post process is reusable if it can be used multiple times within one frame.
        abstract isReusable: unit -> bool
        /// invalidate frameBuffer to hint the postprocess to create a depth buffer 
        abstract markTextureDirty: unit -> unit
        /// <summary>Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.
        /// When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.</summary>
        /// <param name="camera">The camera that will be used in the post process. This camera will be used when calling onActivateObservable.</param>
        /// <param name="sourceTexture">The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)</param>
        /// <param name="forceDepthStencil">If true, a depth and stencil buffer will be generated. (default: false)</param>
        abstract activate: camera: Nullable<Camera> * ?sourceTexture: InternalTexture * ?forceDepthStencil: bool -> InternalTexture
        /// If the post process is supported.
        abstract isSupported: bool
        /// The aspect ratio of the output texture.
        abstract aspectRatio: float
        /// Get a value indicating if the post-process is ready to be used
        abstract isReady: unit -> bool
        /// Binds all textures and uniforms to the shader, this will be run on every pass.
        abstract apply: unit -> Nullable<Effect>
        /// <summary>Disposes the post process.</summary>
        /// <param name="camera">The camera to dispose the post process on.</param>
        abstract dispose: ?camera: Camera -> unit

    /// PostProcess can be used to apply a shader to a texture after it has been rendered
    /// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
    type [<AllowNullLiteral>] PostProcessStatic =
        /// <summary>Creates a new instance PostProcess</summary>
        /// <param name="name">The name of the PostProcess.</param>
        /// <param name="fragmentUrl">The url of the fragment shader to be used.</param>
        /// <param name="parameters">Array of the names of uniform non-sampler2D variables that will be passed to the shader.</param>
        /// <param name="samplers">Array of the names of uniform sampler2D variables that will be passed to the shader.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="defines">String of defines that will be set when running the fragment shader. (default: null)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="vertexUrl">The url of the vertex shader to be used. (default: "postprocess")</param>
        /// <param name="indexParameters">The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx</param>
        /// <param name="blockCompilation">If the shader should not be compiled imediatly. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * fragmentUrl: string * parameters: Nullable<ResizeArray<string>> * samplers: Nullable<ResizeArray<string>> * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?defines: string * ?textureType: float * ?vertexUrl: string * ?indexParameters: obj * ?blockCompilation: bool -> PostProcess

    /// PostProcessManager is used to manage one or more post processes or post process pipelines
    /// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
    type [<AllowNullLiteral>] PostProcessManager =
        /// Rebuilds the vertex buffers of the manager.
        abstract _rebuild: unit -> unit
        /// <summary>Prepares a frame to be run through a post process.</summary>
        /// <param name="sourceTexture">The input texture to the post procesess. (default: null)</param>
        /// <param name="postProcesses">An array of post processes to be run. (default: null)</param>
        abstract _prepareFrame: ?sourceTexture: InternalTexture * ?postProcesses: ResizeArray<PostProcess> -> bool
        /// <summary>Manually render a set of post processes to a texture.</summary>
        /// <param name="postProcesses">An array of post processes to be run.</param>
        /// <param name="targetTexture">The target texture to render to.</param>
        /// <param name="forceFullscreenViewport">force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight</param>
        /// <param name="faceIndex">defines the face to render to if a cubemap is defined as the target</param>
        /// <param name="lodLevel">defines which lod of the texture to render to</param>
        abstract directRender: postProcesses: ResizeArray<PostProcess> * ?targetTexture: InternalTexture * ?forceFullscreenViewport: bool * ?faceIndex: float * ?lodLevel: float -> unit
        /// <summary>Finalize the result of the output of the postprocesses.</summary>
        /// <param name="doNotPresent">If true the result will not be displayed to the screen.</param>
        /// <param name="targetTexture">The target texture to render to.</param>
        /// <param name="faceIndex">The index of the face to bind the target texture to.</param>
        /// <param name="postProcesses">The array of post processes to render.</param>
        /// <param name="forceFullscreenViewport">force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)</param>
        abstract _finalizeFrame: ?doNotPresent: bool * ?targetTexture: InternalTexture * ?faceIndex: float * ?postProcesses: Array<PostProcess> * ?forceFullscreenViewport: bool -> unit
        /// Disposes of the post process manager.
        abstract dispose: unit -> unit

    /// PostProcessManager is used to manage one or more post processes or post process pipelines
    /// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
    type [<AllowNullLiteral>] PostProcessManagerStatic =
        /// <summary>Creates a new instance PostProcess</summary>
        /// <param name="scene">The scene that the post process is associated with.</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> PostProcessManager

    /// Post process which applies a refractin texture
    type [<AllowNullLiteral>] RefractionPostProcess =
        inherit PostProcess
        /// the base color of the refraction (used to taint the rendering) 
        abstract color: Color3 with get, set
        /// simulated refraction depth 
        abstract depth: float with get, set
        /// the coefficient of the base color (0 to remove base color tainting) 
        abstract colorLevel: float with get, set
        /// Gets or sets the refraction texture
        /// Please note that you are responsible for disposing the texture if you set it manually
        abstract refractionTexture: Texture with get, set
        /// <summary>Disposes of the post process</summary>
        /// <param name="camera">Camera to dispose post process on</param>
        abstract dispose: camera: Camera -> unit

    /// Post process which applies a refractin texture
    type [<AllowNullLiteral>] RefractionPostProcessStatic =
        /// <summary>Initializes the RefractionPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="refractionTextureUrl">Url of the refraction texture to use</param>
        /// <param name="color">the base color of the refraction (used to taint the rendering)</param>
        /// <param name="depth">simulated refraction depth</param>
        /// <param name="colorLevel">the coefficient of the base color (0 to remove base color tainting)</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * refractionTextureUrl: string * color: Color3 * depth: float * colorLevel: float * options: U2<float, PostProcessOptions> * camera: Camera * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> RefractionPostProcess

    /// The SharpenPostProcess applies a sharpen kernel to every pixel
    /// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
    type [<AllowNullLiteral>] SharpenPostProcess =
        inherit PostProcess
        /// How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)
        abstract colorAmount: float with get, set
        /// How much sharpness should be applied (default: 0.3)
        abstract edgeAmount: float with get, set

    /// The SharpenPostProcess applies a sharpen kernel to every pixel
    /// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
    type [<AllowNullLiteral>] SharpenPostProcessStatic =
        /// <summary>Creates a new instance ConvolutionPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> SharpenPostProcess

    /// StereoscopicInterlacePostProcess used to render stereo views from a rigged camera
    type [<AllowNullLiteral>] StereoscopicInterlacePostProcess =
        inherit PostProcess

    /// StereoscopicInterlacePostProcess used to render stereo views from a rigged camera
    type [<AllowNullLiteral>] StereoscopicInterlacePostProcessStatic =
        /// <summary>Initializes a StereoscopicInterlacePostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="rigCameras">The rig cameras to be appled to the post process</param>
        /// <param name="isStereoscopicHoriz">If the rendered results are horizontal or verticle</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * rigCameras: ResizeArray<Camera> * isStereoscopicHoriz: bool * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> StereoscopicInterlacePostProcess

    type [<RequireQualifiedAccess>] TonemappingOperator =
        | Hable = 0
        | Reinhard = 1
        | HejiDawson = 2
        | Photographic = 3

    /// Defines a post process to apply tone mapping
    type [<AllowNullLiteral>] TonemapPostProcess =
        inherit PostProcess
        /// Defines the required exposure adjustement 
        abstract exposureAdjustment: float with get, set

    /// Defines a post process to apply tone mapping
    type [<AllowNullLiteral>] TonemapPostProcessStatic =
        /// <summary>Creates a new TonemapPostProcess</summary>
        /// <param name="name">defines the name of the postprocess</param>
        /// <param name="_operator">defines the operator to use</param>
        /// <param name="exposureAdjustment">defines the required exposure adjustement</param>
        /// <param name="camera">defines the camera to use (can be null)</param>
        /// <param name="samplingMode">defines the required sampling mode (BABYLON.Texture.BILINEAR_SAMPLINGMODE by default)</param>
        /// <param name="engine">defines the hosting engine (can be ignore if camera is set)</param>
        /// <param name="textureFormat">defines the texture format to use (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * _operator: TonemappingOperator * exposureAdjustment: float * camera: Camera * ?samplingMode: float * ?engine: Engine * ?textureFormat: float -> TonemapPostProcess

    /// Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html
    type [<AllowNullLiteral>] VolumetricLightScatteringPostProcess =
        inherit PostProcess
        /// If not undefined, the mesh position is computed from the attached node position
        abstract attachedNode: TypeLiteral_34 with get, set
        /// Custom position of the mesh. Used if "useCustomMeshPosition" is set to "true"
        abstract customMeshPosition: Vector3 with get, set
        /// Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)
        abstract useCustomMeshPosition: bool with get, set
        /// If the post-process should inverse the light scattering direction
        abstract invert: bool with get, set
        /// The internal mesh used by the post-process
        abstract mesh: Mesh with get, set
        abstract useDiffuseColor: bool with get, set
        /// Array containing the excluded meshes not rendered in the internal pass
        abstract excludedMeshes: ResizeArray<AbstractMesh> with get, set
        /// Controls the overall intensity of the post-process
        abstract exposure: float with get, set
        /// Dissipates each sample's contribution in range [0, 1]
        abstract decay: float with get, set
        /// Controls the overall intensity of each sample
        abstract weight: float with get, set
        /// Controls the density of each sample
        abstract density: float with get, set
        /// Returns the string "VolumetricLightScatteringPostProcess"
        abstract getClassName: unit -> string
        /// <summary>Sets the new light position for light scattering effect</summary>
        /// <param name="position">The new custom light position</param>
        abstract setCustomMeshPosition: position: Vector3 -> unit
        /// Returns the light position for light scattering effect
        abstract getCustomMeshPosition: unit -> Vector3
        /// Disposes the internal assets and detaches the post-process from the camera
        abstract dispose: camera: Camera -> unit
        /// Returns the render target texture used by the post-process
        abstract getPass: unit -> RenderTargetTexture

    /// Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html
    type [<AllowNullLiteral>] VolumetricLightScatteringPostProcessStatic =
        /// <param name="name">The post-process name</param>
        /// <param name="ratio">The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)</param>
        /// <param name="camera">The camera that the post-process will be attached to</param>
        /// <param name="mesh">The mesh used to create the light scattering</param>
        /// <param name="samples">The post-process quality, default 100</param>
        /// <param name="engine">The babylon engine</param>
        /// <param name="reusable">If the post-process is reusable</param>
        /// <param name="scene">The constructor needs a scene reference to initialize internal components. If "camera" is null a "scene" must be provided</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ratio: obj option * camera: Camera * ?mesh: Mesh * ?samples: float * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?scene: Scene -> VolumetricLightScatteringPostProcess
        /// <summary>Creates a default mesh for the Volumeric Light Scattering post-process</summary>
        /// <param name="name">The mesh name</param>
        /// <param name="scene">The scene where to create the mesh</param>
        abstract CreateDefaultMesh: name: string * scene: Scene -> Mesh

    /// VRDistortionCorrectionPostProcess used for mobile VR
    type [<AllowNullLiteral>] VRDistortionCorrectionPostProcess =
        inherit PostProcess

    /// VRDistortionCorrectionPostProcess used for mobile VR
    type [<AllowNullLiteral>] VRDistortionCorrectionPostProcessStatic =
        /// <summary>Initializes the VRDistortionCorrectionPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="isRightEye">If this is for the right eye distortion</param>
        /// <param name="vrMetrics">All the required metrics for the VR camera</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * camera: Camera * isRightEye: bool * vrMetrics: VRCameraMetrics -> VRDistortionCorrectionPostProcess

    /// Class used to represent a sprite
    type [<AllowNullLiteral>] Sprite =
        /// defines the name 
        abstract name: string with get, set
        /// Gets or sets the current world position 
        abstract position: Vector3 with get, set
        /// Gets or sets the main color 
        abstract color: Color4 with get, set
        /// Gets or sets the width 
        abstract width: float with get, set
        /// Gets or sets the height 
        abstract height: float with get, set
        /// Gets or sets rotation angle 
        abstract angle: float with get, set
        /// Gets or sets the cell index in the sprite sheet 
        abstract cellIndex: float with get, set
        /// Gets or sets a boolean indicating if UV coordinates should be inverted in U axis 
        abstract invertU: float with get, set
        /// Gets or sets a boolean indicating if UV coordinates should be inverted in B axis 
        abstract invertV: float with get, set
        /// Gets or sets a boolean indicating that this sprite should be disposed after animation ends 
        abstract disposeWhenFinishedAnimating: bool with get, set
        /// Gets the list of attached animations 
        abstract animations: ResizeArray<Animation> with get, set
        /// Gets or sets a boolean indicating if the sprite can be picked 
        abstract isPickable: bool with get, set
        /// Gets or sets the associated action manager
        abstract actionManager: Nullable<ActionManager> with get, set
        /// Gets or sets a boolean indicating if the sprite is visible (renderable). Default is true
        abstract isVisible: bool with get, set
        /// Gets or sets the sprite size
        abstract size: float with get, set
        /// <summary>Starts an animation</summary>
        /// <param name="from">defines the initial key</param>
        /// <param name="to">defines the end key</param>
        /// <param name="loop">defines if the animation must loop</param>
        /// <param name="delay">defines the start delay (in ms)</param>
        /// <param name="onAnimationEnd">defines a callback to call when animation ends</param>
        abstract playAnimation: from: float * ``to``: float * loop: bool * delay: float * onAnimationEnd: (unit -> unit) -> unit
        /// Stops current animation (if any) 
        abstract stopAnimation: unit -> unit
        abstract _animate: deltaTime: float -> unit
        /// Release associated resources 
        abstract dispose: unit -> unit

    /// Class used to represent a sprite
    type [<AllowNullLiteral>] SpriteStatic =
        /// <summary>Creates a new Sprite</summary>
        /// <param name="name">defines the name</param>
        /// <param name="manager">defines the manager</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * manager: ISpriteManager -> Sprite

    /// Defines the minimum interface to fullfil in order to be a sprite manager.
    type [<AllowNullLiteral>] ISpriteManager =
        inherit IDisposable
        /// Restricts the camera to viewing objects with the same layerMask.
        /// A camera with a layerMask of 1 will render spriteManager.layerMask & camera.layerMask!== 0
        abstract layerMask: float with get, set
        /// Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true
        abstract isPickable: bool with get, set
        /// Specifies the rendering group id for this mesh (0 by default)
        abstract renderingGroupId: float with get, set
        /// Defines the list of sprites managed by the manager.
        abstract sprites: Array<Sprite> with get, set
        /// <summary>Tests the intersection of a sprite with a specific ray.</summary>
        /// <param name="ray">The ray we are sending to test the collision</param>
        /// <param name="camera">The camera space we are sending rays in</param>
        /// <param name="predicate">A predicate allowing excluding sprites from the list of object to test</param>
        /// <param name="fastCheck">Is the hit test done in a OOBB or AOBB fashion the faster, the less precise</param>
        abstract intersects: ray: Ray * camera: Camera * ?predicate: (Sprite -> bool) * ?fastCheck: bool -> Nullable<PickingInfo>
        /// Renders the list of sprites on screen.
        abstract render: unit -> unit

    /// Class used to manage multiple sprites on the same spritesheet
    type [<AllowNullLiteral>] SpriteManager =
        inherit ISpriteManager
        /// defines the manager's name 
        abstract name: string with get, set
        /// Gets the list of sprites 
        abstract sprites: ResizeArray<Sprite> with get, set
        /// Gets or sets the rendering group id (0 by default) 
        abstract renderingGroupId: float with get, set
        /// Gets or sets camera layer mask 
        abstract layerMask: float with get, set
        /// Gets or sets a boolean indicating if the manager must consider scene fog when rendering 
        abstract fogEnabled: bool with get, set
        /// Gets or sets a boolean indicating if the sprites are pickable 
        abstract isPickable: bool with get, set
        /// Defines the default width of a cell in the spritesheet 
        abstract cellWidth: float with get, set
        /// Defines the default height of a cell in the spritesheet 
        abstract cellHeight: float with get, set
        /// An event triggered when the manager is disposed.
        abstract onDisposeObservable: Observable<SpriteManager> with get, set
        /// Callback called when the manager is disposed
        abstract onDispose: (unit -> unit) with get, set
        /// Gets or sets the spritesheet texture
        abstract texture: Texture with get, set
        /// <summary>Intersects the sprites with a ray</summary>
        /// <param name="ray">defines the ray to intersect with</param>
        /// <param name="camera">defines the current active camera</param>
        /// <param name="predicate">defines a predicate used to select candidate sprites</param>
        /// <param name="fastCheck">defines if a fast check only must be done (the first potential sprite is will be used and not the closer)</param>
        abstract intersects: ray: Ray * camera: Camera * ?predicate: (Sprite -> bool) * ?fastCheck: bool -> Nullable<PickingInfo>
        /// Render all child sprites
        abstract render: unit -> unit
        /// Release associated resources
        abstract dispose: unit -> unit

    /// Class used to manage multiple sprites on the same spritesheet
    type [<AllowNullLiteral>] SpriteManagerStatic =
        /// <summary>Creates a new sprite manager</summary>
        /// <param name="name">defines the manager's name</param>
        /// <param name="imgUrl">defines the sprite sheet url</param>
        /// <param name="capacity">defines the maximum allowed number of sprites</param>
        /// <param name="cellSize">defines the size of a sprite cell</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="epsilon">defines the epsilon value to align texture (0.01 by default)</param>
        /// <param name="samplingMode">defines the smapling mode to use with spritesheet</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * imgUrl: string * capacity: float * cellSize: obj option * scene: Scene * ?epsilon: float * ?samplingMode: float -> SpriteManager

    /// Defines the sprite scene component responsible to manage sprites
    /// in a given scene.
    type [<AllowNullLiteral>] SpriteSceneComponent =
        inherit ISceneComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources.
        abstract dispose: unit -> unit

    /// Defines the sprite scene component responsible to manage sprites
    /// in a given scene.
    type [<AllowNullLiteral>] SpriteSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> SpriteSceneComponent

    type [<AllowNullLiteral>] _AlphaState =
        abstract isDirty: bool
        abstract alphaBlend: bool with get, set
        abstract setAlphaBlendConstants: r: float * g: float * b: float * a: float -> unit
        abstract setAlphaBlendFunctionParameters: value0: float * value1: float * value2: float * value3: float -> unit
        abstract setAlphaEquationParameters: rgb: float * alpha: float -> unit
        abstract reset: unit -> unit
        abstract apply: gl: WebGLRenderingContext -> unit

    type [<AllowNullLiteral>] _AlphaStateStatic =
        /// Initializes the state.
        [<Emit "new $0($1...)">] abstract Create: unit -> _AlphaState

    type [<AllowNullLiteral>] _DepthCullingState =
        abstract isDirty: bool
        abstract zOffset: float with get, set
        abstract cullFace: Nullable<float> with get, set
        abstract cull: Nullable<bool> with get, set
        abstract depthFunc: Nullable<float> with get, set
        abstract depthMask: bool with get, set
        abstract depthTest: bool with get, set
        abstract frontFace: Nullable<float> with get, set
        abstract reset: unit -> unit
        abstract apply: gl: WebGLRenderingContext -> unit

    type [<AllowNullLiteral>] _DepthCullingStateStatic =
        /// Initializes the state.
        [<Emit "new $0($1...)">] abstract Create: unit -> _DepthCullingState

    type [<AllowNullLiteral>] _StencilState =
        abstract isDirty: bool
        abstract stencilFunc: float with get, set
        abstract stencilFuncRef: float with get, set
        abstract stencilFuncMask: float with get, set
        abstract stencilOpStencilFail: float with get, set
        abstract stencilOpDepthFail: float with get, set
        abstract stencilOpStencilDepthPass: float with get, set
        abstract stencilMask: float with get, set
        abstract stencilTest: bool with get, set
        abstract reset: unit -> unit
        abstract apply: gl: WebGLRenderingContext -> unit

    type [<AllowNullLiteral>] _StencilStateStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> _StencilState

    /// Class used to evalaute queries containing `and` and `or` operators
    type [<AllowNullLiteral>] AndOrNotEvaluator =
        interface end

    /// Class used to evalaute queries containing `and` and `or` operators
    type [<AllowNullLiteral>] AndOrNotEvaluatorStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> AndOrNotEvaluator
        /// <summary>Evaluate a query</summary>
        /// <param name="query">defines the query to evaluate</param>
        /// <param name="evaluateCallback">defines the callback used to filter result</param>
        abstract Eval: query: string * evaluateCallback: (obj option -> bool) -> bool

    type [<RequireQualifiedAccess>] AssetTaskState =
        | INIT = 0
        | RUNNING = 1
        | DONE = 2
        | ERROR = 3

    /// Define an abstract asset task used with a AssetsManager class to load assets into a scene
    type [<AllowNullLiteral>] AbstractAssetTask =
        /// Task name
        abstract name: string with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (obj option -> unit) with get, set
        /// Callback called when the task is not successful
        abstract onError: (obj option -> string -> obj -> unit) with get, set
        /// Get if the task is completed
        abstract isCompleted: bool
        /// Gets the current state of the task
        abstract taskState: AssetTaskState
        /// Gets the current error object (if task is in error)
        abstract errorObject: TypeLiteral_19
        /// Internal only
        abstract _setErrorObject: ?message: string * ?``exception``: obj -> unit
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract run: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj -> unit) -> unit
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj -> unit) -> unit
        /// Reset will set the task state back to INIT, so the next load call of the assets manager will execute this task again.
        /// This can be used with failed tasks that have the reason for failure fixed.
        abstract reset: unit -> unit

    /// Define an abstract asset task used with a AssetsManager class to load assets into a scene
    type [<AllowNullLiteral>] AbstractAssetTaskStatic =
        /// <summary>Creates a new AssetsManager</summary>
        /// <param name="name">defines the name of the task</param>
        [<Emit "new $0($1...)">] abstract Create: name: string -> AbstractAssetTask

    /// Define the interface used by progress events raised during assets loading
    type [<AllowNullLiteral>] IAssetsProgressEvent =
        /// Defines the number of remaining tasks to process
        abstract remainingCount: float with get, set
        /// Defines the total number of tasks
        abstract totalCount: float with get, set
        /// Defines the task that was just processed
        abstract task: AbstractAssetTask with get, set

    /// Class used to share progress information about assets loading
    type [<AllowNullLiteral>] AssetsProgressEvent =
        inherit IAssetsProgressEvent
        /// Defines the number of remaining tasks to process
        abstract remainingCount: float with get, set
        /// Defines the total number of tasks
        abstract totalCount: float with get, set
        /// Defines the task that was just processed
        abstract task: AbstractAssetTask with get, set

    /// Class used to share progress information about assets loading
    type [<AllowNullLiteral>] AssetsProgressEventStatic =
        /// <summary>Creates a AssetsProgressEvent</summary>
        /// <param name="remainingCount">defines the number of remaining tasks to process</param>
        /// <param name="totalCount">defines the total number of tasks</param>
        /// <param name="task">defines the task that was just processed</param>
        [<Emit "new $0($1...)">] abstract Create: remainingCount: float * totalCount: float * task: AbstractAssetTask -> AssetsProgressEvent

    /// Define a task used by AssetsManager to load meshes
    type [<AllowNullLiteral>] MeshAssetTask =
        inherit AbstractAssetTask
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the list of mesh's names you want to load
        abstract meshesNames: obj option with get, set
        /// Defines the root url to use as a base to load your meshes and associated resources
        abstract rootUrl: string with get, set
        /// Defines the filename of the scene to load from
        abstract sceneFilename: string with get, set
        /// Gets the list of loaded meshes
        abstract loadedMeshes: Array<AbstractMesh> with get, set
        /// Gets the list of loaded particle systems
        abstract loadedParticleSystems: Array<IParticleSystem> with get, set
        /// Gets the list of loaded skeletons
        abstract loadedSkeletons: Array<Skeleton> with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (MeshAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (MeshAssetTask -> string -> obj -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj -> unit) -> unit

    /// Define a task used by AssetsManager to load meshes
    type [<AllowNullLiteral>] MeshAssetTaskStatic =
        /// <summary>Creates a new MeshAssetTask</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="meshesNames">defines the list of mesh's names you want to load</param>
        /// <param name="rootUrl">defines the root url to use as a base to load your meshes and associated resources</param>
        /// <param name="sceneFilename">defines the filename of the scene to load from</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * meshesNames: obj option * rootUrl: string * sceneFilename: string -> MeshAssetTask

    /// Define a task used by AssetsManager to load text content
    type [<AllowNullLiteral>] TextFileAssetTask =
        inherit AbstractAssetTask
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the file to load
        abstract url: string with get, set
        /// Gets the loaded text string
        abstract text: string with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (TextFileAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (TextFileAssetTask -> string -> obj -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj -> unit) -> unit

    /// Define a task used by AssetsManager to load text content
    type [<AllowNullLiteral>] TextFileAssetTaskStatic =
        /// <summary>Creates a new TextFileAssetTask object</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="url">defines the location of the file to load</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string -> TextFileAssetTask

    /// Define a task used by AssetsManager to load binary data
    type [<AllowNullLiteral>] BinaryFileAssetTask =
        inherit AbstractAssetTask
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the file to load
        abstract url: string with get, set
        /// Gets the lodaded data (as an array buffer)
        abstract data: ArrayBuffer with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (BinaryFileAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (BinaryFileAssetTask -> string -> obj -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj -> unit) -> unit

    /// Define a task used by AssetsManager to load binary data
    type [<AllowNullLiteral>] BinaryFileAssetTaskStatic =
        /// <summary>Creates a new BinaryFileAssetTask object</summary>
        /// <param name="name">defines the name of the new task</param>
        /// <param name="url">defines the location of the file to load</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string -> BinaryFileAssetTask

    /// Define a task used by AssetsManager to load images
    type [<AllowNullLiteral>] ImageAssetTask =
        inherit AbstractAssetTask
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the image to load
        abstract url: string with get, set
        /// Gets the loaded images
        abstract image: HTMLImageElement with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (ImageAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (ImageAssetTask -> string -> obj -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj -> unit) -> unit

    /// Define a task used by AssetsManager to load images
    type [<AllowNullLiteral>] ImageAssetTaskStatic =
        /// <summary>Creates a new ImageAssetTask</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="url">defines the location of the image to load</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string -> ImageAssetTask

    /// Defines the interface used by texture loading tasks
    type [<AllowNullLiteral>] ITextureAssetTask<'TEX> =
        /// Gets the loaded texture
        abstract texture: 'TEX with get, set

    /// Define a task used by AssetsManager to load 2D textures
    type [<AllowNullLiteral>] TextureAssetTask =
        inherit AbstractAssetTask
        inherit ITextureAssetTask<Texture>
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the file to load
        abstract url: string with get, set
        /// Defines if mipmap should not be generated (default is false)
        abstract noMipmap: bool option with get, set
        /// Defines if texture must be inverted on Y axis (default is false)
        abstract invertY: bool option with get, set
        /// Defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)
        abstract samplingMode: float with get, set
        /// Gets the loaded texture
        abstract texture: Texture with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (TextureAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (TextureAssetTask -> string -> obj -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj -> unit) -> unit

    /// Define a task used by AssetsManager to load 2D textures
    type [<AllowNullLiteral>] TextureAssetTaskStatic =
        /// <summary>Creates a new TextureAssetTask object</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="url">defines the location of the file to load</param>
        /// <param name="noMipmap">defines if mipmap should not be generated (default is false)</param>
        /// <param name="invertY">defines if texture must be inverted on Y axis (default is false)</param>
        /// <param name="samplingMode">defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string * ?noMipmap: bool * ?invertY: bool * ?samplingMode: float -> TextureAssetTask

    /// Define a task used by AssetsManager to load cube textures
    type [<AllowNullLiteral>] CubeTextureAssetTask =
        inherit AbstractAssetTask
        inherit ITextureAssetTask<CubeTexture>
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
        abstract url: string with get, set
        /// Defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
        abstract extensions: ResizeArray<string> option with get, set
        /// Defines if mipmaps should not be generated (default is false)
        abstract noMipmap: bool option with get, set
        /// Defines the explicit list of files (undefined by default)
        abstract files: ResizeArray<string> option with get, set
        /// Gets the loaded texture
        abstract texture: CubeTexture with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (CubeTextureAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (CubeTextureAssetTask -> string -> obj -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj -> unit) -> unit

    /// Define a task used by AssetsManager to load cube textures
    type [<AllowNullLiteral>] CubeTextureAssetTaskStatic =
        /// <summary>Creates a new CubeTextureAssetTask</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="url">defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)</param>
        /// <param name="extensions">defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)</param>
        /// <param name="noMipmap">defines if mipmaps should not be generated (default is false)</param>
        /// <param name="files">defines the explicit list of files (undefined by default)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string * ?extensions: ResizeArray<string> * ?noMipmap: bool * ?files: ResizeArray<string> -> CubeTextureAssetTask

    /// Define a task used by AssetsManager to load HDR cube textures
    type [<AllowNullLiteral>] HDRCubeTextureAssetTask =
        inherit AbstractAssetTask
        inherit ITextureAssetTask<HDRCubeTexture>
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the file to load
        abstract url: string with get, set
        /// Defines the desired size (the more it increases the longer the generation will be)
        abstract size: float with get, set
        /// Defines if mipmaps should not be generated (default is false)
        abstract noMipmap: bool with get, set
        /// Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
        abstract generateHarmonics: bool with get, set
        /// Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
        abstract gammaSpace: bool with get, set
        /// Internal Use Only
        abstract reserved: bool with get, set
        /// Gets the loaded texture
        abstract texture: HDRCubeTexture with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (HDRCubeTextureAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (HDRCubeTextureAssetTask -> string -> obj -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract run: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj -> unit) -> unit

    /// Define a task used by AssetsManager to load HDR cube textures
    type [<AllowNullLiteral>] HDRCubeTextureAssetTaskStatic =
        /// <summary>Creates a new HDRCubeTextureAssetTask object</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="url">defines the location of the file to load</param>
        /// <param name="size">defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.</param>
        /// <param name="noMipmap">defines if mipmaps should not be generated (default is false)</param>
        /// <param name="generateHarmonics">specifies whether you want to extract the polynomial harmonics during the generation process (default is true)</param>
        /// <param name="gammaSpace">specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)</param>
        /// <param name="reserved">Internal use only</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string * size: float * ?noMipmap: bool * ?generateHarmonics: bool * ?gammaSpace: bool * ?reserved: bool -> HDRCubeTextureAssetTask

    /// This class can be used to easily import assets into a scene
    type [<AllowNullLiteral>] AssetsManager =
        abstract _tasks: ResizeArray<AbstractAssetTask> with get, set
        abstract _waitingTasksCount: float with get, set
        abstract _totalTasksCount: float with get, set
        /// Callback called when all tasks are processed
        abstract onFinish: (ResizeArray<AbstractAssetTask> -> unit) with get, set
        /// Callback called when a task is successful
        abstract onTaskSuccess: (AbstractAssetTask -> unit) with get, set
        /// Callback called when a task had an error
        abstract onTaskError: (AbstractAssetTask -> unit) with get, set
        /// Callback called when a task is done (whatever the result is)
        abstract onProgress: (float -> float -> AbstractAssetTask -> unit) with get, set
        /// Observable called when all tasks are processed
        abstract onTaskSuccessObservable: Observable<AbstractAssetTask> with get, set
        /// Observable called when a task had an error
        abstract onTaskErrorObservable: Observable<AbstractAssetTask> with get, set
        /// Observable called when a task is successful
        abstract onTasksDoneObservable: Observable<ResizeArray<AbstractAssetTask>> with get, set
        /// Observable called when a task is done (whatever the result is)
        abstract onProgressObservable: Observable<IAssetsProgressEvent> with get, set
        /// Gets or sets a boolean defining if the AssetsManager should use the default loading screen
        abstract useDefaultLoadingScreen: bool with get, set
        /// <summary>Add a MeshAssetTask to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="meshesNames">defines the name of meshes to load</param>
        /// <param name="rootUrl">defines the root url to use to locate files</param>
        /// <param name="sceneFilename">defines the filename of the scene file</param>
        abstract addMeshTask: taskName: string * meshesNames: obj option * rootUrl: string * sceneFilename: string -> MeshAssetTask
        /// <summary>Add a TextFileAssetTask to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        abstract addTextFileTask: taskName: string * url: string -> TextFileAssetTask
        /// <summary>Add a BinaryFileAssetTask to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        abstract addBinaryFileTask: taskName: string * url: string -> BinaryFileAssetTask
        /// <summary>Add a ImageAssetTask to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        abstract addImageTask: taskName: string * url: string -> ImageAssetTask
        /// <summary>Add a TextureAssetTask to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        /// <param name="noMipmap">defines if the texture must not receive mipmaps (false by default)</param>
        /// <param name="invertY">defines if you want to invert Y axis of the loaded texture (false by default)</param>
        /// <param name="samplingMode">defines the sampling mode to use (BABYLON.Texture.TRILINEAR_SAMPLINGMODE by default)</param>
        abstract addTextureTask: taskName: string * url: string * ?noMipmap: bool * ?invertY: bool * ?samplingMode: float -> TextureAssetTask
        /// <summary>Add a CubeTextureAssetTask to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        /// <param name="extensions">defines the extension to use to load the cube map (can be null)</param>
        /// <param name="noMipmap">defines if the texture must not receive mipmaps (false by default)</param>
        /// <param name="files">defines the list of files to load (can be null)</param>
        abstract addCubeTextureTask: taskName: string * url: string * ?extensions: ResizeArray<string> * ?noMipmap: bool * ?files: ResizeArray<string> -> CubeTextureAssetTask
        /// <summary>Add a HDRCubeTextureAssetTask to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        /// <param name="size">defines the size you want for the cubemap (can be null)</param>
        /// <param name="noMipmap">defines if the texture must not receive mipmaps (false by default)</param>
        /// <param name="generateHarmonics">defines if you want to automatically generate (true by default)</param>
        /// <param name="gammaSpace">specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)</param>
        /// <param name="reserved">Internal use only</param>
        abstract addHDRCubeTextureTask: taskName: string * url: string * size: float * ?noMipmap: bool * ?generateHarmonics: bool * ?gammaSpace: bool * ?reserved: bool -> HDRCubeTextureAssetTask
        /// <summary>Remove a task from the assets manager.</summary>
        /// <param name="task">the task to remove</param>
        abstract removeTask: task: AbstractAssetTask -> unit
        /// Reset the AssetsManager and remove all tasks
        abstract reset: unit -> AssetsManager
        /// Start the loading process
        abstract load: unit -> AssetsManager

    /// This class can be used to easily import assets into a scene
    type [<AllowNullLiteral>] AssetsManagerStatic =
        /// <summary>Creates a new AssetsManager</summary>
        /// <param name="scene">defines the scene to work on</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> AssetsManager

    /// Class used to enable access to IndexedDB
    type [<AllowNullLiteral>] Database =
        /// Gets a boolean indicating if scene must be saved in the database
        abstract enableSceneOffline: bool
        /// Gets a boolean indicating if textures must be saved in the database
        abstract enableTexturesOffline: bool
        /// <summary>Open the database and make it available</summary>
        /// <param name="successCallback">defines the callback to call on success</param>
        /// <param name="errorCallback">defines the callback to call on error</param>
        abstract openAsync: successCallback: (unit -> unit) * errorCallback: (unit -> unit) -> unit
        /// <summary>Loads an image from the database</summary>
        /// <param name="url">defines the url to load from</param>
        /// <param name="image">defines the target DOM image</param>
        abstract loadImageFromDB: url: string * image: HTMLImageElement -> unit
        /// <summary>Loads a file from database</summary>
        /// <param name="url">defines the URL to load from</param>
        /// <param name="sceneLoaded">defines a callback to call on success</param>
        /// <param name="progressCallBack">defines a callback to call when progress changed</param>
        /// <param name="errorCallback">defines a callback to call on error</param>
        /// <param name="useArrayBuffer">defines a boolean to use array buffer instead of text string</param>
        abstract loadFileFromDB: url: string * sceneLoaded: (obj option -> unit) * ?progressCallBack: (obj option -> unit) * ?errorCallback: (unit -> unit) * ?useArrayBuffer: bool -> unit

    /// Class used to enable access to IndexedDB
    type [<AllowNullLiteral>] DatabaseStatic =
        /// Gets a boolean indicating if the user agent supports blob storage (this value will be updated after creating the first Database object) 
        abstract IsUASupportingBlobStorage: bool with get, set
        /// Gets a boolean indicating if Database storate is enabled 
        abstract IDBStorageEnabled: bool with get, set
        /// <summary>Creates a new Database</summary>
        /// <param name="urlToScene">defines the url to load the scene</param>
        /// <param name="callbackManifestChecked">defines the callback to use when manifest is checked</param>
        /// <param name="disableManifestCheck">defines a boolean indicating that we want to skip the manifest validation (it will be considered validated and up to date)</param>
        [<Emit "new $0($1...)">] abstract Create: urlToScene: string * callbackManifestChecked: (bool -> obj option) * ?disableManifestCheck: bool -> Database

    /// Direct draw surface info
    type [<AllowNullLiteral>] DDSInfo =
        /// Width of the texture
        abstract width: float with get, set
        /// Width of the texture
        abstract height: float with get, set
        /// Number of Mipmaps for the texture
        abstract mipmapCount: float with get, set
        /// If the textures format is a known fourCC format
        abstract isFourCC: bool with get, set
        /// If the texture is an RGB format eg. DXGI_FORMAT_B8G8R8X8_UNORM format
        abstract isRGB: bool with get, set
        /// If the texture is a lumincance format
        abstract isLuminance: bool with get, set
        /// If this is a cube texture
        abstract isCube: bool with get, set
        /// If the texture is a compressed format eg. FOURCC_DXT1
        abstract isCompressed: bool with get, set
        /// The dxgiFormat of the texture
        abstract dxgiFormat: float with get, set
        /// Texture type eg. Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT
        abstract textureType: float with get, set
        /// Sphericle polynomial created for the dds texture
        abstract sphericalPolynomial: SphericalPolynomial option with get, set

    /// Class used to provide DDS decompression tools
    type [<AllowNullLiteral>] DDSTools =
        interface end

    /// Class used to provide DDS decompression tools
    type [<AllowNullLiteral>] DDSToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> DDSTools
        /// Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)
        abstract StoreLODInAlphaChannel: bool with get, set
        /// <summary>Gets DDS information from an array buffer</summary>
        /// <param name="arrayBuffer">defines the array buffer to read data from</param>
        abstract GetDDSInfo: arrayBuffer: obj option -> DDSInfo
        /// Uploads DDS Levels to a Babylon Texture
        abstract UploadDDSLevels: engine: Engine * texture: InternalTexture * arrayBuffer: obj option * info: DDSInfo * loadMipmaps: bool * faces: float * ?lodIndex: float * ?currentFace: float -> unit

    /// Class used to help serialization objects
    type [<AllowNullLiteral>] SerializationHelper =
        interface end

    /// Class used to help serialization objects
    type [<AllowNullLiteral>] SerializationHelperStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SerializationHelper
        /// <summary>Static function used to serialized a specific entity</summary>
        /// <param name="entity">defines the entity to serialize</param>
        /// <param name="serializationObject">defines the optional target obecjt where serialization data will be stored</param>
        abstract Serialize: entity: 'T * ?serializationObject: obj -> obj option
        /// <summary>Creates a new entity from a serialization data object</summary>
        /// <param name="creationFunction">defines a function used to instanciated the new entity</param>
        /// <param name="source">defines the source serialization data</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="rootUrl">defines the root url for resources</param>
        abstract Parse: creationFunction: (unit -> 'T) * source: obj option * scene: Nullable<Scene> * ?rootUrl: string -> 'T
        /// <summary>Clones an object</summary>
        /// <param name="creationFunction">defines the function used to instanciate the new object</param>
        /// <param name="source">defines the source object</param>
        abstract Clone: creationFunction: (unit -> 'T) * source: 'T -> 'T
        /// <summary>Instanciates a new object based on a source one (some data will be shared between both object)</summary>
        /// <param name="creationFunction">defines the function used to instanciate the new object</param>
        /// <param name="source">defines the source object</param>
        abstract Instanciate: creationFunction: (unit -> 'T) * source: 'T -> 'T

    /// Wrapper class for promise with external resolve and reject.
    type [<AllowNullLiteral>] Deferred<'T> =
        /// The promise associated with this deferred object.
        abstract promise: Promise<'T>
        /// The resolve method of the promise associated with this deferred object.
        abstract resolve: (U2<'T, PromiseLike<'T>> -> unit)
        /// The reject method of the promise associated with this deferred object.
        abstract reject: (obj -> unit)

    /// Wrapper class for promise with external resolve and reject.
    type [<AllowNullLiteral>] DeferredStatic =
        /// Constructor for this deferred object.
        [<Emit "new $0($1...)">] abstract Create: unit -> Deferred<'T>

    /// Raw texture data and descriptor sufficient for WebGL texture upload
    type [<AllowNullLiteral>] EnvironmentTextureInfo =
        /// Version of the environment map
        abstract version: float with get, set
        /// Width of image
        abstract width: float with get, set
        /// Irradiance information stored in the file.
        abstract irradiance: obj option with get, set
        /// Specular information stored in the file.
        abstract specular: obj option with get, set

    /// Sets of helpers addressing the serialization and deserialization of environment texture
    /// stored in a BabylonJS env file.
    /// Those files are usually stored as .env files.
    type [<AllowNullLiteral>] EnvironmentTextureTools =
        interface end

    /// Sets of helpers addressing the serialization and deserialization of environment texture
    /// stored in a BabylonJS env file.
    /// Those files are usually stored as .env files.
    type [<AllowNullLiteral>] EnvironmentTextureToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> EnvironmentTextureTools
        /// <summary>Gets the environment info from an env file.</summary>
        /// <param name="data">The array buffer containing the .env bytes.</param>
        abstract GetEnvInfo: data: ArrayBuffer -> Nullable<EnvironmentTextureInfo>
        /// <summary>Creates an environment texture from a loaded cube texture.</summary>
        /// <param name="texture">defines the cube texture to convert in env file</param>
        abstract CreateEnvTextureAsync: texture: CubeTexture -> Promise<ArrayBuffer>
        /// <summary>Uploads the texture info contained in the env file to the GPU.</summary>
        /// <param name="texture">defines the internal texture to upload to</param>
        /// <param name="arrayBuffer">defines the buffer cotaining the data to load</param>
        /// <param name="info">defines the texture info retrieved through the GetEnvInfo method</param>
        abstract UploadEnvLevelsAsync: texture: InternalTexture * arrayBuffer: obj option * info: EnvironmentTextureInfo -> Promise<unit>
        /// <summary>Uploads the levels of image data to the GPU.</summary>
        /// <param name="texture">defines the internal texture to upload to</param>
        /// <param name="imageData">defines the array buffer views of image data [mipmap][face]</param>
        abstract UploadLevelsAsync: texture: InternalTexture * imageData: ResizeArray<ResizeArray<ArrayBufferView>> -> Promise<unit>
        /// <summary>Uploads spherical polynomials information to the texture.</summary>
        /// <param name="texture">defines the texture we are trying to upload the information to</param>
        /// <param name="info">defines the environment texture info retrieved through the GetEnvInfo method</param>
        abstract UploadEnvSpherical: texture: InternalTexture * info: EnvironmentTextureInfo -> unit

    /// Class used to help managing file picking and drag'n'drop
    type [<AllowNullLiteral>] FilesInput =
        /// Callback called when a file is processed
        abstract onProcessFileCallback: (File -> string -> string -> obj) with get, set
        /// <summary>Calls this function to listen to drag'n'drop events on a specific DOM element</summary>
        /// <param name="elementToMonitor">defines the DOM element to track</param>
        abstract monitorElementForDragNDrop: elementToMonitor: HTMLElement -> unit
        /// Release all associated resources
        abstract dispose: unit -> unit
        /// <summary>Load files from a drop event</summary>
        /// <param name="event">defines the drop event to use as source</param>
        abstract loadFiles: ``event``: obj option -> unit
        /// Reload the current scene from the loaded files
        abstract reload: unit -> unit

    /// Class used to help managing file picking and drag'n'drop
    type [<AllowNullLiteral>] FilesInputStatic =
        /// List of files ready to be loaded
        abstract FilesToLoad: TypeLiteral_35 with get, set
        /// <summary>Creates a new FilesInput</summary>
        /// <param name="engine">defines the rendering engine</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="sceneLoadedCallback">callback called when scene is loaded</param>
        /// <param name="progressCallback">callback called to track progress</param>
        /// <param name="additionalRenderLoopLogicCallback">callback called to add user logic to the rendering loop</param>
        /// <param name="textureLoadingCallback">callback called when a texture is loading</param>
        /// <param name="startingProcessingFilesCallback">callback called when the system is about to process all files</param>
        /// <param name="onReloadCallback">callback called when a reload is requested</param>
        /// <param name="errorCallback">callback call if an error occurs</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * scene: Scene * sceneLoadedCallback: (File -> Scene -> unit) * progressCallback: (SceneLoaderProgressEvent -> unit) * additionalRenderLoopLogicCallback: (unit -> unit) * textureLoadingCallback: (float -> unit) * startingProcessingFilesCallback: (ResizeArray<File> -> unit) * onReloadCallback: (File -> unit) * errorCallback: (File -> Scene -> string -> unit) -> FilesInput

    /// for description see https://www.khronos.org/opengles/sdk/tools/KTX/
    /// for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
    type [<AllowNullLiteral>] KhronosTextureContainer =
        /// contents of the KTX container file 
        abstract arrayBuffer: obj option with get, set
        /// Gets the openGL type
        abstract glType: float with get, set
        /// Gets the openGL type size
        abstract glTypeSize: float with get, set
        /// Gets the openGL format
        abstract glFormat: float with get, set
        /// Gets the openGL internal format
        abstract glInternalFormat: float with get, set
        /// Gets the base internal format
        abstract glBaseInternalFormat: float with get, set
        /// Gets image width in pixel
        abstract pixelWidth: float with get, set
        /// Gets image height in pixel
        abstract pixelHeight: float with get, set
        /// Gets image depth in pixels
        abstract pixelDepth: float with get, set
        /// Gets the number of array elements
        abstract numberOfArrayElements: float with get, set
        /// Gets the number of faces
        abstract numberOfFaces: float with get, set
        /// Gets the number of mipmap levels
        abstract numberOfMipmapLevels: float with get, set
        /// Gets the bytes of key value data
        abstract bytesOfKeyValueData: float with get, set
        /// Gets the load type
        abstract loadType: float with get, set
        /// <summary>Revert the endianness of a value.
        /// Not as fast hardware based, but will probably never need to use</summary>
        /// <param name="val">defines the value to convert</param>
        abstract switchEndianness: ``val``: float -> float
        /// Uploads KTX content to a Babylon Texture.
        /// It is assumed that the texture has already been created & is currently bound
        abstract uploadLevels: texture: InternalTexture * loadMipmaps: bool -> unit

    /// for description see https://www.khronos.org/opengles/sdk/tools/KTX/
    /// for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
    type [<AllowNullLiteral>] KhronosTextureContainerStatic =
        /// <summary>Creates a new KhronosTextureContainer</summary>
        /// <param name="arrayBuffer">contents of the KTX container file</param>
        /// <param name="facesExpected">should be either 1 or 6, based whether a cube texture or or</param>
        /// <param name="threeDExpected">provision for indicating that data should be a 3D texture, not implemented</param>
        /// <param name="textureArrayExpected">provision for indicating that data should be a texture array, not implemented</param>
        [<Emit "new $0($1...)">] abstract Create: arrayBuffer: obj option * facesExpected: float * ?threeDExpected: bool * ?textureArrayExpected: bool -> KhronosTextureContainer

    /// A class serves as a medium between the observable and its observers
    type [<AllowNullLiteral>] EventState =
        /// <summary>Initialize the current event state</summary>
        /// <param name="mask">defines the mask associated with this state</param>
        /// <param name="skipNextObservers">defines a flag which will instruct the observable to skip following observers when set to true</param>
        /// <param name="target">defines the original target of the state</param>
        /// <param name="currentTarget">defines the current target of the state</param>
        abstract initalize: mask: float * ?skipNextObservers: bool * ?target: obj * ?currentTarget: obj -> EventState
        /// An Observer can set this property to true to prevent subsequent observers of being notified
        abstract skipNextObservers: bool with get, set
        /// Get the mask value that were used to trigger the event corresponding to this EventState object
        abstract mask: float with get, set
        /// The object that originally notified the event
        abstract target: obj option with get, set
        /// The current object in the bubbling phase
        abstract currentTarget: obj option with get, set
        /// This will be populated with the return value of the last function that was executed.
        /// If it is the first function in the callback chain it will be the event data.
        abstract lastReturnValue: obj option with get, set

    /// A class serves as a medium between the observable and its observers
    type [<AllowNullLiteral>] EventStateStatic =
        /// <summary>Create a new EventState</summary>
        /// <param name="mask">defines the mask associated with this state</param>
        /// <param name="skipNextObservers">defines a flag which will instruct the observable to skip following observers when set to true</param>
        /// <param name="target">defines the original target of the state</param>
        /// <param name="currentTarget">defines the current target of the state</param>
        [<Emit "new $0($1...)">] abstract Create: mask: float * ?skipNextObservers: bool * ?target: obj * ?currentTarget: obj -> EventState

    /// Represent an Observer registered to a given Observable object.
    type [<AllowNullLiteral>] Observer<'T> =
        /// Defines the callback to call when the observer is notified
        abstract callback: ('T -> EventState -> unit) with get, set
        /// Defines the mask of the observer (used to filter notifications)
        abstract mask: float with get, set
        /// Defines the current scope used to restore the JS context
        abstract scope: obj option with get, set
        abstract _willBeUnregistered: bool with get, set
        /// Gets or sets a property defining that the observer as to be unregistered after the next notification
        abstract unregisterOnNextCall: bool with get, set

    /// Represent an Observer registered to a given Observable object.
    type [<AllowNullLiteral>] ObserverStatic =
        /// <summary>Creates a new observer</summary>
        /// <param name="callback">defines the callback to call when the observer is notified</param>
        /// <param name="mask">defines the mask of the observer (used to filter notifications)</param>
        /// <param name="scope">defines the current scope used to restore the JS context</param>
        [<Emit "new $0($1...)">] abstract Create: callback: ('T -> EventState -> unit) * mask: float * ?scope: obj -> Observer<'T>

    /// Represent a list of observers registered to multiple Observables object.
    type [<AllowNullLiteral>] MultiObserver<'T> =
        /// Release associated resources
        abstract dispose: unit -> unit

    /// Represent a list of observers registered to multiple Observables object.
    type [<AllowNullLiteral>] MultiObserverStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> MultiObserver<'T>
        /// <summary>Raise a callback when one of the observable will notify</summary>
        /// <param name="observables">defines a list of observables to watch</param>
        /// <param name="callback">defines the callback to call on notification</param>
        /// <param name="mask">defines the mask used to filter notifications</param>
        /// <param name="scope">defines the current scope used to restore the JS context</param>
        abstract Watch: observables: ResizeArray<Observable<'T>> * callback: ('T -> EventState -> unit) * ?mask: float * ?scope: obj -> MultiObserver<'T>

    /// The Observable class is a simple implementation of the Observable pattern.
    /// 
    /// There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
    /// This enable a more fine grained execution without having to rely on multiple different Observable objects.
    /// For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
    /// A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
    type [<AllowNullLiteral>] Observable<'T> =
        /// <summary>Create a new Observer with the specified callback</summary>
        /// <param name="callback">the callback that will be executed for that Observer</param>
        /// <param name="mask">the mask used to filter observers</param>
        /// <param name="insertFirst">if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.</param>
        /// <param name="scope">optional scope for the callback to be called from</param>
        /// <param name="unregisterOnFirstCall">defines if the observer as to be unregistered after the next notification</param>
        abstract add: callback: ('T -> EventState -> unit) * ?mask: float * ?insertFirst: bool * ?scope: obj * ?unregisterOnFirstCall: bool -> Nullable<Observer<'T>>
        /// <summary>Create a new Observer with the specified callback and unregisters after the next notification</summary>
        /// <param name="callback">the callback that will be executed for that Observer</param>
        abstract addOnce: callback: ('T -> EventState -> unit) -> Nullable<Observer<'T>>
        /// <summary>Remove an Observer from the Observable object</summary>
        /// <param name="observer">the instance of the Observer to remove</param>
        abstract remove: observer: Nullable<Observer<'T>> -> bool
        /// <summary>Remove a callback from the Observable object</summary>
        /// <param name="callback">the callback to remove</param>
        /// <param name="scope">optional scope. If used only the callbacks with this scope will be removed</param>
        abstract removeCallback: callback: ('T -> EventState -> unit) * ?scope: obj -> bool
        /// <summary>Notify all Observers by calling their respective callback with the given data
        /// Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute</summary>
        /// <param name="eventData">defines the data to send to all observers</param>
        /// <param name="mask">defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)</param>
        /// <param name="target">defines the original target of the state</param>
        /// <param name="currentTarget">defines the current target of the state</param>
        abstract notifyObservers: eventData: 'T * ?mask: float * ?target: obj * ?currentTarget: obj -> bool
        /// <summary>Calling this will execute each callback, expecting it to be a promise or return a value.
        /// If at any point in the chain one function fails, the promise will fail and the execution will not continue.
        /// This is useful when a chain of events (sometimes async events) is needed to initialize a certain object
        /// and it is crucial that all callbacks will be executed.
        /// The order of the callbacks is kept, callbacks are not executed parallel.</summary>
        /// <param name="eventData">The data to be sent to each callback</param>
        /// <param name="mask">is used to filter observers defaults to -1</param>
        /// <param name="target">defines the callback target (see EventState)</param>
        /// <param name="currentTarget">defines he current object in the bubbling phase</param>
        abstract notifyObserversWithPromise: eventData: 'T * ?mask: float * ?target: obj * ?currentTarget: obj -> Promise<'T>
        /// <summary>Notify a specific observer</summary>
        /// <param name="observer">defines the observer to notify</param>
        /// <param name="eventData">defines the data to be sent to each callback</param>
        /// <param name="mask">is used to filter observers defaults to -1</param>
        abstract notifyObserver: observer: Observer<'T> * eventData: 'T * ?mask: float -> unit
        /// Gets a boolean indicating if the observable has at least one observer
        abstract hasObservers: unit -> bool
        /// Clear the list of observers
        abstract clear: unit -> unit
        /// Clone the current observable
        abstract clone: unit -> Observable<'T>
        /// <summary>Does this observable handles observer registered with a given mask</summary>
        /// <param name="mask">defines the mask to be tested</param>
        abstract hasSpecificMask: ?mask: float -> bool

    /// The Observable class is a simple implementation of the Observable pattern.
    /// 
    /// There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
    /// This enable a more fine grained execution without having to rely on multiple different Observable objects.
    /// For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
    /// A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
    type [<AllowNullLiteral>] ObservableStatic =
        /// <summary>Creates a new observable</summary>
        /// <param name="onObserverAdded">defines a callback to call when a new observer is added</param>
        [<Emit "new $0($1...)">] abstract Create: ?onObserverAdded: (Observer<'T> -> unit) -> Observable<'T>

    /// Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window
    type [<AllowNullLiteral>] PerformanceMonitor =
        /// <summary>Samples current frame</summary>
        /// <param name="timeMs">A timestamp in milliseconds of the current frame to compare with other frames</param>
        abstract sampleFrame: ?timeMs: float -> unit
        /// Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
        abstract averageFrameTime: float
        /// Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
        abstract averageFrameTimeVariance: float
        /// Returns the frame time of the most recent frame
        abstract instantaneousFrameTime: float
        /// Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
        abstract averageFPS: float
        /// Returns the average framerate in frames per second using the most recent frame time
        abstract instantaneousFPS: float
        /// Returns true if enough samples have been taken to completely fill the sliding window
        abstract isSaturated: bool
        /// Enables contributions to the sliding window sample set
        abstract enable: unit -> unit
        /// Disables contributions to the sliding window sample set
        /// Samples will not be interpolated over the disabled period
        abstract disable: unit -> unit
        /// Returns true if sampling is enabled
        abstract isEnabled: bool
        /// Resets performance monitor
        abstract reset: unit -> unit

    /// Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window
    type [<AllowNullLiteral>] PerformanceMonitorStatic =
        /// <summary>constructor</summary>
        /// <param name="frameSampleSize">The number of samples required to saturate the sliding window</param>
        [<Emit "new $0($1...)">] abstract Create: ?frameSampleSize: float -> PerformanceMonitor

    /// RollingAverage
    /// 
    /// Utility to efficiently compute the rolling average and variance over a sliding window of samples
    type [<AllowNullLiteral>] RollingAverage =
        /// Current average
        abstract average: float with get, set
        /// Current variance
        abstract variance: float with get, set
        abstract _samples: Array<float> with get, set
        abstract _sampleCount: float with get, set
        abstract _pos: float with get, set
        abstract _m2: float with get, set
        /// <summary>Adds a sample to the sample set</summary>
        /// <param name="v">The sample value</param>
        abstract add: v: float -> unit
        /// <summary>Returns previously added values or null if outside of history or outside the sliding window domain</summary>
        /// <param name="i">Index in history. For example, pass 0 for the most recent value and 1 for the value before that</param>
        abstract history: i: float -> float
        /// Returns true if enough samples have been taken to completely fill the sliding window
        abstract isSaturated: unit -> bool
        /// Resets the rolling average (equivalent to 0 samples taken so far)
        abstract reset: unit -> unit
        /// <summary>Wraps a value around the sample range boundaries</summary>
        /// <param name="i">Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.</param>
        abstract _wrapPosition: i: float -> float

    /// RollingAverage
    /// 
    /// Utility to efficiently compute the rolling average and variance over a sliding window of samples
    type [<AllowNullLiteral>] RollingAverageStatic =
        /// <summary>constructor</summary>
        /// <param name="length">The number of samples required to saturate the sliding window</param>
        [<Emit "new $0($1...)">] abstract Create: length: float -> RollingAverage

    /// Helper class that provides a small promise polyfill
    type [<AllowNullLiteral>] PromisePolyfill =
        interface end

    /// Helper class that provides a small promise polyfill
    type [<AllowNullLiteral>] PromisePolyfillStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PromisePolyfill
        /// <summary>Static function used to check if the polyfill is required
        /// If this is the case then the function will inject the polyfill to window.Promise</summary>
        /// <param name="force">defines a boolean used to force the injection (mostly for testing purposes)</param>
        abstract Apply: ?force: bool -> unit

    /// Defines the root class used to create scene optimization to use with SceneOptimizer
    type [<AllowNullLiteral>] SceneOptimization =
        /// Defines the priority of this optimization (0 by default which means first in the list)
        abstract priority: float with get, set
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines the root class used to create scene optimization to use with SceneOptimizer
    type [<AllowNullLiteral>] SceneOptimizationStatic =
        /// <summary>Creates the SceneOptimization object</summary>
        /// <param name="priority">defines the priority of this optimization (0 by default which means first in the list)</param>
        [<Emit "new $0($1...)">] abstract Create: ?priority: float -> SceneOptimization

    /// Defines an optimization used to reduce the size of render target textures
    type [<AllowNullLiteral>] TextureOptimization =
        inherit SceneOptimization
        /// Defines the priority of this optimization (0 by default which means first in the list)
        abstract priority: float with get, set
        /// Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
        abstract maximumSize: float with get, set
        /// Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
        abstract step: float with get, set
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to reduce the size of render target textures
    type [<AllowNullLiteral>] TextureOptimizationStatic =
        /// <summary>Creates the TextureOptimization object</summary>
        /// <param name="priority">defines the priority of this optimization (0 by default which means first in the list)</param>
        /// <param name="maximumSize">defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter</param>
        /// <param name="step">defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.</param>
        [<Emit "new $0($1...)">] abstract Create: ?priority: float * ?maximumSize: float * ?step: float -> TextureOptimization

    /// Defines an optimization used to increase or decrease the rendering resolution
    type [<AllowNullLiteral>] HardwareScalingOptimization =
        inherit SceneOptimization
        /// Defines the priority of this optimization (0 by default which means first in the list)
        abstract priority: float with get, set
        /// Defines the maximum scale to use (2 by default)
        abstract maximumScale: float with get, set
        /// Defines the step to use between two passes (0.5 by default)
        abstract step: float with get, set
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to increase or decrease the rendering resolution
    type [<AllowNullLiteral>] HardwareScalingOptimizationStatic =
        /// <summary>Creates the HardwareScalingOptimization object</summary>
        /// <param name="priority">defines the priority of this optimization (0 by default which means first in the list)</param>
        /// <param name="maximumScale">defines the maximum scale to use (2 by default)</param>
        /// <param name="step">defines the step to use between two passes (0.5 by default)</param>
        [<Emit "new $0($1...)">] abstract Create: ?priority: float * ?maximumScale: float * ?step: float -> HardwareScalingOptimization

    /// Defines an optimization used to remove shadows
    type [<AllowNullLiteral>] ShadowsOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to remove shadows
    type [<AllowNullLiteral>] ShadowsOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ShadowsOptimization

    /// Defines an optimization used to turn post-processes off
    type [<AllowNullLiteral>] PostProcessesOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to turn post-processes off
    type [<AllowNullLiteral>] PostProcessesOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PostProcessesOptimization

    /// Defines an optimization used to turn lens flares off
    type [<AllowNullLiteral>] LensFlaresOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to turn lens flares off
    type [<AllowNullLiteral>] LensFlaresOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> LensFlaresOptimization

    /// Defines an optimization based on user defined callback.
    type [<AllowNullLiteral>] CustomOptimization =
        inherit SceneOptimization
        /// Callback called to apply the custom optimization.
        abstract onApply: (Scene -> SceneOptimizer -> bool) with get, set
        /// Callback called to get custom description
        abstract onGetDescription: (unit -> string) with get, set
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization based on user defined callback.
    type [<AllowNullLiteral>] CustomOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CustomOptimization

    /// Defines an optimization used to turn particles off
    type [<AllowNullLiteral>] ParticlesOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to turn particles off
    type [<AllowNullLiteral>] ParticlesOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ParticlesOptimization

    /// Defines an optimization used to turn render targets off
    type [<AllowNullLiteral>] RenderTargetsOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to turn render targets off
    type [<AllowNullLiteral>] RenderTargetsOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> RenderTargetsOptimization

    /// Defines an optimization used to merge meshes with compatible materials
    type [<AllowNullLiteral>] MergeMeshesOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        /// <param name="updateSelectionTree">defines that the selection octree has to be updated (false by default)</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer * ?updateSelectionTree: bool -> bool

    /// Defines an optimization used to merge meshes with compatible materials
    type [<AllowNullLiteral>] MergeMeshesOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> MergeMeshesOptimization
        /// Gets or sets a boolean which defines if optimization octree has to be updated
        /// Gets or sets a boolean which defines if optimization octree has to be updated
        abstract UpdateSelectionTree: bool with get, set

    /// Defines a list of options used by SceneOptimizer
    type [<AllowNullLiteral>] SceneOptimizerOptions =
        /// Defines the target frame rate to reach (60 by default)
        abstract targetFrameRate: float with get, set
        /// Defines the interval between two checkes (2000ms by default)
        abstract trackerDuration: float with get, set
        /// Gets the list of optimizations to apply
        abstract optimizations: ResizeArray<SceneOptimization> with get, set
        /// <summary>Add a new optimization</summary>
        /// <param name="optimization">defines the SceneOptimization to add to the list of active optimizations</param>
        abstract addOptimization: optimization: SceneOptimization -> SceneOptimizerOptions
        /// <summary>Add a new custom optimization</summary>
        /// <param name="onApply">defines the callback called to apply the custom optimization (true if everything that can be done was applied)</param>
        /// <param name="onGetDescription">defines the callback called to get the description attached with the optimization.</param>
        /// <param name="priority">defines the priority of this optimization (0 by default which means first in the list)</param>
        abstract addCustomOptimization: onApply: (Scene -> bool) * onGetDescription: (unit -> string) * ?priority: float -> SceneOptimizerOptions

    /// Defines a list of options used by SceneOptimizer
    type [<AllowNullLiteral>] SceneOptimizerOptionsStatic =
        /// <summary>Creates a new list of options used by SceneOptimizer</summary>
        /// <param name="targetFrameRate">defines the target frame rate to reach (60 by default)</param>
        /// <param name="trackerDuration">defines the interval between two checkes (2000ms by default)</param>
        [<Emit "new $0($1...)">] abstract Create: ?targetFrameRate: float * ?trackerDuration: float -> SceneOptimizerOptions
        /// <summary>Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene</summary>
        /// <param name="targetFrameRate">defines the target frame rate (60 by default)</param>
        abstract LowDegradationAllowed: ?targetFrameRate: float -> SceneOptimizerOptions
        /// <summary>Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual</summary>
        /// <param name="targetFrameRate">defines the target frame rate (60 by default)</param>
        abstract ModerateDegradationAllowed: ?targetFrameRate: float -> SceneOptimizerOptions
        /// <summary>Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual</summary>
        /// <param name="targetFrameRate">defines the target frame rate (60 by default)</param>
        abstract HighDegradationAllowed: ?targetFrameRate: float -> SceneOptimizerOptions

    /// Class used to run optimizations in order to reach a target frame rate
    type [<AllowNullLiteral>] SceneOptimizer =
        inherit IDisposable
        /// Defines an observable called when the optimizer reaches the target frame rate
        abstract onSuccessObservable: Observable<SceneOptimizer> with get, set
        /// Defines an observable called when the optimizer enables an optimization
        abstract onNewOptimizationAppliedObservable: Observable<SceneOptimization> with get, set
        /// Defines an observable called when the optimizer is not able to reach the target frame rate
        abstract onFailureObservable: Observable<SceneOptimizer> with get, set
        /// Gets a boolean indicating if the optimizer is in improvement mode
        abstract isInImprovementMode: bool
        /// Gets the current priority level (0 at start)
        abstract currentPriorityLevel: float
        /// Gets the current frame rate checked by the SceneOptimizer
        abstract currentFrameRate: float
        /// Gets or sets the current target frame rate (60 by default)
        /// Gets or sets the current target frame rate (60 by default)
        abstract targetFrameRate: float with get, set
        /// Gets or sets the current interval between two checks (every 2000ms by default)
        /// Gets or sets the current interval between two checks (every 2000ms by default)
        abstract trackerDuration: float with get, set
        /// Gets the list of active optimizations
        abstract optimizations: ResizeArray<SceneOptimization>
        /// Stops the current optimizer
        abstract stop: unit -> unit
        /// Reset the optimizer to initial step (current priority level = 0)
        abstract reset: unit -> unit
        /// Start the optimizer. By default it will try to reach a specific framerate
        /// but if the optimizer is set with improvementMode === true then it will run all optimiatiation while frame rate is above the target frame rate
        abstract start: unit -> unit
        /// Release all resources
        abstract dispose: unit -> unit

    /// Class used to run optimizations in order to reach a target frame rate
    type [<AllowNullLiteral>] SceneOptimizerStatic =
        /// <summary>Creates a new SceneOptimizer</summary>
        /// <param name="scene">defines the scene to work on</param>
        /// <param name="options">defines the options to use with the SceneOptimizer</param>
        /// <param name="autoGeneratePriorities">defines if priorities must be generated and not read from SceneOptimization property (true by default)</param>
        /// <param name="improvementMode">defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?options: SceneOptimizerOptions * ?autoGeneratePriorities: bool * ?improvementMode: bool -> SceneOptimizer
        /// <summary>Helper function to create a SceneOptimizer with one single line of code</summary>
        /// <param name="scene">defines the scene to work on</param>
        /// <param name="options">defines the options to use with the SceneOptimizer</param>
        /// <param name="onSuccess">defines a callback to call on success</param>
        /// <param name="onFailure">defines a callback to call on failure</param>
        abstract OptimizeAsync: scene: Scene * ?options: SceneOptimizerOptions * ?onSuccess: (unit -> unit) * ?onFailure: (unit -> unit) -> SceneOptimizer

    /// Class used to serialize a scene into a string
    type [<AllowNullLiteral>] SceneSerializer =
        interface end

    /// Class used to serialize a scene into a string
    type [<AllowNullLiteral>] SceneSerializerStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SceneSerializer
        /// Clear cache used by a previous serialization
        abstract ClearCache: unit -> unit
        /// <summary>Serialize a scene into a JSON compatible object</summary>
        /// <param name="scene">defines the scene to serialize</param>
        abstract Serialize: scene: Scene -> obj option
        /// <summary>Serialize a mesh into a JSON compatible object</summary>
        /// <param name="toSerialize">defines the mesh to serialize</param>
        /// <param name="withParents">defines if parents must be serialized as well</param>
        /// <param name="withChildren">defines if children must be serialized as well</param>
        abstract SerializeMesh: toSerialize: obj option * ?withParents: bool * ?withChildren: bool -> obj option

    /// Defines an array and its length.
    /// It can be helpfull to group result from both Arrays and smart arrays in one structure.
    type [<AllowNullLiteral>] ISmartArrayLike<'T> =
        /// The data of the array.
        abstract data: Array<'T> with get, set
        /// The active length of the array.
        abstract length: float with get, set

    /// Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
    type [<AllowNullLiteral>] SmartArray<'T> =
        inherit ISmartArrayLike<'T>
        /// The full set of data from the array.
        abstract data: Array<'T> with get, set
        /// The active length of the array.
        abstract length: float with get, set
        abstract _id: float with get, set
        /// <summary>Pushes a value at the end of the active data.</summary>
        /// <param name="value">defines the object to push in the array.</param>
        abstract push: value: 'T -> unit
        /// <summary>Iterates over the active data and apply the lambda to them.</summary>
        /// <param name="func">defines the action to apply on each value.</param>
        abstract forEach: func: ('T -> unit) -> unit
        /// <summary>Sorts the full sets of data.</summary>
        /// <param name="compareFn">defines the comparison function to apply.</param>
        abstract sort: compareFn: ('T -> 'T -> float) -> unit
        /// Resets the active data to an empty array.
        abstract reset: unit -> unit
        /// Releases all the data from the array as well as the array.
        abstract dispose: unit -> unit
        /// <summary>Concats the active data with a given array.</summary>
        /// <param name="array">defines the data to concatenate with.</param>
        abstract concat: array: obj option -> unit
        /// <summary>Returns the position of a value in the active data.</summary>
        /// <param name="value">defines the value to find the index for</param>
        abstract indexOf: value: 'T -> float
        /// <summary>Returns whether an element is part of the active data.</summary>
        /// <param name="value">defines the value to look for</param>
        abstract contains: value: 'T -> bool

    /// Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
    type [<AllowNullLiteral>] SmartArrayStatic =
        /// <summary>Instantiates a Smart Array.</summary>
        /// <param name="capacity">defines the default capacity of the array.</param>
        [<Emit "new $0($1...)">] abstract Create: capacity: float -> SmartArray<'T>

    /// Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
    /// The data in this array can only be present once
    type [<AllowNullLiteral>] SmartArrayNoDuplicate<'T> =
        inherit SmartArray<'T>
        /// <summary>Pushes a value at the end of the active data.
        /// THIS DOES NOT PREVENT DUPPLICATE DATA</summary>
        /// <param name="value">defines the object to push in the array.</param>
        abstract push: value: 'T -> unit
        /// <summary>Pushes a value at the end of the active data.
        /// If the data is already present, it won t be added again</summary>
        /// <param name="value">defines the object to push in the array.</param>
        abstract pushNoDuplicate: value: 'T -> bool
        /// Resets the active data to an empty array.
        abstract reset: unit -> unit
        /// <summary>Concats the active data with a given array.
        /// This ensures no dupplicate will be present in the result.</summary>
        /// <param name="array">defines the data to concatenate with.</param>
        abstract concatWithNoDuplicate: array: obj option -> unit

    /// Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
    /// The data in this array can only be present once
    type [<AllowNullLiteral>] SmartArrayNoDuplicateStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SmartArrayNoDuplicate<'T>

    /// This class implement a typical dictionary using a string as key and the generic type T as value.
    /// The underlying implementation relies on an associative array to ensure the best performances.
    /// The value can be anything including 'null' but except 'undefined'
    type [<AllowNullLiteral>] StringDictionary<'T> =
        /// <summary>This will clear this dictionary and copy the content from the 'source' one.
        /// If the T value is a custom object, it won't be copied/cloned, the same object will be used</summary>
        /// <param name="source">the dictionary to take the content from and copy to this dictionary</param>
        abstract copyFrom: source: StringDictionary<'T> -> unit
        /// <summary>Get a value based from its key</summary>
        /// <param name="key">the given key to get the matching value from</param>
        abstract get: key: string -> 'T option
        /// <summary>Get a value from its key or add it if it doesn't exist.
        /// This method will ensure you that a given key/data will be present in the dictionary.</summary>
        /// <param name="key">the given key to get the matching value from</param>
        /// <param name="factory">the factory that will create the value if the key is not present in the dictionary.
        /// The factory will only be invoked if there's no data for the given key.</param>
        abstract getOrAddWithFactory: key: string * factory: (string -> 'T) -> 'T
        /// <summary>Get a value from its key if present in the dictionary otherwise add it</summary>
        /// <param name="key">the key to get the value from</param>
        /// <param name="val">if there's no such key/value pair in the dictionary add it with this value</param>
        abstract getOrAdd: key: string * ``val``: 'T -> 'T
        /// <summary>Check if there's a given key in the dictionary</summary>
        /// <param name="key">the key to check for</param>
        abstract contains: key: string -> bool
        /// <summary>Add a new key and its corresponding value</summary>
        /// <param name="key">the key to add</param>
        /// <param name="value">the value corresponding to the key</param>
        abstract add: key: string * value: 'T -> bool
        /// <summary>Update a specific value associated to a key</summary>
        /// <param name="key">defines the key to use</param>
        /// <param name="value">defines the value to store</param>
        abstract set: key: string * value: 'T -> bool
        /// <summary>Get the element of the given key and remove it from the dictionary</summary>
        /// <param name="key">defines the key to search</param>
        abstract getAndRemove: key: string -> Nullable<'T>
        /// <summary>Remove a key/value from the dictionary.</summary>
        /// <param name="key">the key to remove</param>
        abstract remove: key: string -> bool
        /// Clear the whole content of the dictionary
        abstract clear: unit -> unit
        /// Gets the current count
        abstract count: float
        /// <summary>Execute a callback on each key/val of the dictionary.
        /// Note that you can remove any element in this dictionary in the callback implementation</summary>
        /// <param name="callback">the callback to execute on a given key/value pair</param>
        abstract forEach: callback: (string -> 'T -> unit) -> unit
        /// <summary>Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.
        /// If the callback returns null or undefined the method will iterate to the next key/value pair
        /// Note that you can remove any element in this dictionary in the callback implementation</summary>
        /// <param name="callback">the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned</param>
        abstract first: callback: (string -> 'T -> 'TRes) -> 'TRes option

    /// This class implement a typical dictionary using a string as key and the generic type T as value.
    /// The underlying implementation relies on an associative array to ensure the best performances.
    /// The value can be anything including 'null' but except 'undefined'
    type [<AllowNullLiteral>] StringDictionaryStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> StringDictionary<'T>

    /// Class used to store custom tags
    type [<AllowNullLiteral>] Tags =
        interface end

    /// Class used to store custom tags
    type [<AllowNullLiteral>] TagsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Tags
        /// <summary>Adds support for tags on the given object</summary>
        /// <param name="obj">defines the object to use</param>
        abstract EnableFor: obj: obj option -> unit
        /// <summary>Removes tags support</summary>
        /// <param name="obj">defines the object to use</param>
        abstract DisableFor: obj: obj option -> unit
        /// <summary>Gets a boolean indicating if the given object has tags</summary>
        /// <param name="obj">defines the object to use</param>
        abstract HasTags: obj: obj option -> bool
        /// <summary>Gets the tags available on a given object</summary>
        /// <param name="obj">defines the object to use</param>
        /// <param name="asString">defines if the tags must be returned as a string instead of an array of strings</param>
        abstract GetTags: obj: obj option * ?asString: bool -> obj option
        /// <summary>Adds tags to an object</summary>
        /// <param name="obj">defines the object to use</param>
        /// <param name="tagsString">defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.
        /// A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces</param>
        abstract AddTagsTo: obj: obj option * tagsString: string -> unit
        abstract _AddTagTo: obj: obj option * tag: string -> unit
        /// <summary>Removes specific tags from a specific object</summary>
        /// <param name="obj">defines the object to use</param>
        /// <param name="tagsString">defines the tags to remove</param>
        abstract RemoveTagsFrom: obj: obj option * tagsString: string -> unit
        abstract _RemoveTagFrom: obj: obj option * tag: string -> unit
        /// <summary>Defines if tags hosted on an object match a given query</summary>
        /// <param name="obj">defines the object to use</param>
        /// <param name="tagsQuery">defines the tag query</param>
        abstract MatchesQuery: obj: obj option * tagsQuery: string -> bool

    /// Class used to host texture specific utilities
    type [<AllowNullLiteral>] TextureTools =
        interface end

    /// Class used to host texture specific utilities
    type [<AllowNullLiteral>] TextureToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> TextureTools
        /// <summary>Uses the GPU to create a copy texture rescaled at a given size</summary>
        /// <param name="texture">Texture to copy from</param>
        /// <param name="width">defines the desired width</param>
        /// <param name="height">defines the desired height</param>
        /// <param name="useBilinearMode">defines if bilinear mode has to be used</param>
        abstract CreateResizedCopy: texture: Texture * width: float * height: float * ?useBilinearMode: bool -> Texture
        /// <summary>Gets an environment BRDF texture for a given scene</summary>
        /// <param name="scene">defines the hosting scene</param>
        abstract GetEnvironmentBRDFTexture: scene: Scene -> BaseTexture

    /// Based on jsTGALoader - Javascript loader for TGA file
    /// By Vincent Thibault
    type [<AllowNullLiteral>] TGATools =
        interface end

    /// Based on jsTGALoader - Javascript loader for TGA file
    /// By Vincent Thibault
    type [<AllowNullLiteral>] TGAToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> TGATools
        /// <summary>Gets the header of a TGA file</summary>
        /// <param name="data">defines the TGA data</param>
        abstract GetTGAHeader: data: Uint8Array -> obj option
        /// Uploads TGA content to a Babylon Texture
        abstract UploadContent: texture: InternalTexture * data: Uint8Array -> unit
        abstract _getImageData8bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array
        abstract _getImageData16bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array
        abstract _getImageData24bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array
        abstract _getImageData32bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array
        abstract _getImageDataGrey8bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array
        abstract _getImageDataGrey16bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array

    /// Interface containing an array of animations
    type [<AllowNullLiteral>] IAnimatable =
        /// Array of animations
        abstract animations: Array<Animation> with get, set

    /// Interface used by value gradients (color, factor, ...) 
    type [<AllowNullLiteral>] IValueGradient =
        /// Gets or sets the gradient value (between 0 and 1)
        abstract gradient: float with get, set

    /// Class used to store color4 gradient 
    type [<AllowNullLiteral>] ColorGradient =
        inherit IValueGradient
        /// Gets or sets the gradient value (between 0 and 1)
        abstract gradient: float with get, set
        /// Gets or sets first associated color
        abstract color1: Color4 with get, set
        /// Gets or sets second associated color
        abstract color2: Color4 option with get, set
        /// <summary>Will get a color picked randomly between color1 and color2.
        /// If color2 is undefined then color1 will be used</summary>
        /// <param name="result">defines the target Color4 to store the result in</param>
        abstract getColorToRef: result: Color4 -> unit

    /// Class used to store color4 gradient 
    type [<AllowNullLiteral>] ColorGradientStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ColorGradient

    /// Class used to store color 3 gradient 
    type [<AllowNullLiteral>] Color3Gradient =
        inherit IValueGradient
        /// Gets or sets the gradient value (between 0 and 1)
        abstract gradient: float with get, set
        /// Gets or sets the associated color
        abstract color: Color3 with get, set

    /// Class used to store color 3 gradient 
    type [<AllowNullLiteral>] Color3GradientStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Color3Gradient

    /// Class used to store factor gradient 
    type [<AllowNullLiteral>] FactorGradient =
        inherit IValueGradient
        /// Gets or sets the gradient value (between 0 and 1)
        abstract gradient: float with get, set
        /// Gets or sets first associated factor
        abstract factor1: float with get, set
        /// Gets or sets second associated factor
        abstract factor2: float option with get, set
        /// Will get a number picked randomly between factor1 and factor2.
        /// If factor2 is undefined then factor1 will be used
        abstract getFactor: unit -> float

    /// Class used to store factor gradient 
    type [<AllowNullLiteral>] FactorGradientStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FactorGradient

    type [<AllowNullLiteral>] LoadFileError =
        inherit Error
        /// defines the optional XHR request 
        abstract request: XMLHttpRequest option with get, set

    type [<AllowNullLiteral>] LoadFileErrorStatic =
        /// <summary>Creates a new LoadFileError</summary>
        /// <param name="message">defines the message of the error</param>
        /// <param name="request">defines the optional XHR request</param>
        [<Emit "new $0($1...)">] abstract Create: message: string * ?request: XMLHttpRequest -> LoadFileError

    /// Class used to define a retry strategy when error happens while loading assets
    type [<AllowNullLiteral>] RetryStrategy =
        interface end

    /// Class used to define a retry strategy when error happens while loading assets
    type [<AllowNullLiteral>] RetryStrategyStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> RetryStrategy
        /// <summary>Function used to defines an exponential back off strategy</summary>
        /// <param name="maxRetries">defines the maximum number of retries (3 by default)</param>
        /// <param name="baseInterval">defines the interval between retries</param>
        abstract ExponentialBackoff: ?maxRetries: float * ?baseInterval: float -> (string -> XMLHttpRequest -> float -> float)

    /// File request interface
    type [<AllowNullLiteral>] IFileRequest =
        /// Raised when the request is complete (success or error).
        abstract onCompleteObservable: Observable<IFileRequest> with get, set
        /// Aborts the request for a file.
        abstract abort: (unit -> unit) with get, set

    /// Class containing a set of static utilities functions
    type [<AllowNullLiteral>] Tools =
        interface end

    /// Class containing a set of static utilities functions
    type [<AllowNullLiteral>] ToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Tools
        /// Gets or sets the base URL to use to load assets
        abstract BaseUrl: string with get, set
        /// Gets or sets the retry strategy to apply when an error happens while loading an asset
        abstract DefaultRetryStrategy: (string -> XMLHttpRequest -> float -> float) with get, set
        /// Default behaviour for cors in the application.
        /// It can be a string if the expected behavior is identical in the entire app.
        /// Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
        abstract CorsBehavior: U2<string, (U2<string, ResizeArray<string>> -> string)> with get, set
        /// Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded
        abstract UseFallbackTexture: bool with get, set
        /// Use this object to register external classes like custom textures or material
        /// to allow the laoders to instantiate them
        abstract RegisteredExternalClasses: TypeLiteral_36 with get, set
        /// Texture content used if a texture cannot loaded
        abstract fallbackTexture: string with get, set
        /// <summary>Read the content of a byte array at a specified coordinates (taking in account wrapping)</summary>
        /// <param name="u">defines the coordinate on X axis</param>
        /// <param name="v">defines the coordinate on Y axis</param>
        /// <param name="width">defines the width of the source data</param>
        /// <param name="height">defines the height of the source data</param>
        /// <param name="pixels">defines the source byte array</param>
        /// <param name="color">defines the output color</param>
        abstract FetchToRef: u: float * v: float * width: float * height: float * pixels: Uint8Array * color: Color4 -> unit
        /// <summary>Interpolates between a and b via alpha</summary>
        /// <param name="a">The lower value (returned when alpha = 0)</param>
        /// <param name="b">The upper value (returned when alpha = 1)</param>
        /// <param name="alpha">The interpolation-factor</param>
        abstract Mix: a: float * b: float * alpha: float -> float
        /// <summary>Tries to instantiate a new object from a given class name</summary>
        /// <param name="className">defines the class name to instantiate</param>
        abstract Instantiate: className: string -> obj option
        /// <summary>Provides a slice function that will work even on IE</summary>
        /// <param name="data">defines the array to slice</param>
        /// <param name="start">defines the start of the data (optional)</param>
        /// <param name="end">defines the end of the data (optional)</param>
        abstract Slice: data: 'T * ?start: float * ?``end``: float -> 'T
        /// <summary>Polyfill for setImmediate</summary>
        /// <param name="action">defines the action to execute after the current execution block</param>
        abstract SetImmediate: action: (unit -> unit) -> unit
        /// <summary>Function indicating if a number is an exponent of 2</summary>
        /// <param name="value">defines the value to test</param>
        abstract IsExponentOfTwo: value: float -> bool
        /// <summary>Returns the nearest 32-bit single precision float representation of a Number</summary>
        /// <param name="value">A Number.  If the parameter is of a different type, it will get converted
        /// to a number or to NaN if it cannot be converted</param>
        abstract FloatRound: value: float -> float
        /// <summary>Find the next highest power of two.</summary>
        /// <param name="x">Number to start search from.</param>
        abstract CeilingPOT: x: float -> float
        /// <summary>Find the next lowest power of two.</summary>
        /// <param name="x">Number to start search from.</param>
        abstract FloorPOT: x: float -> float
        /// <summary>Find the nearest power of two.</summary>
        /// <param name="x">Number to start search from.</param>
        abstract NearestPOT: x: float -> float
        /// <summary>Get the closest exponent of two</summary>
        /// <param name="value">defines the value to approximate</param>
        /// <param name="max">defines the maximum value to return</param>
        /// <param name="mode">defines how to define the closest value</param>
        abstract GetExponentOfTwo: value: float * max: float * ?mode: float -> float
        /// <summary>Extracts the filename from a path</summary>
        /// <param name="path">defines the path to use</param>
        abstract GetFilename: path: string -> string
        /// <summary>Extracts the "folder" part of a path (everything before the filename).</summary>
        /// <param name="uri">The URI to extract the info from</param>
        /// <param name="returnUnchangedIfNoSlash">Do not touch the URI if no slashes are present</param>
        abstract GetFolderPath: uri: string * ?returnUnchangedIfNoSlash: bool -> string
        /// <summary>Extracts text content from a DOM element hierarchy</summary>
        /// <param name="element">defines the root element</param>
        abstract GetDOMTextContent: element: HTMLElement -> string
        /// <summary>Convert an angle in radians to degrees</summary>
        /// <param name="angle">defines the angle to convert</param>
        abstract ToDegrees: angle: float -> float
        /// <summary>Convert an angle in degrees to radians</summary>
        /// <param name="angle">defines the angle to convert</param>
        abstract ToRadians: angle: float -> float
        /// <summary>Encode a buffer to a base64 string</summary>
        /// <param name="buffer">defines the buffer to encode</param>
        abstract EncodeArrayBufferTobase64: buffer: ArrayBuffer -> string
        /// <summary>Extracts minimum and maximum values from a list of indexed positions</summary>
        /// <param name="positions">defines the positions to use</param>
        /// <param name="indices">defines the indices to the positions</param>
        /// <param name="indexStart">defines the start index</param>
        /// <param name="indexCount">defines the end index</param>
        /// <param name="bias">defines bias value to add to the result</param>
        abstract ExtractMinAndMaxIndexed: positions: FloatArray * indices: IndicesArray * indexStart: float * indexCount: float * ?bias: Vector2 -> ToolsStaticExtractMinAndMaxIndexedReturn
        /// <summary>Extracts minimum and maximum values from a list of positions</summary>
        /// <param name="positions">defines the positions to use</param>
        /// <param name="start">defines the start index in the positions array</param>
        /// <param name="count">defines the number of positions to handle</param>
        /// <param name="bias">defines bias value to add to the result</param>
        /// <param name="stride">defines the stride size to use (distance between two positions in the positions array)</param>
        abstract ExtractMinAndMax: positions: FloatArray * start: float * count: float * ?bias: Vector2 * ?stride: float -> ToolsStaticExtractMinAndMaxReturn
        /// <summary>Returns an array if obj is not an array</summary>
        /// <param name="obj">defines the object to evaluate as an array</param>
        /// <param name="allowsNullUndefined">defines a boolean indicating if obj is allowed to be null or undefined</param>
        abstract MakeArray: obj: obj option * ?allowsNullUndefined: bool -> Nullable<Array<obj option>>
        /// Gets the pointer prefix to use
        abstract GetPointerPrefix: unit -> string
        /// <summary>Queue a new function into the requested animation frame pool (ie. this function will be executed byt the browser for the next frame)</summary>
        /// <param name="func">- the function to be called</param>
        /// <param name="requester">- the object that will request the next frame. Falls back to window.</param>
        abstract QueueNewFrame: func: (unit -> unit) * ?requester: obj -> float
        /// <summary>Ask the browser to promote the current element to fullscreen rendering mode</summary>
        /// <param name="element">defines the DOM element to promote</param>
        abstract RequestFullscreen: element: HTMLElement -> unit
        /// Asks the browser to exit fullscreen mode
        abstract ExitFullscreen: unit -> unit
        /// <summary>Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.</summary>
        /// <param name="url">define the url we are trying</param>
        /// <param name="element">define the dom element where to configure the cors policy</param>
        abstract SetCorsBehavior: url: U2<string, ResizeArray<string>> * element: ToolsStaticSetCorsBehaviorElement -> unit
        /// <summary>Removes unwanted characters from an url</summary>
        /// <param name="url">defines the url to clean</param>
        abstract CleanUrl: url: string -> string
        /// Gets or sets a function used to pre-process url before using them to load assets
        abstract PreprocessUrl: (string -> string) with get, set
        /// <summary>Loads an image as an HTMLImageElement.</summary>
        /// <param name="input">url string, ArrayBuffer, or Blob to load</param>
        /// <param name="onLoad">callback called when the image successfully loads</param>
        /// <param name="onError">callback called when the image fails to load</param>
        /// <param name="database">database for caching</param>
        abstract LoadImage: input: U3<string, ArrayBuffer, Blob> * onLoad: (HTMLImageElement -> unit) * onError: (string -> obj -> unit) * database: Nullable<Database> -> HTMLImageElement
        /// <summary>Loads a file</summary>
        /// <param name="url">url string, ArrayBuffer, or Blob to load</param>
        /// <param name="onSuccess">callback called when the file successfully loads</param>
        /// <param name="onProgress">callback called while file is loading (if the server supports this mode)</param>
        /// <param name="database">database for caching</param>
        /// <param name="useArrayBuffer">defines a boolean indicating that date must be returned as ArrayBuffer</param>
        /// <param name="onError">callback called when the file fails to load</param>
        abstract LoadFile: url: string * onSuccess: (U2<string, ArrayBuffer> -> string -> unit) * ?onProgress: (obj option -> unit) * ?database: Database * ?useArrayBuffer: bool * ?onError: (XMLHttpRequest -> obj -> unit) -> IFileRequest
        /// <summary>Load a script (identified by an url). When the url returns, the
        /// content of this file is added into a new script element, attached to the DOM (body element)</summary>
        /// <param name="scriptUrl">defines the url of the script to laod</param>
        /// <param name="onSuccess">defines the callback called when the script is loaded</param>
        /// <param name="onError">defines the callback to call if an error occurs</param>
        abstract LoadScript: scriptUrl: string * onSuccess: (unit -> unit) * ?onError: (string -> obj -> unit) -> unit
        /// <summary>Loads a file from a blob</summary>
        /// <param name="fileToLoad">defines the blob to use</param>
        /// <param name="callback">defines the callback to call when data is loaded</param>
        /// <param name="progressCallback">defines the callback to call during loading process</param>
        abstract ReadFileAsDataURL: fileToLoad: Blob * callback: (obj option -> unit) * progressCallback: (ProgressEvent -> obj option) -> IFileRequest
        /// <summary>Loads a file</summary>
        /// <param name="fileToLoad">defines the file to load</param>
        /// <param name="callback">defines the callback to call when data is loaded</param>
        /// <param name="progressCallBack">defines the callback to call during loading process</param>
        /// <param name="useArrayBuffer">defines a boolean indicating that data must be returned as an ArrayBuffer</param>
        abstract ReadFile: fileToLoad: File * callback: (obj option -> unit) * ?progressCallBack: (ProgressEvent -> obj option) * ?useArrayBuffer: bool -> IFileRequest
        /// <summary>Creates a data url from a given string content</summary>
        /// <param name="content">defines the content to convert</param>
        abstract FileAsURL: content: string -> string
        /// <summary>Format the given number to a specific decimal format</summary>
        /// <param name="value">defines the number to format</param>
        /// <param name="decimals">defines the number of decimals to use</param>
        abstract Format: value: float * ?decimals: float -> string
        /// <summary>Checks if a given vector is inside a specific range</summary>
        /// <param name="v">defines the vector to test</param>
        /// <param name="min">defines the minimum range</param>
        /// <param name="max">defines the maximum range</param>
        abstract CheckExtends: v: Vector3 * min: Vector3 * max: Vector3 -> unit
        /// <summary>Tries to copy an object by duplicating every property</summary>
        /// <param name="source">defines the source object</param>
        /// <param name="destination">defines the target object</param>
        /// <param name="doNotCopyList">defines a list of properties to avoid</param>
        /// <param name="mustCopyList">defines a list of properties to copy (even if they start with _)</param>
        abstract DeepCopy: source: obj option * destination: obj option * ?doNotCopyList: ResizeArray<string> * ?mustCopyList: ResizeArray<string> -> unit
        /// <summary>Gets a boolean indicating if the given object has no own property</summary>
        /// <param name="obj">defines the object to test</param>
        abstract IsEmpty: obj: obj option -> bool
        /// <summary>Function used to register events at window level</summary>
        /// <param name="events">defines the events to register</param>
        abstract RegisterTopRootEvents: events: ResizeArray<TypeLiteral_37> -> unit
        /// <summary>Function used to unregister events from window level</summary>
        /// <param name="events">defines the events to unregister</param>
        abstract UnregisterTopRootEvents: events: ResizeArray<TypeLiteral_37> -> unit
        /// <summary>Dumps the current bound framebuffer</summary>
        /// <param name="width">defines the rendering width</param>
        /// <param name="height">defines the rendering height</param>
        /// <param name="engine">defines the hosting engine</param>
        /// <param name="successCallback">defines the callback triggered once the data are available</param>
        /// <param name="mimeType">defines the mime type of the result</param>
        /// <param name="fileName">defines the filename to download. If present, the result will automatically be downloaded</param>
        abstract DumpFramebuffer: width: float * height: float * engine: Engine * ?successCallback: (string -> unit) * ?mimeType: string * ?fileName: string -> unit
        /// <summary>Converts the canvas data to blob.
        /// This acts as a polyfill for browsers not supporting the to blob function.</summary>
        /// <param name="canvas">Defines the canvas to extract the data from</param>
        /// <param name="successCallback">Defines the callback triggered once the data are available</param>
        /// <param name="mimeType">Defines the mime type of the result</param>
        abstract ToBlob: canvas: HTMLCanvasElement * successCallback: (Nullable<Blob> -> unit) * ?mimeType: string -> unit
        /// <summary>Encodes the canvas data to base 64 or automatically download the result if filename is defined</summary>
        /// <param name="successCallback">defines the callback triggered once the data are available</param>
        /// <param name="mimeType">defines the mime type of the result</param>
        /// <param name="fileName">defines he filename to download. If present, the result will automatically be downloaded</param>
        abstract EncodeScreenshotCanvasData: ?successCallback: (string -> unit) * ?mimeType: string * ?fileName: string -> unit
        /// <summary>Downloads a blob in the browser</summary>
        /// <param name="blob">defines the blob to download</param>
        /// <param name="fileName">defines the name of the downloaded file</param>
        abstract Download: blob: Blob * fileName: string -> unit
        /// <summary>Captures a screenshot of the current rendering</summary>
        /// <param name="engine">defines the rendering engine</param>
        /// <param name="camera">defines the source camera</param>
        /// <param name="size">This parameter can be set to a single number or to an object with the
        /// following (optional) properties: precision, width, height. If a single number is passed,
        /// it will be used for both width and height. If an object is passed, the screenshot size
        /// will be derived from the parameters. The precision property is a multiplier allowing
        /// rendering at a higher or lower resolution</param>
        /// <param name="successCallback">defines the callback receives a single parameter which contains the
        /// screenshot as a string of base64-encoded characters. This string can be assigned to the
        /// src parameter of an <img> to display it</param>
        /// <param name="mimeType">defines the MIME type of the screenshot image (default: image/png).
        /// Check your browser for supported MIME types</param>
        abstract CreateScreenshot: engine: Engine * camera: Camera * size: obj option * ?successCallback: (string -> unit) * ?mimeType: string -> unit
        /// <summary>Generates an image screenshot from the specified camera.</summary>
        /// <param name="engine">The engine to use for rendering</param>
        /// <param name="camera">The camera to use for rendering</param>
        /// <param name="size">This parameter can be set to a single number or to an object with the
        /// following (optional) properties: precision, width, height. If a single number is passed,
        /// it will be used for both width and height. If an object is passed, the screenshot size
        /// will be derived from the parameters. The precision property is a multiplier allowing
        /// rendering at a higher or lower resolution</param>
        /// <param name="successCallback">The callback receives a single parameter which contains the
        /// screenshot as a string of base64-encoded characters. This string can be assigned to the
        /// src parameter of an <img> to display it</param>
        /// <param name="mimeType">The MIME type of the screenshot image (default: image/png).
        /// Check your browser for supported MIME types</param>
        /// <param name="samples">Texture samples (default: 1)</param>
        /// <param name="antialiasing">Whether antialiasing should be turned on or not (default: false)</param>
        /// <param name="fileName">A name for for the downloaded file.</param>
        abstract CreateScreenshotUsingRenderTarget: engine: Engine * camera: Camera * size: obj option * ?successCallback: (string -> unit) * ?mimeType: string * ?samples: float * ?antialiasing: bool * ?fileName: string -> unit
        /// <summary>Validates if xhr data is correct</summary>
        /// <param name="xhr">defines the request to validate</param>
        /// <param name="dataType">defines the expected data type</param>
        abstract ValidateXHRData: xhr: XMLHttpRequest * ?dataType: float -> bool
        /// Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
        /// Be aware Math.random() could cause collisions, but:
        /// "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
        abstract RandomId: unit -> string
        /// <summary>Test if the given uri is a base64 string</summary>
        /// <param name="uri">The uri to test</param>
        abstract IsBase64: uri: string -> bool
        /// <summary>Decode the given base64 uri.</summary>
        /// <param name="uri">The uri to decode</param>
        abstract DecodeBase64: uri: string -> ArrayBuffer
        /// No log
        abstract NoneLogLevel: float
        /// Only message logs
        abstract MessageLogLevel: float
        /// Only warning logs
        abstract WarningLogLevel: float
        /// Only error logs
        abstract ErrorLogLevel: float
        /// All logs
        abstract AllLogLevel: float
        /// Gets a value indicating the number of loading errors
        abstract errorsCount: float with get, set
        /// Callback called when a new log is added
        abstract OnNewCacheEntry: (string -> unit) with get, set
        /// Log a message to the console
        abstract Log: (string -> unit) with get, set
        /// Write a warning message to the console
        abstract Warn: (string -> unit) with get, set
        /// Write an error message to the console
        abstract Error: (string -> unit) with get, set
        /// Gets current log cache (list of logs)
        abstract LogCache: string
        /// Clears the log cache
        abstract ClearLogCache: unit -> unit
        /// Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)
        abstract LogLevels: float with get, set
        /// Checks if the loaded document was accessed via `file:`-Protocol.
        abstract IsFileURL: unit -> bool
        /// Checks if the window object exists
        abstract IsWindowObjectExist: unit -> bool
        /// No performance log
        abstract PerformanceNoneLogLevel: float
        /// Use user marks to log performance
        abstract PerformanceUserMarkLogLevel: float
        /// Log performance to the console
        abstract PerformanceConsoleLogLevel: float
        /// Sets the current performance log level
        abstract PerformanceLogLevel: float with get, set
        /// Starts a performance counter
        abstract StartPerformanceCounter: (string -> bool -> unit) with get, set
        /// Ends a specific performance coutner
        abstract EndPerformanceCounter: (string -> bool -> unit) with get, set
        /// Gets either window.performance.now() if supported or Date.now() else
        abstract Now: float
        /// <summary>This method will return the name of the class used to create the instance of the given object.
        /// It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.</summary>
        /// <param name="object">the object to get the class name from</param>
        /// <param name="isType">defines if the object is actually a type</param>
        abstract GetClassName: ``object``: obj option * ?isType: bool -> string
        /// <summary>Gets the first element of an array satisfying a given predicate</summary>
        /// <param name="array">defines the array to browse</param>
        /// <param name="predicate">defines the predicate to use</param>
        abstract First: array: Array<'T> * predicate: ('T -> bool) -> Nullable<'T>
        /// <summary>This method will return the name of the full name of the class, including its owning module (if any).
        /// It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).</summary>
        /// <param name="object">the object to get the class name from</param>
        /// <param name="isType">defines if the object is actually a type</param>
        abstract getFullClassName: ``object``: obj option * ?isType: bool -> Nullable<string>
        /// <summary>Returns a promise that resolves after the given amount of time.</summary>
        /// <param name="delay">Number of milliseconds to delay</param>
        abstract DelayAsync: delay: float -> Promise<unit>
        /// <summary>Gets the current gradient from an array of IValueGradient</summary>
        /// <param name="ratio">defines the current ratio to get</param>
        /// <param name="gradients">defines the array of IValueGradient</param>
        /// <param name="updateFunc">defines the callback function used to get the final value from the selected gradients</param>
        abstract GetCurrentGradient: ratio: float * gradients: ResizeArray<IValueGradient> * updateFunc: (IValueGradient -> IValueGradient -> float -> unit) -> unit

    type [<AllowNullLiteral>] ToolsStaticExtractMinAndMaxIndexedReturn =
        abstract minimum: Vector3 with get, set
        abstract maximum: Vector3 with get, set

    type [<AllowNullLiteral>] ToolsStaticExtractMinAndMaxReturn =
        abstract minimum: Vector3 with get, set
        abstract maximum: Vector3 with get, set

    type [<AllowNullLiteral>] ToolsStaticSetCorsBehaviorElement =
        abstract crossOrigin: string option with get, set

    /// This class is used to track a performance counter which is number based.
    /// The user has access to many properties which give statistics of different nature.
    /// 
    /// The implementer can track two kinds of Performance Counter: time and count.
    /// For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.
    /// For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.
    type [<AllowNullLiteral>] PerfCounter =
        /// Returns the smallest value ever
        abstract min: float
        /// Returns the biggest value ever
        abstract max: float
        /// Returns the average value since the performance counter is running
        abstract average: float
        /// Returns the average value of the last second the counter was monitored
        abstract lastSecAverage: float
        /// Returns the current value
        abstract current: float
        /// Gets the accumulated total
        abstract total: float
        /// Gets the total value count
        abstract count: float
        /// Call this method to start monitoring a new frame.
        /// This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.
        abstract fetchNewFrame: unit -> unit
        /// <summary>Call this method to monitor a count of something (e.g. mesh drawn in viewport count)</summary>
        /// <param name="newCount">the count value to add to the monitored count</param>
        /// <param name="fetchResult">true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.</param>
        abstract addCount: newCount: float * fetchResult: bool -> unit
        /// Start monitoring this performance counter
        abstract beginMonitoring: unit -> unit
        /// <summary>Compute the time lapsed since the previous beginMonitoring() call.</summary>
        /// <param name="newFrame">true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter</param>
        abstract endMonitoring: ?newFrame: bool -> unit

    /// This class is used to track a performance counter which is number based.
    /// The user has access to many properties which give statistics of different nature.
    /// 
    /// The implementer can track two kinds of Performance Counter: time and count.
    /// For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.
    /// For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.
    type [<AllowNullLiteral>] PerfCounterStatic =
        /// Gets or sets a global boolean to turn on and off all the counters
        abstract Enabled: bool with get, set
        /// Creates a new counter
        [<Emit "new $0($1...)">] abstract Create: unit -> PerfCounter

    /// An implementation of a loop for asynchronous functions.
    type [<AllowNullLiteral>] AsyncLoop =
        /// Defines the number of iterations for the loop
        abstract iterations: float with get, set
        /// Defines the current index of the loop.
        abstract index: float with get, set
        /// Execute the next iteration. Must be called after the last iteration was finished.
        abstract executeNext: unit -> unit
        /// Break the loop and run the success callback.
        abstract breakLoop: unit -> unit

    /// An implementation of a loop for asynchronous functions.
    type [<AllowNullLiteral>] AsyncLoopStatic =
        /// <summary>Constructor.</summary>
        /// <param name="iterations">the number of iterations.</param>
        /// <param name="func">the function to run each iteration</param>
        /// <param name="successCallback">the callback that will be called upon succesful execution</param>
        /// <param name="offset">starting offset.</param>
        [<Emit "new $0($1...)">] abstract Create: iterations: float * func: (AsyncLoop -> unit) * successCallback: (unit -> unit) * ?offset: float -> AsyncLoop
        /// <summary>Create and run an async loop.</summary>
        /// <param name="iterations">the number of iterations.</param>
        /// <param name="fn">the function to run each iteration</param>
        /// <param name="successCallback">the callback that will be called upon succesful execution</param>
        /// <param name="offset">starting offset.</param>
        abstract Run: iterations: float * fn: (AsyncLoop -> unit) * successCallback: (unit -> unit) * ?offset: float -> AsyncLoop
        /// <summary>A for-loop that will run a given number of iterations synchronous and the rest async.</summary>
        /// <param name="iterations">total number of iterations</param>
        /// <param name="syncedIterations">number of synchronous iterations in each async iteration.</param>
        /// <param name="fn">the function to call each iteration.</param>
        /// <param name="callback">a success call back that will be called when iterating stops.</param>
        /// <param name="breakFunction">a break condition (optional)</param>
        /// <param name="timeout">timeout settings for the setTimeout function. default - 0.</param>
        abstract SyncAsyncForLoop: iterations: float * syncedIterations: float * fn: (float -> unit) * callback: (unit -> unit) * ?breakFunction: (unit -> bool) * ?timeout: float -> AsyncLoop

    /// This represents the different options avilable for the video capture.
    type [<AllowNullLiteral>] VideoRecorderOptions =
        /// Defines the mime type of the video 
        abstract mimeType: string with get, set
        /// Defines the video the video should be recorded at 
        abstract fps: float with get, set
        /// Defines the chunk size for the recording data 
        abstract recordChunckSize: float with get, set

    /// This can helps recording videos from BabylonJS.
    /// This is based on the available WebRTC functionalities of the browser.
    type [<AllowNullLiteral>] VideoRecorder =
        /// True wether a recording is already in progress.
        abstract isRecording: bool
        /// Stops the current recording before the default capture timeout passed in the startRecording
        /// functions.
        abstract stopRecording: unit -> unit
        /// <summary>Starts recording the canvas for a max duration specified in parameters.</summary>
        /// <param name="fileName">Defines the name of the file to be downloaded when the recording stop. If null no automatic download will start and you can rely on the promise to get the data back.</param>
        /// <param name="maxDuration">Defines the maximum recording time in seconds.
        /// It default to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.</param>
        abstract startRecording: ?fileName: string * ?maxDuration: float -> Promise<Blob>
        /// Releases internal resources used during the recording.
        abstract dispose: unit -> unit

    /// This can helps recording videos from BabylonJS.
    /// This is based on the available WebRTC functionalities of the browser.
    type [<AllowNullLiteral>] VideoRecorderStatic =
        /// <summary>Returns wehther or not the VideoRecorder is available in your browser.</summary>
        /// <param name="engine">Defines the Babylon Engine to check the support for</param>
        abstract IsSupported: engine: Engine -> bool
        /// <summary>Create a new VideoCapture object which can help converting what you see in Babylon to
        /// a video file.</summary>
        /// <param name="engine">Defines the BabylonJS Engine you wish to record</param>
        /// <param name="options">Defines options that can be used to customized the capture</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * ?options: VideoRecorderOptions -> VideoRecorder

    type [<RequireQualifiedAccess>] JoystickAxis =
        | X = 0
        | Y = 1
        | Z = 2

    /// Class used to define virtual joystick (used in touch mode)
    type [<AllowNullLiteral>] VirtualJoystick =
        /// Gets or sets a boolean indicating that left and right values must be inverted
        abstract reverseLeftRight: bool with get, set
        /// Gets or sets a boolean indicating that up and down values must be inverted
        abstract reverseUpDown: bool with get, set
        /// Gets the offset value for the position (ie. the change of the position value)
        abstract deltaPosition: Vector3 with get, set
        /// Gets a boolean indicating if the virtual joystick was pressed
        abstract pressed: bool with get, set
        /// <summary>Defines joystick sensibility (ie. the ratio beteen a physical move and virtual joystick position change)</summary>
        /// <param name="newJoystickSensibility">defines the new sensibility</param>
        abstract setJoystickSensibility: newJoystickSensibility: float -> unit
        /// <summary>Change the color of the virtual joystick</summary>
        /// <param name="newColor">a string that must be a CSS color value (like "red") or the hexa value (like "#FF0000")</param>
        abstract setJoystickColor: newColor: string -> unit
        /// <summary>Defines a callback to call when the joystick is touched</summary>
        /// <param name="action">defines the callback</param>
        abstract setActionOnTouch: action: (unit -> obj option) -> unit
        /// <summary>Defines which axis you'd like to control for left & right</summary>
        /// <param name="axis">defines the axis to use</param>
        abstract setAxisForLeftRight: axis: JoystickAxis -> unit
        /// <summary>Defines which axis you'd like to control for up & down</summary>
        /// <param name="axis">defines the axis to use</param>
        abstract setAxisForUpDown: axis: JoystickAxis -> unit
        /// Release internal HTML canvas
        abstract releaseCanvas: unit -> unit

    /// Class used to define virtual joystick (used in touch mode)
    type [<AllowNullLiteral>] VirtualJoystickStatic =
        /// <summary>Creates a new virtual joystick</summary>
        /// <param name="leftJoystick">defines that the joystick is for left hand (false by default)</param>
        [<Emit "new $0($1...)">] abstract Create: ?leftJoystick: bool -> VirtualJoystick

    /// Helper class to push actions to a pool of workers.
    type [<AllowNullLiteral>] WorkerPool =
        inherit IDisposable
        /// Terminates all workers and clears any pending actions.
        abstract dispose: unit -> unit
        /// <summary>Pushes an action to the worker pool. If all the workers are active, the action will be
        /// pended until a worker has completed its action.</summary>
        /// <param name="action">The action to perform. Call onComplete when the action is complete.</param>
        abstract push: action: (Worker -> (unit -> unit) -> unit) -> unit

    /// Helper class to push actions to a pool of workers.
    type [<AllowNullLiteral>] WorkerPoolStatic =
        /// <summary>Constructor</summary>
        /// <param name="workers">Array of workers to use for actions</param>
        [<Emit "new $0($1...)">] abstract Create: workers: Array<Worker> -> WorkerPool

    /// The autoRotation behavior (BABYLON.AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.
    type [<AllowNullLiteral>] AutoRotationBehavior =
        inherit Behavior<ArcRotateCamera>
        /// Gets the name of the behavior.
        abstract name: string
        /// Sets the flag that indicates if user zooming should stop animation.
        /// Gets the flag that indicates if user zooming should stop animation.
        abstract zoomStopsAnimation: bool with get, set
        /// Sets the default speed at which the camera rotates around the model.
        /// Gets the default speed at which the camera rotates around the model.
        abstract idleRotationSpeed: float with get, set
        /// Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.
        /// Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.
        abstract idleRotationWaitTime: float with get, set
        /// Sets the time (milliseconds) to take to spin up to the full idle rotation speed.
        /// Gets the time (milliseconds) to take to spin up to the full idle rotation speed.
        abstract idleRotationSpinupTime: float with get, set
        /// Gets a value indicating if the camera is currently rotating because of this behavior
        abstract rotationInProgress: bool
        /// Initializes the behavior.
        abstract init: unit -> unit
        /// <summary>Attaches the behavior to its arc rotate camera.</summary>
        /// <param name="camera">Defines the camera to attach the behavior to</param>
        abstract attach: camera: ArcRotateCamera -> unit
        /// Detaches the behavior from its current arc rotate camera.
        abstract detach: unit -> unit

    /// The autoRotation behavior (BABYLON.AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.
    type [<AllowNullLiteral>] AutoRotationBehaviorStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> AutoRotationBehavior

    /// Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius
    type [<AllowNullLiteral>] BouncingBehavior =
        inherit Behavior<ArcRotateCamera>
        /// Gets the name of the behavior.
        abstract name: string
        /// The duration of the animation, in milliseconds
        abstract transitionDuration: float with get, set
        /// Length of the distance animated by the transition when lower radius is reached
        abstract lowerRadiusTransitionRange: float with get, set
        /// Length of the distance animated by the transition when upper radius is reached
        abstract upperRadiusTransitionRange: float with get, set
        /// Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
        /// Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
        /// Transition ranges will be set to 5% of the bounding box diagonal in world space
        abstract autoTransitionRange: bool with get, set
        /// Initializes the behavior.
        abstract init: unit -> unit
        /// <summary>Attaches the behavior to its arc rotate camera.</summary>
        /// <param name="camera">Defines the camera to attach the behavior to</param>
        abstract attach: camera: ArcRotateCamera -> unit
        /// Detaches the behavior from its current arc rotate camera.
        abstract detach: unit -> unit
        /// Removes all animation locks. Allows new animations to be added to any of the camera properties.
        abstract _clearAnimationLocks: unit -> unit
        /// Stops and removes all animations that have been applied to the camera
        abstract stopAllAnimations: unit -> unit

    /// Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius
    type [<AllowNullLiteral>] BouncingBehaviorStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> BouncingBehavior
        /// The easing function used by animations
        abstract EasingFunction: BackEase with get, set
        /// The easing mode used by animations
        abstract EasingMode: float with get, set

    /// The framing behavior (BABYLON.FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.
    type [<AllowNullLiteral>] FramingBehavior =
        inherit Behavior<ArcRotateCamera>
        /// Gets the name of the behavior.
        abstract name: string
        /// Sets the current mode used by the behavior
        /// Gets current mode used by the behavior.
        abstract mode: float with get, set
        /// Sets the scale applied to the radius (1 by default)
        /// Gets the scale applied to the radius
        abstract radiusScale: float with get, set
        /// Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
        /// Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
        abstract positionScale: float with get, set
        /// Sets the angle above/below the horizontal plane to return to when the return to default elevation idle
        /// behaviour is triggered, in radians.
        /// Gets the angle above/below the horizontal plane to return to when the return to default elevation idle
        /// behaviour is triggered, in radians.
        abstract defaultElevation: float with get, set
        /// Sets the time (in milliseconds) taken to return to the default beta position.
        /// Negative value indicates camera should not return to default.
        /// Gets the time (in milliseconds) taken to return to the default beta position.
        /// Negative value indicates camera should not return to default.
        abstract elevationReturnTime: float with get, set
        /// Sets the delay (in milliseconds) taken before the camera returns to the default beta position.
        /// Gets the delay (in milliseconds) taken before the camera returns to the default beta position.
        abstract elevationReturnWaitTime: float with get, set
        /// Sets the flag that indicates if user zooming should stop animation.
        /// Gets the flag that indicates if user zooming should stop animation.
        abstract zoomStopsAnimation: bool with get, set
        /// Sets the transition time when framing the mesh, in milliseconds
        /// Gets the transition time when framing the mesh, in milliseconds
        abstract framingTime: float with get, set
        /// Define if the behavior should automatically change the configured
        /// camera limits and sensibilities.
        abstract autoCorrectCameraLimitsAndSensibility: bool with get, set
        /// Initializes the behavior.
        abstract init: unit -> unit
        /// <summary>Attaches the behavior to its arc rotate camera.</summary>
        /// <param name="camera">Defines the camera to attach the behavior to</param>
        abstract attach: camera: ArcRotateCamera -> unit
        /// Detaches the behavior from its current arc rotate camera.
        abstract detach: unit -> unit
        /// <summary>Targets the given mesh and updates zoom level accordingly.</summary>
        /// <param name="mesh">The mesh to target.</param>
        /// <param name="focusOnOriginXZ">Determines if the camera should focus on 0 in the X and Z axis instead of the mesh</param>
        /// <param name="onAnimationEnd">Callback triggered at the end of the framing animation</param>
        abstract zoomOnMesh: mesh: AbstractMesh * ?focusOnOriginXZ: bool * ?onAnimationEnd: (unit -> unit) -> unit
        /// <summary>Targets the given mesh with its children and updates zoom level accordingly.</summary>
        /// <param name="mesh">The mesh to target.</param>
        /// <param name="focusOnOriginXZ">Determines if the camera should focus on 0 in the X and Z axis instead of the mesh</param>
        /// <param name="onAnimationEnd">Callback triggered at the end of the framing animation</param>
        abstract zoomOnMeshHierarchy: mesh: AbstractMesh * ?focusOnOriginXZ: bool * ?onAnimationEnd: (unit -> unit) -> unit
        /// <summary>Targets the given meshes with their children and updates zoom level accordingly.</summary>
        /// <param name="meshes">The mesh to target.</param>
        /// <param name="focusOnOriginXZ">Determines if the camera should focus on 0 in the X and Z axis instead of the mesh</param>
        /// <param name="onAnimationEnd">Callback triggered at the end of the framing animation</param>
        abstract zoomOnMeshesHierarchy: meshes: ResizeArray<AbstractMesh> * ?focusOnOriginXZ: bool * ?onAnimationEnd: (unit -> unit) -> unit
        /// <summary>Targets the bounding box info defined by its extends and updates zoom level accordingly.</summary>
        /// <param name="minimumWorld">Determines the smaller position of the bounding box extend</param>
        /// <param name="maximumWorld">Determines the bigger position of the bounding box extend</param>
        /// <param name="focusOnOriginXZ">Determines if the camera should focus on 0 in the X and Z axis instead of the mesh</param>
        /// <param name="onAnimationEnd">Callback triggered at the end of the framing animation</param>
        abstract zoomOnBoundingInfo: minimumWorld: Vector3 * maximumWorld: Vector3 * ?focusOnOriginXZ: bool * ?onAnimationEnd: (unit -> unit) -> unit
        /// Calculates the lowest radius for the camera based on the bounding box of the mesh.
        abstract _calculateLowerRadiusFromModelBoundingSphere: minimumWorld: Vector3 * maximumWorld: Vector3 -> float
        /// Stops and removes all animations that have been applied to the camera
        abstract stopAllAnimations: unit -> unit
        /// Gets a value indicating if the user is moving the camera
        abstract isUserIsMoving: bool

    /// The framing behavior (BABYLON.FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.
    type [<AllowNullLiteral>] FramingBehaviorStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FramingBehavior
        /// The easing function used by animations
        abstract EasingFunction: ExponentialEase with get, set
        /// The easing mode used by animations
        abstract EasingMode: float with get, set
        /// The camera can move all the way towards the mesh.
        abstract IgnoreBoundsSizeMode: float with get, set
        /// The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides
        abstract FitFrustumSidesMode: float with get, set

    /// A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera
    type [<AllowNullLiteral>] AttachToBoxBehavior =
        inherit BABYLON.Behavior<BABYLON.Mesh>
        /// The name of the behavior
        abstract name: string with get, set
        /// The distance away from the face of the mesh that the UI should be attached to (default: 0.15)
        abstract distanceAwayFromFace: float with get, set
        /// The distance from the bottom of the face that the UI should be attached to (default: 0.15)
        abstract distanceAwayFromBottomOfFace: float with get, set
        /// Initializes the behavior
        abstract init: unit -> unit
        /// <summary>Attaches the AttachToBoxBehavior to the passed in mesh</summary>
        /// <param name="target">The mesh that the specified node will be attached to</param>
        abstract attach: target: BABYLON.Mesh -> unit
        /// Detaches the behavior from the mesh
        abstract detach: unit -> unit

    /// A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera
    type [<AllowNullLiteral>] AttachToBoxBehaviorStatic =
        /// <summary>Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera</summary>
        /// <param name="ui">The transform node that should be attched to the mesh</param>
        [<Emit "new $0($1...)">] abstract Create: ui: BABYLON.TransformNode -> AttachToBoxBehavior

    /// A behavior that when attached to a mesh will allow the mesh to fade in and out
    type [<AllowNullLiteral>] FadeInOutBehavior =
        inherit Behavior<Mesh>
        /// Time in milliseconds to delay before fading in (Default: 0)
        abstract delay: float with get, set
        /// Time in milliseconds for the mesh to fade in (Default: 300)
        abstract fadeInTime: float with get, set
        /// The name of the behavior
        abstract name: string
        /// Initializes the behavior
        abstract init: unit -> unit
        /// <summary>Attaches the fade behavior on the passed in mesh</summary>
        /// <param name="ownerNode">The mesh that will be faded in/out once attached</param>
        abstract attach: ownerNode: Mesh -> unit
        /// Detaches the behavior from the mesh
        abstract detach: unit -> unit
        /// <summary>Triggers the mesh to begin fading in or out</summary>
        /// <param name="value">if the object should fade in or out (true to fade in)</param>
        abstract fadeIn: value: bool -> unit

    /// A behavior that when attached to a mesh will allow the mesh to fade in and out
    type [<AllowNullLiteral>] FadeInOutBehaviorStatic =
        /// Instatiates the FadeInOutBehavior
        [<Emit "new $0($1...)">] abstract Create: unit -> FadeInOutBehavior

    /// A behavior that when attached to a mesh will allow the mesh to be scaled
    type [<AllowNullLiteral>] MultiPointerScaleBehavior =
        inherit Behavior<Mesh>
        /// The name of the behavior
        abstract name: string
        /// Initializes the behavior
        abstract init: unit -> unit
        /// <summary>Attaches the scale behavior the passed in mesh</summary>
        /// <param name="ownerNode">The mesh that will be scaled around once attached</param>
        abstract attach: ownerNode: Mesh -> unit
        /// Detaches the behavior from the mesh
        abstract detach: unit -> unit

    /// A behavior that when attached to a mesh will allow the mesh to be scaled
    type [<AllowNullLiteral>] MultiPointerScaleBehaviorStatic =
        /// Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled
        [<Emit "new $0($1...)">] abstract Create: unit -> MultiPointerScaleBehavior

    /// A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events
    type [<AllowNullLiteral>] PointerDragBehavior =
        inherit Behavior<Mesh>
        /// The maximum tolerated angle between the drag plane and dragging pointer rays to trigger pointer events. Set to 0 to allow any angle (default: 0)
        abstract maxDragAngle: float with get, set
        abstract _useAlternatePickedPointAboveMaxDragAngle: bool with get, set
        /// The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
        abstract currentDraggingPointerID: float with get, set
        /// The last position where the pointer hit the drag plane in world space
        abstract lastDragPosition: Vector3 with get, set
        /// If the behavior is currently in a dragging state
        abstract dragging: bool with get, set
        /// The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)
        abstract dragDeltaRatio: float with get, set
        /// If the drag plane orientation should be updated during the dragging (Default: true)
        abstract updateDragPlane: bool with get, set
        /// Fires each time the attached mesh is dragged with the pointer
        /// * delta between last drag position and current drag position in world space
        /// * dragDistance along the drag axis
        /// * dragPlaneNormal normal of the current drag plane used during the drag
        /// * dragPlanePoint in world space where the drag intersects the drag plane
        abstract onDragObservable: Observable<TypeLiteral_38> with get, set
        /// Fires each time a drag begins (eg. mouse down on mesh)
        abstract onDragStartObservable: Observable<TypeLiteral_39> with get, set
        /// Fires each time a drag ends (eg. mouse release after drag)
        abstract onDragEndObservable: Observable<TypeLiteral_39> with get, set
        /// If the attached mesh should be moved when dragged
        abstract moveAttached: bool with get, set
        /// If the drag behavior will react to drag events (Default: true)
        abstract enabled: bool with get, set
        /// If camera controls should be detached during the drag
        abstract detachCameraControls: bool with get, set
        /// If set, the drag plane/axis will be rotated based on the attached mesh's world rotation (Default: true)
        abstract useObjectOrienationForDragging: bool with get, set
        /// The name of the behavior
        abstract name: string
        /// Initializes the behavior
        abstract init: unit -> unit
        /// <summary>Attaches the drag behavior the passed in mesh</summary>
        /// <param name="ownerNode">The mesh that will be dragged around once attached</param>
        abstract attach: ownerNode: Mesh -> unit
        /// Force relase the drag action by code.
        abstract releaseDrag: unit -> unit
        /// <summary>Simulates the start of a pointer drag event on the behavior</summary>
        /// <param name="pointerId">pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)</param>
        /// <param name="fromRay">initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)</param>
        /// <param name="startPickedPoint">picked point of the pointer to be simulated (Default: attached mesh position)</param>
        abstract startDrag: ?pointerId: float * ?fromRay: Ray * ?startPickedPoint: Vector3 -> unit
        /// Detaches the behavior from the mesh
        abstract detach: unit -> unit

    /// A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events
    type [<AllowNullLiteral>] PointerDragBehaviorStatic =
        /// <summary>Creates a pointer drag behavior that can be attached to a mesh</summary>
        /// <param name="options">The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)</param>
        [<Emit "new $0($1...)">] abstract Create: ?options: PointerDragBehaviorStaticOptions -> PointerDragBehavior

    type [<AllowNullLiteral>] PointerDragBehaviorStaticOptions =
        abstract dragAxis: Vector3 option with get, set
        abstract dragPlaneNormal: Vector3 option with get, set

    /// A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
    type [<AllowNullLiteral>] SixDofDragBehavior =
        inherit Behavior<Mesh>
        /// If the behavior is currently in a dragging state
        abstract dragging: bool with get, set
        /// The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)
        abstract dragDeltaRatio: float with get, set
        /// The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
        abstract currentDraggingPointerID: float with get, set
        /// If camera controls should be detached during the drag
        abstract detachCameraControls: bool with get, set
        /// Fires each time a drag starts
        abstract onDragStartObservable: Observable<TypeLiteral_01> with get, set
        /// Fires each time a drag ends (eg. mouse release after drag)
        abstract onDragEndObservable: Observable<TypeLiteral_01> with get, set
        /// The name of the behavior
        abstract name: string
        /// Initializes the behavior
        abstract init: unit -> unit
        /// <summary>Attaches the scale behavior the passed in mesh</summary>
        /// <param name="ownerNode">The mesh that will be scaled around once attached</param>
        abstract attach: ownerNode: Mesh -> unit
        /// Detaches the behavior from the mesh
        abstract detach: unit -> unit

    /// A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
    type [<AllowNullLiteral>] SixDofDragBehaviorStatic =
        /// Instantiates a behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
        [<Emit "new $0($1...)">] abstract Create: unit -> SixDofDragBehavior

    /// Manage the gamepad inputs to control an arc rotate camera.
    type [<AllowNullLiteral>] ArcRotateCameraGamepadInput =
        inherit ICameraInput<ArcRotateCamera>
        /// Defines the camera the input is attached to.
        abstract camera: ArcRotateCamera with get, set
        /// Defines the gamepad the input is gathering event from.
        abstract gamepad: Nullable<Gamepad> with get, set
        /// Defines the gamepad rotation sensiblity.
        /// This is the threshold from when rotation starts to be accounted for to prevent jittering.
        abstract gamepadRotationSensibility: float with get, set
        /// Defines the gamepad move sensiblity.
        /// This is the threshold from when moving starts to be accounted for for to prevent jittering.
        abstract gamepadMoveSensibility: float with get, set
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Update the current camera state depending on the inputs that have been used this frame.
        /// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
        abstract checkInputs: unit -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Manage the gamepad inputs to control an arc rotate camera.
    type [<AllowNullLiteral>] ArcRotateCameraGamepadInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ArcRotateCameraGamepadInput

    /// Manage the keyboard inputs to control the movement of an arc rotate camera.
    type [<AllowNullLiteral>] ArcRotateCameraKeyboardMoveInput =
        inherit ICameraInput<ArcRotateCamera>
        /// Defines the camera the input is attached to.
        abstract camera: ArcRotateCamera with get, set
        /// Defines the list of key codes associated with the up action (increase alpha)
        abstract keysUp: ResizeArray<float> with get, set
        /// Defines the list of key codes associated with the down action (decrease alpha)
        abstract keysDown: ResizeArray<float> with get, set
        /// Defines the list of key codes associated with the left action (increase beta)
        abstract keysLeft: ResizeArray<float> with get, set
        /// Defines the list of key codes associated with the right action (decrease beta)
        abstract keysRight: ResizeArray<float> with get, set
        /// Defines the list of key codes associated with the reset action.
        /// Those keys reset the camera to its last stored state (with the method camera.storeState())
        abstract keysReset: ResizeArray<float> with get, set
        /// Defines the panning sensibility of the inputs.
        /// (How fast is the camera paning)
        abstract panningSensibility: float with get, set
        /// Defines the zooming sensibility of the inputs.
        /// (How fast is the camera zooming)
        abstract zoomingSensibility: float with get, set
        /// Defines wether maintaining the alt key down switch the movement mode from
        /// orientation to zoom.
        abstract useAltToZoom: bool with get, set
        /// Rotation speed of the camera
        abstract angularSpeed: float with get, set
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Update the current camera state depending on the inputs that have been used this frame.
        /// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
        abstract checkInputs: unit -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Manage the keyboard inputs to control the movement of an arc rotate camera.
    type [<AllowNullLiteral>] ArcRotateCameraKeyboardMoveInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ArcRotateCameraKeyboardMoveInput

    /// Manage the mouse wheel inputs to control an arc rotate camera.
    type [<AllowNullLiteral>] ArcRotateCameraMouseWheelInput =
        inherit ICameraInput<ArcRotateCamera>
        /// Defines the camera the input is attached to.
        abstract camera: ArcRotateCamera with get, set
        /// Gets or Set the mouse wheel precision or how fast is the camera zooming.
        abstract wheelPrecision: float with get, set
        /// wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
        /// It defines the percentage of current camera.radius to use as delta when wheel is used.
        abstract wheelDeltaPercentage: float with get, set
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Manage the mouse wheel inputs to control an arc rotate camera.
    type [<AllowNullLiteral>] ArcRotateCameraMouseWheelInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ArcRotateCameraMouseWheelInput

    /// Manage the pointers inputs to control an arc rotate camera.
    type [<AllowNullLiteral>] ArcRotateCameraPointersInput =
        inherit ICameraInput<ArcRotateCamera>
        /// Defines the camera the input is attached to.
        abstract camera: ArcRotateCamera with get, set
        /// Defines the buttons associated with the input to handle camera move.
        abstract buttons: ResizeArray<float> with get, set
        /// Defines the pointer angular sensibility  along the X axis or how fast is the camera rotating.
        abstract angularSensibilityX: float with get, set
        /// Defines the pointer angular sensibility along the Y axis or how fast is the camera rotating.
        abstract angularSensibilityY: float with get, set
        /// Defines the pointer pinch precision or how fast is the camera zooming.
        abstract pinchPrecision: float with get, set
        /// pinchDeltaPercentage will be used instead of pinchPrecision if different from 0.
        /// It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
        abstract pinchDeltaPercentage: float with get, set
        /// Defines the pointer panning sensibility or how fast is the camera moving.
        abstract panningSensibility: float with get, set
        /// Defines whether panning (2 fingers swipe) is enabled through multitouch.
        abstract multiTouchPanning: bool with get, set
        /// Defines whether panning is enabled for both pan (2 fingers swipe) and zoom (pinch) through multitouch.
        abstract multiTouchPanAndZoom: bool with get, set
        /// Revers pinch action direction.
        abstract pinchInwards: bool with get, set
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Manage the pointers inputs to control an arc rotate camera.
    type [<AllowNullLiteral>] ArcRotateCameraPointersInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ArcRotateCameraPointersInput

    /// Manage the device orientation inputs (gyroscope) to control an arc rotate camera.
    type [<AllowNullLiteral>] ArcRotateCameraVRDeviceOrientationInput =
        inherit ICameraInput<ArcRotateCamera>
        /// Defines the camera the input is attached to.
        abstract camera: ArcRotateCamera with get, set
        /// Defines a correction factor applied on the alpha value retrieved from the orientation events.
        abstract alphaCorrection: float with get, set
        /// Defines a correction factor applied on the beta value retrieved from the orientation events.
        abstract betaCorrection: float with get, set
        /// Defines a correction factor applied on the gamma value retrieved from the orientation events.
        abstract gammaCorrection: float with get, set
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract _onOrientationEvent: evt: DeviceOrientationEvent -> unit
        /// Update the current camera state depending on the inputs that have been used this frame.
        /// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
        abstract checkInputs: unit -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Manage the device orientation inputs (gyroscope) to control an arc rotate camera.
    type [<AllowNullLiteral>] ArcRotateCameraVRDeviceOrientationInputStatic =
        /// Instantiate a new ArcRotateCameraVRDeviceOrientationInput.
        [<Emit "new $0($1...)">] abstract Create: unit -> ArcRotateCameraVRDeviceOrientationInput

    /// Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.
    /// Screen rotation is taken into account.
    type [<AllowNullLiteral>] FreeCameraDeviceOrientationInput =
        inherit ICameraInput<FreeCamera>
        /// Define the camera controlled by the input.
        abstract camera: FreeCamera with get, set
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Update the current camera state depending on the inputs that have been used this frame.
        /// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
        abstract checkInputs: unit -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.
    /// Screen rotation is taken into account.
    type [<AllowNullLiteral>] FreeCameraDeviceOrientationInputStatic =
        /// Instantiates a new input
        [<Emit "new $0($1...)">] abstract Create: unit -> FreeCameraDeviceOrientationInput

    /// Manage the gamepad inputs to control a free camera.
    type [<AllowNullLiteral>] FreeCameraGamepadInput =
        inherit ICameraInput<FreeCamera>
        /// Define the camera the input is attached to.
        abstract camera: FreeCamera with get, set
        /// Define the Gamepad controlling the input
        abstract gamepad: Nullable<Gamepad> with get, set
        /// Defines the gamepad rotation sensiblity.
        /// This is the threshold from when rotation starts to be accounted for to prevent jittering.
        abstract gamepadAngularSensibility: float with get, set
        /// Defines the gamepad move sensiblity.
        /// This is the threshold from when moving starts to be accounted for for to prevent jittering.
        abstract gamepadMoveSensibility: float with get, set
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Update the current camera state depending on the inputs that have been used this frame.
        /// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
        abstract checkInputs: unit -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Manage the gamepad inputs to control a free camera.
    type [<AllowNullLiteral>] FreeCameraGamepadInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FreeCameraGamepadInput

    /// Manage the keyboard inputs to control the movement of a free camera.
    type [<AllowNullLiteral>] FreeCameraKeyboardMoveInput =
        inherit ICameraInput<FreeCamera>
        /// Defines the camera the input is attached to.
        abstract camera: FreeCamera with get, set
        /// Gets or Set the list of keyboard keys used to control the forward move of the camera.
        abstract keysUp: ResizeArray<float> with get, set
        /// Gets or Set the list of keyboard keys used to control the backward move of the camera.
        abstract keysDown: ResizeArray<float> with get, set
        /// Gets or Set the list of keyboard keys used to control the left strafe move of the camera.
        abstract keysLeft: ResizeArray<float> with get, set
        /// Gets or Set the list of keyboard keys used to control the right strafe move of the camera.
        abstract keysRight: ResizeArray<float> with get, set
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Update the current camera state depending on the inputs that have been used this frame.
        /// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
        abstract checkInputs: unit -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        abstract _onLostFocus: e: FocusEvent -> unit
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Manage the keyboard inputs to control the movement of a free camera.
    type [<AllowNullLiteral>] FreeCameraKeyboardMoveInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FreeCameraKeyboardMoveInput

    /// Manage the mouse inputs to control the movement of a free camera.
    type [<AllowNullLiteral>] FreeCameraMouseInput =
        inherit ICameraInput<FreeCamera>
        /// Define if touch is enabled in the mouse input
        abstract touchEnabled: bool with get, set
        /// Defines the camera the input is attached to.
        abstract camera: FreeCamera with get, set
        /// Defines the buttons associated with the input to handle camera move.
        abstract buttons: ResizeArray<float> with get, set
        /// Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.
        abstract angularSensibility: float with get, set
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Manage the mouse inputs to control the movement of a free camera.
    type [<AllowNullLiteral>] FreeCameraMouseInputStatic =
        /// <summary>Manage the mouse inputs to control the movement of a free camera.</summary>
        /// <param name="touchEnabled">Defines if touch is enabled or not</param>
        [<Emit "new $0($1...)">] abstract Create: ?touchEnabled: bool -> FreeCameraMouseInput

    /// Manage the touch inputs to control the movement of a free camera.
    type [<AllowNullLiteral>] FreeCameraTouchInput =
        inherit ICameraInput<FreeCamera>
        /// Defines the camera the input is attached to.
        abstract camera: FreeCamera with get, set
        /// Defines the touch sensibility for rotation.
        /// The higher the faster.
        abstract touchAngularSensibility: float with get, set
        /// Defines the touch sensibility for move.
        /// The higher the faster.
        abstract touchMoveSensibility: float with get, set
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Update the current camera state depending on the inputs that have been used this frame.
        /// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
        abstract checkInputs: unit -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Manage the touch inputs to control the movement of a free camera.
    type [<AllowNullLiteral>] FreeCameraTouchInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FreeCameraTouchInput

    /// Manage the Virtual Joystick inputs to control the movement of a free camera.
    type [<AllowNullLiteral>] FreeCameraVirtualJoystickInput =
        inherit ICameraInput<FreeCamera>
        /// Defines the camera the input is attached to.
        abstract camera: FreeCamera with get, set
        /// Gets the left stick of the virtual joystick.
        abstract getLeftJoystick: unit -> VirtualJoystick
        /// Gets the right stick of the virtual joystick.
        abstract getRightJoystick: unit -> VirtualJoystick
        /// Update the current camera state depending on the inputs that have been used this frame.
        /// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
        abstract checkInputs: unit -> unit
        /// <summary>Attach the input controls to a specific dom element to get the input from.</summary>
        /// <param name="element">Defines the element the controls should be listened from</param>
        /// <param name="noPreventDefault">Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detach the current controls from the specified dom element.</summary>
        /// <param name="element">Defines the element to stop listening the inputs from</param>
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        /// Gets the class name of the current intput.
        abstract getClassName: unit -> string
        /// Get the friendly name associated with the input class.
        abstract getSimpleName: unit -> string

    /// Manage the Virtual Joystick inputs to control the movement of a free camera.
    type [<AllowNullLiteral>] FreeCameraVirtualJoystickInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FreeCameraVirtualJoystickInput

    /// Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)
    type [<AllowNullLiteral>] AnaglyphArcRotateCamera =
        inherit ArcRotateCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)
    type [<AllowNullLiteral>] AnaglyphArcRotateCameraStatic =
        /// <summary>Creates a new AnaglyphArcRotateCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="alpha">defines alpha angle (in radians)</param>
        /// <param name="beta">defines beta angle (in radians)</param>
        /// <param name="radius">defines radius</param>
        /// <param name="target">defines camera target</param>
        /// <param name="interaxialDistance">defines distance between each color axis</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * alpha: float * beta: float * radius: float * target: Vector3 * interaxialDistance: float * scene: Scene -> AnaglyphArcRotateCamera

    /// Camera used to simulate anaglyphic rendering (based on FreeCamera)
    type [<AllowNullLiteral>] AnaglyphFreeCamera =
        inherit FreeCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate anaglyphic rendering (based on FreeCamera)
    type [<AllowNullLiteral>] AnaglyphFreeCameraStatic =
        /// <summary>Creates a new AnaglyphFreeCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="position">defines initial position</param>
        /// <param name="interaxialDistance">defines distance between each color axis</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * scene: Scene -> AnaglyphFreeCamera

    /// Camera used to simulate anaglyphic rendering (based on GamepadCamera)
    type [<AllowNullLiteral>] AnaglyphGamepadCamera =
        inherit GamepadCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate anaglyphic rendering (based on GamepadCamera)
    type [<AllowNullLiteral>] AnaglyphGamepadCameraStatic =
        /// <summary>Creates a new AnaglyphGamepadCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="position">defines initial position</param>
        /// <param name="interaxialDistance">defines distance between each color axis</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * scene: Scene -> AnaglyphGamepadCamera

    /// Camera used to simulate anaglyphic rendering (based on UniversalCamera)
    type [<AllowNullLiteral>] AnaglyphUniversalCamera =
        inherit UniversalCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate anaglyphic rendering (based on UniversalCamera)
    type [<AllowNullLiteral>] AnaglyphUniversalCameraStatic =
        /// <summary>Creates a new AnaglyphUniversalCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="position">defines initial position</param>
        /// <param name="interaxialDistance">defines distance between each color axis</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * scene: Scene -> AnaglyphUniversalCamera

    /// Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)
    type [<AllowNullLiteral>] StereoscopicArcRotateCamera =
        inherit ArcRotateCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)
    type [<AllowNullLiteral>] StereoscopicArcRotateCameraStatic =
        /// <summary>Creates a new StereoscopicArcRotateCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="alpha">defines alpha angle (in radians)</param>
        /// <param name="beta">defines beta angle (in radians)</param>
        /// <param name="radius">defines radius</param>
        /// <param name="target">defines camera target</param>
        /// <param name="interaxialDistance">defines distance between each color axis</param>
        /// <param name="isStereoscopicSideBySide">defines is stereoscopic is done side by side or over under</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * alpha: float * beta: float * radius: float * target: Vector3 * interaxialDistance: float * isStereoscopicSideBySide: bool * scene: Scene -> StereoscopicArcRotateCamera

    /// Camera used to simulate stereoscopic rendering (based on FreeCamera)
    type [<AllowNullLiteral>] StereoscopicFreeCamera =
        inherit FreeCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate stereoscopic rendering (based on FreeCamera)
    type [<AllowNullLiteral>] StereoscopicFreeCameraStatic =
        /// <summary>Creates a new StereoscopicFreeCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="position">defines initial position</param>
        /// <param name="interaxialDistance">defines distance between each color axis</param>
        /// <param name="isStereoscopicSideBySide">defines is stereoscopic is done side by side or over under</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * isStereoscopicSideBySide: bool * scene: Scene -> StereoscopicFreeCamera

    /// Camera used to simulate stereoscopic rendering (based on GamepadCamera)
    type [<AllowNullLiteral>] StereoscopicGamepadCamera =
        inherit GamepadCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate stereoscopic rendering (based on GamepadCamera)
    type [<AllowNullLiteral>] StereoscopicGamepadCameraStatic =
        /// <summary>Creates a new StereoscopicGamepadCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="position">defines initial position</param>
        /// <param name="interaxialDistance">defines distance between each color axis</param>
        /// <param name="isStereoscopicSideBySide">defines is stereoscopic is done side by side or over under</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * isStereoscopicSideBySide: bool * scene: Scene -> StereoscopicGamepadCamera

    /// Camera used to simulate stereoscopic rendering (based on UniversalCamera)
    type [<AllowNullLiteral>] StereoscopicUniversalCamera =
        inherit UniversalCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate stereoscopic rendering (based on UniversalCamera)
    type [<AllowNullLiteral>] StereoscopicUniversalCameraStatic =
        /// <summary>Creates a new StereoscopicUniversalCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="position">defines initial position</param>
        /// <param name="interaxialDistance">defines distance between each color axis</param>
        /// <param name="isStereoscopicSideBySide">defines is stereoscopic is done side by side or over under</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * isStereoscopicSideBySide: bool * scene: Scene -> StereoscopicUniversalCamera

    /// This represents all the required metrics to create a VR camera.
    type [<AllowNullLiteral>] VRCameraMetrics =
        /// Define the horizontal resolution off the screen.
        abstract hResolution: float with get, set
        /// Define the vertical resolution off the screen.
        abstract vResolution: float with get, set
        /// Define the horizontal screen size.
        abstract hScreenSize: float with get, set
        /// Define the vertical screen size.
        abstract vScreenSize: float with get, set
        /// Define the vertical screen center position.
        abstract vScreenCenter: float with get, set
        /// Define the distance of the eyes to the screen.
        abstract eyeToScreenDistance: float with get, set
        /// Define the distance between both lenses
        abstract lensSeparationDistance: float with get, set
        /// Define the distance between both viewer's eyes.
        abstract interpupillaryDistance: float with get, set
        /// Define the distortion factor of the VR postprocess.
        /// Please, touch with care.
        abstract distortionK: ResizeArray<float> with get, set
        /// Define the chromatic aberration correction factors for the VR post process.
        abstract chromaAbCorrection: ResizeArray<float> with get, set
        /// Define the scale factor of the post process.
        /// The smaller the better but the slower.
        abstract postProcessScaleFactor: float with get, set
        /// Define an offset for the lens center.
        abstract lensCenterOffset: float with get, set
        /// Define if the current vr camera should compensate the distortion of the lense or not.
        abstract compensateDistortion: bool with get, set
        /// Gets the rendering aspect ratio based on the provided resolutions.
        abstract aspectRatio: float
        /// Gets the aspect ratio based on the FOV, scale factors, and real screen sizes.
        abstract aspectRatioFov: float
        abstract leftHMatrix: Matrix
        abstract rightHMatrix: Matrix
        abstract leftPreViewMatrix: Matrix
        abstract rightPreViewMatrix: Matrix

    /// This represents all the required metrics to create a VR camera.
    type [<AllowNullLiteral>] VRCameraMetricsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> VRCameraMetrics
        /// Get the default VRMetrics based on the most generic setup.
        abstract GetDefault: unit -> VRCameraMetrics

    /// Camera used to simulate VR rendering (based on ArcRotateCamera)
    type [<AllowNullLiteral>] VRDeviceOrientationArcRotateCamera =
        inherit ArcRotateCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate VR rendering (based on ArcRotateCamera)
    type [<AllowNullLiteral>] VRDeviceOrientationArcRotateCameraStatic =
        /// <summary>Creates a new VRDeviceOrientationArcRotateCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="alpha">defines the camera rotation along the logitudinal axis</param>
        /// <param name="beta">defines the camera rotation along the latitudinal axis</param>
        /// <param name="radius">defines the camera distance from its target</param>
        /// <param name="target">defines the camera target</param>
        /// <param name="scene">defines the scene the camera belongs to</param>
        /// <param name="compensateDistortion">defines if the camera needs to compensate the lens distorsion</param>
        /// <param name="vrCameraMetrics">defines the vr metrics associated to the camera</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * alpha: float * beta: float * radius: float * target: Vector3 * scene: Scene * ?compensateDistortion: bool * ?vrCameraMetrics: VRCameraMetrics -> VRDeviceOrientationArcRotateCamera

    /// Camera used to simulate VR rendering (based on FreeCamera)
    type [<AllowNullLiteral>] VRDeviceOrientationFreeCamera =
        inherit DeviceOrientationCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate VR rendering (based on FreeCamera)
    type [<AllowNullLiteral>] VRDeviceOrientationFreeCameraStatic =
        /// <summary>Creates a new VRDeviceOrientationFreeCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="position">defines the start position of the camera</param>
        /// <param name="scene">defines the scene the camera belongs to</param>
        /// <param name="compensateDistortion">defines if the camera needs to compensate the lens distorsion</param>
        /// <param name="vrCameraMetrics">defines the vr metrics associated to the camera</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?compensateDistortion: bool * ?vrCameraMetrics: VRCameraMetrics -> VRDeviceOrientationFreeCamera

    /// Camera used to simulate VR rendering (based on VRDeviceOrientationFreeCamera)
    type [<AllowNullLiteral>] VRDeviceOrientationGamepadCamera =
        inherit VRDeviceOrientationFreeCamera
        /// Gets camera class name
        abstract getClassName: unit -> string

    /// Camera used to simulate VR rendering (based on VRDeviceOrientationFreeCamera)
    type [<AllowNullLiteral>] VRDeviceOrientationGamepadCameraStatic =
        /// <summary>Creates a new VRDeviceOrientationGamepadCamera</summary>
        /// <param name="name">defines camera name</param>
        /// <param name="position">defines the start position of the camera</param>
        /// <param name="scene">defines the scene the camera belongs to</param>
        /// <param name="compensateDistortion">defines if the camera needs to compensate the lens distorsion</param>
        /// <param name="vrCameraMetrics">defines the vr metrics associated to the camera</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?compensateDistortion: bool * ?vrCameraMetrics: VRCameraMetrics -> VRDeviceOrientationGamepadCamera

    /// Options to modify the vr teleportation behavior.
    type [<AllowNullLiteral>] VRTeleportationOptions =
        /// The name of the mesh which should be used as the teleportation floor. (default: null)
        abstract floorMeshName: string option with get, set
        /// A list of meshes to be used as the teleportation floor. (default: empty)
        abstract floorMeshes: ResizeArray<Mesh> option with get, set

    /// Options to modify the vr experience helper's behavior.
    type [<AllowNullLiteral>] VRExperienceHelperOptions =
        inherit WebVROptions
        /// Create a DeviceOrientationCamera to be used as your out of vr camera. (default: true)
        abstract createDeviceOrientationCamera: bool option with get, set
        /// Create a VRDeviceOrientationFreeCamera to be used for VR when no external HMD is found. (default: true)
        abstract createFallbackVRDeviceOrientationFreeCamera: bool option with get, set
        /// Uses the main button on the controller to toggle the laser casted. (default: true)
        abstract laserToggle: bool option with get, set
        /// A list of meshes to be used as the teleportation floor. If specified, teleportation will be enabled (default: undefined)
        abstract floorMeshes: ResizeArray<Mesh> option with get, set

    /// Helps to quickly add VR support to an existing scene.
    /// See http://doc.babylonjs.com/how_to/webvr_helper
    type [<AllowNullLiteral>] VRExperienceHelper =
        /// Options to modify the vr experience helper's behavior. 
        abstract webVROptions: VRExperienceHelperOptions with get, set
        /// Observable raised when entering VR.
        abstract onEnteringVRObservable: Observable<VRExperienceHelper> with get, set
        /// Observable raised when exiting VR.
        abstract onExitingVRObservable: Observable<VRExperienceHelper> with get, set
        /// Observable raised when controller mesh is loaded.
        abstract onControllerMeshLoadedObservable: Observable<WebVRController> with get, set
        /// Return this.onEnteringVRObservable
        /// Note: This one is for backward compatibility. Please use onEnteringVRObservable directly
        abstract onEnteringVR: Observable<VRExperienceHelper>
        /// Return this.onExitingVRObservable
        /// Note: This one is for backward compatibility. Please use onExitingVRObservable directly
        abstract onExitingVR: Observable<VRExperienceHelper>
        /// Return this.onControllerMeshLoadedObservable
        /// Note: This one is for backward compatibility. Please use onControllerMeshLoadedObservable directly
        abstract onControllerMeshLoaded: Observable<WebVRController>
        /// Observable raised when a new mesh is selected based on meshSelectionPredicate
        abstract onNewMeshSelected: Observable<AbstractMesh> with get, set
        /// Observable raised when a new mesh is picked based on meshSelectionPredicate
        abstract onNewMeshPicked: Observable<PickingInfo> with get, set
        /// Observable raised before camera teleportation
        abstract onBeforeCameraTeleport: Observable<Vector3> with get, set
        /// Observable raised after camera teleportation
        abstract onAfterCameraTeleport: Observable<Vector3> with get, set
        /// Observable raised when current selected mesh gets unselected
        abstract onSelectedMeshUnselected: Observable<AbstractMesh> with get, set
        /// To be optionaly changed by user to define custom ray selection
        abstract raySelectionPredicate: (AbstractMesh -> bool) with get, set
        /// To be optionaly changed by user to define custom selection logic (after ray selection)
        abstract meshSelectionPredicate: (AbstractMesh -> bool) with get, set
        /// Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.
        abstract teleportationEnabled: bool with get, set
        /// The mesh used to display where the user is going to teleport.
        /// Sets the mesh to be used to display where the user is going to teleport.
        abstract teleportationTarget: Mesh with get, set
        /// The mesh used to display where the user is selecting, this mesh will be cloned and set as the gazeTracker for the left and right controller
        /// when set bakeCurrentTransformIntoVertices will be called on the mesh.
        /// See http://doc.babylonjs.com/resources/baking_transformations
        abstract gazeTrackerMesh: Mesh with get, set
        /// If the gaze trackers scale should be updated to be constant size when pointing at near/far meshes
        abstract updateGazeTrackerScale: bool with get, set
        /// The gaze tracking mesh corresponding to the left controller
        abstract leftControllerGazeTrackerMesh: Nullable<Mesh>
        /// The gaze tracking mesh corresponding to the right controller
        abstract rightControllerGazeTrackerMesh: Nullable<Mesh>
        /// If the ray of the gaze should be displayed.
        /// Sets if the ray of the gaze should be displayed.
        abstract displayGaze: bool with get, set
        /// If the ray of the LaserPointer should be displayed.
        /// Sets if the ray of the LaserPointer should be displayed.
        abstract displayLaserPointer: bool with get, set
        /// The deviceOrientationCamera used as the camera when not in VR.
        abstract deviceOrientationCamera: Nullable<DeviceOrientationCamera>
        /// Based on the current WebVR support, returns the current VR camera used.
        abstract currentVRCamera: Nullable<Camera>
        /// The webVRCamera which is used when in VR.
        abstract webVRCamera: WebVRFreeCamera
        /// The deviceOrientationCamera that is used as a fallback when vr device is not connected.
        abstract vrDeviceOrientationCamera: Nullable<VRDeviceOrientationFreeCamera>
        /// Gets a value indicating if we are currently in VR mode.
        abstract isInVRMode: bool
        /// Attempt to enter VR. If a headset is connected and ready, will request present on that.
        /// Otherwise, will use the fullscreen API.
        abstract enterVR: unit -> unit
        /// Attempt to exit VR, or fullscreen.
        abstract exitVR: unit -> unit
        /// The position of the vr experience helper.
        /// Sets the position of the vr experience helper.
        abstract position: Vector3 with get, set
        /// Enables controllers and user interactions such as selecting and object or clicking on an object.
        abstract enableInteractions: unit -> unit
        /// <summary>Adds a floor mesh to be used for teleportation.</summary>
        /// <param name="floorMesh">the mesh to be used for teleportation.</param>
        abstract addFloorMesh: floorMesh: Mesh -> unit
        /// <summary>Removes a floor mesh from being used for teleportation.</summary>
        /// <param name="floorMesh">the mesh to be removed.</param>
        abstract removeFloorMesh: floorMesh: Mesh -> unit
        /// <summary>Enables interactions and teleportation using the VR controllers and gaze.</summary>
        /// <param name="vrTeleportationOptions">options to modify teleportation behavior.</param>
        abstract enableTeleportation: ?vrTeleportationOptions: VRTeleportationOptions -> unit
        /// <summary>Teleports the users feet to the desired location</summary>
        /// <param name="location">The location where the user's feet should be placed</param>
        abstract teleportCamera: location: Vector3 -> unit
        /// <summary>Sets the color of the laser ray from the vr controllers.</summary>
        /// <param name="color">new color for the ray.</param>
        abstract changeLaserColor: color: Color3 -> unit
        /// <summary>Sets the color of the ray from the vr headsets gaze.</summary>
        /// <param name="color">new color for the ray.</param>
        abstract changeGazeColor: color: Color3 -> unit
        /// Exits VR and disposes of the vr experience helper
        abstract dispose: unit -> unit
        /// Gets the name of the VRExperienceHelper class
        abstract getClassName: unit -> string

    /// Helps to quickly add VR support to an existing scene.
    /// See http://doc.babylonjs.com/how_to/webvr_helper
    type [<AllowNullLiteral>] VRExperienceHelperStatic =
        /// <summary>Instantiates a VRExperienceHelper.
        /// Helps to quickly add VR support to an existing scene.</summary>
        /// <param name="scene">The scene the VRExperienceHelper belongs to.</param>
        /// <param name="webVROptions">Options to modify the vr experience helper's behavior.</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?webVROptions: VRExperienceHelperOptions -> VRExperienceHelper

    /// This is a copy of VRPose. See https://developer.mozilla.org/en-US/docs/Web/API/VRPose
    /// IMPORTANT!! The data is right-hand data.
    type [<AllowNullLiteral>] DevicePose =
        /// The position of the device, values in array are [x,y,z].
        abstract position: Nullable<Float32Array>
        /// The linearVelocity of the device, values in array are [x,y,z].
        abstract linearVelocity: Nullable<Float32Array>
        /// The linearAcceleration of the device, values in array are [x,y,z].
        abstract linearAcceleration: Nullable<Float32Array>
        /// The orientation of the device in a quaternion array, values in array are [x,y,z,w].
        abstract orientation: Nullable<Float32Array>
        /// The angularVelocity of the device, values in array are [x,y,z].
        abstract angularVelocity: Nullable<Float32Array>
        /// The angularAcceleration of the device, values in array are [x,y,z].
        abstract angularAcceleration: Nullable<Float32Array>

    /// Interface representing a pose controlled object in Babylon.
    /// A pose controlled object has both regular pose values as well as pose values
    /// from an external device such as a VR head mounted display
    type [<AllowNullLiteral>] PoseControlled =
        /// The position of the object in babylon space.
        abstract position: Vector3 with get, set
        /// The rotation quaternion of the object in babylon space.
        abstract rotationQuaternion: Quaternion with get, set
        /// The position of the device in babylon space.
        abstract devicePosition: Vector3 option with get, set
        /// The rotation quaternion of the device in babylon space.
        abstract deviceRotationQuaternion: Quaternion with get, set
        /// The raw pose coming from the device.
        abstract rawPose: Nullable<DevicePose> with get, set
        /// The scale of the device to be used when translating from device space to babylon space.
        abstract deviceScaleFactor: float with get, set
        /// <summary>Updates the poseControlled values based on the input device pose.</summary>
        /// <param name="poseData">the pose data to update the object with</param>
        abstract updateFromDevice: poseData: DevicePose -> unit

    /// Set of options to customize the webVRCamera
    type [<AllowNullLiteral>] WebVROptions =
        /// Sets if the webVR camera should be tracked to the vrDevice. (default: true)
        abstract trackPosition: bool option with get, set
        /// Sets the scale of the vrDevice in babylon space. (default: 1)
        abstract positionScale: float option with get, set
        /// If there are more than one VRDisplays, this will choose the display matching this name. (default: pick first vrDisplay)
        abstract displayName: string option with get, set
        /// Should the native controller meshes be initialized. (default: true)
        abstract controllerMeshes: bool option with get, set
        /// Creating a default HemiLight only on controllers. (default: true)
        abstract defaultLightingOnControllers: bool option with get, set
        /// If you don't want to use the default VR button of the helper. (default: false)
        abstract useCustomVRButton: bool option with get, set
        /// If you'd like to provide your own button to the VRHelper. (default: standard babylon vr button)
        abstract customVRButton: HTMLButtonElement option with get, set
        /// To change the length of the ray for gaze/controllers. Will be scaled by positionScale. (default: 100)
        abstract rayLength: float option with get, set
        /// To change the default offset from the ground to account for user's height in meters. Will be scaled by positionScale. (default: 1.7)
        abstract defaultHeight: float option with get, set

    /// This represents a WebVR camera.
    /// The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.
    type [<AllowNullLiteral>] WebVRFreeCamera =
        inherit FreeCamera
        inherit PoseControlled
        abstract _vrDevice: obj option with get, set
        /// The rawPose of the vrDevice.
        abstract rawPose: Nullable<DevicePose> with get, set
        abstract _descendants: Array<Node> with get, set
        abstract _deviceRoomRotationQuaternion: Quaternion with get, set
        /// Represents device position in babylon space.
        abstract devicePosition: Vector3 with get, set
        /// Represents device rotation in babylon space.
        abstract deviceRotationQuaternion: Quaternion with get, set
        /// The scale of the device to be used when translating from device space to babylon space.
        abstract deviceScaleFactor: float with get, set
        /// References to the webVR controllers for the vrDevice.
        abstract controllers: Array<WebVRController> with get, set
        /// Emits an event when a controller is attached.
        abstract onControllersAttachedObservable: Observable<ResizeArray<WebVRController>> with get, set
        /// Emits an event when a controller's mesh has been loaded;
        abstract onControllerMeshLoadedObservable: Observable<WebVRController> with get, set
        /// Emits an event when the HMD's pose has been updated.
        abstract onPoseUpdatedFromDeviceObservable: Observable<obj option> with get, set
        /// If the rig cameras be used as parent instead of this camera.
        abstract rigParenting: bool with get, set
        /// Gets the device distance from the ground in meters.
        abstract deviceDistanceToRoomGround: unit -> float
        /// <summary>Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.</summary>
        /// <param name="callback">will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.</param>
        abstract useStandingMatrix: ?callback: (bool -> unit) -> unit
        /// Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
        abstract useStandingMatrixAsync: unit -> Promise<bool>
        /// Disposes the camera
        abstract dispose: unit -> unit
        /// <summary>Gets a vrController by name.</summary>
        /// <param name="name">The name of the controller to retreive</param>
        abstract getControllerByName: name: string -> Nullable<WebVRController>
        /// The controller corrisponding to the users left hand.
        abstract leftController: Nullable<WebVRController>
        /// The controller corrisponding to the users right hand.
        abstract rightController: Nullable<WebVRController>
        /// <summary>Casts a ray forward from the vrCamera's gaze.</summary>
        /// <param name="length">Length of the ray (default: 100)</param>
        abstract getForwardRay: ?length: float -> Ray
        abstract _checkInputs: unit -> unit
        /// <summary>Updates the poseControlled values based on the input device pose.</summary>
        /// <param name="poseData">Pose coming from the device</param>
        abstract updateFromDevice: poseData: DevicePose -> unit
        /// <summary>WebVR's attach control will start broadcasting frames to the device.
        /// Note that in certain browsers (chrome for example) this function must be called
        /// within a user-interaction callback. Example:
        /// <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre></summary>
        /// <param name="element">html element to attach the vrDevice to</param>
        /// <param name="noPreventDefault">prevent the default html element operation when attaching the vrDevice</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detaches the camera from the html element and disables VR</summary>
        /// <param name="element">html element to detach from</param>
        abstract detachControl: element: HTMLElement -> unit
        abstract getClassName: unit -> string
        /// Calls resetPose on the vrDisplay
        /// See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose
        abstract resetToCurrentRotation: unit -> unit
        abstract _updateRigCameras: unit -> unit
        /// <param name="ignoreParentClass">ignores updating the parent class's cache (default: false)</param>
        abstract _updateCache: ?ignoreParentClass: bool -> unit
        abstract _computeDevicePosition: unit -> unit
        /// Updates the current device position and rotation in the babylon world
        abstract update: unit -> unit
        abstract _getViewMatrix: unit -> Matrix
        /// This function is called by the two RIG cameras.
        /// 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)
        abstract _getWebVRViewMatrix: unit -> Matrix
        abstract _getWebVRProjectionMatrix: unit -> Matrix
        /// Initializes the controllers and their meshes
        abstract initControllers: unit -> unit

    /// This represents a WebVR camera.
    /// The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.
    type [<AllowNullLiteral>] WebVRFreeCameraStatic =
        /// <summary>Instantiates a WebVRFreeCamera.</summary>
        /// <param name="name">The name of the WebVRFreeCamera</param>
        /// <param name="position">The starting anchor position for the camera</param>
        /// <param name="scene">The scene the camera belongs to</param>
        /// <param name="webVROptions">a set of customizable options for the webVRCamera</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?webVROptions: WebVROptions -> WebVRFreeCamera

    type [<AllowNullLiteral>] _OcclusionDataStorage =
        abstract occlusionInternalRetryCounter: float with get, set
        abstract isOcclusionQueryInProgress: bool with get, set
        abstract isOccluded: bool with get, set
        abstract occlusionRetryCount: float with get, set
        abstract occlusionType: float with get, set
        abstract occlusionQueryAlgorithmType: float with get, set

    type [<AllowNullLiteral>] _OcclusionDataStorageStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> _OcclusionDataStorage

    /// Contains an array of blocks representing the octree
    type [<AllowNullLiteral>] IOctreeContainer<'T> =
        /// Blocks within the octree
        abstract blocks: Array<OctreeBlock<'T>> with get, set

    /// Octrees are a really powerful data structure that can quickly select entities based on space coordinates.
    type [<AllowNullLiteral>] Octree<'T> =
        /// Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.) 
        abstract maxDepth: float with get, set
        /// Blocks within the octree containing objects
        abstract blocks: Array<OctreeBlock<'T>> with get, set
        /// Content stored in the octree
        abstract dynamicContent: ResizeArray<'T> with get, set
        /// <summary>Updates the octree by adding blocks for the passed in meshes within the min and max world parameters</summary>
        /// <param name="worldMin">worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);</param>
        /// <param name="worldMax">worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);</param>
        /// <param name="entries">meshes to be added to the octree blocks</param>
        abstract update: worldMin: Vector3 * worldMax: Vector3 * entries: ResizeArray<'T> -> unit
        /// <summary>Adds a mesh to the octree</summary>
        /// <param name="entry">Mesh to add to the octree</param>
        abstract addMesh: entry: 'T -> unit
        /// <summary>Selects an array of meshes within the frustum</summary>
        /// <param name="frustumPlanes">The frustum planes to use which will select all meshes within it</param>
        /// <param name="allowDuplicate">If duplicate objects are allowed in the resulting object array</param>
        abstract select: frustumPlanes: ResizeArray<Plane> * ?allowDuplicate: bool -> SmartArray<'T>
        /// <summary>Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array</summary>
        /// <param name="sphereCenter">defines the bounding sphere center</param>
        /// <param name="sphereRadius">defines the bounding sphere radius</param>
        /// <param name="allowDuplicate">defines if the selection array can contains duplicated entries</param>
        abstract intersects: sphereCenter: Vector3 * sphereRadius: float * ?allowDuplicate: bool -> SmartArray<'T>
        /// <summary>Test if the octree intersect with the given ray and if yes, then add its content to resulting array
        ///  </summary>
        /// <param name="ray">defines the ray to test with</param>
        abstract intersectsRay: ray: Ray -> SmartArray<'T>

    /// Octrees are a really powerful data structure that can quickly select entities based on space coordinates.
    type [<AllowNullLiteral>] OctreeStatic =
        /// <summary>Creates a octree</summary>
        /// <param name="creationFunc">function to be used to instatiate the octree</param>
        /// <param name="maxBlockCapacity">defines the maximum number of meshes you want on your octree's leaves (default: 64)</param>
        /// <param name="maxDepth">defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)</param>
        [<Emit "new $0($1...)">] abstract Create: creationFunc: ('T -> OctreeBlock<'T> -> unit) * ?maxBlockCapacity: float * ?maxDepth: float -> Octree<'T>
        abstract _CreateBlocks: worldMin: Vector3 * worldMax: Vector3 * entries: ResizeArray<'T> * maxBlockCapacity: float * currentDepth: float * maxDepth: float * target: IOctreeContainer<'T> * creationFunc: ('T -> OctreeBlock<'T> -> unit) -> unit
        /// Adds a mesh into the octree block if it intersects the block
        abstract CreationFuncForMeshes: (AbstractMesh -> OctreeBlock<AbstractMesh> -> unit) with get, set
        /// Adds a submesh into the octree block if it intersects the block
        abstract CreationFuncForSubMeshes: (SubMesh -> OctreeBlock<SubMesh> -> unit) with get, set

    /// Class used to store a cell in an octree
    type [<AllowNullLiteral>] OctreeBlock<'T> =
        /// Gets the content of the current block
        abstract entries: ResizeArray<'T> with get, set
        /// Gets the list of block children
        abstract blocks: Array<OctreeBlock<'T>> with get, set
        /// Gets the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)
        abstract capacity: float
        /// Gets the minimum vector (in world space) of the block's bounding box
        abstract minPoint: Vector3
        /// Gets the maximum vector (in world space) of the block's bounding box
        abstract maxPoint: Vector3
        /// <summary>Add a new element to this block</summary>
        /// <param name="entry">defines the element to add</param>
        abstract addEntry: entry: 'T -> unit
        /// <summary>Add an array of elements to this block</summary>
        /// <param name="entries">defines the array of elements to add</param>
        abstract addEntries: entries: ResizeArray<'T> -> unit
        /// <summary>Test if the current block intersects the furstum planes and if yes, then add its content to the selection array</summary>
        /// <param name="frustumPlanes">defines the frustum planes to test</param>
        /// <param name="selection">defines the array to store current content if selection is positive</param>
        /// <param name="allowDuplicate">defines if the selection array can contains duplicated entries</param>
        abstract select: frustumPlanes: ResizeArray<Plane> * selection: SmartArrayNoDuplicate<'T> * ?allowDuplicate: bool -> unit
        /// <summary>Test if the current block intersect with the given bounding sphere and if yes, then add its content to the selection array</summary>
        /// <param name="sphereCenter">defines the bounding sphere center</param>
        /// <param name="sphereRadius">defines the bounding sphere radius</param>
        /// <param name="selection">defines the array to store current content if selection is positive</param>
        /// <param name="allowDuplicate">defines if the selection array can contains duplicated entries</param>
        abstract intersects: sphereCenter: Vector3 * sphereRadius: float * selection: SmartArrayNoDuplicate<'T> * ?allowDuplicate: bool -> unit
        /// <summary>Test if the current block intersect with the given ray and if yes, then add its content to the selection array</summary>
        /// <param name="ray">defines the ray to test with</param>
        /// <param name="selection">defines the array to store current content if selection is positive</param>
        abstract intersectsRay: ray: Ray * selection: SmartArrayNoDuplicate<'T> -> unit
        /// Subdivide the content into child blocks (this block will then be empty)
        abstract createInnerBlocks: unit -> unit

    /// Class used to store a cell in an octree
    type [<AllowNullLiteral>] OctreeBlockStatic =
        /// <summary>Creates a new block</summary>
        /// <param name="minPoint">defines the minimum vector (in world space) of the block's bounding box</param>
        /// <param name="maxPoint">defines the maximum vector (in world space) of the block's bounding box</param>
        /// <param name="capacity">defines the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)</param>
        /// <param name="depth">defines the current depth of this block in the octree</param>
        /// <param name="maxDepth">defines the maximal depth allowed (beyond this value, the capacity is ignored)</param>
        /// <param name="creationFunc">defines a callback to call when an element is added to the block</param>
        [<Emit "new $0($1...)">] abstract Create: minPoint: Vector3 * maxPoint: Vector3 * capacity: float * depth: float * maxDepth: float * creationFunc: ('T -> OctreeBlock<'T> -> unit) -> OctreeBlock<'T>

    /// Defines the octree scene component responsible to manage any octrees
    /// in a given scene.
    type [<AllowNullLiteral>] OctreeSceneComponent =
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Indicates if the meshes have been checked to make sure they are isEnabled()
        abstract checksIsEnabled: bool
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Return the list of active meshes
        abstract getActiveMeshCandidates: unit -> ISmartArrayLike<AbstractMesh>
        /// <summary>Return the list of active sub meshes</summary>
        /// <param name="mesh">The mesh to get the candidates sub meshes from</param>
        abstract getActiveSubMeshCandidates: mesh: AbstractMesh -> ISmartArrayLike<SubMesh>
        /// <summary>Return the list of sub meshes intersecting with a given local ray</summary>
        /// <param name="mesh">defines the mesh to find the submesh for</param>
        /// <param name="localRay">defines the ray in local space</param>
        abstract getIntersectingSubMeshCandidates: mesh: AbstractMesh * localRay: Ray -> ISmartArrayLike<SubMesh>
        /// <summary>Return the list of sub meshes colliding with a collider</summary>
        /// <param name="mesh">defines the mesh to find the submesh for</param>
        /// <param name="collider">defines the collider to evaluate the collision against</param>
        abstract getCollidingSubMeshCandidates: mesh: AbstractMesh * collider: Collider -> ISmartArrayLike<SubMesh>
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources.
        abstract dispose: unit -> unit

    /// Defines the octree scene component responsible to manage any octrees
    /// in a given scene.
    type [<AllowNullLiteral>] OctreeSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> OctreeSceneComponent

    /// Google Daydream controller
    type [<AllowNullLiteral>] DaydreamController =
        inherit WebVRController
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// <summary>Called once for each button that changed state since the last frame</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit

    /// Google Daydream controller
    type [<AllowNullLiteral>] DaydreamControllerStatic =
        /// Base Url for the controller model.
        abstract MODEL_BASE_URL: string with get, set
        /// File name for the controller model.
        abstract MODEL_FILENAME: string with get, set
        /// Gamepad Id prefix used to identify Daydream Controller.
        abstract GAMEPAD_ID_PREFIX: string
        /// <summary>Creates a new DaydreamController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> DaydreamController

    /// Gear VR Controller
    type [<AllowNullLiteral>] GearVRController =
        inherit WebVRController
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// <summary>Called once for each button that changed state since the last frame</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit

    /// Gear VR Controller
    type [<AllowNullLiteral>] GearVRControllerStatic =
        /// Base Url for the controller model.
        abstract MODEL_BASE_URL: string with get, set
        /// File name for the controller model.
        abstract MODEL_FILENAME: string with get, set
        /// Gamepad Id prefix used to identify this controller.
        abstract GAMEPAD_ID_PREFIX: string
        /// <summary>Creates a new GearVRController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> GearVRController

    /// Generic Controller
    type [<AllowNullLiteral>] GenericController =
        inherit WebVRController
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// <summary>Called once for each button that changed state since the last frame</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit

    /// Generic Controller
    type [<AllowNullLiteral>] GenericControllerStatic =
        /// Base Url for the controller model.
        abstract MODEL_BASE_URL: string
        /// File name for the controller model.
        abstract MODEL_FILENAME: string
        /// <summary>Creates a new GenericController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> GenericController

    /// Oculus Touch Controller
    type [<AllowNullLiteral>] OculusTouchController =
        inherit WebVRController
        /// Fired when the secondary trigger on this controller is modified
        abstract onSecondaryTriggerStateChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when the thumb rest on this controller is modified
        abstract onThumbRestChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// Fired when the A button on this controller is modified
        abstract onAButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the B button on this controller is modified
        abstract onBButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the X button on this controller is modified
        abstract onXButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the Y button on this controller is modified
        abstract onYButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// <summary>Called once for each button that changed state since the last frame
        /// 0) thumb stick (touch, press, value = pressed (0,1)). value is in this.leftStick
        /// 1) index trigger (touch (?), press (only when value > 0.1), value 0 to 1)
        /// 2) secondary trigger (same)
        /// 3) A (right) X (left), touch, pressed = value
        /// 4) B / Y
        /// 5) thumb rest</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit

    /// Oculus Touch Controller
    type [<AllowNullLiteral>] OculusTouchControllerStatic =
        /// Base Url for the controller model.
        abstract MODEL_BASE_URL: string with get, set
        /// File name for the left controller model.
        abstract MODEL_LEFT_FILENAME: string with get, set
        /// File name for the right controller model.
        abstract MODEL_RIGHT_FILENAME: string with get, set
        /// <summary>Creates a new OculusTouchController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> OculusTouchController

    type [<RequireQualifiedAccess>] PoseEnabledControllerType =
        | VIVE = 0
        | OCULUS = 1
        | WINDOWS = 2
        | GEAR_VR = 3
        | DAYDREAM = 4
        | GENERIC = 5

    /// Defines the MutableGamepadButton interface for the state of a gamepad button
    type [<AllowNullLiteral>] MutableGamepadButton =
        /// Value of the button/trigger
        abstract value: float with get, set
        /// If the button/trigger is currently touched
        abstract touched: bool with get, set
        /// If the button/trigger is currently pressed
        abstract pressed: bool with get, set

    /// Defines the ExtendedGamepadButton interface for a gamepad button which includes state provided by a pose controller
    type [<AllowNullLiteral>] ExtendedGamepadButton =
        inherit GamepadButton
        /// If the button/trigger is currently pressed
        abstract pressed: bool
        /// If the button/trigger is currently touched
        abstract touched: bool
        /// Value of the button/trigger
        abstract value: float

    /// Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
    type [<AllowNullLiteral>] PoseEnabledControllerHelper =
        interface end

    /// Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
    type [<AllowNullLiteral>] PoseEnabledControllerHelperStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PoseEnabledControllerHelper
        /// <summary>Initializes a gamepad as the controller type it is specified as (eg. windows mixed reality controller)</summary>
        /// <param name="vrGamepad">the gamepad to initialized</param>
        abstract InitiateController: vrGamepad: obj option -> U6<OculusTouchController, WindowsMotionController, ViveController, GearVRController, DaydreamController, GenericController>

    /// Defines the PoseEnabledController object that contains state of a vr capable controller
    type [<AllowNullLiteral>] PoseEnabledController =
        inherit Gamepad
        inherit PoseControlled
        /// The device position in babylon space
        abstract devicePosition: Vector3 with get, set
        /// The device rotation in babylon space
        abstract deviceRotationQuaternion: Quaternion with get, set
        /// The scale factor of the device in babylon space
        abstract deviceScaleFactor: float with get, set
        /// (Likely devicePosition should be used instead) The device position in its room space
        abstract position: Vector3 with get, set
        /// (Likely deviceRotationQuaternion should be used instead) The device rotation in its room space
        abstract rotationQuaternion: Quaternion with get, set
        /// The type of controller (Eg. Windows mixed reality)
        abstract controllerType: PoseEnabledControllerType with get, set
        abstract _calculatedPosition: Vector3 with get, set
        /// The raw pose from the device
        abstract rawPose: DevicePose with get, set
        abstract _disableTrackPosition: fixedPosition: Vector3 -> unit
        /// Internal, the mesh attached to the controller
        abstract _mesh: Nullable<AbstractMesh> with get, set
        /// Internal, matrix used to convert room space to babylon space
        abstract _deviceToWorld: Matrix with get, set
        /// Node to be used when casting a ray from the controller
        abstract _pointingPoseNode: Nullable<AbstractMesh> with get, set
        /// Updates the state of the pose enbaled controller and mesh based on the current position and rotation of the controller
        abstract update: unit -> unit
        /// Updates only the pose device and mesh without doing any button event checking
        abstract _updatePoseAndMesh: unit -> unit
        /// <summary>Updates the state of the pose enbaled controller based on the raw pose data from the device</summary>
        /// <param name="poseData">raw pose fromthe device</param>
        abstract updateFromDevice: poseData: DevicePose -> unit
        abstract _meshAttachedObservable: Observable<AbstractMesh> with get, set
        /// <summary>Attaches a mesh to the controller</summary>
        /// <param name="mesh">the mesh to be attached</param>
        abstract attachToMesh: mesh: AbstractMesh -> unit
        /// <summary>Attaches the controllers mesh to a camera</summary>
        /// <param name="camera">the camera the mesh should be attached to</param>
        abstract attachToPoseControlledCamera: camera: TargetCamera -> unit
        /// Disposes of the controller
        abstract dispose: unit -> unit
        /// The mesh that is attached to the controller
        abstract mesh: Nullable<AbstractMesh>
        /// <summary>Gets the ray of the controller in the direction the controller is pointing</summary>
        /// <param name="length">the length the resulting ray should be</param>
        abstract getForwardRay: ?length: float -> Ray

    /// Defines the PoseEnabledController object that contains state of a vr capable controller
    type [<AllowNullLiteral>] PoseEnabledControllerStatic =
        /// Name of the child mesh that can be used to cast a ray from the controller
        abstract POINTING_POSE: string
        /// <summary>Creates a new PoseEnabledController from a gamepad</summary>
        /// <param name="browserGamepad">the gamepad that the PoseEnabledController should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: browserGamepad: obj option -> PoseEnabledController

    /// Vive Controller
    type [<AllowNullLiteral>] ViveController =
        inherit WebVRController
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// Fired when the left button on this controller is modified
        abstract onLeftButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the right button on this controller is modified
        abstract onRightButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the menu button on this controller is modified
        abstract onMenuButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// <summary>Called once for each button that changed state since the last frame
        /// Vive mapping:
        /// 0: touchpad
        /// 1: trigger
        /// 2: left AND right buttons
        /// 3: menu button</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit

    /// Vive Controller
    type [<AllowNullLiteral>] ViveControllerStatic =
        /// Base Url for the controller model.
        abstract MODEL_BASE_URL: string with get, set
        /// File name for the controller model.
        abstract MODEL_FILENAME: string with get, set
        /// <summary>Creates a new ViveController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> ViveController

    /// Defines the WebVRController object that represents controllers tracked in 3D space
    type [<AllowNullLiteral>] WebVRController =
        inherit PoseEnabledController
        /// Internal, the default controller model for the controller
        abstract _defaultModel: AbstractMesh with get, set
        /// Fired when the trigger state has changed
        abstract onTriggerStateChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when the main button state has changed
        abstract onMainButtonStateChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when the secondary button state has changed
        abstract onSecondaryButtonStateChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when the pad state has changed
        abstract onPadStateChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when controllers stick values have changed
        abstract onPadValuesChangedObservable: Observable<StickValues> with get, set
        /// Array of button availible on the controller
        abstract _buttons: Array<MutableGamepadButton> with get, set
        /// <summary>Fired when a controller button's state has changed</summary>
        /// <param name="callback">the callback containing the button that was modified</param>
        abstract onButtonStateChange: callback: (float -> float -> ExtendedGamepadButton -> unit) -> unit
        /// X and Y axis corrisponding to the controllers joystick
        abstract pad: StickValues with get, set
        /// 'left' or 'right', see https://w3c.github.io/gamepad/extensions.html#gamepadhand-enum
        abstract hand: string with get, set
        /// The default controller model for the controller
        abstract defaultModel: AbstractMesh
        /// Updates the state of the controller and mesh based on the current position and rotation of the controller
        abstract update: unit -> unit
        /// Function to be called when a button is modified
        abstract _handleButtonChange: buttonIdx: float * value: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit
        /// <summary>Loads a mesh and attaches it to the controller</summary>
        /// <param name="scene">the scene the mesh should be added to</param>
        /// <param name="meshLoaded">callback for when the mesh has been loaded</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// Disposes of th webVRCOntroller
        abstract dispose: unit -> unit

    /// Defines the WebVRController object that represents controllers tracked in 3D space
    type [<AllowNullLiteral>] WebVRControllerStatic =
        /// <summary>Creates a new WebVRController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the WebVRController should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> WebVRController

    /// Defines the WindowsMotionController object that the state of the windows motion controller
    type [<AllowNullLiteral>] WindowsMotionController =
        inherit WebVRController
        /// Fired when the trackpad on this controller is clicked
        abstract onTrackpadChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when the trackpad on this controller is modified
        abstract onTrackpadValuesChangedObservable: Observable<StickValues> with get, set
        /// The current x and y values of this controller's trackpad
        abstract trackpad: StickValues with get, set
        /// Fired when the trigger on this controller is modified
        abstract onTriggerButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the menu button on this controller is modified
        abstract onMenuButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the grip button on this controller is modified
        abstract onGripButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the thumbstick button on this controller is modified
        abstract onThumbstickButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the touchpad button on this controller is modified
        abstract onTouchpadButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the touchpad values on this controller are modified
        abstract onTouchpadValuesChangedObservable: Observable<StickValues>
        /// Called once per frame by the engine.
        abstract update: unit -> unit
        /// <summary>Called once for each button that changed state since the last frame</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit
        /// <summary>Moves the buttons on the controller mesh based on their current state</summary>
        /// <param name="buttonName">the name of the button to move</param>
        /// <param name="buttonValue">the value of the button which determines the buttons new position</param>
        abstract _lerpButtonTransform: buttonName: string * buttonValue: float -> unit
        /// <summary>Moves the axis on the controller mesh based on its current state</summary>
        /// <param name="axis">the index of the axis</param>
        /// <param name="axisValue">the value of the axis which determines the meshes new position</param>
        abstract _lerpAxisTransform: axis: float * axisValue: float -> unit
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) * ?forceDefault: bool -> unit
        /// <summary>Gets the ray of the controller in the direction the controller is pointing</summary>
        /// <param name="length">the length the resulting ray should be</param>
        abstract getForwardRay: ?length: float -> Ray
        /// Disposes of the controller
        abstract dispose: unit -> unit

    /// Defines the WindowsMotionController object that the state of the windows motion controller
    type [<AllowNullLiteral>] WindowsMotionControllerStatic =
        /// The base url used to load the left and right controller models
        abstract MODEL_BASE_URL: string with get, set
        /// The name of the left controller model file
        abstract MODEL_LEFT_FILENAME: string with get, set
        /// The name of the right controller model file
        abstract MODEL_RIGHT_FILENAME: string with get, set
        /// The controller name prefix for this controller type
        abstract GAMEPAD_ID_PREFIX: string
        /// <summary>Creates a new WindowsMotionController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> WindowsMotionController

    /// Interface to implement to create a shadow generator compatible with BJS.
    type [<AllowNullLiteral>] IShadowGenerator =
        /// Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
        abstract getShadowMap: unit -> Nullable<RenderTargetTexture>
        /// Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
        abstract getShadowMapForRendering: unit -> Nullable<RenderTargetTexture>
        /// <summary>Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).</summary>
        /// <param name="subMesh">The submesh we want to render in the shadow map</param>
        /// <param name="useInstances">Defines wether will draw in the map using instances</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// <summary>Prepare all the defines in a material relying on a shadow map at the specified light index.</summary>
        /// <param name="defines">Defines of the material we want to update</param>
        /// <param name="lightIndex">Index of the light in the enabled light list of the material</param>
        abstract prepareDefines: defines: MaterialDefines * lightIndex: float -> unit
        /// <summary>Binds the shadow related information inside of an effect (information like near, far, darkness...
        /// defined in the generator but impacting the effect).
        /// It implies the unifroms available on the materials are the standard BJS ones.</summary>
        /// <param name="lightIndex">Index of the light in the enabled light list of the material owning the effect</param>
        /// <param name="effect">The effect we are binfing the information for</param>
        abstract bindShadowLight: lightIndex: string * effect: Effect -> unit
        /// Gets the transformation matrix used to project the meshes into the map from the light point of view.
        /// (eq to shadow prjection matrix * light transform matrix)
        abstract getTransformMatrix: unit -> Matrix
        /// Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
        /// Cube and 2D textures for instance.
        abstract recreateShadowMap: unit -> unit
        /// <summary>Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.</summary>
        /// <param name="onCompiled">Callback triggered at the and of the effects compilation</param>
        /// <param name="options">Sets of optional options forcing the compilation with different modes</param>
        abstract forceCompilation: ?onCompiled: (ShadowGenerator -> unit) * ?options: obj -> unit
        /// <summary>Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.</summary>
        /// <param name="options">Sets of optional options forcing the compilation with different modes</param>
        abstract forceCompilationAsync: ?options: obj -> Promise<unit>
        /// Serializes the shadow generator setup to a json object.
        abstract serialize: unit -> obj option
        /// Disposes the Shadow map and related Textures and effects.
        abstract dispose: unit -> unit

    /// Default implementation IShadowGenerator.
    /// This is the main object responsible of generating shadows in the framework.
    /// Documentation: https://doc.babylonjs.com/babylon101/shadows
    type [<AllowNullLiteral>] ShadowGenerator =
        inherit IShadowGenerator
        /// Gets the bias: offset applied on the depth preventing acnea (in light direction).
        /// Sets the bias: offset applied on the depth preventing acnea (in light direction).
        abstract bias: float with get, set
        /// Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
        /// Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
        abstract normalBias: float with get, set
        /// Gets the blur box offset: offset applied during the blur pass.
        /// Only usefull if useKernelBlur = false
        /// Sets the blur box offset: offset applied during the blur pass.
        /// Only usefull if useKernelBlur = false
        abstract blurBoxOffset: float with get, set
        /// Gets the blur scale: scale of the blurred texture compared to the main shadow map.
        /// 2 means half of the size.
        /// Sets the blur scale: scale of the blurred texture compared to the main shadow map.
        /// 2 means half of the size.
        abstract blurScale: float with get, set
        /// Gets the blur kernel: kernel size of the blur pass.
        /// Only usefull if useKernelBlur = true
        /// Sets the blur kernel: kernel size of the blur pass.
        /// Only usefull if useKernelBlur = true
        abstract blurKernel: float with get, set
        /// Gets whether the blur pass is a kernel blur (if true) or box blur.
        /// Only usefull in filtered mode (useBlurExponentialShadowMap...)
        /// Sets whether the blur pass is a kernel blur (if true) or box blur.
        /// Only usefull in filtered mode (useBlurExponentialShadowMap...)
        abstract useKernelBlur: bool with get, set
        /// Gets the depth scale used in ESM mode.
        /// Sets the depth scale used in ESM mode.
        /// This can override the scale stored on the light.
        abstract depthScale: float with get, set
        /// Gets the current mode of the shadow generator (normal, PCF, ESM...).
        /// The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
        /// Sets the current mode of the shadow generator (normal, PCF, ESM...).
        /// The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
        abstract filter: float with get, set
        /// Gets if the current filter is set to Poisson Sampling.
        /// Sets the current filter to Poisson Sampling.
        abstract usePoissonSampling: bool with get, set
        /// Gets if the current filter is set to VSM.
        /// DEPRECATED. Should use useExponentialShadowMap instead.
        /// Sets the current filter is to VSM.
        /// DEPRECATED. Should use useExponentialShadowMap instead.
        abstract useVarianceShadowMap: bool with get, set
        /// Gets if the current filter is set to blurred VSM.
        /// DEPRECATED. Should use useBlurExponentialShadowMap instead.
        /// Sets the current filter is to blurred VSM.
        /// DEPRECATED. Should use useBlurExponentialShadowMap instead.
        abstract useBlurVarianceShadowMap: bool with get, set
        /// Gets if the current filter is set to ESM.
        /// Sets the current filter is to ESM.
        abstract useExponentialShadowMap: bool with get, set
        /// Gets if the current filter is set to filtered ESM.
        /// Gets if the current filter is set to filtered  ESM.
        abstract useBlurExponentialShadowMap: bool with get, set
        /// Gets if the current filter is set to "close ESM" (using the inverse of the
        /// exponential to prevent steep falloff artifacts).
        /// Sets the current filter to "close ESM" (using the inverse of the
        /// exponential to prevent steep falloff artifacts).
        abstract useCloseExponentialShadowMap: bool with get, set
        /// Gets if the current filter is set to filtered "close ESM" (using the inverse of the
        /// exponential to prevent steep falloff artifacts).
        /// Sets the current filter to filtered "close ESM" (using the inverse of the
        /// exponential to prevent steep falloff artifacts).
        abstract useBlurCloseExponentialShadowMap: bool with get, set
        /// Gets if the current filter is set to "PCF" (percentage closer filtering).
        /// Sets the current filter to "PCF" (percentage closer filtering).
        abstract usePercentageCloserFiltering: bool with get, set
        /// Gets the PCF or PCSS Quality.
        /// Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
        /// Sets the PCF or PCSS Quality.
        /// Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
        abstract filteringQuality: float with get, set
        /// Gets if the current filter is set to "PCSS" (contact hardening).
        /// Sets the current filter to "PCSS" (contact hardening).
        abstract useContactHardeningShadow: bool with get, set
        /// Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
        /// Using a ratio helps keeping shape stability independently of the map size.
        /// 
        /// It does not account for the light projection as it was having too much
        /// instability during the light setup or during light position changes.
        /// 
        /// Only valid if useContactHardeningShadow is true.
        /// Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
        /// Using a ratio helps keeping shape stability independently of the map size.
        /// 
        /// It does not account for the light projection as it was having too much
        /// instability during the light setup or during light position changes.
        /// 
        /// Only valid if useContactHardeningShadow is true.
        abstract contactHardeningLightSizeUVRatio: float with get, set
        /// Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
        /// 0 means strongest and 1 would means no shadow.
        abstract getDarkness: unit -> float
        /// <summary>Sets the darkness value (float). This can only decrease the actual darkness of a shadow.</summary>
        /// <param name="darkness">The darkness value 0 means strongest and 1 would means no shadow.</param>
        abstract setDarkness: darkness: float -> ShadowGenerator
        /// <summary>Sets the ability to have transparent shadow (boolean).</summary>
        /// <param name="transparent">True if transparent else False</param>
        abstract setTransparencyShadow: transparent: bool -> ShadowGenerator
        /// Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
        abstract getShadowMap: unit -> Nullable<RenderTargetTexture>
        /// Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
        abstract getShadowMapForRendering: unit -> Nullable<RenderTargetTexture>
        /// <summary>Helper function to add a mesh and its descendants to the list of shadow casters.</summary>
        /// <param name="mesh">Mesh to add</param>
        /// <param name="includeDescendants">boolean indicating if the descendants should be added. Default to true</param>
        abstract addShadowCaster: mesh: AbstractMesh * ?includeDescendants: bool -> ShadowGenerator
        /// <summary>Helper function to remove a mesh and its descendants from the list of shadow casters</summary>
        /// <param name="mesh">Mesh to remove</param>
        /// <param name="includeDescendants">boolean indicating if the descendants should be removed. Default to true</param>
        abstract removeShadowCaster: mesh: AbstractMesh * ?includeDescendants: bool -> ShadowGenerator
        /// Controls the extent to which the shadows fade out at the edge of the frustum
        /// Used only by directionals and spots
        abstract frustumEdgeFalloff: float with get, set
        /// Returns the associated light object.
        abstract getLight: unit -> IShadowLight
        /// If true the shadow map is generated by rendering the back face of the mesh instead of the front face.
        /// This can help with self-shadowing as the geometry making up the back of objects is slightly offset.
        /// It might on the other hand introduce peter panning.
        abstract forceBackFacesOnly: bool with get, set
        /// <summary>Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.</summary>
        /// <param name="onCompiled">Callback triggered at the and of the effects compilation</param>
        /// <param name="options">Sets of optional options forcing the compilation with different modes</param>
        abstract forceCompilation: ?onCompiled: (ShadowGenerator -> unit) * ?options: obj -> unit
        /// <summary>Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.</summary>
        /// <param name="options">Sets of optional options forcing the compilation with different modes</param>
        abstract forceCompilationAsync: ?options: obj -> Promise<unit>
        /// <summary>Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).</summary>
        /// <param name="subMesh">The submesh we want to render in the shadow map</param>
        /// <param name="useInstances">Defines wether will draw in the map using instances</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// <summary>Prepare all the defines in a material relying on a shadow map at the specified light index.</summary>
        /// <param name="defines">Defines of the material we want to update</param>
        /// <param name="lightIndex">Index of the light in the enabled light list of the material</param>
        abstract prepareDefines: defines: obj option * lightIndex: float -> unit
        /// <summary>Binds the shadow related information inside of an effect (information like near, far, darkness...
        /// defined in the generator but impacting the effect).</summary>
        /// <param name="lightIndex">Index of the light in the enabled light list of the material owning the effect</param>
        /// <param name="effect">The effect we are binfing the information for</param>
        abstract bindShadowLight: lightIndex: string * effect: Effect -> unit
        /// Gets the transformation matrix used to project the meshes into the map from the light point of view.
        /// (eq to shadow prjection matrix * light transform matrix)
        abstract getTransformMatrix: unit -> Matrix
        /// Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
        /// Cube and 2D textures for instance.
        abstract recreateShadowMap: unit -> unit
        /// Disposes the ShadowGenerator.
        /// Returns nothing.
        abstract dispose: unit -> unit
        /// Serializes the shadow generator setup to a json object.
        abstract serialize: unit -> obj option

    /// Default implementation IShadowGenerator.
    /// This is the main object responsible of generating shadows in the framework.
    /// Documentation: https://doc.babylonjs.com/babylon101/shadows
    type [<AllowNullLiteral>] ShadowGeneratorStatic =
        /// Shadow generator mode None: no filtering applied.
        abstract FILTER_NONE: float
        /// Shadow generator mode ESM: Exponential Shadow Mapping.
        /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
        abstract FILTER_EXPONENTIALSHADOWMAP: float
        /// Shadow generator mode Poisson Sampling: Percentage Closer Filtering.
        /// (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)
        abstract FILTER_POISSONSAMPLING: float
        /// Shadow generator mode ESM: Blurred Exponential Shadow Mapping.
        /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
        abstract FILTER_BLUREXPONENTIALSHADOWMAP: float
        /// Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing
        /// edge artifacts on steep falloff.
        /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
        abstract FILTER_CLOSEEXPONENTIALSHADOWMAP: float
        /// Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing
        /// edge artifacts on steep falloff.
        /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
        abstract FILTER_BLURCLOSEEXPONENTIALSHADOWMAP: float
        /// Shadow generator mode PCF: Percentage Closer Filtering
        /// benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
        /// (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)
        abstract FILTER_PCF: float
        /// Shadow generator mode PCSS: Percentage Closering Soft Shadow.
        /// benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
        /// Contact Hardening
        abstract FILTER_PCSS: float
        /// Reserved for PCF and PCSS
        /// Highest Quality.
        /// 
        /// Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.
        /// 
        /// Execute PCSS with 32 taps blocker search and 64 taps PCF.
        abstract QUALITY_HIGH: float
        /// Reserved for PCF and PCSS
        /// Good tradeoff for quality/perf cross devices
        /// 
        /// Execute PCF on a 3*3 kernel.
        /// 
        /// Execute PCSS with 16 taps blocker search and 32 taps PCF.
        abstract QUALITY_MEDIUM: float
        /// Reserved for PCF and PCSS
        /// The lowest quality but the fastest.
        /// 
        /// Execute PCF on a 1*1 kernel.
        /// 
        /// Execute PCSS with 16 taps blocker search and 16 taps PCF.
        abstract QUALITY_LOW: float
        /// <summary>Creates a ShadowGenerator object.
        /// A ShadowGenerator is the required tool to use the shadows.
        /// Each light casting shadows needs to use its own ShadowGenerator.
        /// Documentation : http://doc.babylonjs.com/tutorials/shadows</summary>
        /// <param name="mapSize">The size of the texture what stores the shadows. Example : 1024.</param>
        /// <param name="light">The light object generating the shadows.</param>
        /// <param name="useFullFloatFirst">By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.</param>
        [<Emit "new $0($1...)">] abstract Create: mapSize: float * light: IShadowLight * ?useFullFloatFirst: bool -> ShadowGenerator
        /// <summary>Parses a serialized ShadowGenerator and returns a new ShadowGenerator.</summary>
        /// <param name="parsedShadowGenerator">The JSON object to parse</param>
        /// <param name="scene">The scene to create the shadow map for</param>
        abstract Parse: parsedShadowGenerator: obj option * scene: Scene -> ShadowGenerator

    /// Defines the shadow generator component responsible to manage any shadow generators
    /// in a given scene.
    type [<AllowNullLiteral>] ShadowGeneratorSceneComponent =
        inherit ISceneSerializableComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// <summary>Serializes the component data to the specified json object</summary>
        /// <param name="serializationObject">The object to serialize to</param>
        abstract serialize: serializationObject: obj option -> unit
        /// <summary>Adds all the element from the container to the scene</summary>
        /// <param name="container">the container holding the elements</param>
        abstract addFromContainer: container: AbstractScene -> unit
        /// <summary>Removes all the elements in the container from the scene</summary>
        /// <param name="container">contains the elements to remove</param>
        abstract removeFromContainer: container: AbstractScene -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract dispose: unit -> unit

    /// Defines the shadow generator component responsible to manage any shadow generators
    /// in a given scene.
    type [<AllowNullLiteral>] ShadowGeneratorSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> ShadowGeneratorSceneComponent

    /// Background material used to create an efficient environement around your scene.
    type [<AllowNullLiteral>] BackgroundMaterial =
        inherit PushMaterial
        abstract _primaryColor: Color3 with get, set
        /// Key light Color (multiply against the environement texture)
        abstract primaryColor: Color3 with get, set
        abstract __perceptualColor: Nullable<Color3> with get, set
        /// Experimental Internal Use Only.
        /// 
        /// Key light Color in "perceptual value" meaning the color you would like to see on screen.
        /// This acts as a helper to set the primary color to a more "human friendly" value.
        /// Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the
        /// output color as close as possible from the chosen value.
        /// (This does not account for contrast color grading and color curves as they are considered post effect and not directly
        /// part of lighting setup.)
        abstract _perceptualColor: Nullable<Color3> with get, set
        abstract _primaryColorShadowLevel: float with get, set
        /// Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.
        /// The color opposite to the primary color is used at the level chosen to define what the black area would look.
        abstract primaryColorShadowLevel: float with get, set
        abstract _primaryColorHighlightLevel: float with get, set
        /// Defines the level of the highliights (highlight area of the reflection map) in order to help scaling the colors.
        /// The primary color is used at the level chosen to define what the white area would look.
        abstract primaryColorHighlightLevel: float with get, set
        abstract _reflectionTexture: Nullable<BaseTexture> with get, set
        /// Reflection Texture used in the material.
        /// Should be author in a specific way for the best result (refer to the documentation).
        abstract reflectionTexture: Nullable<BaseTexture> with get, set
        abstract _reflectionBlur: float with get, set
        /// Reflection Texture level of blur.
        /// 
        /// Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the
        /// texture twice.
        abstract reflectionBlur: float with get, set
        abstract _diffuseTexture: Nullable<BaseTexture> with get, set
        /// Diffuse Texture used in the material.
        /// Should be author in a specific way for the best result (refer to the documentation).
        abstract diffuseTexture: Nullable<BaseTexture> with get, set
        abstract _shadowLights: Nullable<ResizeArray<IShadowLight>> with get, set
        /// Specify the list of lights casting shadow on the material.
        /// All scene shadow lights will be included if null.
        abstract shadowLights: Nullable<ResizeArray<IShadowLight>> with get, set
        abstract _shadowLevel: float with get, set
        /// Helps adjusting the shadow to a softer level if required.
        /// 0 means black shadows and 1 means no shadows.
        abstract shadowLevel: float with get, set
        abstract _sceneCenter: Vector3 with get, set
        /// In case of opacity Fresnel or reflection falloff, this is use as a scene center.
        /// It is usually zero but might be interesting to modify according to your setup.
        abstract sceneCenter: Vector3 with get, set
        abstract _opacityFresnel: bool with get, set
        /// This helps specifying that the material is falling off to the sky box at grazing angle.
        /// This helps ensuring a nice transition when the camera goes under the ground.
        abstract opacityFresnel: bool with get, set
        abstract _reflectionFresnel: bool with get, set
        /// This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.
        /// This helps adding a mirror texture on the ground.
        abstract reflectionFresnel: bool with get, set
        abstract _reflectionFalloffDistance: float with get, set
        /// This helps specifying the falloff radius off the reflection texture from the sceneCenter.
        /// This helps adding a nice falloff effect to the reflection if used as a mirror for instance.
        abstract reflectionFalloffDistance: float with get, set
        abstract _reflectionAmount: float with get, set
        /// This specifies the weight of the reflection against the background in case of reflection Fresnel.
        abstract reflectionAmount: float with get, set
        abstract _reflectionReflectance0: float with get, set
        /// This specifies the weight of the reflection at grazing angle.
        abstract reflectionReflectance0: float with get, set
        abstract _reflectionReflectance90: float with get, set
        /// This specifies the weight of the reflection at a perpendicular point of view.
        abstract reflectionReflectance90: float with get, set
        /// Sets the reflection reflectance fresnel values according to the default standard
        /// empirically know to work well :-)
        abstract reflectionStandardFresnelWeight: float with get, set
        abstract _useRGBColor: bool with get, set
        /// Helps to directly use the maps channels instead of their level.
        abstract useRGBColor: bool with get, set
        abstract _enableNoise: bool with get, set
        /// This helps reducing the banding effect that could occur on the background.
        abstract enableNoise: bool with get, set
        /// The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
        /// Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.
        /// Recommended to be keep at 1.0 except for special cases.
        abstract fovMultiplier: float with get, set
        /// Enable the FOV adjustment feature controlled by fovMultiplier.
        abstract useEquirectangularFOV: bool with get, set
        /// Number of Simultaneous lights allowed on the material.
        abstract maxSimultaneousLights: int with get, set
        /// Default configuration related to image processing available in the Background Material.
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// <summary>Attaches a new image processing configuration to the PBR Material.</summary>
        /// <param name="configuration">(if null the scene configuration will be use)</param>
        abstract _attachImageProcessingConfiguration: configuration: Nullable<ImageProcessingConfiguration> -> unit
        /// Gets the image processing configuration used either in this material.
        /// Sets the Default image processing configuration used either in the this material.
        /// 
        /// If sets to null, the scene one is in use.
        abstract imageProcessingConfiguration: Nullable<ImageProcessingConfiguration> with get, set
        /// Gets wether the color curves effect is enabled.
        /// Sets wether the color curves effect is enabled.
        abstract cameraColorCurvesEnabled: bool with get, set
        /// Gets wether the color grading effect is enabled.
        /// Gets wether the color grading effect is enabled.
        abstract cameraColorGradingEnabled: bool with get, set
        /// Gets wether tonemapping is enabled or not.
        /// Sets wether tonemapping is enabled or not
        abstract cameraToneMappingEnabled: bool with get, set
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        abstract cameraExposure: float with get, set
        /// Gets The camera contrast used on this material.
        /// Sets The camera contrast used on this material.
        abstract cameraContrast: float with get, set
        /// Gets the Color Grading 2D Lookup Texture.
        /// Sets the Color Grading 2D Lookup Texture.
        abstract cameraColorGradingTexture: Nullable<BaseTexture> with get, set
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        abstract cameraColorCurves: Nullable<ColorCurves> with get, set
        /// Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.
        /// Setting this flag to true (not done automatically!) will convert it back to RGB.
        abstract switchToBGR: bool with get, set
        /// Gets a boolean indicating that current material needs to register RTT
        abstract hasRenderTargetTextures: bool
        /// The entire material has been created in order to prevent overdraw.
        abstract needAlphaTesting: unit -> bool
        /// The entire material has been created in order to prevent overdraw.
        abstract needAlphaBlending: unit -> bool
        /// <summary>Checks wether the material is ready to be rendered for a given mesh.</summary>
        /// <param name="mesh">The mesh to render</param>
        /// <param name="subMesh">The submesh to check against</param>
        /// <param name="useInstances">Specify wether or not the material is used with instances</param>
        abstract isReadyForSubMesh: mesh: AbstractMesh * subMesh: SubMesh * ?useInstances: bool -> bool
        /// Build the uniform buffer used in the material.
        abstract buildUniformLayout: unit -> unit
        /// Unbind the material.
        abstract unbind: unit -> unit
        /// <summary>Bind only the world matrix to the material.</summary>
        /// <param name="world">The world matrix to bind.</param>
        abstract bindOnlyWorldMatrix: world: Matrix -> unit
        /// <summary>Bind the material for a dedicated submeh (every used meshes will be considered opaque).</summary>
        /// <param name="world">The world matrix to bind.</param>
        /// <param name="subMesh">The submesh to bind for.</param>
        abstract bindForSubMesh: world: Matrix * mesh: Mesh * subMesh: SubMesh -> unit
        /// <summary>Dispose the material.</summary>
        /// <param name="forceDisposeEffect">Force disposal of the associated effect.</param>
        /// <param name="forceDisposeTextures">Force disposal of the associated textures.</param>
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit
        /// <summary>Clones the material.</summary>
        /// <param name="name">The cloned name.</param>
        abstract clone: name: string -> BackgroundMaterial
        /// Serializes the current material to its JSON representation.
        abstract serialize: unit -> obj option
        /// Gets the class name of the material
        abstract getClassName: unit -> string

    /// Background material used to create an efficient environement around your scene.
    type [<AllowNullLiteral>] BackgroundMaterialStatic =
        /// Standard reflectance value at parallel view angle.
        abstract StandardReflectance0: float with get, set
        /// Standard reflectance value at grazing angle.
        abstract StandardReflectance90: float with get, set
        /// <summary>Instantiates a Background Material in the given scene</summary>
        /// <param name="name">The friendly name of the material</param>
        /// <param name="scene">The scene to add the material to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> BackgroundMaterial
        /// <summary>Parse a JSON input to create back a background material.</summary>
        /// <param name="source">The JSON data to parse</param>
        /// <param name="scene">The scene to create the parsed material in</param>
        /// <param name="rootUrl">The root url of the assets the material depends upon</param>
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> BackgroundMaterial

    /// The Physically based material base class of BJS.
    /// 
    /// This offers the main features of a standard PBR material.
    /// For more information, please refer to the documentation :
    /// http://doc.babylonjs.com/extensions/Physically_Based_Rendering
    type [<AllowNullLiteral>] PBRBaseMaterial =
        inherit PushMaterial
        /// Intensity of the direct lights e.g. the four lights available in your scene.
        /// This impacts both the direct diffuse and specular highlights.
        abstract _directIntensity: float with get, set
        /// Intensity of the emissive part of the material.
        /// This helps controlling the emissive effect without modifying the emissive color.
        abstract _emissiveIntensity: float with get, set
        /// Intensity of the environment e.g. how much the environment will light the object
        /// either through harmonics for rough material or through the refelction for shiny ones.
        abstract _environmentIntensity: float with get, set
        /// This is a special control allowing the reduction of the specular highlights coming from the
        /// four lights of the scene. Those highlights may not be needed in full environment lighting.
        abstract _specularIntensity: float with get, set
        /// Debug Control allowing disabling the bump map on this material.
        abstract _disableBumpMap: bool with get, set
        /// AKA Diffuse Texture in standard nomenclature.
        abstract _albedoTexture: BaseTexture with get, set
        /// AKA Occlusion Texture in other nomenclature.
        abstract _ambientTexture: BaseTexture with get, set
        /// AKA Occlusion Texture Intensity in other nomenclature.
        abstract _ambientTextureStrength: float with get, set
        /// Defines how much the AO map is occluding the analytical lights (point spot...).
        /// 1 means it completely occludes it
        /// 0 mean it has no impact
        abstract _ambientTextureImpactOnAnalyticalLights: float with get, set
        /// Stores the alpha values in a texture.
        abstract _opacityTexture: BaseTexture with get, set
        /// Stores the reflection values in a texture.
        abstract _reflectionTexture: BaseTexture with get, set
        /// Stores the refraction values in a texture.
        abstract _refractionTexture: BaseTexture with get, set
        /// Stores the emissive values in a texture.
        abstract _emissiveTexture: BaseTexture with get, set
        /// AKA Specular texture in other nomenclature.
        abstract _reflectivityTexture: BaseTexture with get, set
        /// Used to switch from specular/glossiness to metallic/roughness workflow.
        abstract _metallicTexture: BaseTexture with get, set
        /// Specifies the metallic scalar of the metallic/roughness workflow.
        /// Can also be used to scale the metalness values of the metallic texture.
        abstract _metallic: Nullable<float> with get, set
        /// Specifies the roughness scalar of the metallic/roughness workflow.
        /// Can also be used to scale the roughness values of the metallic texture.
        abstract _roughness: Nullable<float> with get, set
        /// Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.
        /// Gray Scale represents roughness in metallic mode and glossiness in specular mode.
        abstract _microSurfaceTexture: BaseTexture with get, set
        /// Stores surface normal data used to displace a mesh in a texture.
        abstract _bumpTexture: BaseTexture with get, set
        /// Stores the pre-calculated light information of a mesh in a texture.
        abstract _lightmapTexture: BaseTexture with get, set
        /// The color of a material in ambient lighting.
        abstract _ambientColor: Color3 with get, set
        /// AKA Diffuse Color in other nomenclature.
        abstract _albedoColor: Color3 with get, set
        /// AKA Specular Color in other nomenclature.
        abstract _reflectivityColor: Color3 with get, set
        /// The color applied when light is reflected from a material.
        abstract _reflectionColor: Color3 with get, set
        /// The color applied when light is emitted from a material.
        abstract _emissiveColor: Color3 with get, set
        /// AKA Glossiness in other nomenclature.
        abstract _microSurface: float with get, set
        /// source material index of refraction (IOR)' / 'destination material IOR.
        abstract _indexOfRefraction: float with get, set
        /// Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.
        abstract _invertRefractionY: bool with get, set
        /// This parameters will make the material used its opacity to control how much it is refracting aginst not.
        /// Materials half opaque for instance using refraction could benefit from this control.
        abstract _linkRefractionWithTransparency: bool with get, set
        /// Specifies that the material will use the light map as a show map.
        abstract _useLightmapAsShadowmap: bool with get, set
        /// This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
        /// makes the reflect vector face the model (under horizon).
        abstract _useHorizonOcclusion: bool with get, set
        /// This parameters will enable/disable radiance occlusion by preventing the radiance to lit
        /// too much the area relying on ambient texture to define their ambient occlusion.
        abstract _useRadianceOcclusion: bool with get, set
        /// Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
        abstract _useAlphaFromAlbedoTexture: bool with get, set
        /// Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).
        /// A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
        abstract _useSpecularOverAlpha: bool with get, set
        /// Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
        abstract _useMicroSurfaceFromReflectivityMapAlpha: bool with get, set
        /// Specifies if the metallic texture contains the roughness information in its alpha channel.
        abstract _useRoughnessFromMetallicTextureAlpha: bool with get, set
        /// Specifies if the metallic texture contains the roughness information in its green channel.
        abstract _useRoughnessFromMetallicTextureGreen: bool with get, set
        /// Specifies if the metallic texture contains the metallness information in its blue channel.
        abstract _useMetallnessFromMetallicTextureBlue: bool with get, set
        /// Specifies if the metallic texture contains the ambient occlusion information in its red channel.
        abstract _useAmbientOcclusionFromMetallicTextureRed: bool with get, set
        /// Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
        abstract _useAmbientInGrayScale: bool with get, set
        /// In case the reflectivity map does not contain the microsurface information in its alpha channel,
        /// The material will try to infer what glossiness each pixel should be.
        abstract _useAutoMicroSurfaceFromReflectivityMap: bool with get, set
        /// Defines the  falloff type used in this material.
        /// It by default is Physical.
        abstract _lightFalloff: float with get, set
        /// Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
        /// A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
        abstract _useRadianceOverAlpha: bool with get, set
        /// Allows using an object space normal map (instead of tangent space).
        abstract _useObjectSpaceNormalMap: bool with get, set
        /// Allows using the bump map in parallax mode.
        abstract _useParallax: bool with get, set
        /// Allows using the bump map in parallax occlusion mode.
        abstract _useParallaxOcclusion: bool with get, set
        /// Controls the scale bias of the parallax mode.
        abstract _parallaxScaleBias: float with get, set
        /// If sets to true, disables all the lights affecting the material.
        abstract _disableLighting: bool with get, set
        /// Number of Simultaneous lights allowed on the material.
        abstract _maxSimultaneousLights: float with get, set
        /// If sets to true, x component of normal map value will be inverted (x = 1.0 - x).
        abstract _invertNormalMapX: bool with get, set
        /// If sets to true, y component of normal map value will be inverted (y = 1.0 - y).
        abstract _invertNormalMapY: bool with get, set
        /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
        abstract _twoSidedLighting: bool with get, set
        /// Defines the alpha limits in alpha test mode.
        abstract _alphaCutOff: float with get, set
        /// Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
        abstract _forceAlphaTest: bool with get, set
        /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
        /// And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
        abstract _useAlphaFresnel: bool with get, set
        /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
        /// And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
        abstract _useLinearAlphaFresnel: bool with get, set
        /// The transparency mode of the material.
        abstract _transparencyMode: Nullable<float> with get, set
        /// Specifies the environment BRDF texture used to comput the scale and offset roughness values
        /// from cos thetav and roughness:
        /// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
        abstract _environmentBRDFTexture: Nullable<BaseTexture> with get, set
        /// Force the shader to compute irradiance in the fragment shader in order to take bump in account.
        abstract _forceIrradianceInFragment: bool with get, set
        /// Force normal to face away from face.
        abstract _forceNormalForward: bool with get, set
        /// Enables specular anti aliasing in the PBR shader.
        /// It will both interacts on the Geometry for analytical and IBL lighting.
        /// It also prefilter the roughness map based on the bump values.
        abstract _enableSpecularAntiAliasing: bool with get, set
        /// Default configuration related to image processing available in the PBR Material.
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// <summary>Attaches a new image processing configuration to the PBR Material.</summary>
        /// <param name="configuration"></param>
        abstract _attachImageProcessingConfiguration: configuration: Nullable<ImageProcessingConfiguration> -> unit
        /// Gets a boolean indicating that current material needs to register RTT
        abstract hasRenderTargetTextures: bool
        /// Gets the name of the material class.
        abstract getClassName: unit -> string
        /// Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
        /// Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
        abstract useLogarithmicDepth: bool with get, set
        /// Gets the current transparency mode.
        /// Sets the transparency mode of the material.
        /// 
        /// | Value | Type                                | Description |
        /// | ----- | ----------------------------------- | ----------- |
        /// | 0     | OPAQUE                              |             |
        /// | 1     | ALPHATEST                           |             |
        /// | 2     | ALPHABLEND                          |             |
        /// | 3     | ALPHATESTANDBLEND                   |             |
        abstract transparencyMode: Nullable<float> with get, set
        /// Specifies whether or not this material should be rendered in alpha blend mode.
        abstract needAlphaBlending: unit -> bool
        /// <summary>Specifies if the mesh will require alpha blending.</summary>
        /// <param name="mesh">- BJS mesh.</param>
        abstract needAlphaBlendingForMesh: mesh: AbstractMesh -> bool
        /// Specifies whether or not this material should be rendered in alpha test mode.
        abstract needAlphaTesting: unit -> bool
        /// Specifies whether or not the alpha value of the albedo texture should be used for alpha blending.
        abstract _shouldUseAlphaFromAlbedoTexture: unit -> bool
        /// Gets the texture used for the alpha test.
        abstract getAlphaTestTexture: unit -> BaseTexture
        /// <summary>Specifies that the submesh is ready to be used.</summary>
        /// <param name="mesh">- BJS mesh.</param>
        /// <param name="subMesh">- A submesh of the BJS mesh.  Used to check if it is ready.</param>
        /// <param name="useInstances">- Specifies that instances should be used.</param>
        abstract isReadyForSubMesh: mesh: AbstractMesh * subMesh: SubMesh * ?useInstances: bool -> bool
        /// Specifies if the material uses metallic roughness workflow.
        abstract isMetallicWorkflow: unit -> bool
        /// Force shader compilation
        abstract forceCompilation: mesh: AbstractMesh * ?onCompiled: (Material -> unit) * ?options: obj -> unit
        /// Initializes the uniform buffer layout for the shader.
        abstract buildUniformLayout: unit -> unit
        /// Unbinds the textures.
        abstract unbind: unit -> unit
        /// <summary>Binds the submesh data.</summary>
        /// <param name="world">- The world matrix.</param>
        /// <param name="mesh">- The BJS mesh.</param>
        /// <param name="subMesh">- A submesh of the BJS mesh.</param>
        abstract bindForSubMesh: world: Matrix * mesh: Mesh * subMesh: SubMesh -> unit
        /// Returns the animatable textures.
        abstract getAnimatables: unit -> ResizeArray<IAnimatable>
        /// <summary>Disposes the resources of the material.</summary>
        /// <param name="forceDisposeEffect">- Forces the disposal of effects.</param>
        /// <param name="forceDisposeTextures">- Forces the disposal of all textures.</param>
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit

    /// The Physically based material base class of BJS.
    /// 
    /// This offers the main features of a standard PBR material.
    /// For more information, please refer to the documentation :
    /// http://doc.babylonjs.com/extensions/Physically_Based_Rendering
    type [<AllowNullLiteral>] PBRBaseMaterialStatic =
        /// PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.
        abstract LIGHTFALLOFF_PHYSICAL: float
        /// PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document
        /// to enhance interoperability with other engines.
        abstract LIGHTFALLOFF_GLTF: float
        /// PBRMaterialLightFalloff Standard: light is falling off like in the standard material
        /// to enhance interoperability with other materials.
        abstract LIGHTFALLOFF_STANDARD: float
        /// <summary>Instantiates a new PBRMaterial instance.</summary>
        /// <param name="name">The material name</param>
        /// <param name="scene">The scene the material will be use in.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PBRBaseMaterial

    /// The Physically based simple base material of BJS.
    /// 
    /// This enables better naming and convention enforcements on top of the pbrMaterial.
    /// It is used as the base class for both the specGloss and metalRough conventions.
    type [<AllowNullLiteral>] PBRBaseSimpleMaterial =
        inherit PBRBaseMaterial
        /// Number of Simultaneous lights allowed on the material.
        abstract maxSimultaneousLights: float with get, set
        /// If sets to true, disables all the lights affecting the material.
        abstract disableLighting: bool with get, set
        /// Environment Texture used in the material (this is use for both reflection and environment lighting).
        abstract environmentTexture: BaseTexture with get, set
        /// If sets to true, x component of normal map value will invert (x = 1.0 - x).
        abstract invertNormalMapX: bool with get, set
        /// If sets to true, y component of normal map value will invert (y = 1.0 - y).
        abstract invertNormalMapY: bool with get, set
        /// Normal map used in the model.
        abstract normalTexture: BaseTexture with get, set
        /// Emissivie color used to self-illuminate the model.
        abstract emissiveColor: Color3 with get, set
        /// Emissivie texture used to self-illuminate the model.
        abstract emissiveTexture: BaseTexture with get, set
        /// Occlusion Channel Strenght.
        abstract occlusionStrength: float with get, set
        /// Occlusion Texture of the material (adding extra occlusion effects).
        abstract occlusionTexture: BaseTexture with get, set
        /// Defines the alpha limits in alpha test mode.
        abstract alphaCutOff: float with get, set
        /// Gets the current double sided mode.
        /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
        abstract doubleSided: bool with get, set
        /// Stores the pre-calculated light information of a mesh in a texture.
        abstract lightmapTexture: BaseTexture with get, set
        /// If true, the light map contains occlusion information instead of lighting info.
        abstract useLightmapAsShadowmap: bool with get, set
        /// Return the active textures of the material.
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        abstract hasTexture: texture: BaseTexture -> bool
        abstract getClassName: unit -> string

    /// The Physically based simple base material of BJS.
    /// 
    /// This enables better naming and convention enforcements on top of the pbrMaterial.
    /// It is used as the base class for both the specGloss and metalRough conventions.
    type [<AllowNullLiteral>] PBRBaseSimpleMaterialStatic =
        /// <summary>Instantiates a new PBRMaterial instance.</summary>
        /// <param name="name">The material name</param>
        /// <param name="scene">The scene the material will be use in.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PBRBaseSimpleMaterial

    /// The Physically based material of BJS.
    /// 
    /// This offers the main features of a standard PBR material.
    /// For more information, please refer to the documentation :
    /// http://doc.babylonjs.com/extensions/Physically_Based_Rendering
    type [<AllowNullLiteral>] PBRMaterial =
        inherit PBRBaseMaterial
        /// Intensity of the direct lights e.g. the four lights available in your scene.
        /// This impacts both the direct diffuse and specular highlights.
        abstract directIntensity: float with get, set
        /// Intensity of the emissive part of the material.
        /// This helps controlling the emissive effect without modifying the emissive color.
        abstract emissiveIntensity: float with get, set
        /// Intensity of the environment e.g. how much the environment will light the object
        /// either through harmonics for rough material or through the refelction for shiny ones.
        abstract environmentIntensity: float with get, set
        /// This is a special control allowing the reduction of the specular highlights coming from the
        /// four lights of the scene. Those highlights may not be needed in full environment lighting.
        abstract specularIntensity: float with get, set
        /// Debug Control allowing disabling the bump map on this material.
        abstract disableBumpMap: bool with get, set
        /// AKA Diffuse Texture in standard nomenclature.
        abstract albedoTexture: BaseTexture with get, set
        /// AKA Occlusion Texture in other nomenclature.
        abstract ambientTexture: BaseTexture with get, set
        /// AKA Occlusion Texture Intensity in other nomenclature.
        abstract ambientTextureStrength: float with get, set
        /// Defines how much the AO map is occluding the analytical lights (point spot...).
        /// 1 means it completely occludes it
        /// 0 mean it has no impact
        abstract ambientTextureImpactOnAnalyticalLights: float with get, set
        /// Stores the alpha values in a texture.
        abstract opacityTexture: BaseTexture with get, set
        /// Stores the reflection values in a texture.
        abstract reflectionTexture: Nullable<BaseTexture> with get, set
        /// Stores the emissive values in a texture.
        abstract emissiveTexture: BaseTexture with get, set
        /// AKA Specular texture in other nomenclature.
        abstract reflectivityTexture: BaseTexture with get, set
        /// Used to switch from specular/glossiness to metallic/roughness workflow.
        abstract metallicTexture: BaseTexture with get, set
        /// Specifies the metallic scalar of the metallic/roughness workflow.
        /// Can also be used to scale the metalness values of the metallic texture.
        abstract metallic: Nullable<float> with get, set
        /// Specifies the roughness scalar of the metallic/roughness workflow.
        /// Can also be used to scale the roughness values of the metallic texture.
        abstract roughness: Nullable<float> with get, set
        /// Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.
        /// Gray Scale represents roughness in metallic mode and glossiness in specular mode.
        abstract microSurfaceTexture: BaseTexture with get, set
        /// Stores surface normal data used to displace a mesh in a texture.
        abstract bumpTexture: BaseTexture with get, set
        /// Stores the pre-calculated light information of a mesh in a texture.
        abstract lightmapTexture: BaseTexture with get, set
        /// Stores the refracted light information in a texture.
        abstract refractionTexture: BaseTexture with get, set
        /// The color of a material in ambient lighting.
        abstract ambientColor: Color3 with get, set
        /// AKA Diffuse Color in other nomenclature.
        abstract albedoColor: Color3 with get, set
        /// AKA Specular Color in other nomenclature.
        abstract reflectivityColor: Color3 with get, set
        /// The color reflected from the material.
        abstract reflectionColor: Color3 with get, set
        /// The color emitted from the material.
        abstract emissiveColor: Color3 with get, set
        /// AKA Glossiness in other nomenclature.
        abstract microSurface: float with get, set
        /// source material index of refraction (IOR)' / 'destination material IOR.
        abstract indexOfRefraction: float with get, set
        /// Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.
        abstract invertRefractionY: bool with get, set
        /// This parameters will make the material used its opacity to control how much it is refracting aginst not.
        /// Materials half opaque for instance using refraction could benefit from this control.
        abstract linkRefractionWithTransparency: bool with get, set
        /// If true, the light map contains occlusion information instead of lighting info.
        abstract useLightmapAsShadowmap: bool with get, set
        /// Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
        abstract useAlphaFromAlbedoTexture: bool with get, set
        /// Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
        abstract forceAlphaTest: bool with get, set
        /// Defines the alpha limits in alpha test mode.
        abstract alphaCutOff: float with get, set
        /// Specifies that the material will keep the specular highlights over a transparent surface (only the most limunous ones).
        /// A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
        abstract useSpecularOverAlpha: bool with get, set
        /// Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
        abstract useMicroSurfaceFromReflectivityMapAlpha: bool with get, set
        /// Specifies if the metallic texture contains the roughness information in its alpha channel.
        abstract useRoughnessFromMetallicTextureAlpha: bool with get, set
        /// Specifies if the metallic texture contains the roughness information in its green channel.
        abstract useRoughnessFromMetallicTextureGreen: bool with get, set
        /// Specifies if the metallic texture contains the metallness information in its blue channel.
        abstract useMetallnessFromMetallicTextureBlue: bool with get, set
        /// Specifies if the metallic texture contains the ambient occlusion information in its red channel.
        abstract useAmbientOcclusionFromMetallicTextureRed: bool with get, set
        /// Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
        abstract useAmbientInGrayScale: bool with get, set
        /// In case the reflectivity map does not contain the microsurface information in its alpha channel,
        /// The material will try to infer what glossiness each pixel should be.
        abstract useAutoMicroSurfaceFromReflectivityMap: bool with get, set
        /// BJS is using an harcoded light falloff based on a manually sets up range.
        /// In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
        /// This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
        /// BJS is using an harcoded light falloff based on a manually sets up range.
        /// In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
        /// This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
        abstract usePhysicalLightFalloff: bool with get, set
        /// In order to support the falloff compatibility with gltf, a special mode has been added
        /// to reproduce the gltf light falloff.
        /// In order to support the falloff compatibility with gltf, a special mode has been added
        /// to reproduce the gltf light falloff.
        abstract useGLTFLightFalloff: bool with get, set
        /// Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
        /// A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
        abstract useRadianceOverAlpha: bool with get, set
        /// Allows using an object space normal map (instead of tangent space).
        abstract useObjectSpaceNormalMap: bool with get, set
        /// Allows using the bump map in parallax mode.
        abstract useParallax: bool with get, set
        /// Allows using the bump map in parallax occlusion mode.
        abstract useParallaxOcclusion: bool with get, set
        /// Controls the scale bias of the parallax mode.
        abstract parallaxScaleBias: float with get, set
        /// If sets to true, disables all the lights affecting the material.
        abstract disableLighting: bool with get, set
        /// Force the shader to compute irradiance in the fragment shader in order to take bump in account.
        abstract forceIrradianceInFragment: bool with get, set
        /// Number of Simultaneous lights allowed on the material.
        abstract maxSimultaneousLights: float with get, set
        /// If sets to true, x component of normal map value will invert (x = 1.0 - x).
        abstract invertNormalMapX: bool with get, set
        /// If sets to true, y component of normal map value will invert (y = 1.0 - y).
        abstract invertNormalMapY: bool with get, set
        /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
        abstract twoSidedLighting: bool with get, set
        /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
        /// And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
        abstract useAlphaFresnel: bool with get, set
        /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
        /// And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
        abstract useLinearAlphaFresnel: bool with get, set
        /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
        /// And/Or occlude the blended part.
        abstract environmentBRDFTexture: Nullable<BaseTexture> with get, set
        /// Force normal to face away from face.
        abstract forceNormalForward: bool with get, set
        /// Enables specular anti aliasing in the PBR shader.
        /// It will both interacts on the Geometry for analytical and IBL lighting.
        /// It also prefilter the roughness map based on the bump values.
        abstract enableSpecularAntiAliasing: bool with get, set
        /// This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
        /// makes the reflect vector face the model (under horizon).
        abstract useHorizonOcclusion: bool with get, set
        /// This parameters will enable/disable radiance occlusion by preventing the radiance to lit
        /// too much the area relying on ambient texture to define their ambient occlusion.
        abstract useRadianceOcclusion: bool with get, set
        /// If set to true, no lighting calculations will be applied.
        abstract unlit: bool with get, set
        /// Gets the image processing configuration used either in this material.
        /// Sets the Default image processing configuration used either in the this material.
        /// 
        /// If sets to null, the scene one is in use.
        abstract imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Gets wether the color curves effect is enabled.
        /// Sets wether the color curves effect is enabled.
        abstract cameraColorCurvesEnabled: bool with get, set
        /// Gets wether the color grading effect is enabled.
        /// Gets wether the color grading effect is enabled.
        abstract cameraColorGradingEnabled: bool with get, set
        /// Gets wether tonemapping is enabled or not.
        /// Sets wether tonemapping is enabled or not
        abstract cameraToneMappingEnabled: bool with get, set
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        abstract cameraExposure: float with get, set
        /// Gets The camera contrast used on this material.
        /// Sets The camera contrast used on this material.
        abstract cameraContrast: float with get, set
        /// Gets the Color Grading 2D Lookup Texture.
        /// Sets the Color Grading 2D Lookup Texture.
        abstract cameraColorGradingTexture: Nullable<BaseTexture> with get, set
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        abstract cameraColorCurves: Nullable<ColorCurves> with get, set
        /// Returns the name of this material class.
        abstract getClassName: unit -> string
        /// Returns an array of the actively used textures.
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// <summary>Checks to see if a texture is used in the material.</summary>
        /// <param name="texture">- Base texture to use.</param>
        abstract hasTexture: texture: BaseTexture -> bool
        /// <summary>Makes a duplicate of the current material.</summary>
        /// <param name="name">- name to use for the new material.</param>
        abstract clone: name: string -> PBRMaterial
        /// Serializes this PBR Material.
        abstract serialize: unit -> obj option

    /// The Physically based material of BJS.
    /// 
    /// This offers the main features of a standard PBR material.
    /// For more information, please refer to the documentation :
    /// http://doc.babylonjs.com/extensions/Physically_Based_Rendering
    type [<AllowNullLiteral>] PBRMaterialStatic =
        /// PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.
        abstract PBRMATERIAL_OPAQUE: float
        /// PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
        abstract PBRMATERIAL_ALPHATEST: float
        /// PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
        abstract PBRMATERIAL_ALPHABLEND: float
        /// PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
        /// They are also discarded below the alpha cutoff threshold to improve performances.
        abstract PBRMATERIAL_ALPHATESTANDBLEND: float
        /// Defines the default value of how much AO map is occluding the analytical lights
        /// (point spot...).
        abstract DEFAULT_AO_ON_ANALYTICAL_LIGHTS: float with get, set
        /// <summary>Instantiates a new PBRMaterial instance.</summary>
        /// <param name="name">The material name</param>
        /// <param name="scene">The scene the material will be use in.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PBRMaterial
        /// <summary>Parses a PBR Material from a serialized object.</summary>
        /// <param name="source">- Serialized object.</param>
        /// <param name="scene">- BJS scene instance.</param>
        /// <param name="rootUrl">- url for the scene object</param>
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> PBRMaterial

    /// The PBR material of BJS following the metal roughness convention.
    /// 
    /// This fits to the PBR convention in the GLTF definition:
    /// https://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0
    type [<AllowNullLiteral>] PBRMetallicRoughnessMaterial =
        inherit PBRBaseSimpleMaterial
        /// The base color has two different interpretations depending on the value of metalness.
        /// When the material is a metal, the base color is the specific measured reflectance value
        /// at normal incidence (F0). For a non-metal the base color represents the reflected diffuse color
        /// of the material.
        abstract baseColor: Color3 with get, set
        /// Base texture of the metallic workflow. It contains both the baseColor information in RGB as
        /// well as opacity information in the alpha channel.
        abstract baseTexture: BaseTexture with get, set
        /// Specifies the metallic scalar value of the material.
        /// Can also be used to scale the metalness values of the metallic texture.
        abstract metallic: float with get, set
        /// Specifies the roughness scalar value of the material.
        /// Can also be used to scale the roughness values of the metallic texture.
        abstract roughness: float with get, set
        /// Texture containing both the metallic value in the B channel and the
        /// roughness value in the G channel to keep better precision.
        abstract metallicRoughnessTexture: BaseTexture with get, set
        /// Return the currrent class name of the material.
        abstract getClassName: unit -> string
        /// Return the active textures of the material.
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// <summary>Checks to see if a texture is used in the material.</summary>
        /// <param name="texture">- Base texture to use.</param>
        abstract hasTexture: texture: BaseTexture -> bool
        /// <summary>Makes a duplicate of the current material.</summary>
        /// <param name="name">- name to use for the new material.</param>
        abstract clone: name: string -> PBRMetallicRoughnessMaterial
        /// Serialize the material to a parsable JSON object.
        abstract serialize: unit -> obj option

    /// The PBR material of BJS following the metal roughness convention.
    /// 
    /// This fits to the PBR convention in the GLTF definition:
    /// https://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0
    type [<AllowNullLiteral>] PBRMetallicRoughnessMaterialStatic =
        /// <summary>Instantiates a new PBRMetalRoughnessMaterial instance.</summary>
        /// <param name="name">The material name</param>
        /// <param name="scene">The scene the material will be use in.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PBRMetallicRoughnessMaterial
        /// Parses a JSON object correponding to the serialize function.
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> PBRMetallicRoughnessMaterial

    /// The PBR material of BJS following the specular glossiness convention.
    /// 
    /// This fits to the PBR convention in the GLTF definition:
    /// https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
    type [<AllowNullLiteral>] PBRSpecularGlossinessMaterial =
        inherit PBRBaseSimpleMaterial
        /// Specifies the diffuse color of the material.
        abstract diffuseColor: Color3 with get, set
        /// Specifies the diffuse texture of the material. This can also contains the opcity value in its alpha
        /// channel.
        abstract diffuseTexture: BaseTexture with get, set
        /// Specifies the specular color of the material. This indicates how reflective is the material (none to mirror).
        abstract specularColor: Color3 with get, set
        /// Specifies the glossiness of the material. This indicates "how sharp is the reflection".
        abstract glossiness: float with get, set
        /// Specifies both the specular color RGB and the glossiness A of the material per pixels.
        abstract specularGlossinessTexture: BaseTexture with get, set
        /// Return the currrent class name of the material.
        abstract getClassName: unit -> string
        /// Return the active textures of the material.
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// <summary>Checks to see if a texture is used in the material.</summary>
        /// <param name="texture">- Base texture to use.</param>
        abstract hasTexture: texture: BaseTexture -> bool
        /// <summary>Makes a duplicate of the current material.</summary>
        /// <param name="name">- name to use for the new material.</param>
        abstract clone: name: string -> PBRSpecularGlossinessMaterial
        /// Serialize the material to a parsable JSON object.
        abstract serialize: unit -> obj option

    /// The PBR material of BJS following the specular glossiness convention.
    /// 
    /// This fits to the PBR convention in the GLTF definition:
    /// https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
    type [<AllowNullLiteral>] PBRSpecularGlossinessMaterialStatic =
        /// <summary>Instantiates a new PBRSpecularGlossinessMaterial instance.</summary>
        /// <param name="name">The material name</param>
        /// <param name="scene">The scene the material will be use in.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PBRSpecularGlossinessMaterial
        /// Parses a JSON object correponding to the serialize function.
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> PBRSpecularGlossinessMaterial

    /// Base class of all the textures in babylon.
    /// It groups all the common properties the materials, post process, lights... might need
    /// in order to make a correct use of the texture.
    type [<AllowNullLiteral>] BaseTexture =
        /// Define the name of the texture.
        abstract name: string with get, set
        /// Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).
        abstract hasAlpha: bool with get, set
        /// Defines if the alpha value should be determined via the rgb values.
        /// If true the luminance of the pixel might be used to find the corresponding alpha value.
        abstract getAlphaFromRGB: bool with get, set
        /// Intensity or strength of the texture.
        /// It is commonly used by materials to fine tune the intensity of the texture
        abstract level: float with get, set
        /// Define the UV chanel to use starting from 0 and defaulting to 0.
        /// This is part of the texture as textures usually maps to one uv set.
        abstract coordinatesIndex: float with get, set
        /// How a texture is mapped.
        /// 
        /// | Value | Type                                | Description |
        /// | ----- | ----------------------------------- | ----------- |
        /// | 0     | EXPLICIT_MODE                       |             |
        /// | 1     | SPHERICAL_MODE                      |             |
        /// | 2     | PLANAR_MODE                         |             |
        /// | 3     | CUBIC_MODE                          |             |
        /// | 4     | PROJECTION_MODE                     |             |
        /// | 5     | SKYBOX_MODE                         |             |
        /// | 6     | INVCUBIC_MODE                       |             |
        /// | 7     | EQUIRECTANGULAR_MODE                |             |
        /// | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |
        /// | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |
        abstract coordinatesMode: float with get, set
        /// | Value | Type               | Description |
        /// | ----- | ------------------ | ----------- |
        /// | 0     | CLAMP_ADDRESSMODE  |             |
        /// | 1     | WRAP_ADDRESSMODE   |             |
        /// | 2     | MIRROR_ADDRESSMODE |             |
        abstract wrapU: float with get, set
        /// | Value | Type               | Description |
        /// | ----- | ------------------ | ----------- |
        /// | 0     | CLAMP_ADDRESSMODE  |             |
        /// | 1     | WRAP_ADDRESSMODE   |             |
        /// | 2     | MIRROR_ADDRESSMODE |             |
        abstract wrapV: float with get, set
        /// | Value | Type               | Description |
        /// | ----- | ------------------ | ----------- |
        /// | 0     | CLAMP_ADDRESSMODE  |             |
        /// | 1     | WRAP_ADDRESSMODE   |             |
        /// | 2     | MIRROR_ADDRESSMODE |             |
        abstract wrapR: float with get, set
        /// With compliant hardware and browser (supporting anisotropic filtering)
        /// this defines the level of anisotropic filtering in the texture.
        /// The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.
        abstract anisotropicFilteringLevel: float with get, set
        /// Define if the texture is a cube texture or if false a 2d texture.
        abstract isCube: bool with get, set
        /// Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.
        abstract is3D: bool with get, set
        /// Define if the texture contains data in gamma space (most of the png/jpg aside bump).
        /// HDR texture are usually stored in linear space.
        /// This only impacts the PBR and Background materials
        abstract gammaSpace: bool with get, set
        /// Gets whether or not the texture contains RGBD data.
        abstract isRGBD: bool
        /// Is Z inverted in the texture (useful in a cube texture).
        abstract invertZ: bool with get, set
        abstract lodLevelInAlpha: bool with get, set
        /// With prefiltered texture, defined the offset used during the prefiltering steps.
        abstract lodGenerationOffset: float with get, set
        /// With prefiltered texture, defined the scale used during the prefiltering steps.
        abstract lodGenerationScale: float with get, set
        /// Define if the texture is a render target.
        abstract isRenderTarget: bool with get, set
        /// Define the unique id of the texture in the scene.
        abstract uid: string
        /// Return a string representation of the texture.
        abstract toString: unit -> string
        /// Get the class name of the texture.
        abstract getClassName: unit -> string
        /// Define the list of animation attached to the texture.
        abstract animations: ResizeArray<Animation> with get, set
        /// An event triggered when the texture is disposed.
        abstract onDisposeObservable: Observable<BaseTexture> with get, set
        /// Callback triggered when the texture has been disposed.
        /// Kept for back compatibility, you can use the onDisposeObservable instead.
        abstract onDispose: (unit -> unit) with get, set
        /// Define the current state of the loading sequence when in delayed load mode.
        abstract delayLoadState: float with get, set
        abstract _texture: Nullable<InternalTexture> with get, set
        /// Define if the texture is preventinga material to render or not.
        /// If not and the texture is not ready, the engine will use a default black texture instead.
        abstract isBlocking: bool
        /// Get the scene the texture belongs to.
        abstract getScene: unit -> Nullable<Scene>
        /// Get the texture transform matrix used to offset tile the texture for istance.
        abstract getTextureMatrix: unit -> Matrix
        /// Get the texture reflection matrix used to rotate/transform the reflection.
        abstract getReflectionTextureMatrix: unit -> Matrix
        /// Get the underlying lower level texture from Babylon.
        abstract getInternalTexture: unit -> Nullable<InternalTexture>
        /// Get if the texture is ready to be consumed (either it is ready or it is not blocking)
        abstract isReadyOrNotBlocking: unit -> bool
        /// Get if the texture is ready to be used (downloaded, converted, mip mapped...).
        abstract isReady: unit -> bool
        /// Get the size of the texture.
        abstract getSize: unit -> ISize
        /// Get the base size of the texture.
        /// It can be different from the size if the texture has been resized for POT for instance
        abstract getBaseSize: unit -> ISize
        /// <summary>Scales the texture if is `canRescale()`</summary>
        /// <param name="ratio">the resize factor we want to use to rescale</param>
        abstract scale: ratio: float -> unit
        /// Get if the texture can rescale.
        abstract canRescale: bool
        abstract _getFromCache: url: Nullable<string> * noMipmap: bool * ?sampling: float -> Nullable<InternalTexture>
        abstract _rebuild: unit -> unit
        /// Triggers the load sequence in delayed load mode.
        abstract delayLoad: unit -> unit
        /// Clones the texture.
        abstract clone: unit -> Nullable<BaseTexture>
        /// Get the texture underlying type (INT, FLOAT...)
        abstract textureType: float
        /// Get the texture underlying format (RGB, RGBA...)
        abstract textureFormat: float
        /// <summary>Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.
        /// This will returns an RGBA array buffer containing either in values (0-255) or
        /// float values (0-1) depending of the underlying buffer type.</summary>
        /// <param name="faceIndex">defines the face of the texture to read (in case of cube texture)</param>
        /// <param name="level">defines the LOD level of the texture to read (in case of Mip Maps)</param>
        /// <param name="buffer">defines a user defined buffer to fill with data (can be null)</param>
        abstract readPixels: ?faceIndex: float * ?level: float * ?buffer: ArrayBufferView -> Nullable<ArrayBufferView>
        /// Release and destroy the underlying lower level texture aka internalTexture.
        abstract releaseInternalTexture: unit -> unit
        /// Get the polynomial representation of the texture data.
        /// This is mainly use as a fast way to recover IBL Diffuse irradiance data.
        abstract sphericalPolynomial: Nullable<SphericalPolynomial> with get, set
        abstract _lodTextureHigh: Nullable<BaseTexture>
        abstract _lodTextureMid: Nullable<BaseTexture>
        abstract _lodTextureLow: Nullable<BaseTexture>
        /// Dispose the texture and release its associated resources.
        abstract dispose: unit -> unit
        /// Serialize the texture into a JSON representation that can be parsed later on.
        abstract serialize: unit -> obj option

    /// Base class of all the textures in babylon.
    /// It groups all the common properties the materials, post process, lights... might need
    /// in order to make a correct use of the texture.
    type [<AllowNullLiteral>] BaseTextureStatic =
        /// Default anisotropic filtering level for the application.
        /// It is set to 4 as a good tradeoff between perf and quality.
        abstract DEFAULT_ANISOTROPIC_FILTERING_LEVEL: float with get, set
        /// <summary>Instantiates a new BaseTexture.
        /// Base class of all the textures in babylon.
        /// It groups all the common properties the materials, post process, lights... might need
        /// in order to make a correct use of the texture.</summary>
        /// <param name="scene">Define the scene the texture blongs to</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Nullable<Scene> -> BaseTexture
        /// <summary>Helper function to be called back once a list of texture contains only ready textures.</summary>
        /// <param name="textures">Define the list of textures to wait for</param>
        /// <param name="callback">Define the callback triggered once the entire list will be ready</param>
        abstract WhenAllReady: textures: ResizeArray<BaseTexture> * callback: (unit -> unit) -> unit

    /// This represents a color grading texture. This acts as a lookup table LUT, useful during post process
    /// It can help converting any input color in a desired output one. This can then be used to create effects
    /// from sepia, black and white to sixties or futuristic rendering...
    /// 
    /// The only supported format is currently 3dl.
    /// More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table
    type [<AllowNullLiteral>] ColorGradingTexture =
        inherit BaseTexture
        /// The texture URL.
        abstract url: string with get, set
        /// Returns the texture matrix used in most of the material.
        /// This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).
        abstract getTextureMatrix: unit -> Matrix
        /// Clones the color gradind texture.
        abstract clone: unit -> ColorGradingTexture
        /// Called during delayed load for textures.
        abstract delayLoad: unit -> unit
        /// Serializes the LUT texture to json format.
        abstract serialize: unit -> obj option

    /// This represents a color grading texture. This acts as a lookup table LUT, useful during post process
    /// It can help converting any input color in a desired output one. This can then be used to create effects
    /// from sepia, black and white to sixties or futuristic rendering...
    /// 
    /// The only supported format is currently 3dl.
    /// More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table
    type [<AllowNullLiteral>] ColorGradingTextureStatic =
        /// <summary>Instantiates a ColorGradingTexture from the following parameters.</summary>
        /// <param name="url">The location of the color gradind data (currently only supporting 3dl)</param>
        /// <param name="scene">The scene the texture will be used in</param>
        [<Emit "new $0($1...)">] abstract Create: url: string * scene: Scene -> ColorGradingTexture
        /// <summary>Parses a color grading texture serialized by Babylon.</summary>
        /// <param name="parsedTexture">The texture information being parsedTexture</param>
        /// <param name="scene">The scene to load the texture in</param>
        /// <param name="rootUrl">The root url of the data assets to load</param>
        abstract Parse: parsedTexture: obj option * scene: Scene * rootUrl: string -> Nullable<ColorGradingTexture>

    /// Class for creating a cube texture
    type [<AllowNullLiteral>] CubeTexture =
        inherit BaseTexture
        /// The url of the texture
        abstract url: string with get, set
        /// Gets or sets the center of the bounding box associated with the cube texture.
        /// It must define where the camera used to render the texture was set
        abstract boundingBoxPosition: Vector3 with get, set
        /// Gets or sets the size of the bounding box associated with the cube texture
        /// When defined, the cubemap will switch to local mode
        /// Returns the bounding box size
        abstract boundingBoxSize: Vector3 with get, set
        abstract _rotationY: float with get, set
        /// Sets texture matrix rotation angle around Y axis in radians.
        /// Gets texture matrix rotation angle around Y axis radians.
        abstract rotationY: float with get, set
        abstract _prefiltered: bool
        /// Delays loading of the cube texture
        abstract delayLoad: unit -> unit
        /// Returns the reflection texture matrix
        abstract getReflectionTextureMatrix: unit -> Matrix
        /// <summary>Sets the reflection texture matrix</summary>
        /// <param name="value">Reflection texture matrix</param>
        abstract setReflectionTextureMatrix: value: Matrix -> unit
        /// Makes a clone, or deep copy, of the cube texture
        abstract clone: unit -> CubeTexture

    /// Class for creating a cube texture
    type [<AllowNullLiteral>] CubeTextureStatic =
        /// <summary>Creates a cube texture from an array of image urls</summary>
        /// <param name="files">defines an array of image urls</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="noMipmap">specifies if mip maps are not used</param>
        abstract CreateFromImages: files: ResizeArray<string> * scene: Scene * ?noMipmap: bool -> CubeTexture
        /// <summary>Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.</summary>
        /// <param name="url">defines the url of the prefiltered texture</param>
        /// <param name="scene">defines the scene the texture is attached to</param>
        /// <param name="forcedExtension">defines the extension of the file if different from the url</param>
        /// <param name="createPolynomials">defines whether or not to create polynomial harmonics from the texture data if necessary</param>
        abstract CreateFromPrefilteredData: url: string * scene: Scene * ?forcedExtension: obj * ?createPolynomials: bool -> CubeTexture
        /// <summary>Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well
        /// as prefiltered data.</summary>
        /// <param name="rootUrl">defines the url of the texture or the root name of the six images</param>
        /// <param name="scene">defines the scene the texture is attached to</param>
        /// <param name="extensions">defines the suffixes add to the picture name in case six images are in use like _px.jpg...</param>
        /// <param name="noMipmap">defines if mipmaps should be created or not</param>
        /// <param name="files">defines the six files to load for the different faces</param>
        /// <param name="onLoad">defines a callback triggered at the end of the file load if no errors occured</param>
        /// <param name="onError">defines a callback triggered in case of error during load</param>
        /// <param name="format">defines the internal format to use for the texture once loaded</param>
        /// <param name="prefiltered">defines whether or not the texture is created from prefiltered data</param>
        /// <param name="forcedExtension">defines the extensions to use (force a special type of file to load) in case it is different from the file name</param>
        /// <param name="createPolynomials">defines whether or not to create polynomial harmonics from the texture data if necessary</param>
        /// <param name="lodScale">defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness</param>
        /// <param name="lodOffset">defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness</param>
        [<Emit "new $0($1...)">] abstract Create: rootUrl: string * scene: Scene * ?extensions: ResizeArray<string> * ?noMipmap: bool * ?files: ResizeArray<string> * ?onLoad: (unit -> unit) * ?onError: (string -> obj -> unit) * ?format: float * ?prefiltered: bool * ?forcedExtension: obj * ?createPolynomials: bool * ?lodScale: float * ?lodOffset: float -> CubeTexture
        /// <summary>Parses text to create a cube texture</summary>
        /// <param name="parsedTexture">define the serialized text to read from</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="rootUrl">defines the root url of the cube texture</param>
        abstract Parse: parsedTexture: obj option * scene: Scene * rootUrl: string -> CubeTexture

    /// A class extending Texture allowing drawing on a texture
    type [<AllowNullLiteral>] DynamicTexture =
        inherit Texture
        /// Gets the current state of canRescale
        abstract canRescale: bool
        /// <summary>Scales the texture</summary>
        /// <param name="ratio">the scale factor to apply to both width and height</param>
        abstract scale: ratio: float -> unit
        /// <summary>Resizes the texture</summary>
        /// <param name="width">the new width</param>
        /// <param name="height">the new height</param>
        abstract scaleTo: width: float * height: float -> unit
        /// Gets the context of the canvas used by the texture
        abstract getContext: unit -> CanvasRenderingContext2D
        /// Clears the texture
        abstract clear: unit -> unit
        /// <summary>Updates the texture</summary>
        /// <param name="invertY">defines the direction for the Y axis (default is true - y increases downwards)</param>
        /// <param name="premulAlpha">defines if alpha is stored as premultiplied (default is false)</param>
        abstract update: ?invertY: bool * ?premulAlpha: bool -> unit
        /// <summary>Draws text onto the texture</summary>
        /// <param name="text">defines the text to be drawn</param>
        /// <param name="x">defines the placement of the text from the left</param>
        /// <param name="y">defines the placement of the text from the top when invertY is true and from the bottom when false</param>
        /// <param name="font">defines the font to be used with font-style, font-size, font-name</param>
        /// <param name="color">defines the color used for the text</param>
        /// <param name="clearColor">defines the color for the canvas, use null to not overwrite canvas</param>
        /// <param name="invertY">defines the direction for the Y axis (default is true - y increases downwards)</param>
        /// <param name="update">defines whether texture is immediately update (default is true)</param>
        abstract drawText: text: string * x: float * y: float * font: string * color: string * clearColor: string * ?invertY: bool * ?update: bool -> unit
        /// Clones the texture
        abstract clone: unit -> DynamicTexture
        /// Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized
        abstract serialize: unit -> obj option
        abstract _rebuild: unit -> unit

    /// A class extending Texture allowing drawing on a texture
    type [<AllowNullLiteral>] DynamicTextureStatic =
        /// <summary>Creates a DynamicTexture</summary>
        /// <param name="name">defines the name of the texture</param>
        /// <param name="options">provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height</param>
        /// <param name="scene">defines the scene where you want the texture</param>
        /// <param name="generateMipMaps">defines the use of MinMaps or not (default is false)</param>
        /// <param name="samplingMode">defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)</param>
        /// <param name="format">defines the texture format to use (default is BABYLON.Engine.TEXTUREFORMAT_RGBA)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: obj option * scene: Scene option * generateMipMaps: bool * ?samplingMode: float * ?format: float -> DynamicTexture

    /// This represents a texture coming from an HDR input.
    /// 
    /// The only supported format is currently panorama picture stored in RGBE format.
    /// Example of such files can be found on HDRLib: http://hdrlib.com/
    type [<AllowNullLiteral>] HDRCubeTexture =
        inherit BaseTexture
        /// The texture URL.
        abstract url: string with get, set
        /// The texture coordinates mode. As this texture is stored in a cube format, please modify carefully.
        abstract coordinatesMode: float with get, set
        abstract _isBlocking: bool with get, set
        /// Sets wether or not the texture is blocking during loading.
        /// Gets wether or not the texture is blocking during loading.
        abstract isBlocking: bool with get, set
        abstract _rotationY: float with get, set
        /// Sets texture matrix rotation angle around Y axis in radians.
        /// Gets texture matrix rotation angle around Y axis radians.
        abstract rotationY: float with get, set
        /// Gets or sets the center of the bounding box associated with the cube texture
        /// It must define where the camera used to render the texture was set
        abstract boundingBoxPosition: Vector3 with get, set
        /// Gets or sets the size of the bounding box associated with the cube texture
        /// When defined, the cubemap will switch to local mode
        abstract boundingBoxSize: Vector3 with get, set
        abstract clone: unit -> HDRCubeTexture
        abstract delayLoad: unit -> unit
        /// Get the texture reflection matrix used to rotate/transform the reflection.
        abstract getReflectionTextureMatrix: unit -> Matrix
        /// <summary>Set the texture reflection matrix used to rotate/transform the reflection.</summary>
        /// <param name="value">Define the reflection matrix to set</param>
        abstract setReflectionTextureMatrix: value: Matrix -> unit
        abstract serialize: unit -> obj option

    /// This represents a texture coming from an HDR input.
    /// 
    /// The only supported format is currently panorama picture stored in RGBE format.
    /// Example of such files can be found on HDRLib: http://hdrlib.com/
    type [<AllowNullLiteral>] HDRCubeTextureStatic =
        /// <summary>Instantiates an HDRTexture from the following parameters.</summary>
        /// <param name="url">The location of the HDR raw data (Panorama stored in RGBE format)</param>
        /// <param name="scene">The scene the texture will be used in</param>
        /// <param name="size">The cubemap desired size (the more it increases the longer the generation will be)</param>
        /// <param name="noMipmap">Forces to not generate the mipmap if true</param>
        /// <param name="generateHarmonics">Specifies whether you want to extract the polynomial harmonics during the generation process</param>
        /// <param name="gammaSpace">Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)</param>
        /// <param name="reserved">Reserved flag for internal use.</param>
        [<Emit "new $0($1...)">] abstract Create: url: string * scene: Scene * size: float * ?noMipmap: bool * ?generateHarmonics: bool * ?gammaSpace: bool * ?reserved: bool * ?onLoad: (unit -> unit) * ?onError: (string -> obj -> unit) -> HDRCubeTexture
        /// <summary>Parses a JSON representation of an HDR Texture in order to create the texture</summary>
        /// <param name="parsedTexture">Define the JSON representation</param>
        /// <param name="scene">Define the scene the texture should be created in</param>
        /// <param name="rootUrl">Define the root url in case we need to load relative dependencies</param>
        abstract Parse: parsedTexture: obj option * scene: Scene * rootUrl: string -> Nullable<HDRCubeTexture>

    /// Class used to store data associated with WebGL texture data for the engine
    /// This class should not be used directly
    type [<AllowNullLiteral>] InternalTexture =
        inherit IInternalTextureTracker
        /// Defines if the texture is ready
        abstract isReady: bool with get, set
        /// Defines if the texture is a cube texture
        abstract isCube: bool with get, set
        /// Defines if the texture contains 3D data
        abstract is3D: bool with get, set
        /// Gets the URL used to load this texture
        abstract url: string with get, set
        /// Gets the sampling mode of the texture
        abstract samplingMode: float with get, set
        /// Gets a boolean indicating if the texture needs mipmaps generation
        abstract generateMipMaps: bool with get, set
        /// Gets the number of samples used by the texture (WebGL2+ only)
        abstract samples: float with get, set
        /// Gets the type of the texture (int, float...)
        abstract ``type``: float with get, set
        /// Gets the format of the texture (RGB, RGBA...)
        abstract format: float with get, set
        /// Observable called when the texture is loaded
        abstract onLoadedObservable: Observable<InternalTexture> with get, set
        /// Gets the width of the texture
        abstract width: float with get, set
        /// Gets the height of the texture
        abstract height: float with get, set
        /// Gets the depth of the texture
        abstract depth: float with get, set
        /// Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)
        abstract baseWidth: float with get, set
        /// Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)
        abstract baseHeight: float with get, set
        /// Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)
        abstract baseDepth: float with get, set
        /// Gets a boolean indicating if the texture is inverted on Y axis
        abstract invertY: bool with get, set
        /// Gets or set the previous tracker in the list
        abstract previous: Nullable<IInternalTextureTracker> with get, set
        /// Gets or set the next tracker in the list
        abstract next: Nullable<IInternalTextureTracker> with get, set
        abstract _initialSlot: float with get, set
        abstract _designatedSlot: float with get, set
        abstract _dataSource: float with get, set
        abstract _buffer: Nullable<U4<string, ArrayBuffer, HTMLImageElement, Blob>> with get, set
        abstract _bufferView: Nullable<ArrayBufferView> with get, set
        abstract _bufferViewArray: Nullable<ResizeArray<ArrayBufferView>> with get, set
        abstract _bufferViewArrayArray: Nullable<ResizeArray<ResizeArray<ArrayBufferView>>> with get, set
        abstract _size: float with get, set
        abstract _extension: string with get, set
        abstract _files: Nullable<ResizeArray<string>> with get, set
        abstract _workingCanvas: HTMLCanvasElement with get, set
        abstract _workingContext: CanvasRenderingContext2D with get, set
        abstract _framebuffer: Nullable<WebGLFramebuffer> with get, set
        abstract _depthStencilBuffer: Nullable<WebGLRenderbuffer> with get, set
        abstract _MSAAFramebuffer: Nullable<WebGLFramebuffer> with get, set
        abstract _MSAARenderBuffer: Nullable<WebGLRenderbuffer> with get, set
        abstract _attachments: Nullable<ResizeArray<float>> with get, set
        abstract _cachedCoordinatesMode: Nullable<float> with get, set
        abstract _cachedWrapU: Nullable<float> with get, set
        abstract _cachedWrapV: Nullable<float> with get, set
        abstract _cachedWrapR: Nullable<float> with get, set
        abstract _cachedAnisotropicFilteringLevel: Nullable<float> with get, set
        abstract _isDisabled: bool with get, set
        abstract _compression: Nullable<string> with get, set
        abstract _generateStencilBuffer: bool with get, set
        abstract _generateDepthBuffer: bool with get, set
        abstract _comparisonFunction: float with get, set
        abstract _sphericalPolynomial: Nullable<SphericalPolynomial> with get, set
        abstract _lodGenerationScale: float with get, set
        abstract _lodGenerationOffset: float with get, set
        abstract _lodTextureHigh: BaseTexture with get, set
        abstract _lodTextureMid: BaseTexture with get, set
        abstract _lodTextureLow: BaseTexture with get, set
        abstract _isRGBD: bool with get, set
        abstract _webGLTexture: Nullable<WebGLTexture> with get, set
        abstract _references: float with get, set
        /// Gets the Engine the texture belongs to.
        abstract getEngine: unit -> Engine
        /// Gets the data source type of the texture (can be one of the BABYLON.InternalTexture.DATASOURCE_XXXX)
        abstract dataSource: float
        /// Increments the number of references (ie. the number of Texture that point to it)
        abstract incrementReferences: unit -> unit
        /// <summary>Change the size of the texture (not the size of the content)</summary>
        /// <param name="width">defines the new width</param>
        /// <param name="height">defines the new height</param>
        /// <param name="depth">defines the new depth (1 by default)</param>
        abstract updateSize: width: int * height: int * ?depth: int -> unit
        abstract _rebuild: unit -> unit
        abstract _swapAndDie: target: InternalTexture -> unit
        /// Dispose the current allocated resources
        abstract dispose: unit -> unit

    /// Class used to store data associated with WebGL texture data for the engine
    /// This class should not be used directly
    type [<AllowNullLiteral>] InternalTextureStatic =
        /// The source of the texture data is unknown
        abstract DATASOURCE_UNKNOWN: float with get, set
        /// Texture data comes from an URL
        abstract DATASOURCE_URL: float with get, set
        /// Texture data is only used for temporary storage
        abstract DATASOURCE_TEMP: float with get, set
        /// Texture data comes from raw data (ArrayBuffer)
        abstract DATASOURCE_RAW: float with get, set
        /// Texture content is dynamic (video or dynamic texture)
        abstract DATASOURCE_DYNAMIC: float with get, set
        /// Texture content is generated by rendering to it
        abstract DATASOURCE_RENDERTARGET: float with get, set
        /// Texture content is part of a multi render target process
        abstract DATASOURCE_MULTIRENDERTARGET: float with get, set
        /// Texture data comes from a cube data file
        abstract DATASOURCE_CUBE: float with get, set
        /// Texture data comes from a raw cube data
        abstract DATASOURCE_CUBERAW: float with get, set
        /// Texture data come from a prefiltered cube data file
        abstract DATASOURCE_CUBEPREFILTERED: float with get, set
        /// Texture content is raw 3D data
        abstract DATASOURCE_RAW3D: float with get, set
        /// Texture content is a depth texture
        abstract DATASOURCE_DEPTHTEXTURE: float with get, set
        /// Texture data comes from a raw cube data encoded with RGBD
        abstract DATASOURCE_CUBERAW_RGBD: float with get, set
        /// <summary>Creates a new InternalTexture</summary>
        /// <param name="engine">defines the engine to use</param>
        /// <param name="dataSource">defines the type of data that will be used</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * dataSource: float -> InternalTexture

    /// This represents the required contract to create a new type of texture loader.
    type [<AllowNullLiteral>] IInternalTextureLoader =
        /// Defines wether the loader supports cascade loading the different faces.
        abstract supportCascades: bool with get, set
        /// <summary>This returns if the loader support the current file information.</summary>
        /// <param name="extension">defines the file extension of the file being loaded</param>
        /// <param name="textureFormatInUse">defines the current compressed format in use iun the engine</param>
        /// <param name="fallback">defines the fallback internal texture if any</param>
        /// <param name="isBase64">defines whether the texture is encoded as a base64</param>
        /// <param name="isBuffer">defines whether the texture data are stored as a buffer</param>
        abstract canLoad: extension: string * textureFormatInUse: Nullable<string> * fallback: Nullable<InternalTexture> * isBase64: bool * isBuffer: bool -> bool
        /// <summary>Transform the url before loading if required.</summary>
        /// <param name="rootUrl">the url of the texture</param>
        /// <param name="textureFormatInUse">defines the current compressed format in use iun the engine</param>
        abstract transformUrl: rootUrl: string * textureFormatInUse: Nullable<string> -> string
        /// <summary>Gets the fallback url in case the load fail. This can return null to allow the default fallback mecanism to work</summary>
        /// <param name="rootUrl">the url of the texture</param>
        /// <param name="textureFormatInUse">defines the current compressed format in use iun the engine</param>
        abstract getFallbackTextureUrl: rootUrl: string * textureFormatInUse: Nullable<string> -> Nullable<string>
        /// <summary>Uploads the cube texture data to the WebGl Texture. It has alreday been bound.</summary>
        /// <param name="data">contains the texture data</param>
        /// <param name="texture">defines the BabylonJS internal texture</param>
        /// <param name="createPolynomials">will be true if polynomials have been requested</param>
        /// <param name="onLoad">defines the callback to trigger once the texture is ready</param>
        /// <param name="onError">defines the callback to trigger in case of error</param>
        abstract loadCubeData: data: U3<string, ArrayBuffer, ResizeArray<U2<string, ArrayBuffer>>> * texture: InternalTexture * createPolynomials: bool * onLoad: Nullable<(obj -> unit)> * onError: Nullable<(string -> obj -> unit)> -> unit
        /// <summary>Uploads the 2D texture data to the WebGl Texture. It has alreday been bound once in the callback.</summary>
        /// <param name="data">contains the texture data</param>
        /// <param name="texture">defines the BabylonJS internal texture</param>
        /// <param name="callback">defines the method to call once ready to upload</param>
        abstract loadData: data: ArrayBuffer * texture: InternalTexture * callback: (float -> float -> bool -> bool -> (unit -> unit) -> unit) -> unit

    /// Internal interface used to track InternalTexture already bound to the GL context
    type [<AllowNullLiteral>] IInternalTextureTracker =
        /// Gets or set the previous tracker in the list
        abstract previous: Nullable<IInternalTextureTracker> with get, set
        /// Gets or set the next tracker in the list
        abstract next: Nullable<IInternalTextureTracker> with get, set

    /// Internal class used by the engine to get list of InternalTexture already bound to the GL context
    type [<AllowNullLiteral>] DummyInternalTextureTracker =
        /// Gets or set the previous tracker in the list
        abstract previous: Nullable<IInternalTextureTracker> with get, set
        /// Gets or set the next tracker in the list
        abstract next: Nullable<IInternalTextureTracker> with get, set

    /// Internal class used by the engine to get list of InternalTexture already bound to the GL context
    type [<AllowNullLiteral>] DummyInternalTextureTrackerStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> DummyInternalTextureTracker

    /// Mirror texture can be used to simulate the view from a mirror in a scene.
    /// It will dynamically be rendered every frame to adapt to the camera point of view.
    /// You can then easily use it as a reflectionTexture on a flat surface.
    /// In case the surface is not a plane, please consider relying on reflection probes.
    type [<AllowNullLiteral>] MirrorTexture =
        inherit RenderTargetTexture
        /// Define the reflection plane we want to use. The mirrorPlane is usually set to the constructed reflector.
        /// It is possible to directly set the mirrorPlane by directly using a BABYLON.Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the mirrorPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the reflector as stated in the doc.
        abstract mirrorPlane: Plane with get, set
        /// Define the blur ratio used to blur the reflection if needed.
        abstract blurRatio: float with get, set
        /// Define the adaptive blur kernel used to blur the reflection if needed.
        /// This will autocompute the closest best match for the `blurKernel`
        abstract adaptiveBlurKernel: float with get, set
        /// Define the blur kernel used to blur the reflection if needed.
        /// Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
        abstract blurKernel: float with get, set
        /// Define the blur kernel on the X Axis used to blur the reflection if needed.
        /// Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
        abstract blurKernelX: float with get, set
        /// Define the blur kernel on the Y Axis used to blur the reflection if needed.
        /// Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
        abstract blurKernelY: float with get, set
        abstract _onRatioRescale: unit -> unit
        /// Clone the mirror texture.
        abstract clone: unit -> MirrorTexture
        /// Serialize the texture to a JSON representation you could use in Parse later on
        abstract serialize: unit -> obj option
        /// Dispose the texture and release its associated resources.
        abstract dispose: unit -> unit

    /// Mirror texture can be used to simulate the view from a mirror in a scene.
    /// It will dynamically be rendered every frame to adapt to the camera point of view.
    /// You can then easily use it as a reflectionTexture on a flat surface.
    /// In case the surface is not a plane, please consider relying on reflection probes.
    type [<AllowNullLiteral>] MirrorTextureStatic =
        /// <summary>Instantiates a Mirror Texture.
        /// Mirror texture can be used to simulate the view from a mirror in a scene.
        /// It will dynamically be rendered every frame to adapt to the camera point of view.
        /// You can then easily use it as a reflectionTexture on a flat surface.
        /// In case the surface is not a plane, please consider relying on reflection probes.</summary>
        /// <param name="name"></param>
        /// <param name="size"></param>
        /// <param name="scene"></param>
        /// <param name="generateMipMaps"></param>
        /// <param name="type"></param>
        /// <param name="samplingMode"></param>
        /// <param name="generateDepthBuffer"></param>
        [<Emit "new $0($1...)">] abstract Create: name: string * size: U3<float, TypeLiteral_08, TypeLiteral_40> * scene: Scene * ?generateMipMaps: bool * ?``type``: float * ?samplingMode: float * ?generateDepthBuffer: bool -> MirrorTexture

    /// Creation options of the multi render target texture.
    type [<AllowNullLiteral>] IMultiRenderTargetOptions =
        /// Define if the texture needs to create mip maps after render.
        abstract generateMipMaps: bool option with get, set
        /// Define the types of all the draw buffers we want to create
        abstract types: ResizeArray<float> option with get, set
        /// Define the sampling modes of all the draw buffers we want to create
        abstract samplingModes: ResizeArray<float> option with get, set
        /// Define if a depth buffer is required
        abstract generateDepthBuffer: bool option with get, set
        /// Define if a stencil buffer is required
        abstract generateStencilBuffer: bool option with get, set
        /// Define if a depth texture is required instead of a depth buffer
        abstract generateDepthTexture: bool option with get, set
        /// Define the number of desired draw buffers
        abstract textureCount: float option with get, set
        /// Define if aspect ratio should be adapted to the texture or stay the scene one
        abstract doNotChangeAspectRatio: bool option with get, set
        /// Define the default type of the buffers we are creating
        abstract defaultType: float option with get, set

    /// A multi render target, like a render target provides the ability to render to a texture.
    /// Unlike the render target, it can render to several draw buffers in one draw.
    /// This is specially interesting in deferred rendering or for any effects requiring more than
    /// just one color from a single pass.
    type [<AllowNullLiteral>] MultiRenderTarget =
        inherit RenderTargetTexture
        /// Get if draw buffers are currently supported by the used hardware and browser.
        abstract isSupported: bool
        /// Get the list of textures generated by the multi render target.
        abstract textures: ResizeArray<Texture>
        /// Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
        abstract depthTexture: Texture
        /// Set the wrapping mode on U of all the textures we are rendering to.
        /// Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
        abstract wrapU: float with get, set
        /// Set the wrapping mode on V of all the textures we are rendering to.
        /// Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
        abstract wrapV: float with get, set
        abstract _rebuild: unit -> unit
        /// Define the number of samples used if MSAA is enabled.
        abstract samples: float with get, set
        /// <summary>Resize all the textures in the multi render target.
        /// Be carrefull as it will recreate all the data in the new texture.</summary>
        /// <param name="size">Define the new size</param>
        abstract resize: size: obj option -> unit
        abstract unbindFrameBuffer: engine: Engine * faceIndex: float -> unit
        /// Dispose the render targets and their associated resources
        abstract dispose: unit -> unit
        /// Release all the underlying texture used as draw buffers.
        abstract releaseInternalTextures: unit -> unit

    /// A multi render target, like a render target provides the ability to render to a texture.
    /// Unlike the render target, it can render to several draw buffers in one draw.
    /// This is specially interesting in deferred rendering or for any effects requiring more than
    /// just one color from a single pass.
    type [<AllowNullLiteral>] MultiRenderTargetStatic =
        /// <summary>Instantiate a new multi render target texture.
        /// A multi render target, like a render target provides the ability to render to a texture.
        /// Unlike the render target, it can render to several draw buffers in one draw.
        /// This is specially interesting in deferred rendering or for any effects requiring more than
        /// just one color from a single pass.</summary>
        /// <param name="name">Define the name of the texture</param>
        /// <param name="size">Define the size of the buffers to render to</param>
        /// <param name="count">Define the number of target we are rendering into</param>
        /// <param name="scene">Define the scene the texture belongs to</param>
        /// <param name="options">Define the options used to create the multi render target</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * size: obj option * count: float * scene: Scene * ?options: IMultiRenderTargetOptions -> MultiRenderTarget

    /// Raw cube texture where the raw buffers are passed in
    type [<AllowNullLiteral>] RawCubeTexture =
        inherit CubeTexture
        /// <summary>Updates the raw cube texture.</summary>
        /// <param name="data">defines the data to store</param>
        /// <param name="format">defines the data format</param>
        /// <param name="type">defines the type fo the data (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="compression">defines the compression used (null by default)</param>
        /// <param name="level">defines which level of the texture to update</param>
        abstract update: data: ResizeArray<ArrayBufferView> * format: float * ``type``: float * invertY: bool * ?compression: string * ?level: float -> unit
        /// <summary>Updates a raw cube texture with RGBD encoded data.</summary>
        /// <param name="data">defines the array of data [mipmap][face] to use to create each face</param>
        /// <param name="sphericalPolynomial">defines the spherical polynomial for irradiance</param>
        /// <param name="lodScale">defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness</param>
        /// <param name="lodOffset">defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness</param>
        abstract updateRGBDAsync: data: ResizeArray<ResizeArray<ArrayBufferView>> * ?sphericalPolynomial: SphericalPolynomial * ?lodScale: float * ?lodOffset: float -> Promise<unit>
        /// Clones the raw cube texture.
        abstract clone: unit -> CubeTexture

    /// Raw cube texture where the raw buffers are passed in
    type [<AllowNullLiteral>] RawCubeTextureStatic =
        /// <summary>Creates a cube texture where the raw buffers are passed in.</summary>
        /// <param name="scene">defines the scene the texture is attached to</param>
        /// <param name="data">defines the array of data to use to create each face</param>
        /// <param name="size">defines the size of the textures</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="type">defines the type of the data (like BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT)</param>
        /// <param name="generateMipMaps">defines if the engine should generate the mip levels</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="samplingMode">defines the required sampling mode (like BABYLON.Texture.NEAREST_SAMPLINGMODE)</param>
        /// <param name="compression">defines the compression used (null by default)</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * data: Nullable<ResizeArray<ArrayBufferView>> * size: float * ?format: float * ?``type``: float * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?compression: string -> RawCubeTexture
        abstract _UpdateRGBDAsync: internalTexture: InternalTexture * data: ResizeArray<ResizeArray<ArrayBufferView>> * sphericalPolynomial: Nullable<SphericalPolynomial> * lodScale: float * lodOffset: float -> Promise<unit>

    /// Raw texture can help creating a texture directly from an array of data.
    /// This can be super useful if you either get the data from an uncompressed source or
    /// if you wish to create your texture pixel by pixel.
    type [<AllowNullLiteral>] RawTexture =
        inherit Texture
        /// Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
        abstract format: float with get, set
        /// <summary>Updates the texture underlying data.</summary>
        /// <param name="data">Define the new data of the texture</param>
        abstract update: data: ArrayBufferView -> unit

    /// Raw texture can help creating a texture directly from an array of data.
    /// This can be super useful if you either get the data from an uncompressed source or
    /// if you wish to create your texture pixel by pixel.
    type [<AllowNullLiteral>] RawTextureStatic =
        /// <summary>Instantiates a new RawTexture.
        /// Raw texture can help creating a texture directly from an array of data.
        /// This can be super useful if you either get the data from an uncompressed source or
        /// if you wish to create your texture pixel by pixel.</summary>
        /// <param name="data">define the array of data to use to create the texture</param>
        /// <param name="width">define the width of the texture</param>
        /// <param name="height">define the height of the texture</param>
        /// <param name="format">define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)</param>
        /// <param name="scene">define the scene the texture belongs to</param>
        /// <param name="generateMipMaps">define whether mip maps should be generated or not</param>
        /// <param name="invertY">define if the data should be flipped on Y when uploaded to the GPU</param>
        /// <param name="samplingMode">define the texture sampling mode (Texture.xxx_SAMPLINGMODE)</param>
        /// <param name="type">define the format of the data (int, float... Engine.TEXTURETYPE_xxx)</param>
        [<Emit "new $0($1...)">] abstract Create: data: ArrayBufferView * width: float * height: float * format: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?``type``: float -> RawTexture
        /// <summary>Creates a luminance texture from some data.</summary>
        /// <param name="data">Define the texture data</param>
        /// <param name="width">Define the width of the texture</param>
        /// <param name="height">Define the height of the texture</param>
        /// <param name="scene">Define the scene the texture belongs to</param>
        /// <param name="generateMipMaps">Define whether or not to create mip maps for the texture</param>
        /// <param name="invertY">define if the data should be flipped on Y when uploaded to the GPU</param>
        /// <param name="samplingMode">define the texture sampling mode (Texture.xxx_SAMPLINGMODE)</param>
        abstract CreateLuminanceTexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float -> RawTexture
        /// <summary>Creates a luminance alpha texture from some data.</summary>
        /// <param name="data">Define the texture data</param>
        /// <param name="width">Define the width of the texture</param>
        /// <param name="height">Define the height of the texture</param>
        /// <param name="scene">Define the scene the texture belongs to</param>
        /// <param name="generateMipMaps">Define whether or not to create mip maps for the texture</param>
        /// <param name="invertY">define if the data should be flipped on Y when uploaded to the GPU</param>
        /// <param name="samplingMode">define the texture sampling mode (Texture.xxx_SAMPLINGMODE)</param>
        abstract CreateLuminanceAlphaTexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float -> RawTexture
        /// <summary>Creates an alpha texture from some data.</summary>
        /// <param name="data">Define the texture data</param>
        /// <param name="width">Define the width of the texture</param>
        /// <param name="height">Define the height of the texture</param>
        /// <param name="scene">Define the scene the texture belongs to</param>
        /// <param name="generateMipMaps">Define whether or not to create mip maps for the texture</param>
        /// <param name="invertY">define if the data should be flipped on Y when uploaded to the GPU</param>
        /// <param name="samplingMode">define the texture sampling mode (Texture.xxx_SAMPLINGMODE)</param>
        abstract CreateAlphaTexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float -> RawTexture
        /// <summary>Creates a RGB texture from some data.</summary>
        /// <param name="data">Define the texture data</param>
        /// <param name="width">Define the width of the texture</param>
        /// <param name="height">Define the height of the texture</param>
        /// <param name="scene">Define the scene the texture belongs to</param>
        /// <param name="generateMipMaps">Define whether or not to create mip maps for the texture</param>
        /// <param name="invertY">define if the data should be flipped on Y when uploaded to the GPU</param>
        /// <param name="samplingMode">define the texture sampling mode (Texture.xxx_SAMPLINGMODE)</param>
        /// <param name="type">define the format of the data (int, float... Engine.TEXTURETYPE_xxx)</param>
        abstract CreateRGBTexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?``type``: float -> RawTexture
        /// <summary>Creates a RGBA texture from some data.</summary>
        /// <param name="data">Define the texture data</param>
        /// <param name="width">Define the width of the texture</param>
        /// <param name="height">Define the height of the texture</param>
        /// <param name="scene">Define the scene the texture belongs to</param>
        /// <param name="generateMipMaps">Define whether or not to create mip maps for the texture</param>
        /// <param name="invertY">define if the data should be flipped on Y when uploaded to the GPU</param>
        /// <param name="samplingMode">define the texture sampling mode (Texture.xxx_SAMPLINGMODE)</param>
        /// <param name="type">define the format of the data (int, float... Engine.TEXTURETYPE_xxx)</param>
        abstract CreateRGBATexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?``type``: float -> RawTexture
        /// <summary>Creates a R texture from some data.</summary>
        /// <param name="data">Define the texture data</param>
        /// <param name="width">Define the width of the texture</param>
        /// <param name="height">Define the height of the texture</param>
        /// <param name="scene">Define the scene the texture belongs to</param>
        /// <param name="generateMipMaps">Define whether or not to create mip maps for the texture</param>
        /// <param name="invertY">define if the data should be flipped on Y when uploaded to the GPU</param>
        /// <param name="samplingMode">define the texture sampling mode (Texture.xxx_SAMPLINGMODE)</param>
        /// <param name="type">define the format of the data (int, float... Engine.TEXTURETYPE_xxx)</param>
        abstract CreateRTexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?``type``: float -> RawTexture

    /// Class used to store 3D textures containing user data
    type [<AllowNullLiteral>] RawTexture3D =
        inherit Texture
        /// Gets or sets the texture format to use 
        abstract format: float with get, set
        /// <summary>Update the texture with new data</summary>
        /// <param name="data">defines the data to store in the texture</param>
        abstract update: data: ArrayBufferView -> unit

    /// Class used to store 3D textures containing user data
    type [<AllowNullLiteral>] RawTexture3DStatic =
        /// <summary>Create a new RawTexture3D</summary>
        /// <param name="data">defines the data of the texture</param>
        /// <param name="width">defines the width of the texture</param>
        /// <param name="height">defines the height of the texture</param>
        /// <param name="depth">defines the depth of the texture</param>
        /// <param name="format">defines the texture format to use</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="generateMipMaps">defines a boolean indicating if mip levels should be generated (true by default)</param>
        /// <param name="invertY">defines if texture must be stored with Y axis inverted</param>
        /// <param name="samplingMode">defines the sampling mode to use (BABYLON.Texture.TRILINEAR_SAMPLINGMODE by default)</param>
        /// <param name="textureType">defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)</param>
        [<Emit "new $0($1...)">] abstract Create: data: ArrayBufferView * width: float * height: float * depth: float * format: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?textureType: float -> RawTexture3D

    /// Creates a refraction texture used by refraction channel of the standard material.
    /// It is like a mirror but to see through a material.
    type [<AllowNullLiteral>] RefractionTexture =
        inherit RenderTargetTexture
        /// Define the reflection plane we want to use. The refractionPlane is usually set to the constructed refractor.
        /// It is possible to directly set the refractionPlane by directly using a BABYLON.Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the refractionPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the refractor as stated in the doc.
        abstract refractionPlane: Plane with get, set
        /// Define how deep under the surface we should see.
        abstract depth: float with get, set
        /// Clone the refraction texture.
        abstract clone: unit -> RefractionTexture
        /// Serialize the texture to a JSON representation you could use in Parse later on
        abstract serialize: unit -> obj option

    /// Creates a refraction texture used by refraction channel of the standard material.
    /// It is like a mirror but to see through a material.
    type [<AllowNullLiteral>] RefractionTextureStatic =
        /// <summary>Creates a refraction texture used by refraction channel of the standard material.
        /// It is like a mirror but to see through a material.</summary>
        /// <param name="name">Define the texture name</param>
        /// <param name="size">Define the size of the underlying texture</param>
        /// <param name="scene">Define the scene the refraction belongs to</param>
        /// <param name="generateMipMaps">Define if we need to generate mips level for the refraction</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * size: float * scene: Scene * ?generateMipMaps: bool -> RefractionTexture

    /// This Helps creating a texture that will be created from a camera in your scene.
    /// It is basically a dynamic texture that could be used to create special effects for instance.
    /// Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...
    type [<AllowNullLiteral>] RenderTargetTexture =
        inherit Texture
        abstract isCube: bool with get, set
        /// Use this predicate to dynamically define the list of mesh you want to render.
        /// If set, the renderList property will be overwritten.
        abstract renderListPredicate: (AbstractMesh -> bool) with get, set
        /// Use this list to define the list of mesh you want to render.
        abstract renderList: Nullable<Array<AbstractMesh>> with get, set
        /// Define if particles should be rendered in your texture.
        abstract renderParticles: bool with get, set
        /// Define if sprites should be rendered in your texture.
        abstract renderSprites: bool with get, set
        /// Override the default coordinates mode to projection for RTT as it is the most common case for rendered textures.
        abstract coordinatesMode: float with get, set
        /// Define the camera used to render the texture.
        abstract activeCamera: Nullable<Camera> with get, set
        /// Override the render function of the texture with your own one.
        abstract customRenderFunction: (SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> (unit -> unit) -> unit) with get, set
        /// Define if camera post processes should be use while rendering the texture.
        abstract useCameraPostProcesses: bool with get, set
        /// Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.
        abstract ignoreCameraViewport: bool with get, set
        /// An event triggered when the texture is unbind.
        abstract onBeforeBindObservable: Observable<RenderTargetTexture> with get, set
        /// An event triggered when the texture is unbind.
        abstract onAfterUnbindObservable: Observable<RenderTargetTexture> with get, set
        /// Set a after unbind callback in the texture.
        /// This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.
        abstract onAfterUnbind: (unit -> unit) with get, set
        /// An event triggered before rendering the texture
        abstract onBeforeRenderObservable: Observable<float> with get, set
        /// Set a before render callback in the texture.
        /// This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.
        abstract onBeforeRender: (float -> unit) with get, set
        /// An event triggered after rendering the texture
        abstract onAfterRenderObservable: Observable<float> with get, set
        /// Set a after render callback in the texture.
        /// This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.
        abstract onAfterRender: (float -> unit) with get, set
        /// An event triggered after the texture clear
        abstract onClearObservable: Observable<Engine> with get, set
        /// Set a clear callback in the texture.
        /// This has been kept for backward compatibility and use of onClearObservable is recommended.
        abstract onClear: (Engine -> unit) with get, set
        /// Define the clear color of the Render Target if it should be different from the scene.
        abstract clearColor: Color4 with get, set
        abstract _size: U2<float, TypeLiteral_08> with get, set
        abstract _initialSizeParameter: U3<float, TypeLiteral_08, TypeLiteral_40> with get, set
        abstract _sizeRatio: Nullable<float> with get, set
        abstract _generateMipMaps: bool with get, set
        abstract _renderingManager: RenderingManager with get, set
        abstract _waitingRenderList: ResizeArray<string> with get, set
        abstract _doNotChangeAspectRatio: bool with get, set
        abstract _currentRefreshId: float with get, set
        abstract _refreshRate: float with get, set
        abstract _textureMatrix: Matrix with get, set
        abstract _samples: float with get, set
        abstract _renderTargetOptions: RenderTargetCreationOptions with get, set
        /// Gets render target creation options that were used.
        abstract renderTargetOptions: RenderTargetCreationOptions
        abstract _engine: Engine with get, set
        abstract _onRatioRescale: unit -> unit
        /// Gets or sets the center of the bounding box associated with the texture (when in cube mode)
        /// It must define where the camera used to render the texture is set
        abstract boundingBoxPosition: Vector3 with get, set
        /// Gets or sets the size of the bounding box associated with the texture (when in cube mode)
        /// When defined, the cubemap will switch to local mode
        abstract boundingBoxSize: Vector3 with get, set
        /// In case the RTT has been created with a depth texture, get the associated
        /// depth texture.
        /// Otherwise, return null.
        abstract depthStencilTexture: Nullable<InternalTexture> with get, set
        /// <summary>Creates a depth stencil texture.
        /// This is only available in WebGL 2 or with the depth texture extension available.</summary>
        /// <param name="comparisonFunction">Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode</param>
        /// <param name="bilinearFiltering">Specifies whether or not bilinear filtering is enable on the texture</param>
        /// <param name="generateStencil">Specifies whether or not a stencil should be allocated in the texture</param>
        abstract createDepthStencilTexture: ?comparisonFunction: float * ?bilinearFiltering: bool * ?generateStencil: bool -> unit
        /// Define the number of samples to use in case of MSAA.
        /// It defaults to one meaning no MSAA has been enabled.
        abstract samples: float with get, set
        /// Resets the refresh counter of the texture and start bak from scratch.
        /// Could be usefull to regenerate the texture if it is setup to render only once.
        abstract resetRefreshCounter: unit -> unit
        /// Define the refresh rate of the texture or the rendering frequency.
        /// Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
        abstract refreshRate: float with get, set
        /// <summary>Adds a post process to the render target rendering passes.</summary>
        /// <param name="postProcess">define the post process to add</param>
        abstract addPostProcess: postProcess: PostProcess -> unit
        /// <summary>Clear all the post processes attached to the render target</summary>
        /// <param name="dispose">define if the cleared post processesshould also be disposed (false by default)</param>
        abstract clearPostProcesses: ?dispose: bool -> unit
        /// <summary>Remove one of the post process from the list of attached post processes to the texture</summary>
        /// <param name="postProcess">define the post process to remove from the list</param>
        abstract removePostProcess: postProcess: PostProcess -> unit
        abstract _shouldRender: unit -> bool
        /// Gets the actual render size of the texture.
        abstract getRenderSize: unit -> float
        /// Gets the actual render width of the texture.
        abstract getRenderWidth: unit -> float
        /// Gets the actual render height of the texture.
        abstract getRenderHeight: unit -> float
        /// Get if the texture can be rescaled or not.
        abstract canRescale: bool
        /// <summary>Resize the texture using a ratio.</summary>
        /// <param name="ratio">the ratio to apply to the texture size in order to compute the new target size</param>
        abstract scale: ratio: float -> unit
        /// Get the texture reflection matrix used to rotate/transform the reflection.
        abstract getReflectionTextureMatrix: unit -> Matrix
        /// <summary>Resize the texture to a new desired size.
        /// Be carrefull as it will recreate all the data in the new texture.</summary>
        /// <param name="size">Define the new size. It can be:
        /// - a number for squared texture,
        /// - an object containing { width: number, height: number }
        /// - or an object containing a ratio { ratio: number }</param>
        abstract resize: size: U3<float, TypeLiteral_08, TypeLiteral_40> -> unit
        /// <summary>Renders all the objects from the render list into the texture.</summary>
        /// <param name="useCameraPostProcess">Define if camera post processes should be used during the rendering</param>
        /// <param name="dumpForDebug">Define if the rendering result should be dumped (copied) for debugging purpose</param>
        abstract render: ?useCameraPostProcess: bool * ?dumpForDebug: bool -> unit
        abstract unbindFrameBuffer: engine: Engine * faceIndex: float -> unit
        /// <summary>Overrides the default sort function applied in the renderging group to prepare the meshes.
        /// This allowed control for front to back rendering or reversly depending of the special needs.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="opaqueSortCompareFn">The opaque queue comparison function use to sort.</param>
        /// <param name="alphaTestSortCompareFn">The alpha test queue comparison function use to sort.</param>
        /// <param name="transparentSortCompareFn">The transparent queue comparison function use to sort.</param>
        abstract setRenderingOrder: renderingGroupId: float * ?opaqueSortCompareFn: (SubMesh -> SubMesh -> float) * ?alphaTestSortCompareFn: (SubMesh -> SubMesh -> float) * ?transparentSortCompareFn: (SubMesh -> SubMesh -> float) -> unit
        /// <summary>Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="autoClearDepthStencil">Automatically clears depth and stencil between groups if true.</param>
        abstract setRenderingAutoClearDepthStencil: renderingGroupId: float * autoClearDepthStencil: bool -> unit
        /// Clones the texture.
        abstract clone: unit -> RenderTargetTexture
        /// Serialize the texture to a JSON representation we can easily use in the resepective Parse function.
        abstract serialize: unit -> obj option
        /// This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore
        abstract disposeFramebufferObjects: unit -> unit
        /// Dispose the texture and release its associated resources.
        abstract dispose: unit -> unit
        abstract _rebuild: unit -> unit
        /// Clear the info related to rendering groups preventing retention point in material dispose.
        abstract freeRenderingGroups: unit -> unit

    /// This Helps creating a texture that will be created from a camera in your scene.
    /// It is basically a dynamic texture that could be used to create special effects for instance.
    /// Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...
    type [<AllowNullLiteral>] RenderTargetTextureStatic =
        /// The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.
        abstract REFRESHRATE_RENDER_ONCE: float
        /// The texture will only be rendered rendered every frame and is recomended for dynamic contents.
        abstract REFRESHRATE_RENDER_ONEVERYFRAME: float
        /// The texture will be rendered every 2 frames which could be enough if your dynamic objects are not
        /// the central point of your effect and can save a lot of performances.
        abstract REFRESHRATE_RENDER_ONEVERYTWOFRAMES: float
        /// <summary>Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post processse
        /// or used a shadow, depth texture...</summary>
        /// <param name="name">The friendly name of the texture</param>
        /// <param name="size">The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)</param>
        /// <param name="scene">The scene the RTT belongs to. The latest created scene will be used if not precised.</param>
        /// <param name="generateMipMaps">True if mip maps need to be generated after render.</param>
        /// <param name="doNotChangeAspectRatio">True to not change the aspect ratio of the scene in the RTT</param>
        /// <param name="type">The type of the buffer in the RTT (int, half float, float...)</param>
        /// <param name="isCube">True if a cube texture needs to be created</param>
        /// <param name="samplingMode">The sampling mode to be usedwith the render target (Linear, Nearest...)</param>
        /// <param name="generateDepthBuffer">True to generate a depth buffer</param>
        /// <param name="generateStencilBuffer">True to generate a stencil buffer</param>
        /// <param name="isMulti">True if multiple textures need to be created (Draw Buffers)</param>
        /// <param name="format">The internal format of the buffer in the RTT (RED, RG, RGB, RGBA, ALPHA...)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * size: U3<float, TypeLiteral_08, TypeLiteral_40> * scene: Nullable<Scene> * ?generateMipMaps: bool * ?doNotChangeAspectRatio: bool * ?``type``: float * ?isCube: bool * ?samplingMode: float * ?generateDepthBuffer: bool * ?generateStencilBuffer: bool * ?isMulti: bool * ?format: float -> RenderTargetTexture

    /// This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
    type [<AllowNullLiteral>] Texture =
        inherit BaseTexture
        /// Define the url of the texture.
        abstract url: Nullable<string> with get, set
        /// Define an offset on the texture to offset the u coordinates of the UVs
        abstract uOffset: float with get, set
        /// Define an offset on the texture to offset the v coordinates of the UVs
        abstract vOffset: float with get, set
        /// Define an offset on the texture to scale the u coordinates of the UVs
        abstract uScale: float with get, set
        /// Define an offset on the texture to scale the v coordinates of the UVs
        abstract vScale: float with get, set
        /// Define an offset on the texture to rotate around the u coordinates of the UVs
        abstract uAng: float with get, set
        /// Define an offset on the texture to rotate around the v coordinates of the UVs
        abstract vAng: float with get, set
        /// Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)
        abstract wAng: float with get, set
        /// Defines the center of rotation (U)
        abstract uRotationCenter: float with get, set
        /// Defines the center of rotation (V)
        abstract vRotationCenter: float with get, set
        /// Defines the center of rotation (W)
        abstract wRotationCenter: float with get, set
        /// Are mip maps generated for this texture or not.
        abstract noMipmap: bool
        abstract _invertY: bool with get, set
        abstract _samplingMode: float with get, set
        abstract _buffer: Nullable<U4<string, ArrayBuffer, HTMLImageElement, Blob>> with get, set
        abstract _format: Nullable<float> with get, set
        /// Observable triggered once the texture has been loaded.
        abstract onLoadObservable: Observable<Texture> with get, set
        abstract _isBlocking: bool with get, set
        /// Is the texture preventing material to render while loading.
        /// If false, a default texture will be used instead of the loading one during the preparation step.
        abstract isBlocking: bool with get, set
        /// Get the current sampling mode associated with the texture.
        abstract samplingMode: float
        /// <summary>Update the url (and optional buffer) of this texture if url was null during construction.</summary>
        /// <param name="url">the url of the texture</param>
        /// <param name="buffer">the buffer of the texture (defaults to null)</param>
        abstract updateURL: url: string * ?buffer: U4<string, ArrayBuffer, HTMLImageElement, Blob> -> unit
        /// Finish the loading sequence of a texture flagged as delayed load.
        abstract delayLoad: unit -> unit
        /// <summary>Update the sampling mode of the texture.
        /// Default is Trilinear mode.
        /// 
        /// | Value | Type               | Description |
        /// | ----- | ------------------ | ----------- |
        /// | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |
        /// | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |
        /// | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |
        /// | 4     | NEAREST_NEAREST_MIPNEAREST |             |
        /// | 5    | NEAREST_LINEAR_MIPNEAREST |             |
        /// | 6    | NEAREST_LINEAR_MIPLINEAR |             |
        /// | 7    | NEAREST_LINEAR |             |
        /// | 8    | NEAREST_NEAREST |             |
        /// | 9   | LINEAR_NEAREST_MIPNEAREST |             |
        /// | 10   | LINEAR_NEAREST_MIPLINEAR |             |
        /// | 11   | LINEAR_LINEAR |             |
        /// | 12   | LINEAR_NEAREST |             |
        /// 
        ///    > _mag_: magnification filter (close to the viewer)
        ///    > _min_: minification filter (far from the viewer)
        ///    > _mip_: filter used between mip map levels</summary>
        /// <param name="samplingMode">Define the new sampling mode of the texture</param>
        abstract updateSamplingMode: samplingMode: float -> unit
        /// Get the current texture matrix which includes the requested offsetting, tiling and rotation components.
        abstract getTextureMatrix: unit -> Matrix
        /// Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.
        abstract getReflectionTextureMatrix: unit -> Matrix
        /// Clones the texture.
        abstract clone: unit -> Texture
        /// Serialize the texture to a JSON representation we can easily use in the resepective Parse function.
        abstract serialize: unit -> obj option
        /// Get the current class name of the texture usefull for serialization or dynamic coding.
        abstract getClassName: unit -> string
        /// Dispose the texture and release its associated resources.
        abstract dispose: unit -> unit

    /// This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
    type [<AllowNullLiteral>] TextureStatic =
        /// nearest is mag = nearest and min = nearest and mip = linear 
        abstract NEAREST_SAMPLINGMODE: float
        /// nearest is mag = nearest and min = nearest and mip = linear 
        abstract NEAREST_NEAREST_MIPLINEAR: float
        /// Bilinear is mag = linear and min = linear and mip = nearest 
        abstract BILINEAR_SAMPLINGMODE: float
        /// Bilinear is mag = linear and min = linear and mip = nearest 
        abstract LINEAR_LINEAR_MIPNEAREST: float
        /// Trilinear is mag = linear and min = linear and mip = linear 
        abstract TRILINEAR_SAMPLINGMODE: float
        /// Trilinear is mag = linear and min = linear and mip = linear 
        abstract LINEAR_LINEAR_MIPLINEAR: float
        /// mag = nearest and min = nearest and mip = nearest 
        abstract NEAREST_NEAREST_MIPNEAREST: float
        /// mag = nearest and min = linear and mip = nearest 
        abstract NEAREST_LINEAR_MIPNEAREST: float
        /// mag = nearest and min = linear and mip = linear 
        abstract NEAREST_LINEAR_MIPLINEAR: float
        /// mag = nearest and min = linear and mip = none 
        abstract NEAREST_LINEAR: float
        /// mag = nearest and min = nearest and mip = none 
        abstract NEAREST_NEAREST: float
        /// mag = linear and min = nearest and mip = nearest 
        abstract LINEAR_NEAREST_MIPNEAREST: float
        /// mag = linear and min = nearest and mip = linear 
        abstract LINEAR_NEAREST_MIPLINEAR: float
        /// mag = linear and min = linear and mip = none 
        abstract LINEAR_LINEAR: float
        /// mag = linear and min = nearest and mip = none 
        abstract LINEAR_NEAREST: float
        /// Explicit coordinates mode 
        abstract EXPLICIT_MODE: float
        /// Spherical coordinates mode 
        abstract SPHERICAL_MODE: float
        /// Planar coordinates mode 
        abstract PLANAR_MODE: float
        /// Cubic coordinates mode 
        abstract CUBIC_MODE: float
        /// Projection coordinates mode 
        abstract PROJECTION_MODE: float
        /// Inverse Cubic coordinates mode 
        abstract SKYBOX_MODE: float
        /// Inverse Cubic coordinates mode 
        abstract INVCUBIC_MODE: float
        /// Equirectangular coordinates mode 
        abstract EQUIRECTANGULAR_MODE: float
        /// Equirectangular Fixed coordinates mode 
        abstract FIXED_EQUIRECTANGULAR_MODE: float
        /// Equirectangular Fixed Mirrored coordinates mode 
        abstract FIXED_EQUIRECTANGULAR_MIRRORED_MODE: float
        /// Texture is not repeating outside of 0..1 UVs 
        abstract CLAMP_ADDRESSMODE: float
        /// Texture is repeating outside of 0..1 UVs 
        abstract WRAP_ADDRESSMODE: float
        /// Texture is repeating and mirrored 
        abstract MIRROR_ADDRESSMODE: float
        /// Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file
        abstract UseSerializedUrlIfAny: bool with get, set
        /// <summary>Instantiates a new texture.
        /// This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.</summary>
        /// <param name="url">define the url of the picture to load as a texture</param>
        /// <param name="scene">define the scene the texture will belong to</param>
        /// <param name="noMipmap">define if the texture will require mip maps or not</param>
        /// <param name="invertY">define if the texture needs to be inverted on the y axis during loading</param>
        /// <param name="samplingMode">define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)</param>
        /// <param name="onLoad">define a callback triggered when the texture has been loaded</param>
        /// <param name="onError">define a callback triggered when an error occurred during the loading session</param>
        /// <param name="buffer">define the buffer to load the texture from in case the texture is loaded from a buffer representation</param>
        /// <param name="deleteBuffer">define if the buffer we are loading the texture from should be deleted after load</param>
        /// <param name="format">define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)</param>
        [<Emit "new $0($1...)">] abstract Create: url: Nullable<string> * scene: Nullable<Scene> * ?noMipmap: bool * ?invertY: bool * ?samplingMode: float * ?onLoad: (unit -> unit) * ?onError: (string -> obj -> unit) * ?buffer: U4<string, ArrayBuffer, HTMLImageElement, Blob> * ?deleteBuffer: bool * ?format: float -> Texture
        /// <summary>Parse the JSON representation of a texture in order to recreate the texture in the given scene.</summary>
        /// <param name="parsedTexture">Define the JSON representation of the texture</param>
        /// <param name="scene">Define the scene the parsed texture should be instantiated in</param>
        /// <param name="rootUrl">Define the root url of the parsing sequence in the case of relative dependencies</param>
        abstract Parse: parsedTexture: obj option * scene: Scene * rootUrl: string -> Nullable<BaseTexture>
        /// <summary>Creates a texture from its base 64 representation.</summary>
        /// <param name="data">Define the base64 payload without the data: prefix</param>
        /// <param name="name">Define the name of the texture in the scene useful fo caching purpose for instance</param>
        /// <param name="scene">Define the scene the texture should belong to</param>
        /// <param name="noMipmap">Forces the texture to not create mip map information if true</param>
        /// <param name="invertY">define if the texture needs to be inverted on the y axis during loading</param>
        /// <param name="samplingMode">define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)</param>
        /// <param name="onLoad">define a callback triggered when the texture has been loaded</param>
        /// <param name="onError">define a callback triggered when an error occurred during the loading session</param>
        /// <param name="format">define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)</param>
        abstract CreateFromBase64String: data: string * name: string * scene: Scene * ?noMipmap: bool * ?invertY: bool * ?samplingMode: float * ?onLoad: (unit -> unit) * ?onError: (unit -> unit) * ?format: float -> Texture
        /// <summary>Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)</summary>
        /// <param name="name">Define the name of the texture in the scene useful fo caching purpose for instance</param>
        /// <param name="buffer">define the buffer to load the texture from in case the texture is loaded from a buffer representation</param>
        /// <param name="scene">Define the scene the texture should belong to</param>
        /// <param name="deleteBuffer">define if the buffer we are loading the texture from should be deleted after load</param>
        /// <param name="noMipmap">Forces the texture to not create mip map information if true</param>
        /// <param name="invertY">define if the texture needs to be inverted on the y axis during loading</param>
        /// <param name="samplingMode">define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)</param>
        /// <param name="onLoad">define a callback triggered when the texture has been loaded</param>
        /// <param name="onError">define a callback triggered when an error occurred during the loading session</param>
        /// <param name="format">define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)</param>
        abstract LoadFromDataString: name: string * buffer: obj option * scene: Scene * ?deleteBuffer: bool * ?noMipmap: bool * ?invertY: bool * ?samplingMode: float * ?onLoad: (unit -> unit) * ?onError: (string -> obj -> unit) * ?format: float -> Texture

    /// Settings for finer control over video usage
    type [<AllowNullLiteral>] VideoTextureSettings =
        /// Applies `autoplay` to video, if specified
        abstract autoPlay: bool option with get, set
        /// Applies `loop` to video, if specified
        abstract loop: bool option with get, set
        /// Automatically updates internal texture from video at every frame in the render loop
        abstract autoUpdateTexture: bool with get, set
        /// Image src displayed during the video loading or until the user interacts with the video.
        abstract poster: string option with get, set

    /// If you want to display a video in your scene, this is the special texture for that.
    /// This special texture works similar to other textures, with the exception of a few parameters.
    type [<AllowNullLiteral>] VideoTexture =
        inherit Texture
        /// Tells whether textures will be updated automatically or user is required to call `updateTexture` manually
        abstract autoUpdateTexture: bool
        /// The video instance used by the texture internally
        abstract video: HTMLVideoElement
        /// Event triggerd when a dom action is required by the user to play the video.
        /// This happens due to recent changes in browser policies preventing video to auto start.
        abstract onUserActionRequestedObservable: Observable<Texture>
        abstract _rebuild: unit -> unit
        /// Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.
        abstract update: unit -> unit
        /// <summary>Update Texture in `manual` mode. Does not do anything if not visible or paused.</summary>
        /// <param name="isVisible">Visibility state, detected by user using `scene.getActiveMeshes()` or othervise.</param>
        abstract updateTexture: isVisible: bool -> unit
        abstract _updateInternalTexture: (Event -> unit) with get, set
        /// <summary>Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.</summary>
        /// <param name="url">New url.</param>
        abstract updateURL: url: string -> unit
        /// Dispose the texture and release its associated resources.
        abstract dispose: unit -> unit

    /// If you want to display a video in your scene, this is the special texture for that.
    /// This special texture works similar to other textures, with the exception of a few parameters.
    type [<AllowNullLiteral>] VideoTextureStatic =
        /// <summary>Creates a video texture.
        /// If you want to display a video in your scene, this is the special texture for that.
        /// This special texture works similar to other textures, with the exception of a few parameters.</summary>
        /// <param name="name">optional name, will detect from video source, if not defined</param>
        /// <param name="src">can be used to provide an url, array of urls or an already setup HTML video element.</param>
        /// <param name="scene">is obviously the current scene.</param>
        /// <param name="generateMipMaps">can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).</param>
        /// <param name="invertY">is false by default but can be used to invert video on Y axis</param>
        /// <param name="samplingMode">controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default</param>
        /// <param name="settings">allows finer control over video usage</param>
        [<Emit "new $0($1...)">] abstract Create: name: Nullable<string> * src: U3<string, ResizeArray<string>, HTMLVideoElement> * scene: Nullable<Scene> * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?settings: VideoTextureSettings -> VideoTexture
        /// <summary>Creates a video texture straight from your WebCam video feed.</summary>
        /// <param name="scene">Define the scene the texture should be created in</param>
        /// <param name="onReady">Define a callback to triggered once the texture will be ready</param>
        /// <param name="constraints">Define the constraints to use to create the web cam feed from WebRTC</param>
        abstract CreateFromWebCam: scene: Scene * onReady: (VideoTexture -> unit) * constraints: VideoTextureStaticCreateFromWebCamConstraints -> unit

    type [<AllowNullLiteral>] VideoTextureStaticCreateFromWebCamConstraints =
        abstract minWidth: float with get, set
        abstract maxWidth: float with get, set
        abstract minHeight: float with get, set
        abstract maxHeight: float with get, set
        abstract deviceId: string with get, set

    /// Configuration for Draco compression
    type [<AllowNullLiteral>] IDracoCompressionConfiguration =
        /// Configuration for the decoder.
        abstract decoder: TypeLiteral_41 option with get, set

    /// Draco compression (https://google.github.io/draco/)
    /// 
    /// This class wraps the Draco module.
    /// 
    /// **Encoder**
    /// 
    /// The encoder is not currently implemented.
    /// 
    /// **Decoder**
    /// 
    /// By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.
    /// 
    /// To update the configuration, use the following code:
    /// ```javascript
    ///      BABYLON.DracoCompression.Configuration = {
    ///          decoder: {
    ///              wasmUrl: "<url to the WebAssembly library>",
    ///              wasmBinaryUrl: "<url to the WebAssembly binary>",
    ///              fallbackUrl: "<url to the fallback JavaScript library>",
    ///          }
    ///      };
    /// ```
    /// 
    /// Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support Webssembly or only support the JavaScript version.
    /// Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.
    /// Use `BABYLON.DracoCompression.DecoderAvailable` to determine if the decoder is available for the current session.
    /// 
    /// To decode Draco compressed data, create a DracoCompression object and call decodeMeshAsync:
    /// ```javascript
    ///      var dracoCompression = new BABYLON.DracoCompression();
    ///      var vertexData = await dracoCompression.decodeMeshAsync(data, {
    ///          [BABYLON.VertexBuffer.PositionKind]: 0
    ///      });
    /// ```
    type [<AllowNullLiteral>] DracoCompression =
        inherit IDisposable
        /// Stop all async operations and release resources.
        abstract dispose: unit -> unit
        /// <summary>Decode Draco compressed mesh data to vertex data.</summary>
        /// <param name="data">The ArrayBuffer or ArrayBufferView for the Draco compression data</param>
        /// <param name="attributes">A map of attributes from vertex buffer kinds to Draco unique ids</param>
        abstract decodeMeshAsync: data: U2<ArrayBuffer, ArrayBufferView> * attributes: DracoCompressionDecodeMeshAsyncAttributes -> Promise<VertexData>

    type [<AllowNullLiteral>] DracoCompressionDecodeMeshAsyncAttributes =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: kind: string -> float with get, set

    /// Draco compression (https://google.github.io/draco/)
    /// 
    /// This class wraps the Draco module.
    /// 
    /// **Encoder**
    /// 
    /// The encoder is not currently implemented.
    /// 
    /// **Decoder**
    /// 
    /// By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.
    /// 
    /// To update the configuration, use the following code:
    /// ```javascript
    ///      BABYLON.DracoCompression.Configuration = {
    ///          decoder: {
    ///              wasmUrl: "<url to the WebAssembly library>",
    ///              wasmBinaryUrl: "<url to the WebAssembly binary>",
    ///              fallbackUrl: "<url to the fallback JavaScript library>",
    ///          }
    ///      };
    /// ```
    /// 
    /// Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support Webssembly or only support the JavaScript version.
    /// Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.
    /// Use `BABYLON.DracoCompression.DecoderAvailable` to determine if the decoder is available for the current session.
    /// 
    /// To decode Draco compressed data, create a DracoCompression object and call decodeMeshAsync:
    /// ```javascript
    ///      var dracoCompression = new BABYLON.DracoCompression();
    ///      var vertexData = await dracoCompression.decodeMeshAsync(data, {
    ///          [BABYLON.VertexBuffer.PositionKind]: 0
    ///      });
    /// ```
    type [<AllowNullLiteral>] DracoCompressionStatic =
        /// The configuration. Defaults to the following urls:
        /// - wasmUrl: "https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js"
        /// - wasmBinaryUrl: "https://preview.babylonjs.com/draco_decoder_gltf.wasm"
        /// - fallbackUrl: "https://preview.babylonjs.com/draco_decoder_gltf.js"
        abstract Configuration: IDracoCompressionConfiguration with get, set
        /// Returns true if the decoder is available.
        abstract DecoderAvailable: bool
        /// Constructor
        [<Emit "new $0($1...)">] abstract Create: unit -> DracoCompression

    /// Particle emitter emitting particles from the inside of a box.
    /// It emits the particles randomly between 2 given directions.
    type [<AllowNullLiteral>] BoxParticleEmitter =
        inherit IParticleEmitterType
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        abstract direction1: Vector3 with get, set
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        abstract direction2: Vector3 with get, set
        /// Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
        abstract minEmitBox: Vector3 with get, set
        /// Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
        abstract maxEmitBox: Vector3 with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> BoxParticleEmitter
        /// <summary>Called by the GPUParticleSystem to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "BoxParticleEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a box.
    /// It emits the particles randomly between 2 given directions.
    type [<AllowNullLiteral>] BoxParticleEmitterStatic =
        /// Creates a new instance BoxParticleEmitter
        [<Emit "new $0($1...)">] abstract Create: unit -> BoxParticleEmitter

    /// Particle emitter emitting particles from the inside of a cone.
    /// It emits the particles alongside the cone volume from the base to the particle.
    /// The emission direction might be randomized.
    type [<AllowNullLiteral>] ConeParticleEmitter =
        inherit IParticleEmitterType
        /// defines how much to randomize the particle direction [0-1] (default is 0) 
        abstract directionRandomizer: float with get, set
        /// Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)
        abstract radiusRange: float with get, set
        /// Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)
        abstract heightRange: float with get, set
        /// Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)
        abstract emitFromSpawnPointOnly: bool with get, set
        /// Gets or sets the radius of the emission cone
        abstract radius: float with get, set
        /// Gets or sets the angle of the emission cone
        abstract angle: float with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> ConeParticleEmitter
        /// <summary>Called by the GPUParticleSystem to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "ConeParticleEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a cone.
    /// It emits the particles alongside the cone volume from the base to the particle.
    /// The emission direction might be randomized.
    type [<AllowNullLiteral>] ConeParticleEmitterStatic =
        /// <summary>Creates a new instance ConeParticleEmitter</summary>
        /// <param name="radius">the radius of the emission cone (1 by default)</param>
        /// <param name="directionRandomizer">defines how much to randomize the particle direction [0-1] (default is 0)</param>
        [<Emit "new $0($1...)">] abstract Create: ?radius: float * ?angle: float * ?directionRandomizer: float -> ConeParticleEmitter

    /// Particle emitter emitting particles from the inside of a cylinder.
    /// It emits the particles alongside the cylinder radius. The emission direction might be randomized.
    type [<AllowNullLiteral>] CylinderParticleEmitter =
        inherit IParticleEmitterType
        /// The radius of the emission cylinder.
        abstract radius: float with get, set
        /// The height of the emission cylinder.
        abstract height: float with get, set
        /// The range of emission [0-1] 0 Surface only, 1 Entire Radius.
        abstract radiusRange: float with get, set
        /// How much to randomize the particle direction [0-1].
        abstract directionRandomizer: float with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> CylinderParticleEmitter
        /// <summary>Called by the GPUParticleSystem to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "CylinderParticleEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a cylinder.
    /// It emits the particles alongside the cylinder radius. The emission direction might be randomized.
    type [<AllowNullLiteral>] CylinderParticleEmitterStatic =
        /// <summary>Creates a new instance CylinderParticleEmitter</summary>
        /// <param name="radius">the radius of the emission cylinder (1 by default)</param>
        /// <param name="height">the height of the emission cylinder (1 by default)</param>
        /// <param name="radiusRange">the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)</param>
        /// <param name="directionRandomizer">defines how much to randomize the particle direction [0-1]</param>
        [<Emit "new $0($1...)">] abstract Create: ?radius: float * ?height: float * ?radiusRange: float * ?directionRandomizer: float -> CylinderParticleEmitter

    /// Particle emitter emitting particles from the inside of a cylinder.
    /// It emits the particles randomly between two vectors.
    type [<AllowNullLiteral>] CylinderDirectedParticleEmitter =
        inherit CylinderParticleEmitter
        /// The min limit of the emission direction.
        abstract direction1: Vector3 with get, set
        /// The max limit of the emission direction.
        abstract direction2: Vector3 with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> CylinderDirectedParticleEmitter
        /// <summary>Called by the GPUParticleSystem to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "CylinderDirectedParticleEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a cylinder.
    /// It emits the particles randomly between two vectors.
    type [<AllowNullLiteral>] CylinderDirectedParticleEmitterStatic =
        /// <summary>Creates a new instance CylinderDirectedParticleEmitter</summary>
        /// <param name="radius">the radius of the emission cylinder (1 by default)</param>
        /// <param name="height">the height of the emission cylinder (1 by default)</param>
        /// <param name="radiusRange">the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)</param>
        /// <param name="direction1">the min limit of the emission direction (up vector by default)</param>
        /// <param name="direction2">the max limit of the emission direction (up vector by default)</param>
        [<Emit "new $0($1...)">] abstract Create: ?radius: float * ?height: float * ?radiusRange: float * ?direction1: Vector3 * ?direction2: Vector3 -> CylinderDirectedParticleEmitter

    /// Particle emitter emitting particles from the inside of a hemisphere.
    /// It emits the particles alongside the hemisphere radius. The emission direction might be randomized.
    type [<AllowNullLiteral>] HemisphericParticleEmitter =
        inherit IParticleEmitterType
        /// The radius of the emission hemisphere.
        abstract radius: float with get, set
        /// The range of emission [0-1] 0 Surface only, 1 Entire Radius.
        abstract radiusRange: float with get, set
        /// How much to randomize the particle direction [0-1].
        abstract directionRandomizer: float with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> HemisphericParticleEmitter
        /// <summary>Called by the GPUParticleSystem to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "HemisphericParticleEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a hemisphere.
    /// It emits the particles alongside the hemisphere radius. The emission direction might be randomized.
    type [<AllowNullLiteral>] HemisphericParticleEmitterStatic =
        /// <summary>Creates a new instance HemisphericParticleEmitter</summary>
        /// <param name="radius">the radius of the emission hemisphere (1 by default)</param>
        /// <param name="radiusRange">the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)</param>
        /// <param name="directionRandomizer">defines how much to randomize the particle direction [0-1]</param>
        [<Emit "new $0($1...)">] abstract Create: ?radius: float * ?radiusRange: float * ?directionRandomizer: float -> HemisphericParticleEmitter

    /// Particle emitter represents a volume emitting particles.
    /// This is the responsibility of the implementation to define the volume shape like cone/sphere/box.
    type [<AllowNullLiteral>] IParticleEmitterType =
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> IParticleEmitterType
        /// <summary>Called by the GPUParticleSystem to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns a string representing the class name
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from a point.
    /// It emits the particles randomly between 2 given directions.
    type [<AllowNullLiteral>] PointParticleEmitter =
        inherit IParticleEmitterType
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        abstract direction1: Vector3 with get, set
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        abstract direction2: Vector3 with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> PointParticleEmitter
        /// <summary>Called by the GPUParticleSystem to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "PointParticleEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from a point.
    /// It emits the particles randomly between 2 given directions.
    type [<AllowNullLiteral>] PointParticleEmitterStatic =
        /// Creates a new instance PointParticleEmitter
        [<Emit "new $0($1...)">] abstract Create: unit -> PointParticleEmitter

    /// Particle emitter emitting particles from the inside of a sphere.
    /// It emits the particles alongside the sphere radius. The emission direction might be randomized.
    type [<AllowNullLiteral>] SphereParticleEmitter =
        inherit IParticleEmitterType
        /// The radius of the emission sphere.
        abstract radius: float with get, set
        /// The range of emission [0-1] 0 Surface only, 1 Entire Radius.
        abstract radiusRange: float with get, set
        /// How much to randomize the particle direction [0-1].
        abstract directionRandomizer: float with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> SphereParticleEmitter
        /// <summary>Called by the GPUParticleSystem to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "SphereParticleEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a sphere.
    /// It emits the particles alongside the sphere radius. The emission direction might be randomized.
    type [<AllowNullLiteral>] SphereParticleEmitterStatic =
        /// <summary>Creates a new instance SphereParticleEmitter</summary>
        /// <param name="radius">the radius of the emission sphere (1 by default)</param>
        /// <param name="radiusRange">the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)</param>
        /// <param name="directionRandomizer">defines how much to randomize the particle direction [0-1]</param>
        [<Emit "new $0($1...)">] abstract Create: ?radius: float * ?radiusRange: float * ?directionRandomizer: float -> SphereParticleEmitter

    /// Particle emitter emitting particles from the inside of a sphere.
    /// It emits the particles randomly between two vectors.
    type [<AllowNullLiteral>] SphereDirectedParticleEmitter =
        inherit SphereParticleEmitter
        /// The min limit of the emission direction.
        abstract direction1: Vector3 with get, set
        /// The max limit of the emission direction.
        abstract direction2: Vector3 with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> SphereDirectedParticleEmitter
        /// <summary>Called by the GPUParticleSystem to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "SphereDirectedParticleEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a sphere.
    /// It emits the particles randomly between two vectors.
    type [<AllowNullLiteral>] SphereDirectedParticleEmitterStatic =
        /// <summary>Creates a new instance SphereDirectedParticleEmitter</summary>
        /// <param name="radius">the radius of the emission sphere (1 by default)</param>
        /// <param name="direction1">the min limit of the emission direction (up vector by default)</param>
        /// <param name="direction2">the max limit of the emission direction (up vector by default)</param>
        [<Emit "new $0($1...)">] abstract Create: ?radius: float * ?direction1: Vector3 * ?direction2: Vector3 -> SphereDirectedParticleEmitter

    type [<AllowNullLiteral>] CannonJSPlugin =
        inherit IPhysicsEnginePlugin
        abstract world: obj option with get, set
        abstract name: string with get, set
        abstract BJSCANNON: obj option with get, set
        abstract setGravity: gravity: Vector3 -> unit
        abstract setTimeStep: timeStep: float -> unit
        abstract getTimeStep: unit -> float
        abstract executeStep: delta: float * impostors: Array<PhysicsImpostor> -> unit
        abstract applyImpulse: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract applyForce: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract generatePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract removePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract generateJoint: impostorJoint: PhysicsImpostorJoint -> unit
        abstract removeJoint: impostorJoint: PhysicsImpostorJoint -> unit
        abstract setTransformationFromPhysicsBody: impostor: PhysicsImpostor -> unit
        abstract setPhysicsBodyTransformation: impostor: PhysicsImpostor * newPosition: Vector3 * newRotation: Quaternion -> unit
        abstract isSupported: unit -> bool
        abstract setLinearVelocity: impostor: PhysicsImpostor * velocity: Vector3 -> unit
        abstract setAngularVelocity: impostor: PhysicsImpostor * velocity: Vector3 -> unit
        abstract getLinearVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract getAngularVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract setBodyMass: impostor: PhysicsImpostor * mass: float -> unit
        abstract getBodyMass: impostor: PhysicsImpostor -> float
        abstract getBodyFriction: impostor: PhysicsImpostor -> float
        abstract setBodyFriction: impostor: PhysicsImpostor * friction: float -> unit
        abstract getBodyRestitution: impostor: PhysicsImpostor -> float
        abstract setBodyRestitution: impostor: PhysicsImpostor * restitution: float -> unit
        abstract sleepBody: impostor: PhysicsImpostor -> unit
        abstract wakeUpBody: impostor: PhysicsImpostor -> unit
        abstract updateDistanceJoint: joint: PhysicsJoint * maxDistance: float * ?minDistance: float -> unit
        abstract setMotor: joint: IMotorEnabledJoint * ?speed: float * ?maxForce: float * ?motorIndex: float -> unit
        abstract setLimit: joint: IMotorEnabledJoint * upperLimit: float * ?lowerLimit: float -> unit
        abstract syncMeshWithImpostor: mesh: AbstractMesh * impostor: PhysicsImpostor -> unit
        abstract getRadius: impostor: PhysicsImpostor -> float
        abstract getBoxSizeToRef: impostor: PhysicsImpostor * result: Vector3 -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] CannonJSPluginStatic =
        [<Emit "new $0($1...)">] abstract Create: ?_useDeltaForWorldStep: bool * ?iterations: float -> CannonJSPlugin

    type [<AllowNullLiteral>] OimoJSPlugin =
        inherit IPhysicsEnginePlugin
        abstract world: obj option with get, set
        abstract name: string with get, set
        abstract BJSOIMO: obj option with get, set
        abstract setGravity: gravity: Vector3 -> unit
        abstract setTimeStep: timeStep: float -> unit
        abstract getTimeStep: unit -> float
        abstract executeStep: delta: float * impostors: Array<PhysicsImpostor> -> unit
        abstract applyImpulse: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract applyForce: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract generatePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract removePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract generateJoint: impostorJoint: PhysicsImpostorJoint -> unit
        abstract removeJoint: impostorJoint: PhysicsImpostorJoint -> unit
        abstract isSupported: unit -> bool
        abstract setTransformationFromPhysicsBody: impostor: PhysicsImpostor -> unit
        abstract setPhysicsBodyTransformation: impostor: PhysicsImpostor * newPosition: Vector3 * newRotation: Quaternion -> unit
        abstract setLinearVelocity: impostor: PhysicsImpostor * velocity: Vector3 -> unit
        abstract setAngularVelocity: impostor: PhysicsImpostor * velocity: Vector3 -> unit
        abstract getLinearVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract getAngularVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract setBodyMass: impostor: PhysicsImpostor * mass: float -> unit
        abstract getBodyMass: impostor: PhysicsImpostor -> float
        abstract getBodyFriction: impostor: PhysicsImpostor -> float
        abstract setBodyFriction: impostor: PhysicsImpostor * friction: float -> unit
        abstract getBodyRestitution: impostor: PhysicsImpostor -> float
        abstract setBodyRestitution: impostor: PhysicsImpostor * restitution: float -> unit
        abstract sleepBody: impostor: PhysicsImpostor -> unit
        abstract wakeUpBody: impostor: PhysicsImpostor -> unit
        abstract updateDistanceJoint: joint: PhysicsJoint * maxDistance: float * ?minDistance: float -> unit
        abstract setMotor: joint: IMotorEnabledJoint * speed: float * ?maxForce: float * ?motorIndex: float -> unit
        abstract setLimit: joint: IMotorEnabledJoint * upperLimit: float * ?lowerLimit: float * ?motorIndex: float -> unit
        abstract syncMeshWithImpostor: mesh: AbstractMesh * impostor: PhysicsImpostor -> unit
        abstract getRadius: impostor: PhysicsImpostor -> float
        abstract getBoxSizeToRef: impostor: PhysicsImpostor * result: Vector3 -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] OimoJSPluginStatic =
        [<Emit "new $0($1...)">] abstract Create: ?iterations: float -> OimoJSPlugin

    /// This represents a set of one or more post processes in Babylon.
    /// A post process can be used to apply a shader to a texture after it is rendered.
    type [<AllowNullLiteral>] PostProcessRenderEffect =
        /// Name of the effect
        abstract _name: string with get, set
        /// Checks if all the post processes in the effect are supported.
        abstract isSupported: bool
        /// Updates the current state of the effect
        abstract _update: unit -> unit
        /// <summary>Attaches the effect on cameras</summary>
        /// <param name="cameras">The camera to attach to.</param>
        abstract _attachCameras: cameras: Camera -> unit
        /// <summary>Attaches the effect on cameras</summary>
        /// <param name="cameras">The camera to attach to.</param>
        abstract _attachCameras: cameras: ResizeArray<Camera> -> unit
        /// <summary>Detatches the effect on cameras</summary>
        /// <param name="cameras">The camera to detatch from.</param>
        abstract _detachCameras: cameras: Camera -> unit
        /// <summary>Detatches the effect on cameras</summary>
        /// <param name="cameras">The camera to detatch from.</param>
        abstract _detachCameras: cameras: ResizeArray<Camera> -> unit
        /// <summary>Enables the effect on given cameras</summary>
        /// <param name="cameras">The camera to enable.</param>
        abstract _enable: cameras: Camera -> unit
        /// <summary>Enables the effect on given cameras</summary>
        /// <param name="cameras">The camera to enable.</param>
        abstract _enable: cameras: Nullable<ResizeArray<Camera>> -> unit
        /// <summary>Disables the effect on the given cameras</summary>
        /// <param name="cameras">The camera to disable.</param>
        abstract _disable: cameras: Camera -> unit
        /// <summary>Disables the effect on the given cameras</summary>
        /// <param name="cameras">The camera to disable.</param>
        abstract _disable: cameras: Nullable<ResizeArray<Camera>> -> unit
        /// <summary>Gets a list of the post processes contained in the effect.</summary>
        /// <param name="camera">The camera to get the post processes on.</param>
        abstract getPostProcesses: ?camera: Camera -> Nullable<Array<PostProcess>>

    /// This represents a set of one or more post processes in Babylon.
    /// A post process can be used to apply a shader to a texture after it is rendered.
    type [<AllowNullLiteral>] PostProcessRenderEffectStatic =
        /// <summary>Instantiates a post process render effect.
        /// A post process can be used to apply a shader to a texture after it is rendered.</summary>
        /// <param name="engine">The engine the effect is tied to</param>
        /// <param name="name">The name of the effect</param>
        /// <param name="getPostProcesses">A function that returns a set of post processes which the effect will run in order to be run.</param>
        /// <param name="singleInstance">False if this post process can be run on multiple cameras. (default: true)</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * name: string * getPostProcesses: (unit -> Nullable<U2<PostProcess, Array<PostProcess>>>) * ?singleInstance: bool -> PostProcessRenderEffect

    /// PostProcessRenderPipeline
    type [<AllowNullLiteral>] PostProcessRenderPipeline =
        abstract _cameras: ResizeArray<Camera> with get, set
        abstract _name: string with get, set
        /// "PostProcessRenderPipeline"
        abstract getClassName: unit -> string
        /// If all the render effects in the pipeline are support
        abstract isSupported: bool
        /// <summary>Adds an effect to the pipeline</summary>
        /// <param name="renderEffect">the effect to add</param>
        abstract addEffect: renderEffect: PostProcessRenderEffect -> unit
        abstract _rebuild: unit -> unit
        abstract _enableEffect: renderEffectName: string * cameras: Camera -> unit
        abstract _enableEffect: renderEffectName: string * cameras: ResizeArray<Camera> -> unit
        abstract _disableEffect: renderEffectName: string * cameras: Nullable<ResizeArray<Camera>> -> unit
        abstract _attachCameras: cameras: Camera * unique: bool -> unit
        abstract _attachCameras: cameras: ResizeArray<Camera> * unique: bool -> unit
        abstract _detachCameras: cameras: Camera -> unit
        abstract _detachCameras: cameras: Nullable<ResizeArray<Camera>> -> unit
        abstract _update: unit -> unit
        abstract _reset: unit -> unit
        abstract _enableMSAAOnFirstPostProcess: sampleCount: float -> bool
        /// Disposes of the pipeline
        abstract dispose: unit -> unit

    /// PostProcessRenderPipeline
    type [<AllowNullLiteral>] PostProcessRenderPipelineStatic =
        /// <summary>Initializes a PostProcessRenderPipeline</summary>
        /// <param name="engine">engine to add the pipeline to</param>
        /// <param name="name">name of the pipeline</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * name: string -> PostProcessRenderPipeline

    /// PostProcessRenderPipelineManager class
    type [<AllowNullLiteral>] PostProcessRenderPipelineManager =
        /// <summary>Adds a pipeline to the manager</summary>
        /// <param name="renderPipeline">The pipeline to add</param>
        abstract addPipeline: renderPipeline: PostProcessRenderPipeline -> unit
        /// <summary>Attaches a camera to the pipeline</summary>
        /// <param name="renderPipelineName">The name of the pipeline to attach to</param>
        /// <param name="cameras">the camera to attach</param>
        /// <param name="unique">if the camera can be attached multiple times to the pipeline</param>
        abstract attachCamerasToRenderPipeline: renderPipelineName: string * cameras: U3<obj option, ResizeArray<Camera>, Camera> * ?unique: bool -> unit
        /// <summary>Detaches a camera from the pipeline</summary>
        /// <param name="renderPipelineName">The name of the pipeline to detach from</param>
        /// <param name="cameras">the camera to detach</param>
        abstract detachCamerasFromRenderPipeline: renderPipelineName: string * cameras: U3<obj option, ResizeArray<Camera>, Camera> -> unit
        /// <summary>Enables an effect by name on a pipeline</summary>
        /// <param name="renderPipelineName">the name of the pipeline to enable the effect in</param>
        /// <param name="renderEffectName">the name of the effect to enable</param>
        /// <param name="cameras">the cameras that the effect should be enabled on</param>
        abstract enableEffectInPipeline: renderPipelineName: string * renderEffectName: string * cameras: U3<obj option, ResizeArray<Camera>, Camera> -> unit
        /// <summary>Disables an effect by name on a pipeline</summary>
        /// <param name="renderPipelineName">the name of the pipeline to disable the effect in</param>
        /// <param name="renderEffectName">the name of the effect to disable</param>
        /// <param name="cameras">the cameras that the effect should be disabled on</param>
        abstract disableEffectInPipeline: renderPipelineName: string * renderEffectName: string * cameras: U3<obj option, ResizeArray<Camera>, Camera> -> unit
        /// Updates the state of all contained render pipelines and disposes of any non supported pipelines
        abstract update: unit -> unit
        abstract _rebuild: unit -> unit
        /// Disposes of the manager and pipelines
        abstract dispose: unit -> unit

    /// PostProcessRenderPipelineManager class
    type [<AllowNullLiteral>] PostProcessRenderPipelineManagerStatic =
        /// Initializes a PostProcessRenderPipelineManager
        [<Emit "new $0($1...)">] abstract Create: unit -> PostProcessRenderPipelineManager

    /// Defines the Render Pipeline scene component responsible to rendering pipelines
    type [<AllowNullLiteral>] PostProcessRenderPipelineManagerSceneComponent =
        inherit ISceneComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources
        abstract dispose: unit -> unit

    /// Defines the Render Pipeline scene component responsible to rendering pipelines
    type [<AllowNullLiteral>] PostProcessRenderPipelineManagerSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> PostProcessRenderPipelineManagerSceneComponent

    /// Helper class dealing with the extraction of spherical polynomial dataArray
    /// from a cube map.
    type [<AllowNullLiteral>] CubeMapToSphericalPolynomialTools =
        interface end

    /// Helper class dealing with the extraction of spherical polynomial dataArray
    /// from a cube map.
    type [<AllowNullLiteral>] CubeMapToSphericalPolynomialToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CubeMapToSphericalPolynomialTools
        /// <summary>Converts a texture to the according Spherical Polynomial data.
        /// This extracts the first 3 orders only as they are the only one used in the lighting.</summary>
        /// <param name="texture">The texture to extract the information from.</param>
        abstract ConvertCubeMapTextureToSphericalPolynomial: texture: BaseTexture -> Nullable<SphericalPolynomial>
        /// <summary>Converts a cubemap to the according Spherical Polynomial data.
        /// This extracts the first 3 orders only as they are the only one used in the lighting.</summary>
        /// <param name="cubeInfo">The Cube map to extract the information from.</param>
        abstract ConvertCubeMapToSphericalPolynomial: cubeInfo: CubeMapInfo -> SphericalPolynomial

    /// Header information of HDR texture files.
    type [<AllowNullLiteral>] HDRInfo =
        /// The height of the texture in pixels.
        abstract height: float with get, set
        /// The width of the texture in pixels.
        abstract width: float with get, set
        /// The index of the beginning of the data in the binary file.
        abstract dataPosition: float with get, set

    /// This groups tools to convert HDR texture to native colors array.
    type [<AllowNullLiteral>] HDRTools =
        interface end

    /// This groups tools to convert HDR texture to native colors array.
    type [<AllowNullLiteral>] HDRToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> HDRTools
        /// <summary>Reads header information from an RGBE texture stored in a native array.
        /// More information on this format are available here:
        /// https://en.wikipedia.org/wiki/RGBE_image_format</summary>
        /// <param name="uint8array">The binary file stored in  native array.</param>
        abstract RGBE_ReadHeader: uint8array: Uint8Array -> HDRInfo
        /// <summary>Returns the cubemap information (each faces texture data) extracted from an RGBE texture.
        /// This RGBE texture needs to store the information as a panorama.
        /// 
        /// More information on this format are available here:
        /// https://en.wikipedia.org/wiki/RGBE_image_format</summary>
        /// <param name="buffer">The binary file stored in an array buffer.</param>
        /// <param name="size">The expected size of the extracted cubemap.</param>
        abstract GetCubeMapTextureData: buffer: ArrayBuffer * size: float -> CubeMapInfo
        /// <summary>Returns the pixels data extracted from an RGBE texture.
        /// This pixels will be stored left to right up to down in the R G B order in one array.
        /// 
        /// More information on this format are available here:
        /// https://en.wikipedia.org/wiki/RGBE_image_format</summary>
        /// <param name="uint8array">The binary file stored in an array buffer.</param>
        /// <param name="hdrInfo">The header information of the file.</param>
        abstract RGBE_ReadPixels: uint8array: Uint8Array * hdrInfo: HDRInfo -> Float32Array

    /// CubeMap information grouping all the data for each faces as well as the cubemap size.
    type [<AllowNullLiteral>] CubeMapInfo =
        /// The pixel array for the front face.
        /// This is stored in format, left to right, up to down format.
        abstract front: Nullable<ArrayBufferView> with get, set
        /// The pixel array for the back face.
        /// This is stored in format, left to right, up to down format.
        abstract back: Nullable<ArrayBufferView> with get, set
        /// The pixel array for the left face.
        /// This is stored in format, left to right, up to down format.
        abstract left: Nullable<ArrayBufferView> with get, set
        /// The pixel array for the right face.
        /// This is stored in format, left to right, up to down format.
        abstract right: Nullable<ArrayBufferView> with get, set
        /// The pixel array for the up face.
        /// This is stored in format, left to right, up to down format.
        abstract up: Nullable<ArrayBufferView> with get, set
        /// The pixel array for the down face.
        /// This is stored in format, left to right, up to down format.
        abstract down: Nullable<ArrayBufferView> with get, set
        /// The size of the cubemap stored.
        /// 
        /// Each faces will be size * size pixels.
        abstract size: float with get, set
        /// The format of the texture.
        /// 
        /// RGBA, RGB.
        abstract format: float with get, set
        /// The type of the texture data.
        /// 
        /// UNSIGNED_INT, FLOAT.
        abstract ``type``: float with get, set
        /// Specifies whether the texture is in gamma space.
        abstract gammaSpace: bool with get, set

    /// Helper class usefull to convert panorama picture to their cubemap representation in 6 faces.
    type [<AllowNullLiteral>] PanoramaToCubeMapTools =
        interface end

    /// Helper class usefull to convert panorama picture to their cubemap representation in 6 faces.
    type [<AllowNullLiteral>] PanoramaToCubeMapToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PanoramaToCubeMapTools
        /// <summary>Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).</summary>
        /// <param name="float32Array">The source data.</param>
        /// <param name="inputWidth">The width of the input panorama.</param>
        /// <param name="inputHeight">The height of the input panorama.</param>
        /// <param name="size">The willing size of the generated cubemap (each faces will be size * size pixels)</param>
        abstract ConvertPanoramaToCubemap: float32Array: Float32Array * inputWidth: float * inputHeight: float * size: float -> CubeMapInfo

    /// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
    /// Custom Procedural textures are the easiest way to create your own procedural in your application.
    type [<AllowNullLiteral>] CustomProceduralTexture =
        inherit ProceduralTexture
        /// Is the texture ready to be used ? (rendered at least once)
        abstract isReady: unit -> bool
        /// <summary>Render the texture to its associated render target.</summary>
        /// <param name="useCameraPostProcess">Define if camera post process should be applied to the texture</param>
        abstract render: ?useCameraPostProcess: bool -> unit
        /// Update the list of dependant textures samplers in the shader.
        abstract updateTextures: unit -> unit
        /// Update the uniform values of the procedural texture in the shader.
        abstract updateShaderUniforms: unit -> unit
        /// Define if the texture animates or not.
        abstract animate: bool with get, set

    /// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
    /// Custom Procedural textures are the easiest way to create your own procedural in your application.
    type [<AllowNullLiteral>] CustomProceduralTextureStatic =
        /// <summary>Instantiates a new Custom Procedural Texture.
        /// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
        /// Custom Procedural textures are the easiest way to create your own procedural in your application.</summary>
        /// <param name="name">Define the name of the texture</param>
        /// <param name="texturePath">Define the folder path containing all the cutom texture related files (config, shaders...)</param>
        /// <param name="size">Define the size of the texture to create</param>
        /// <param name="scene">Define the scene the texture belongs to</param>
        /// <param name="fallbackTexture">Define a fallback texture in case there were issues to create the custom texture</param>
        /// <param name="generateMipMaps">Define if the texture should creates mip maps or not</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * texturePath: string * size: float * scene: Scene * ?fallbackTexture: Texture * ?generateMipMaps: bool -> CustomProceduralTexture

    /// Class used to generate noise procedural textures
    type [<AllowNullLiteral>] NoiseProceduralTexture =
        inherit ProceduralTexture
        /// Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) 
        abstract brightness: float with get, set
        /// Defines the number of octaves to process 
        abstract octaves: float with get, set
        /// Defines the level of persistence (0.8 by default) 
        abstract persistence: float with get, set
        /// Gets or sets animation speed factor (default is 1) 
        abstract animationSpeedFactor: float with get, set
        abstract _getDefines: unit -> string
        /// Generate the current state of the procedural texture 
        abstract render: ?useCameraPostProcess: bool -> unit
        /// Serializes this noise procedural texture
        abstract serialize: unit -> obj option

    /// Class used to generate noise procedural textures
    type [<AllowNullLiteral>] NoiseProceduralTextureStatic =
        /// <summary>Creates a new NoiseProceduralTexture</summary>
        /// <param name="name">defines the name fo the texture</param>
        /// <param name="size">defines the size of the texture (default is 256)</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="fallbackTexture">defines the texture to use if the NoiseProceduralTexture can't be created</param>
        /// <param name="generateMipMaps">defines if mipmaps must be generated (true by default)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ?size: float * ?scene: Scene * ?fallbackTexture: Texture * ?generateMipMaps: bool -> NoiseProceduralTexture
        /// <summary>Creates a NoiseProceduralTexture from parsed noise procedural texture data</summary>
        /// <param name="parsedTexture">defines parsed texture data</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="rootUrl">defines the root URL containing noise procedural texture information</param>
        abstract Parse: parsedTexture: obj option * scene: Scene * rootUrl: string -> NoiseProceduralTexture

    /// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
    /// This is the base class of any Procedural texture and contains most of the shareable code.
    type [<AllowNullLiteral>] ProceduralTexture =
        inherit Texture
        abstract isCube: bool with get, set
        /// Define if the texture is enabled or not (disabled texture will not render)
        abstract isEnabled: bool with get, set
        /// Define if the texture must be cleared before rendering (default is true)
        abstract autoClear: bool with get, set
        /// Callback called when the texture is generated
        abstract onGenerated: (unit -> unit) with get, set
        /// Event raised when the texture is generated
        abstract onGeneratedObservable: Observable<ProceduralTexture> with get, set
        abstract _generateMipMaps: bool with get, set
        abstract _effect: Effect with get, set
        abstract _textures: TypeLiteral_42 with get, set
        /// Gets texture content (Use this function wisely as reading from a texture can be slow)
        abstract getContent: unit -> Nullable<ArrayBufferView>
        abstract _rebuild: unit -> unit
        /// Resets the texture in order to recreate its associated resources.
        /// This can be called in case of context loss
        abstract reset: unit -> unit
        abstract _getDefines: unit -> string
        /// Is the texture ready to be used ? (rendered at least once)
        abstract isReady: unit -> bool
        /// Resets the refresh counter of the texture and start bak from scratch.
        /// Could be usefull to regenerate the texture if it is setup to render only once.
        abstract resetRefreshCounter: unit -> unit
        /// <summary>Set the fragment shader to use in order to render the texture.</summary>
        /// <param name="fragment">This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.</param>
        abstract setFragment: fragment: obj option -> unit
        /// Define the refresh rate of the texture or the rendering frequency.
        /// Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
        abstract refreshRate: float with get, set
        abstract _shouldRender: unit -> bool
        /// Get the size the texture is rendering at.
        abstract getRenderSize: unit -> float
        /// <summary>Resize the texture to new value.</summary>
        /// <param name="size">Define the new size the texture should have</param>
        /// <param name="generateMipMaps">Define whether the new texture should create mip maps</param>
        abstract resize: size: float * generateMipMaps: bool -> unit
        /// <summary>Set a texture in the shader program used to render.</summary>
        /// <param name="name">Define the name of the uniform samplers as defined in the shader</param>
        /// <param name="texture">Define the texture to bind to this sampler</param>
        abstract setTexture: name: string * texture: Texture -> ProceduralTexture
        /// <summary>Set a float in the shader.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setFloat: name: string * value: float -> ProceduralTexture
        /// <summary>Set a int in the shader.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setInt: name: string * value: float -> ProceduralTexture
        /// <summary>Set an array of floats in the shader.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setFloats: name: string * value: ResizeArray<float> -> ProceduralTexture
        /// <summary>Set a vec3 in the shader from a Color3.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setColor3: name: string * value: Color3 -> ProceduralTexture
        /// <summary>Set a vec4 in the shader from a Color4.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setColor4: name: string * value: Color4 -> ProceduralTexture
        /// <summary>Set a vec2 in the shader from a Vector2.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setVector2: name: string * value: Vector2 -> ProceduralTexture
        /// <summary>Set a vec3 in the shader from a Vector3.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setVector3: name: string * value: Vector3 -> ProceduralTexture
        /// <summary>Set a mat4 in the shader from a MAtrix.</summary>
        /// <param name="name">Define the name of the uniform as defined in the shader</param>
        /// <param name="value">Define the value to give to the uniform</param>
        abstract setMatrix: name: string * value: Matrix -> ProceduralTexture
        /// <summary>Render the texture to its associated render target.</summary>
        /// <param name="useCameraPostProcess">Define if camera post process should be applied to the texture</param>
        abstract render: ?useCameraPostProcess: bool -> unit
        /// Clone the texture.
        abstract clone: unit -> ProceduralTexture
        /// Dispose the texture and release its asoociated resources.
        abstract dispose: unit -> unit

    /// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
    /// This is the base class of any Procedural texture and contains most of the shareable code.
    type [<AllowNullLiteral>] ProceduralTextureStatic =
        /// <summary>Instantiates a new procedural texture.
        /// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
        /// This is the base class of any Procedural texture and contains most of the shareable code.</summary>
        /// <param name="name">Define the name of the texture</param>
        /// <param name="size">Define the size of the texture to create</param>
        /// <param name="fragment">Define the fragment shader to use to generate the texture or null if it is defined later</param>
        /// <param name="scene">Define the scene the texture belongs to</param>
        /// <param name="fallbackTexture">Define a fallback texture in case there were issues to create the custom texture</param>
        /// <param name="generateMipMaps">Define if the texture should creates mip maps or not</param>
        /// <param name="isCube">Define if the texture is a cube texture or not (this will render each faces of the cube)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * size: obj option * fragment: obj option * scene: Nullable<Scene> * ?fallbackTexture: Texture * ?generateMipMaps: bool * ?isCube: bool -> ProceduralTexture

    /// Defines the Procedural Texture scene component responsible to manage any Procedural Texture
    /// in a given scene.
    type [<AllowNullLiteral>] ProceduralTextureSceneComponent =
        inherit ISceneComponent
        /// The component name helpfull to identify the component in the list of scene components.
        abstract name: string
        /// The scene the component belongs to.
        abstract scene: Scene with get, set
        /// Registers the component in a given scene
        abstract register: unit -> unit
        /// Rebuilds the elements related to this component in case of
        /// context lost for instance.
        abstract rebuild: unit -> unit
        /// Disposes the component and the associated ressources.
        abstract dispose: unit -> unit

    /// Defines the Procedural Texture scene component responsible to manage any Procedural Texture
    /// in a given scene.
    type [<AllowNullLiteral>] ProceduralTextureSceneComponentStatic =
        /// <summary>Creates a new instance of the component for the given scene</summary>
        /// <param name="scene">Defines the scene to register the component in</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> ProceduralTextureSceneComponent

    /// The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
    /// See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
    type [<AllowNullLiteral>] DefaultRenderingPipeline =
        inherit PostProcessRenderPipeline
        inherit IDisposable
        inherit IAnimatable
        abstract ImageProcessingPostProcessId: string
        abstract FxaaPostProcessId: string
        /// Sharpen post process which will apply a sharpen convolution to enhance edges
        abstract sharpen: SharpenPostProcess with get, set
        /// Depth of field effect, applies a blur based on how far away objects are from the focus distance.
        abstract depthOfField: DepthOfFieldEffect with get, set
        /// The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
        abstract fxaa: FxaaPostProcess with get, set
        /// Image post processing pass used to perform operations such as tone mapping or color grading.
        abstract imageProcessing: ImageProcessingPostProcess with get, set
        /// Chromatic aberration post process which will shift rgb colors in the image
        abstract chromaticAberration: ChromaticAberrationPostProcess with get, set
        /// Grain post process which add noise to the image
        abstract grain: GrainPostProcess with get, set
        /// Animations which can be used to tweak settings over a period of time
        abstract animations: ResizeArray<Animation> with get, set
        /// Enable or disable the sharpen process from the pipeline
        abstract sharpenEnabled: bool with get, set
        /// Specifies the size of the bloom blur kernel, relative to the final output size
        abstract bloomKernel: float with get, set
        /// The strength of the bloom.
        abstract bloomWeight: float with get, set
        /// The strength of the bloom.
        abstract bloomThreshold: float with get, set
        /// The scale of the bloom, lower value will provide better performance.
        abstract bloomScale: float with get, set
        /// Enable or disable the bloom from the pipeline
        abstract bloomEnabled: bool with get, set
        /// If the depth of field is enabled.
        abstract depthOfFieldEnabled: bool with get, set
        /// Blur level of the depth of field effect. (Higher blur will effect performance)
        abstract depthOfFieldBlurLevel: DepthOfFieldEffectBlurLevel with get, set
        /// If the anti aliasing is enabled.
        abstract fxaaEnabled: bool with get, set
        /// MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
        abstract samples: float with get, set
        /// If image processing is enabled.
        abstract imageProcessingEnabled: bool with get, set
        /// If glow layer is enabled. (Adds a glow effect to emmissive materials)
        abstract glowLayerEnabled: bool with get, set
        /// Enable or disable the chromaticAberration process from the pipeline
        abstract chromaticAberrationEnabled: bool with get, set
        /// Enable or disable the grain process from the pipeline
        abstract grainEnabled: bool with get, set
        /// Force the compilation of the entire pipeline.
        abstract prepare: unit -> unit
        /// <summary>Adds a camera to the pipeline</summary>
        /// <param name="camera">the camera to be added</param>
        abstract addCamera: camera: Camera -> unit
        /// <summary>Removes a camera from the pipeline</summary>
        /// <param name="camera">the camera to remove</param>
        abstract removeCamera: camera: Camera -> unit
        /// Dispose of the pipeline and stop all post processes
        abstract dispose: unit -> unit
        /// Serialize the rendering pipeline (Used when exporting)
        abstract serialize: unit -> obj option

    /// The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
    /// See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
    type [<AllowNullLiteral>] DefaultRenderingPipelineStatic =
        /// <param name="name">- The rendering pipeline name (default: "")</param>
        /// <param name="hdr">- If high dynamic range textures should be used (default: true)</param>
        /// <param name="scene">- The scene linked to this pipeline (default: the last created scene)</param>
        /// <param name="cameras">- The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)</param>
        /// <param name="automaticBuild">- if false, you will have to manually call prepare() to update the pipeline (default: true)</param>
        [<Emit "new $0($1...)">] abstract Create: ?name: string * ?hdr: bool * ?scene: Scene * ?cameras: ResizeArray<Camera> * ?automaticBuild: bool -> DefaultRenderingPipeline
        /// <summary>Parse the serialized pipeline</summary>
        /// <param name="source">Source pipeline.</param>
        /// <param name="scene">The scene to load the pipeline to.</param>
        /// <param name="rootUrl">The URL of the serialized pipeline.</param>
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> DefaultRenderingPipeline

    /// BABYLON.JS Chromatic Aberration GLSL Shader
    /// Author: Olivier Guyot
    /// Separates very slightly R, G and B colors on the edges of the screen
    /// Inspired by Francois Tarlier & Martins Upitis
    type [<AllowNullLiteral>] LensRenderingPipeline =
        inherit PostProcessRenderPipeline
        abstract LensChromaticAberrationEffect: string with get, set
        abstract HighlightsEnhancingEffect: string with get, set
        abstract LensDepthOfFieldEffect: string with get, set
        /// <summary>Sets the amount of blur at the edges</summary>
        /// <param name="amount">blur amount</param>
        abstract setEdgeBlur: amount: float -> unit
        /// Sets edge blur to 0
        abstract disableEdgeBlur: unit -> unit
        /// <summary>Sets the amout of grain</summary>
        /// <param name="amount">Amount of grain</param>
        abstract setGrainAmount: amount: float -> unit
        /// Set grain amount to 0
        abstract disableGrain: unit -> unit
        /// <summary>Sets the chromatic aberration amount</summary>
        /// <param name="amount">amount of chromatic aberration</param>
        abstract setChromaticAberration: amount: float -> unit
        /// Sets chromatic aberration amount to 0
        abstract disableChromaticAberration: unit -> unit
        /// <summary>Sets the EdgeDistortion amount</summary>
        /// <param name="amount">amount of EdgeDistortion</param>
        abstract setEdgeDistortion: amount: float -> unit
        /// Sets edge distortion to 0
        abstract disableEdgeDistortion: unit -> unit
        /// <summary>Sets the FocusDistance amount</summary>
        /// <param name="amount">amount of FocusDistance</param>
        abstract setFocusDistance: amount: float -> unit
        /// Disables depth of field
        abstract disableDepthOfField: unit -> unit
        /// <summary>Sets the Aperture amount</summary>
        /// <param name="amount">amount of Aperture</param>
        abstract setAperture: amount: float -> unit
        /// <summary>Sets the DarkenOutOfFocus amount</summary>
        /// <param name="amount">amount of DarkenOutOfFocus</param>
        abstract setDarkenOutOfFocus: amount: float -> unit
        /// Creates a pentagon bokeh effect
        abstract enablePentagonBokeh: unit -> unit
        /// Disables the pentagon bokeh effect
        abstract disablePentagonBokeh: unit -> unit
        /// Enables noise blur
        abstract enableNoiseBlur: unit -> unit
        /// Disables noise blur
        abstract disableNoiseBlur: unit -> unit
        /// <summary>Sets the HighlightsGain amount</summary>
        /// <param name="amount">amount of HighlightsGain</param>
        abstract setHighlightsGain: amount: float -> unit
        /// <summary>Sets the HighlightsThreshold amount</summary>
        /// <param name="amount">amount of HighlightsThreshold</param>
        abstract setHighlightsThreshold: amount: float -> unit
        /// Disables highlights
        abstract disableHighlights: unit -> unit
        /// <summary>Removes the internal pipeline assets and detaches the pipeline from the scene cameras</summary>
        /// <param name="disableDepthRender">If the scens depth rendering should be disabled (default: false)</param>
        abstract dispose: ?disableDepthRender: bool -> unit

    /// BABYLON.JS Chromatic Aberration GLSL Shader
    /// Author: Olivier Guyot
    /// Separates very slightly R, G and B colors on the edges of the screen
    /// Inspired by Francois Tarlier & Martins Upitis
    type [<AllowNullLiteral>] LensRenderingPipelineStatic =
        /// <param name="name">The rendering pipeline name</param>
        /// <param name="parameters">- An object containing all parameters (see above)</param>
        /// <param name="scene">The scene linked to this pipeline</param>
        /// <param name="ratio">The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)</param>
        /// <param name="cameras">The array of cameras that the rendering pipeline will be attached to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * parameters: obj option * scene: Scene * ?ratio: float * ?cameras: ResizeArray<Camera> -> LensRenderingPipeline

    /// Render pipeline to produce ssao effect
    type [<AllowNullLiteral>] SSAO2RenderingPipeline =
        inherit PostProcessRenderPipeline
        abstract SSAOOriginalSceneColorEffect: string with get, set
        abstract SSAORenderEffect: string with get, set
        abstract SSAOBlurHRenderEffect: string with get, set
        abstract SSAOBlurVRenderEffect: string with get, set
        abstract SSAOCombineRenderEffect: string with get, set
        /// The output strength of the SSAO post-process. Default value is 1.0.
        abstract totalStrength: float with get, set
        /// Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.
        abstract maxZ: float with get, set
        /// In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much
        abstract minZAspect: float with get, set
        /// Number of samples used for the SSAO calculations. Default value is 8
        abstract samples: float with get, set
        /// Number of samples to use for antialiasing
        abstract textureSamples: float with get, set
        /// If bilateral blur should be used
        abstract expensiveBlur: bool with get, set
        /// The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0
        abstract radius: float with get, set
        /// The base color of the SSAO post-process
        /// The final result is "base + ssao" between [0, 1]
        abstract ``base``: float with get, set
        /// Removes the internal pipeline assets and detatches the pipeline from the scene cameras
        abstract dispose: ?disableGeometryBufferRenderer: bool -> unit
        abstract _rebuild: unit -> unit
        /// Serialize the rendering pipeline (Used when exporting)
        abstract serialize: unit -> obj option

    /// Render pipeline to produce ssao effect
    type [<AllowNullLiteral>] SSAO2RenderingPipelineStatic =
        /// Support test.
        abstract IsSupported: bool
        /// <param name="name">The rendering pipeline name</param>
        /// <param name="scene">The scene linked to this pipeline</param>
        /// <param name="ratio">The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, blurRatio: 1.0 }</param>
        /// <param name="cameras">The array of cameras that the rendering pipeline will be attached to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ratio: obj option * ?cameras: ResizeArray<Camera> -> SSAO2RenderingPipeline
        /// <summary>Parse the serialized pipeline</summary>
        /// <param name="source">Source pipeline.</param>
        /// <param name="scene">The scene to load the pipeline to.</param>
        /// <param name="rootUrl">The URL of the serialized pipeline.</param>
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> SSAO2RenderingPipeline

    /// Render pipeline to produce ssao effect
    type [<AllowNullLiteral>] SSAORenderingPipeline =
        inherit PostProcessRenderPipeline
        abstract SSAOOriginalSceneColorEffect: string with get, set
        abstract SSAORenderEffect: string with get, set
        abstract SSAOBlurHRenderEffect: string with get, set
        abstract SSAOBlurVRenderEffect: string with get, set
        abstract SSAOCombineRenderEffect: string with get, set
        /// The output strength of the SSAO post-process. Default value is 1.0.
        abstract totalStrength: float with get, set
        /// The radius around the analyzed pixel used by the SSAO post-process. Default value is 0.0006
        abstract radius: float with get, set
        /// Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel
        /// Must not be equal to fallOff and superior to fallOff.
        /// Default value is 0.975
        abstract area: float with get, set
        /// Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel
        /// Must not be equal to area and inferior to area.
        /// Default value is 0.0
        abstract fallOff: float with get, set
        /// The base color of the SSAO post-process
        /// The final result is "base + ssao" between [0, 1]
        abstract ``base``: float with get, set
        /// Removes the internal pipeline assets and detatches the pipeline from the scene cameras
        abstract dispose: ?disableDepthRender: bool -> unit
        abstract _rebuild: unit -> unit

    /// Render pipeline to produce ssao effect
    type [<AllowNullLiteral>] SSAORenderingPipelineStatic =
        /// <param name="name">- The rendering pipeline name</param>
        /// <param name="scene">- The scene linked to this pipeline</param>
        /// <param name="ratio">- The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, combineRatio: 1.0 }</param>
        /// <param name="cameras">- The array of cameras that the rendering pipeline will be attached to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ratio: obj option * ?cameras: ResizeArray<Camera> -> SSAORenderingPipeline

    /// Standard rendering pipeline
    /// Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
    type [<AllowNullLiteral>] StandardRenderingPipeline =
        inherit PostProcessRenderPipeline
        inherit IDisposable
        inherit IAnimatable
        /// Public members
        /// Post-process which contains the original scene color before the pipeline applies all the effects
        abstract originalPostProcess: Nullable<PostProcess> with get, set
        /// Post-process used to down scale an image x4
        abstract downSampleX4PostProcess: Nullable<PostProcess> with get, set
        /// Post-process used to calculate the illuminated surfaces controlled by a threshold
        abstract brightPassPostProcess: Nullable<PostProcess> with get, set
        /// Post-process array storing all the horizontal blur post-processes used by the pipeline
        abstract blurHPostProcesses: ResizeArray<PostProcess> with get, set
        /// Post-process array storing all the vertical blur post-processes used by the pipeline
        abstract blurVPostProcesses: ResizeArray<PostProcess> with get, set
        /// Post-process used to add colors of 2 textures (typically brightness + real scene color)
        abstract textureAdderPostProcess: Nullable<PostProcess> with get, set
        /// Post-process used to create volumetric lighting effect
        abstract volumetricLightPostProcess: Nullable<PostProcess> with get, set
        /// Post-process used to smooth the previous volumetric light post-process on the X axis
        abstract volumetricLightSmoothXPostProcess: Nullable<BlurPostProcess> with get, set
        /// Post-process used to smooth the previous volumetric light post-process on the Y axis
        abstract volumetricLightSmoothYPostProcess: Nullable<BlurPostProcess> with get, set
        /// Post-process used to merge the volumetric light effect and the real scene color
        abstract volumetricLightMergePostProces: Nullable<PostProcess> with get, set
        /// Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)
        abstract volumetricLightFinalPostProcess: Nullable<PostProcess> with get, set
        /// Base post-process used to calculate the average luminance of the final image for HDR
        abstract luminancePostProcess: Nullable<PostProcess> with get, set
        /// Post-processes used to create down sample post-processes in order to get
        /// the average luminance of the final image for HDR
        /// Array of length "StandardRenderingPipeline.LuminanceSteps"
        abstract luminanceDownSamplePostProcesses: ResizeArray<PostProcess> with get, set
        /// Post-process used to create a HDR effect (light adaptation)
        abstract hdrPostProcess: Nullable<PostProcess> with get, set
        /// Post-process used to store the final texture adder post-process (attach/detach for debug purpose)
        abstract textureAdderFinalPostProcess: Nullable<PostProcess> with get, set
        /// Post-process used to store the final lens flare post-process (attach/detach for debug purpose)
        abstract lensFlareFinalPostProcess: Nullable<PostProcess> with get, set
        /// Post-process used to merge the final HDR post-process and the real scene color
        abstract hdrFinalPostProcess: Nullable<PostProcess> with get, set
        /// Post-process used to create a lens flare effect
        abstract lensFlarePostProcess: Nullable<PostProcess> with get, set
        /// Post-process that merges the result of the lens flare post-process and the real scene color
        abstract lensFlareComposePostProcess: Nullable<PostProcess> with get, set
        /// Post-process used to create a motion blur effect
        abstract motionBlurPostProcess: Nullable<PostProcess> with get, set
        /// Post-process used to create a depth of field effect
        abstract depthOfFieldPostProcess: Nullable<PostProcess> with get, set
        /// The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
        abstract fxaaPostProcess: Nullable<FxaaPostProcess> with get, set
        /// Represents the brightness threshold in order to configure the illuminated surfaces
        abstract brightThreshold: float with get, set
        /// Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)
        abstract blurWidth: float with get, set
        /// Sets if the blur for highlighted surfaces must be only horizontal
        abstract horizontalBlur: bool with get, set
        /// Sets the overall exposure used by the pipeline
        abstract exposure: float with get, set
        /// Texture used typically to simulate "dirty" on camera lens
        abstract lensTexture: Nullable<Texture> with get, set
        /// Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]
        abstract volumetricLightCoefficient: float with get, set
        /// The overall power of volumetric lights, typically in interval [0, 10] maximum
        abstract volumetricLightPower: float with get, set
        /// Used the set the blur intensity to smooth the volumetric lights
        abstract volumetricLightBlurScale: float with get, set
        /// Light (spot or directional) used to generate the volumetric lights rays
        /// The source light must have a shadow generate so the pipeline can get its
        /// depth map
        abstract sourceLight: Nullable<U2<SpotLight, DirectionalLight>> with get, set
        /// For eye adaptation, represents the minimum luminance the eye can see
        abstract hdrMinimumLuminance: float with get, set
        /// For eye adaptation, represents the decrease luminance speed
        abstract hdrDecreaseRate: float with get, set
        /// For eye adaptation, represents the increase luminance speed
        abstract hdrIncreaseRate: float with get, set
        /// Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled
        abstract lensColorTexture: Nullable<Texture> with get, set
        /// The overall strengh for the lens flare effect
        abstract lensFlareStrength: float with get, set
        /// Dispersion coefficient for lens flare ghosts
        abstract lensFlareGhostDispersal: float with get, set
        /// Main lens flare halo width
        abstract lensFlareHaloWidth: float with get, set
        /// Based on the lens distortion effect, defines how much the lens flare result
        /// is distorted
        abstract lensFlareDistortionStrength: float with get, set
        /// Lens star texture must be used to simulate rays on the flares and is available
        /// in the documentation
        abstract lensStarTexture: Nullable<Texture> with get, set
        /// As the "lensTexture" (can be the same texture or different), it is used to apply the lens
        /// flare effect by taking account of the dirt texture
        abstract lensFlareDirtTexture: Nullable<Texture> with get, set
        /// Represents the focal length for the depth of field effect
        abstract depthOfFieldDistance: float with get, set
        /// Represents the blur intensity for the blurred part of the depth of field effect
        abstract depthOfFieldBlurWidth: float with get, set
        /// For motion blur, defines how much the image is blurred by the movement
        abstract motionStrength: float with get, set
        /// List of animations for the pipeline (IAnimatable implementation)
        abstract animations: ResizeArray<Animation> with get, set
        abstract BloomEnabled: bool with get, set
        abstract DepthOfFieldEnabled: bool with get, set
        abstract LensFlareEnabled: bool with get, set
        abstract HDREnabled: bool with get, set
        abstract VLSEnabled: bool with get, set
        abstract MotionBlurEnabled: bool with get, set
        /// Specifies if anti-aliasing is enabled
        abstract fxaaEnabled: bool with get, set
        /// Specifies the number of steps used to calculate the volumetric lights
        /// Typically in interval [50, 200]
        abstract volumetricLightStepsCount: float with get, set
        /// Specifies the number of samples used for the motion blur effect
        /// Typically in interval [16, 64]
        abstract motionBlurSamples: float with get, set
        /// Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
        abstract samples: float with get, set
        /// Dispose of the pipeline and stop all post processes
        abstract dispose: unit -> unit
        /// Serialize the rendering pipeline (Used when exporting)
        abstract serialize: unit -> obj option

    /// Standard rendering pipeline
    /// Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
    type [<AllowNullLiteral>] StandardRenderingPipelineStatic =
        /// <summary>Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.</summary>
        /// <param name="name">The rendering pipeline name</param>
        /// <param name="scene">The scene linked to this pipeline</param>
        /// <param name="ratio">The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)</param>
        /// <param name="originalPostProcess">the custom original color post-process. Must be "reusable". Can be null.</param>
        /// <param name="cameras">The array of cameras that the rendering pipeline will be attached to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ratio: float * ?originalPostProcess: PostProcess * ?cameras: ResizeArray<Camera> -> StandardRenderingPipeline
        /// <summary>Parse the serialized pipeline</summary>
        /// <param name="source">Source pipeline.</param>
        /// <param name="scene">The scene to load the pipeline to.</param>
        /// <param name="rootUrl">The URL of the serialized pipeline.</param>
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> StandardRenderingPipeline
        /// Luminance steps
        abstract LuminanceSteps: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_01 =
        interface end

    type [<AllowNullLiteral>] TypeLiteral_12 =
        abstract ``object``: obj option with get, set
        abstract property: string with get, set
        abstract value: obj option with get, set
        abstract initialValue: obj option with get, set

    type [<AllowNullLiteral>] TypeLiteral_13 =
        abstract backgroundColor: string option with get, set
        abstract backgroundColorLighter: string option with get, set
        abstract backgroundColorLighter2: string option with get, set
        abstract backgroundColorLighter3: string option with get, set
        abstract color: string option with get, set
        abstract colorTop: string option with get, set
        abstract colorBot: string option with get, set

    type [<AllowNullLiteral>] TypeLiteral_33 =
        abstract blurred: PostProcess with get, set
        abstract weight: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_30 =
        abstract body: obj option with get, set

    type [<AllowNullLiteral>] TypeLiteral_32 =
        abstract circleOfConfusion: PostProcess with get, set
        abstract blurSteps: Array<PostProcess> with get, set

    type [<AllowNullLiteral>] TypeLiteral_38 =
        abstract delta: Vector3 with get, set
        abstract dragPlanePoint: Vector3 with get, set
        abstract dragPlaneNormal: Vector3 with get, set
        abstract dragDistance: float with get, set
        abstract pointerId: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_39 =
        abstract dragPlanePoint: Vector3 with get, set
        abstract pointerId: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_29 =
        abstract idx: float with get, set
        abstract faceId: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_04<'T> =
        abstract index: float with get, set
        abstract ``component``: ISceneComponent with get, set
        abstract action: 'T with get, set

    type [<AllowNullLiteral>] TypeLiteral_21 =
        abstract isBinary: bool with get, set

    type [<AllowNullLiteral>] TypeLiteral_16 =
        abstract key: string with get, set
        abstract capture: obj with get, set
        abstract captureConstraint: obj with get, set
        abstract targets: ResizeArray<string> with get, set

    type [<AllowNullLiteral>] TypeLiteral_15 =
        abstract key: string with get, set
        abstract capture: string with get, set
        abstract captureConstraint: float with get, set
        abstract targets: ResizeArray<string> with get, set

    type [<AllowNullLiteral>] TypeLiteral_22 =
        abstract meshes: ResizeArray<AbstractMesh> with get, set
        abstract particleSystems: ResizeArray<IParticleSystem> with get, set
        abstract skeletons: ResizeArray<Skeleton> with get, set
        abstract animationGroups: ResizeArray<AnimationGroup> with get, set

    type [<AllowNullLiteral>] TypeLiteral_19 =
        abstract message: string option with get, set
        abstract ``exception``: obj option with get, set

    type [<AllowNullLiteral>] TypeLiteral_27 =
        abstract min: Vector3 with get, set
        abstract max: Vector3 with get, set

    type [<AllowNullLiteral>] TypeLiteral_11 =
        abstract min: Vector3 with get, set
        abstract max: Vector3 with get, set
        abstract distance: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_25 =
        abstract minimum: Vector3 with get, set
        abstract maximum: Vector3 with get, set

    type [<AllowNullLiteral>] TypeLiteral_37 =
        abstract name: string with get, set
        abstract handler: Nullable<(FocusEvent -> obj option)> with get, set

    type [<AllowNullLiteral>] TypeLiteral_05 =
        abstract name: string with get, set
        abstract targetType: string with get, set
        abstract value: string with get, set

    type [<AllowNullLiteral>] TypeLiteral_34 =
        abstract position: Vector3 with get, set

    type [<AllowNullLiteral>] TypeLiteral_18 =
        abstract positionGizmo: Nullable<PositionGizmo> with get, set
        abstract rotationGizmo: Nullable<RotationGizmo> with get, set
        abstract scaleGizmo: Nullable<ScaleGizmo> with get, set
        abstract boundingBoxGizmo: Nullable<BoundingBoxGizmo> with get, set

    type [<AllowNullLiteral>] TypeLiteral_40 =
        abstract ratio: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_17 =
        abstract snapDistance: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_20 =
        abstract texture: Nullable<BaseTexture> with get, set
        abstract color: Color4 with get, set

    type [<AllowNullLiteral>] TypeLiteral_26 =
        abstract w: float with get, set
        abstract h: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_08 =
        abstract width: float with get, set
        abstract height: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_07 =
        abstract x: float with get, set
        abstract y: float with get, set

    type [<AllowNullLiteral>] TypeLiteral_03 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: id: string -> DepthRenderer with get, set

    type [<AllowNullLiteral>] TypeLiteral_35 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> File with get, set

    type [<AllowNullLiteral>] TypeLiteral_36 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> Object with get, set

    type [<AllowNullLiteral>] TypeLiteral_42 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> Texture with get, set

    type [<AllowNullLiteral>] TypeLiteral_24 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> VertexBuffer with get, set

    type [<AllowNullLiteral>] TypeLiteral_06 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> float with get, set

    type [<AllowNullLiteral>] TypeLiteral_23 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> string with get, set

    type [<AllowNullLiteral>] TypeLiteral_14 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> Nullable<InternalTexture> with get, set

    type [<AllowNullLiteral>] TypeLiteral_31 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> Nullable<VertexBuffer> with get, set

    type [<AllowNullLiteral>] TypeLiteral_09 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: n: float -> SerializedMesh with get, set

    type [<AllowNullLiteral>] TypeLiteral_02 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: name: string -> Nullable<AnimationRange> with get, set

    type [<AllowNullLiteral>] TypeLiteral_10 =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: s: string -> SerializedGeometry with get, set

    type [<AllowNullLiteral>] TypeLiteral_41 =
        /// The url to the WebAssembly module.
        abstract wasmUrl: string option with get, set
        /// The url to the WebAssembly binary.
        abstract wasmBinaryUrl: string option with get, set
        /// The url to the fallback JavaScript module.
        abstract fallbackUrl: string option with get, set

    type [<AllowNullLiteral>] TypeLiteral_28 =
        [<Emit "$0($1...)">] abstract Invoke: i: float * distance: float -> float

type [<AllowNullLiteral>] Window =
    abstract mozIndexedDB: IDBFactory with get, set
    abstract webkitIndexedDB: IDBFactory with get, set
    abstract msIndexedDB: IDBFactory with get, set
    abstract webkitURL: obj with get, set
    abstract mozRequestAnimationFrame: callback: FrameRequestCallback -> float
    abstract oRequestAnimationFrame: callback: FrameRequestCallback -> float
    abstract WebGLRenderingContext: WebGLRenderingContext with get, set
    abstract MSGesture: MSGesture with get, set
    abstract CANNON: obj option with get, set
    abstract AudioContext: AudioContext with get, set
    abstract webkitAudioContext: AudioContext with get, set
    abstract PointerEvent: obj option with get, set
    abstract Math: Math with get, set
    abstract Uint8Array: Uint8ArrayConstructor with get, set
    abstract Float32Array: Float32ArrayConstructor with get, set
    abstract mozURL: obj with get, set
    abstract msURL: obj with get, set
    abstract VRFrameData: obj option with get, set
    abstract DracoDecoderModule: obj option with get, set
    abstract setImmediate: handler: (ResizeArray<obj option> -> unit) -> float
    abstract onvrdisplayconnected: (Window -> Event -> obj option) option with get, set
    abstract onvrdisplaydisconnected: (Window -> Event -> obj option) option with get, set
    abstract onvrdisplaypresentchange: (Window -> Event -> obj option) option with get, set
    [<Emit "$0.addEventListener('vrdisplayconnected',$1,$2)">] abstract addEventListener_vrdisplayconnected: listener: (Event -> obj option) * ?useCapture: bool -> unit
    [<Emit "$0.addEventListener('vrdisplaydisconnected',$1,$2)">] abstract addEventListener_vrdisplaydisconnected: listener: (Event -> obj option) * ?useCapture: bool -> unit
    [<Emit "$0.addEventListener('vrdisplaypresentchange',$1,$2)">] abstract addEventListener_vrdisplaypresentchange: listener: (Event -> obj option) * ?useCapture: bool -> unit

type [<AllowNullLiteral>] WebGLRenderingContext =
    abstract drawArraysInstanced: mode: float * first: float * count: float * primcount: float -> unit
    abstract drawElementsInstanced: mode: float * count: float * ``type``: float * offset: float * primcount: float -> unit
    abstract vertexAttribDivisor: index: float * divisor: float -> unit
    abstract createVertexArray: unit -> obj option
    abstract bindVertexArray: ?vao: WebGLVertexArrayObject -> unit
    abstract deleteVertexArray: vao: WebGLVertexArrayObject -> unit
    abstract blitFramebuffer: srcX0: float * srcY0: float * srcX1: float * srcY1: float * dstX0: float * dstY0: float * dstX1: float * dstY1: float * mask: float * filter: float -> unit
    abstract renderbufferStorageMultisample: target: float * samples: float * internalformat: float * width: float * height: float -> unit
    abstract bindBufferBase: target: float * index: float * buffer: WebGLBuffer option -> unit
    abstract getUniformBlockIndex: program: WebGLProgram * uniformBlockName: string -> float
    abstract uniformBlockBinding: program: WebGLProgram * uniformBlockIndex: float * uniformBlockBinding: float -> unit
    abstract createQuery: unit -> WebGLQuery
    abstract deleteQuery: query: WebGLQuery -> unit
    abstract beginQuery: target: float * query: WebGLQuery -> unit
    abstract endQuery: target: float -> unit
    abstract getQueryParameter: query: WebGLQuery * pname: float -> obj option
    abstract getQuery: target: float * pname: float -> obj option
    abstract MAX_SAMPLES: float with get, set
    abstract RGBA8: float with get, set
    abstract READ_FRAMEBUFFER: float with get, set
    abstract DRAW_FRAMEBUFFER: float with get, set
    abstract UNIFORM_BUFFER: float with get, set
    abstract HALF_FLOAT_OES: float with get, set
    abstract RGBA16F: float with get, set
    abstract RGBA32F: float with get, set
    abstract R32F: float with get, set
    abstract RG32F: float with get, set
    abstract RGB32F: float with get, set
    abstract R16F: float with get, set
    abstract RG16F: float with get, set
    abstract RGB16F: float with get, set
    abstract RED: float with get, set
    abstract RG: float with get, set
    abstract R8: float with get, set
    abstract RG8: float with get, set
    abstract UNSIGNED_INT_24_8: float with get, set
    abstract DEPTH24_STENCIL8: float with get, set
    abstract drawBuffers: buffers: ResizeArray<float> -> unit
    abstract readBuffer: src: float -> unit
    abstract COLOR_ATTACHMENT0: float
    abstract COLOR_ATTACHMENT1: float
    abstract COLOR_ATTACHMENT2: float
    abstract COLOR_ATTACHMENT3: float
    abstract ANY_SAMPLES_PASSED_CONSERVATIVE: float with get, set
    abstract ANY_SAMPLES_PASSED: float with get, set
    abstract QUERY_RESULT_AVAILABLE: float with get, set
    abstract QUERY_RESULT: float with get, set
    abstract RASTERIZER_DISCARD: float
    abstract DEPTH_COMPONENT24: float
    abstract TEXTURE_3D: float
    abstract TEXTURE_2D_ARRAY: float
    abstract TEXTURE_COMPARE_FUNC: float
    abstract TEXTURE_COMPARE_MODE: float
    abstract COMPARE_REF_TO_TEXTURE: float
    abstract TEXTURE_WRAP_R: float
    abstract HALF_FLOAT: float
    abstract RGB8: float
    abstract RED_INTEGER: float
    abstract RG_INTEGER: float
    abstract RGB_INTEGER: float
    abstract RGBA_INTEGER: float
    abstract R8_SNORM: float
    abstract RG8_SNORM: float
    abstract RGB8_SNORM: float
    abstract RGBA8_SNORM: float
    abstract R8I: float
    abstract RG8I: float
    abstract RGB8I: float
    abstract RGBA8I: float
    abstract R8UI: float
    abstract RG8UI: float
    abstract RGB8UI: float
    abstract RGBA8UI: float
    abstract R16I: float
    abstract RG16I: float
    abstract RGB16I: float
    abstract RGBA16I: float
    abstract R16UI: float
    abstract RG16UI: float
    abstract RGB16UI: float
    abstract RGBA16UI: float
    abstract R32I: float
    abstract RG32I: float
    abstract RGB32I: float
    abstract RGBA32I: float
    abstract R32UI: float
    abstract RG32UI: float
    abstract RGB32UI: float
    abstract RGBA32UI: float
    abstract RGB10_A2UI: float
    abstract R11F_G11F_B10F: float
    abstract RGB9_E5: float
    abstract RGB10_A2: float
    abstract UNSIGNED_INT_2_10_10_10_REV: float
    abstract UNSIGNED_INT_10F_11F_11F_REV: float
    abstract UNSIGNED_INT_5_9_9_9_REV: float
    abstract FLOAT_32_UNSIGNED_INT_24_8_REV: float
    abstract texImage3D: target: float * level: float * internalformat: float * width: float * height: float * depth: float * border: float * format: float * ``type``: float * pixels: ArrayBufferView option -> unit
    abstract texImage3D: target: float * level: float * internalformat: float * width: float * height: float * depth: float * border: float * format: float * ``type``: float * pixels: ArrayBufferView * offset: float -> unit
    abstract texImage3D: target: float * level: float * internalformat: float * width: float * height: float * depth: float * border: float * format: float * ``type``: float * pixels: U5<ImageBitmap, ImageData, HTMLVideoElement, HTMLImageElement, HTMLCanvasElement> -> unit
    abstract compressedTexImage3D: target: float * level: float * internalformat: float * width: float * height: float * depth: float * border: float * data: ArrayBufferView * ?offset: float * ?length: float -> unit
    abstract TRANSFORM_FEEDBACK: float
    abstract INTERLEAVED_ATTRIBS: float
    abstract TRANSFORM_FEEDBACK_BUFFER: float
    abstract createTransformFeedback: unit -> WebGLTransformFeedback
    abstract deleteTransformFeedback: transformFeedbac: WebGLTransformFeedback -> unit
    abstract bindTransformFeedback: target: float * transformFeedback: WebGLTransformFeedback option -> unit
    abstract beginTransformFeedback: primitiveMode: float -> unit
    abstract endTransformFeedback: unit -> unit
    abstract transformFeedbackVaryings: program: WebGLProgram * varyings: ResizeArray<string> * bufferMode: float -> unit
    abstract clearBufferfv: buffer: float * drawbuffer: float * values: ArrayBufferView * srcOffset: float option -> unit
    abstract clearBufferiv: buffer: float * drawbuffer: float * values: ArrayBufferView * srcOffset: float option -> unit
    abstract clearBufferuiv: buffer: float * drawbuffer: float * values: ArrayBufferView * srcOffset: float option -> unit
    abstract clearBufferfi: buffer: float * drawbuffer: float * depth: float * stencil: float -> unit

type [<AllowNullLiteral>] Document =
    abstract mozCancelFullScreen: unit -> unit
    abstract msCancelFullScreen: unit -> unit
    abstract webkitCancelFullScreen: unit -> unit
    abstract requestPointerLock: unit -> unit
    abstract exitPointerLock: unit -> unit
    abstract fullscreen: bool with get, set
    abstract mozFullScreen: bool with get, set
    abstract msIsFullScreen: bool with get, set
    abstract webkitIsFullScreen: bool
    abstract pointerLockElement: Element
    abstract mozPointerLockElement: HTMLElement with get, set
    abstract msPointerLockElement: HTMLElement with get, set
    abstract webkitPointerLockElement: HTMLElement with get, set

type [<AllowNullLiteral>] HTMLCanvasElement =
    abstract requestPointerLock: unit -> unit
    abstract msRequestPointerLock: unit -> unit
    abstract mozRequestPointerLock: unit -> unit
    abstract webkitRequestPointerLock: unit -> unit
    /// Track wether a record is in progress 
    abstract isRecording: bool with get, set
    /// Capture Stream method defined by some browsers 
    abstract captureStream: ?fps: float -> MediaStream

type [<AllowNullLiteral>] CanvasRenderingContext2D =
    abstract msImageSmoothingEnabled: bool with get, set

type [<AllowNullLiteral>] WebGLBuffer =
    abstract references: float with get, set
    abstract capacity: float with get, set
    abstract is32Bits: bool with get, set

type [<AllowNullLiteral>] WebGLProgram =
    abstract transformFeedback: WebGLTransformFeedback option with get, set
    abstract __SPECTOR_rebuildProgram: (string -> string -> (WebGLProgram -> unit) -> (string -> unit) -> unit) option with get, set

type [<AllowNullLiteral>] MouseEvent =
    abstract mozMovementX: float with get, set
    abstract mozMovementY: float with get, set
    abstract webkitMovementX: float with get, set
    abstract webkitMovementY: float with get, set
    abstract msMovementX: float with get, set
    abstract msMovementY: float with get, set

type [<AllowNullLiteral>] HTMLVideoElement =
    abstract mozSrcObject: obj option with get, set

type [<AllowNullLiteral>] Element =
    abstract webkitRequestFullScreen: (unit -> unit) with get, set

type [<AllowNullLiteral>] Screen =
    abstract orientation: string
    abstract mozOrientation: string

type [<AllowNullLiteral>] Math =
    abstract fround: x: float -> float
    abstract imul: a: float * b: float -> float

type [<AllowNullLiteral>] EXT_disjoint_timer_query =
    abstract QUERY_COUNTER_BITS_EXT: float with get, set
    abstract TIME_ELAPSED_EXT: float with get, set
    abstract TIMESTAMP_EXT: float with get, set
    abstract GPU_DISJOINT_EXT: float with get, set
    abstract QUERY_RESULT_EXT: float with get, set
    abstract QUERY_RESULT_AVAILABLE_EXT: float with get, set
    abstract queryCounterEXT: query: WebGLQuery * target: float -> unit
    abstract createQueryEXT: unit -> WebGLQuery
    abstract beginQueryEXT: target: float * query: WebGLQuery -> unit
    abstract endQueryEXT: target: float -> unit
    abstract getQueryObjectEXT: query: WebGLQuery * target: float -> obj option
    abstract deleteQueryEXT: query: WebGLQuery -> unit

type [<AllowNullLiteral>] WebGLUniformLocation =
    abstract _currentState: obj option with get, set

type [<AllowNullLiteral>] VRDisplay =
    inherit EventTarget
    /// Dictionary of capabilities describing the VRDisplay.
    abstract capabilities: VRDisplayCapabilities
    /// z-depth defining the far plane of the eye view frustum
    /// enables mapping of values in the render target depth
    /// attachment to scene coordinates. Initially set to 10000.0.
    abstract depthFar: float with get, set
    /// z-depth defining the near plane of the eye view frustum
    /// enables mapping of values in the render target depth
    /// attachment to scene coordinates. Initially set to 0.01.
    abstract depthNear: float with get, set
    /// An identifier for this distinct VRDisplay. Used as an
    /// association point in the Gamepad API.
    abstract displayId: float
    /// A display name, a user-readable name identifying it.
    abstract displayName: string
    abstract isConnected: bool
    abstract isPresenting: bool
    /// If this VRDisplay supports room-scale experiences, the optional
    /// stage attribute contains details on the room-scale parameters.
    abstract stageParameters: VRStageParameters option
    /// <summary>Passing the value returned by `requestAnimationFrame` to
    /// `cancelAnimationFrame` will unregister the callback.</summary>
    /// <param name="handle">Define the hanle of the request to cancel</param>
    abstract cancelAnimationFrame: handle: float -> unit
    /// Stops presenting to the VRDisplay.
    abstract exitPresent: unit -> Promise<unit>
    /// <summary>Return the current VREyeParameters for the given eye.</summary>
    /// <param name="whichEye">Define the eye we want the parameter for</param>
    abstract getEyeParameters: whichEye: string -> VREyeParameters
    /// <summary>Populates the passed VRFrameData with the information required to render
    /// the current frame.</summary>
    /// <param name="frameData">Define the data structure to populate</param>
    abstract getFrameData: frameData: VRFrameData -> bool
    /// Get the layers currently being presented.
    abstract getLayers: unit -> ResizeArray<VRLayer>
    /// Return a VRPose containing the future predicted pose of the VRDisplay
    /// when the current frame will be presented. The value returned will not
    /// change until JavaScript has returned control to the browser.
    /// 
    /// The VRPose will contain the position, orientation, velocity,
    /// and acceleration of each of these properties.
    abstract getPose: unit -> VRPose
    /// Return the current instantaneous pose of the VRDisplay, with no
    /// prediction applied.
    abstract getImmediatePose: unit -> VRPose
    /// <summary>The callback passed to `requestAnimationFrame` will be called
    /// any time a new frame should be rendered. When the VRDisplay is
    /// presenting the callback will be called at the native refresh
    /// rate of the HMD. When not presenting this function acts
    /// identically to how window.requestAnimationFrame acts. Content should
    /// make no assumptions of frame rate or vsync behavior as the HMD runs
    /// asynchronously from other displays and at differing refresh rates.</summary>
    /// <param name="callback">Define the eaction to run next frame</param>
    abstract requestAnimationFrame: callback: FrameRequestCallback -> float
    /// <summary>Begin presenting to the VRDisplay. Must be called in response to a user gesture.
    /// Repeat calls while already presenting will update the VRLayers being displayed.</summary>
    /// <param name="layers">Define the list of layer to present</param>
    abstract requestPresent: layers: ResizeArray<VRLayer> -> Promise<unit>
    /// Reset the pose for this display, treating its current position and
    /// orientation as the "origin/zero" values. VRPose.position,
    /// VRPose.orientation, and VRStageParameters.sittingToStandingTransform may be
    /// updated when calling resetPose(). This should be called in only
    /// sitting-space experiences.
    abstract resetPose: unit -> unit
    /// <summary>The VRLayer provided to the VRDisplay will be captured and presented
    /// in the HMD. Calling this function has the same effect on the source
    /// canvas as any other operation that uses its source image, and canvases
    /// created without preserveDrawingBuffer set to true will be cleared.</summary>
    /// <param name="pose">Define the pose to submit</param>
    abstract submitFrame: ?pose: VRPose -> unit

type [<AllowNullLiteral>] VRLayer =
    abstract leftBounds: U2<ResizeArray<float>, Float32Array> option with get, set
    abstract rightBounds: U2<ResizeArray<float>, Float32Array> option with get, set
    abstract source: HTMLCanvasElement option with get, set

type [<AllowNullLiteral>] VRDisplayCapabilities =
    abstract canPresent: bool
    abstract hasExternalDisplay: bool
    abstract hasOrientation: bool
    abstract hasPosition: bool
    abstract maxLayers: float

type [<AllowNullLiteral>] VREyeParameters =
    abstract fieldOfView: VRFieldOfView
    abstract offset: Float32Array
    abstract renderHeight: float
    abstract renderWidth: float

type [<AllowNullLiteral>] VRFieldOfView =
    abstract downDegrees: float
    abstract leftDegrees: float
    abstract rightDegrees: float
    abstract upDegrees: float

type [<AllowNullLiteral>] VRFrameData =
    abstract leftProjectionMatrix: Float32Array
    abstract leftViewMatrix: Float32Array
    abstract pose: VRPose
    abstract rightProjectionMatrix: Float32Array
    abstract rightViewMatrix: Float32Array
    abstract timestamp: float

type [<AllowNullLiteral>] VRPose =
    abstract angularAcceleration: Float32Array option
    abstract angularVelocity: Float32Array option
    abstract linearAcceleration: Float32Array option
    abstract linearVelocity: Float32Array option
    abstract orientation: Float32Array option
    abstract position: Float32Array option
    abstract timestamp: float

type [<AllowNullLiteral>] VRStageParameters =
    abstract sittingToStandingTransform: Float32Array option with get, set
    abstract sizeX: float option with get, set
    abstract sizeY: float option with get, set

type [<AllowNullLiteral>] Gamepad =
    abstract displayId: float

type [<AllowNullLiteral>] ImageBitmap =
    abstract width: float
    abstract height: float
    abstract close: unit -> unit

type [<AllowNullLiteral>] WebGLQuery =
    inherit WebGLObject

type [<AllowNullLiteral>] WebGLSampler =
    inherit WebGLObject

type [<AllowNullLiteral>] WebGLSync =
    inherit WebGLObject

type [<AllowNullLiteral>] WebGLTransformFeedback =
    inherit WebGLObject

type [<AllowNullLiteral>] WebGLVertexArrayObject =
    inherit WebGLObject

/// MediaRecoreder object available in some browsers.
type [<AllowNullLiteral>] MediaRecorder =
    /// Starts recording 
    abstract start: timeSlice: float -> unit
    /// Stops recording 
    abstract stop: unit -> unit
    /// Event raised when an error arised. 
    abstract onerror: (ErrorEvent -> unit) with get, set
    /// Event raised when the recording stops. 
    abstract onstop: (Event -> unit) with get, set
    /// Event raised when a new chunk  of data is available and should be tracked. 
    abstract ondataavailable: (Event -> unit) with get, set

type [<AllowNullLiteral>] MediaRecorderOptions =
    /// The mime type you want to use as the recording container for the new MediaRecorder 
    abstract mimeType: string option with get, set
    /// The chosen bitrate for the audio component of the media. 
    abstract audioBitsPerSecond: float option with get, set
    /// The chosen bitrate for the video component of the media. 
    abstract videoBitsPerSecond: float option with get, set
    /// The chosen bitrate for the audio and video components of the media. This can be specified instead of the above two properties. If this is specified along with one or the other of the above properties, this will be used for the one that isn't specified. 
    abstract bitsPerSecond: float option with get, set

type [<AllowNullLiteral>] MediaRecorderConstructor =
    /// A reference to the prototype.
    abstract prototype: MediaRecorder

type [<AllowNullLiteral>] MediaRecorderConstructorStatic =
    /// <summary>Creates a new MediaRecorder.</summary>
    /// <param name="stream">Defines the stream to record.</param>
    /// <param name="options">Defines the options for the recorder available in the type MediaRecorderOptions.</param>
    [<Emit "new $0($1...)">] abstract Create: stream: MediaStream * ?options: MediaRecorderOptions -> MediaRecorderConstructor

type [<AllowNullLiteral>] TypeLiteral_43 =
    abstract prototype: VRDisplay with get, set
    [<Emit "new $0($1...)">] abstract Create: unit -> obj

type [<AllowNullLiteral>] TypeLiteral_44 =
    abstract prototype: WebGLQuery with get, set
    [<Emit "new $0($1...)">] abstract Create: unit -> obj

type [<AllowNullLiteral>] TypeLiteral_45 =
    abstract prototype: WebGLSampler with get, set
    [<Emit "new $0($1...)">] abstract Create: unit -> obj

type [<AllowNullLiteral>] TypeLiteral_46 =
    abstract prototype: WebGLSync with get, set
    [<Emit "new $0($1...)">] abstract Create: unit -> obj

type [<AllowNullLiteral>] TypeLiteral_47 =
    abstract prototype: WebGLTransformFeedback with get, set
    [<Emit "new $0($1...)">] abstract Create: unit -> obj

type [<AllowNullLiteral>] TypeLiteral_48 =
    abstract prototype: WebGLVertexArrayObject with get, set
    [<Emit "new $0($1...)">] abstract Create: unit -> obj
